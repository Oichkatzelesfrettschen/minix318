implementations, the [ENOEXEC] error is not mentioned for execlp() or execvp(), although implementations can still
give it.
Another way that some historical implementations handle shell scripts is by recognizing the first two bytes of the file as the
character string "#!" and using the remainder of the first line of the file as the name of the command interpreter to
execute.
One potential source of confusion noted by the standard developers is over how the contents of a process image file affect the
behavior of the exec family of functions. The following is a description of the actions taken:
If the process image file is a valid executable (in a format that is executable and valid and having appropriate privileges) for
this system, then the system executes the file.
If the process image file has appropriate privileges and is in a format that is executable but not valid for this system (such
as a recognized binary for another architecture), then this is an error and errno is set to [EINVAL] (see later RATIONALE on
[EINVAL]).
If the process image file has appropriate privileges but is not otherwise recognized:
If this is a call to execlp() or execvp(), then they invoke a command interpreter assuming that the process image
file is a shell script.
If this is not a call to execlp() or execvp(), then an error occurs and errno is set to [ENOEXEC].
Applications that do not require to access their arguments may use the form:
main(void)
as specified in the ISO C standard. However, the implementation will always provide the two arguments argc and
argv, even if they are not used.
Some implementations provide a third argument to main() called envp. This is defined as a pointer to the
environment. The ISO C standard specifies invoking main() with two arguments, so implementations are required to
support applications written this way. Since this volume of POSIX.1-2024 defines the global variable environ, which is also
provided by historical implementations and can be used anywhere that envp could be used, there is no functional need for the
envp argument. Applications should use the getenv() function rather than
accessing the environment directly via either envp or environ. Implementations are required to support the
two-argument calling sequence, but this does not prohibit an implementation from supporting envp as an optional third
argument.
This volume of POSIX.1-2024 specifies that signals set to SIG_IGN remain set to SIG_IGN, and that the new process image inherits
the signal mask of the thread that called exec in the old process image. This is consistent with historical implementations,
and it permits some useful functionality, such as the nohup command. However, it
should be noted that many existing applications wrongly assume that they start with certain signals set to the default action
and/or unblocked. In particular, applications written with a simpler signal model that does not include blocking of signals, such
as the one in the ISO C standard, may not behave properly if invoked with some signals blocked. Therefore, it is best not to
block or ignore signals across execs without explicit reason to do so, and especially not to block signals across
execs of arbitrary (not closely cooperating) programs.
The exec functions always save the value of the effective user ID and effective group ID of the process at the completion
of the exec, whether or not the set-user-ID or the set-group-ID bit of the process image file is set.
The statement about argv[] and envp[] being constants is included to make explicit to future writers of language
bindings that these objects are completely constant. Due to a limitation of the ISO C standard, it is not possible to state
that idea in standard C. Specifying two levels of const-qualification for the argv[] and envp[]
parameters for the exec functions may seem to be the natural choice, given that these functions do not modify either the
array of pointers or the characters to which the function points, but this would disallow existing correct code. Instead, only the
array of pointers is noted as constant. The table of assignment compatibility for dst=src derived from the ISO C
standard summarizes the compatibility:
dst:
char *[]
const char *[]
char *const[]
const char *const[]
src:
char *[]
VALID
—
VALID
—
const char *[]
—
VALID
—
VALID
char * const []
—
—
VALID
—
const char *const[]
—
—
—
VALID
Since all existing code has a source type matching the first row, the column that gives the most valid combinations
is the third column. The only other possibility is the fourth column, but using it would require a cast on the argv or
envp arguments. It is unfortunate that the fourth column cannot be used, because the declaration a non-expert would
naturally use would be that in the second row.
The ISO C standard and this volume of POSIX.1-2024 do not conflict on the use of environ, but some
historical implementations of environ may cause a conflict. As long as environ is treated in the same way as an entry
point (for example, fork()), it conforms to both standards. A library can contain
fork(), but if there is a user-provided fork(), that fork() is given precedence and no
problem ensues. The situation is similar for environ: the definition in this volume of POSIX.1-2024 is to be used if there
is no user-provided environ to take precedence. At least three implementations are known to exist that solve this
problem.
[E2BIG]
The limit {ARG_MAX} applies not just to the size of the argument list, but to the sum of that and the size of the environment
list.
[EFAULT]
Some historical systems return [EFAULT] rather than [ENOEXEC] when the new process image file is corrupted. They are
non-conforming.
[EINVAL]
This error condition was added to POSIX.1-2024 to allow an implementation to detect executable files generated for different
architectures, and indicate this situation to the application. Historical implementations of shells, execvp(), and
execlp() that encounter an [ENOEXEC] error will execute a shell on the assumption that the file is a shell script. This will
not produce the desired effect when the file is a valid executable for a different architecture. An implementation may now choose
to avoid this problem by returning [EINVAL] when a valid executable for a different architecture is encountered. Some historical
implementations return [EINVAL] to indicate that the path argument contains a character with the high order bit set. The
standard developers chose to deviate from historical practice for the following reasons:
The new utilization of [EINVAL] will provide some measure of utility to the user community.
Historical use of [EINVAL] is not acceptable in an internationalized operating environment.
[ENAMETOOLONG]
Since the file pathname may be constructed by taking elements in the PATH variable and putting them together with the
filename, the [ENAMETOOLONG] error condition could also be reached this way.
[ETXTBSY]
System V returns this error when the executable file is currently open for writing by some process. This volume of POSIX.1-2024
neither requires nor prohibits this behavior.
Other systems (such as System V) may return [EINTR] from exec. This is not addressed by this volume of
POSIX.1-2024, but implementations may have a window between the call to exec and the time that a signal could cause one of
the exec calls to return with [EINTR].
An explicit statement regarding the floating-point environment (as defined in the  header) was added to make it clear that the floating-point environment is set
to its default when a call to one of the exec functions succeeds. The requirements for inheritance or setting to the default
for other process and thread start-up functions is covered by more generic statements in their descriptions and can be summarized
as follows:
posix_spawn()
Set to default.
fork()
Inherit.
pthread_create()
Inherit.
The purpose of the fexecve() function is to enable executing a file which has been verified to be the
intended file. It is possible to actively check the file by reading from the file descriptor and be sure that the file is not
exchanged for another between the reading and the execution. Alternatively, a function like openat() can be used to open a file which has been found by reading the content of a
directory using readdir().
When execlp() or execvp() fall back to invoking sh because
of an [ENOEXEC] condition, the standard leaves the process name (what becomes argv[0] in the resulting sh process) unspecified. Existing implementations vary on whether they pass a variation of
"sh", or preserve the original arg0. There are existing implementations of sh that behave differently depending on the contents of argv[0], such that blindly passing
the original arg0 on to the fallback execution can fail to invoke a compliant shell environment. Because of the requirements
on how sh handles its command line arguments, the shell script will see $0
containing the pathname of the script being executed, regardless of the value of argv[0].
FUTURE DIRECTIONS
None.
SEE ALSO
alarm(), atexit(), chmod(), close(), confstr(), exit(), fcntl(), fork(), fstatvfs(), getenv(), getrlimit(), mknod(), mmap(), nice(), open(), posix_spawn(), pthread_atfork(), pthread_sigmask(), putenv(),
readdir(), semop(), setlocale(), shmat(), sigaction(), sigaltstack(),
sigpending(), system(),
times(), umask()
XBD 8. Environment Variables,
XCU test
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Realtime Extension and the POSIX Threads Extension.
Large File Summit extensions are added.
Issue 6
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
In the DESCRIPTION, behavior is defined for when the process image file is not a valid executable.
In this version, _POSIX_SAVED_IDS is mandated, thus the effective user ID and effective group ID of the new
process image shall be saved (as the saved set-user-ID and the saved set-group-ID) for use by the setuid() function.
The [ELOOP] mandatory error condition is added.
A second [ENAMETOOLONG] is added as an optional error condition.
The [ETXTBSY] optional error condition is added.
The following changes were made to align with the IEEE P1003.1a draft standard:
The [EINVAL] mandatory error condition is added.
The [ELOOP] optional error condition is added.
The description of CPU-time clock semantics is added for alignment with IEEE Std 1003.1d-1999.
The DESCRIPTION is updated for alignment with IEEE Std 1003.1j-2000 by adding semantics for typed
memory.
The normative text is updated to avoid use of the term "must" for application requirements.
The description of tracing semantics is added for alignment with IEEE Std 1003.1q-2000.
IEEE PASC Interpretation 1003.1 #132 is applied.
The DESCRIPTION is updated to make it explicit that the floating-point environment in the new process image is set
to the default.
The DESCRIPTION and RATIONALE are updated to include clarifications of how the contents of a process image file
affect the behavior of the exec functions.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/15 is applied, adding a new paragraph to the
DESCRIPTION and text to the end of the APPLICATION USAGE section. This change addresses a security concern, where implementations
may want to reopen file descriptors 0, 1, and 2 for programs with the set-user-id or set-group-id file mode bits calling the
exec family of functions.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/24 is applied, applying changes to the DESCRIPTION,
addressing which attributes are inherited by threads, and behavioral requirements for threads attributes.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/25 is applied, updating text in the RATIONALE from
"the process signal mask be unchanged across an exec" to "the new process image inherits the signal mask of the thread
that called exec in the old process image".
Issue 7
Austin Group Interpretation 1003.1-2001 #047 is applied, adding the description of _CS_V7_ENV to the APPLICATION USAGE.
Austin Group Interpretation 1003.1-2001 #143 is applied.
The fexecve() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 2.
Functionality relating to the Asynchronous Input and Output, Memory Mapped Files, Threads, and Timers options is
moved to the Base.
Changes are made related to support for finegrained timestamps.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0095 [386], XSH/TC1-2008/0096 [167], XSH/TC1-2008/0097 [291],
XSH/TC1-2008/0098 [173], XSH/TC1-2008/0099 [296], XSH/TC1-2008/00100 [324], XSH/TC1-2008/00101 [296], XSH/TC1-2008/00102 [302],
XSH/TC1-2008/00103 [167], XSH/TC1-2008/00104 [173], and XSH/TC1-2008/00105 [291,429] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0097 [584], XSH/TC2-2008/0098 [898], and XSH/TC2-2008/0099
[734] are applied.
Issue 8
Austin Group Defects 51 and 1669 are applied, moving the getrlimit() and
setrlimit() functions from the XSI option to the Base.
Austin Group Defect 368 is applied, adding a requirement for unnamed semaphores to be destroyed.
Austin Group Defect 768 is applied, adding OFD-owned file locks.
Austin Group Defect 922 is applied, adding the secure_getenv()
function.
Austin Group Defect 1284 is applied, changing "checksum test" to "integrity test" in the APPLICATION USAGE
section.
Austin Group Defect 1318 is applied, adding FD_CLOFORK.
Austin Group Defect 1330 is applied, removing obsolescent interfaces and changing "_V7_" to "_V8_".
Austin Group Defect 1435 is applied, adding function lists to the descriptions of the path and file
arguments.
Austin Group Defect 1645 is applied, making it unspecified what string is passed to the shell in argv[0]
when executed by execlp() or execvp().
Austin Group Defect 1646 is applied, adding at_quick_exit() to
the list of registration functions whose registrations are not inherited across exec.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sem_trywait.html =====
sem_trywait
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sem_trywait, sem_wait — lock a semaphore
SYNOPSIS
#include
int sem_trywait(sem_t *sem);
int sem_wait(sem_t *sem);
DESCRIPTION
The sem_trywait() function shall lock the semaphore referenced by sem only if the semaphore is currently not
locked; that is, if the semaphore value is currently positive. Otherwise, it shall not lock the semaphore.
The sem_wait() function shall lock the semaphore referenced by sem by performing a semaphore lock operation on
that semaphore. If the semaphore value is currently zero, then the calling thread shall not return from the call to
sem_wait() until it either locks the semaphore or the call is interrupted by a signal.
Upon successful return, the state of the semaphore shall be locked and shall remain locked until the sem_post() function is executed and returns successfully.
The sem_wait() function is interruptible by the delivery of a signal.
RETURN VALUE
The sem_trywait() and sem_wait() functions shall return zero if the calling process successfully performed the
semaphore lock operation on the semaphore designated by sem. If the call was unsuccessful, the state of the semaphore shall
be unchanged, and the function shall return a value of -1 and set errno to indicate the error.
ERRORS
The sem_trywait() function shall fail if:
[EAGAIN]
The semaphore was already locked, so it cannot be immediately locked by the sem_trywait() operation.
The sem_trywait() and sem_wait() functions may fail if:
[EDEADLK]
A deadlock condition was detected.
[EINTR]
A signal interrupted this function.
[EINVAL]
The sem argument does not refer to a valid semaphore.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Applications using these functions may be subject to priority inversion, as discussed in XBD 3.275 Priority Inversion.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
semctl(), semget(), semop(), sem_clockwait(), sem_post()
XBD 3.275 Priority Inversion, 4.15.2 Memory Synchronization,
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Issue 6
The sem_trywait() and sem_wait() functions are marked as part of the Semaphores option.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Semaphores
option.
The sem_timedwait() function is added to the SEE ALSO section for alignment
with IEEE Std 1003.1d-1999.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/121 is applied, updating the ERRORS section so that the [EINVAL]
error becomes optional.
Issue 7
SD5-XSH-ERN-54 is applied, removing the sem_wait() function from the "shall fail" error cases.
The sem_trywait() and sem_wait() functions are moved from the Semaphores option to the Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0530 [37] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/atomic_store_explicit.html =====
atomic_store
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
atomic_store, atomic_store_explicit — atomically store a value in an object
SYNOPSIS
#include
void atomic_store(volatile A *object, C desired);
void atomic_store_explicit(volatile A *object, C desired,
memory_order order);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
Implementations that define the macro __STDC_NO_ATOMICS__ need not provide the  header nor support these generic functions.
The atomic_store_explicit() generic function shall atomically replace the value pointed to by object with
desired. Memory shall be affected according to the value of order, which the application shall ensure is not
memory_order_acquire, memory_order_consume, nor memory_order_acq_rel.
The atomic_store() generic function shall be equivalent to atomic_store_explicit() called with order set to
memory_order_seq_cst.
RETURN VALUE
These generic functions shall not return a value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD 4.15.1 Memory Ordering,
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/longjmp.html =====
longjmp
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
longjmp — non-local goto
SYNOPSIS
#include
_Noreturn void longjmp(jmp_buf env, int val);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The longjmp() function shall restore the environment saved by the most recent invocation of setjmp() in the same process, with the corresponding jmp_buf argument. If the most
recent invocation of setjmp() with the corresponding jmp_buf occurred in
another thread, or if there is no such invocation, or if the function containing the invocation of setjmp() has terminated execution in the interim, or if the invocation of setjmp() was within the scope of an identifier with variably modified type and execution has
left that scope in the interim, the behavior is undefined. [CX]   It is unspecified whether longjmp() restores the signal
mask, leaves the signal mask unchanged, or restores it to its value at the time setjmp() was called.
All accessible objects have values, and all other components of the abstract machine have state (for example, floating-point
status flags and open files), as of the time longjmp() was called, except that the values of objects of automatic storage
duration are unspecified if they meet all the following conditions:
They are local to the function containing the corresponding setjmp()
invocation.
They do not have volatile-qualified type.
They are changed between the setjmp() invocation and longjmp() call.
[CX]
Although longjmp() is an async-signal-safe function, if it is invoked from a signal handler which interrupted a
non-async-signal-safe function or equivalent (such as the processing equivalent to exit() performed after a return from the initial call to main()), the behavior of any
subsequent call to a non-async-signal-safe function or equivalent is undefined.
The effect of a call to longjmp() where initialization of the jmp_buf structure was not performed in the calling
thread is undefined.
RETURN VALUE
After longjmp() is completed, thread execution shall continue as if the corresponding invocation of setjmp() had just returned the value specified by val. The longjmp() function
shall not cause setjmp() to return 0; if val is 0, setjmp() shall return 1.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Applications whose behavior depends on the value of the signal mask should not use longjmp() and setjmp(), since their effect on the signal mask is unspecified, but should instead use the
siglongjmp() and sigsetjmp()
functions (which can save and restore the signal mask under application control).
It is recommended that applications do not call longjmp() or siglongjmp() from signal handlers. To avoid undefined behavior when calling these
functions from a signal handler, the application needs to ensure one of the following two things:
After the call to longjmp() or siglongjmp() the process only calls
async-signal-safe functions and does not return from the initial call to main().
Any signal whose handler calls longjmp() or siglongjmp() is blocked
during every call to a non-async-signal-safe function, and no such calls are made after returning from the initial call to
main().
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
setjmp(), sigaction(),
siglongjmp(), sigsetjmp()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Threads Extension.
Issue 6
Extensions beyond the ISO C standard are marked.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The DESCRIPTION now explicitly makes longjmp()'s effect on the signal mask unspecified.
The DESCRIPTION is updated for alignment with the ISO/IEC 9899:1999 standard.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0365 [394] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0202 [516] is applied.
Issue 8
Austin Group Defect 1302 is applied, aligning this function with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/ctan.html =====
ctan
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ctan, ctanf, ctanl — complex tangent functions
SYNOPSIS
#include
double complex ctan(double complex z);
float complex ctanf(float complex z);
long double complex ctanl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex tangent of z.
RETURN VALUE
These functions shall return the complex tangent value.
[MXC]
ctan(conj(iz)), ctanf(conjf(iz)), and ctanl(conjl(iz)) shall return
exactly the same value as conj(ctan(iz)), conjf(ctanf(iz)), and
conjl(ctanl(iz)), respectively, and ctan(-iz), ctanf(-iz), and
ctanl(-iz) shall return exactly the same value as -ctan(iz), -ctanf(iz), and
-ctanl(iz), respectively, including for the special values of iz below.
If iz is +0 + i0, -i (+0 + i0) shall be returned.
If iz is 0 + iInf, -i (0 + iNaN) shall be returned and the invalid floating-point exception shall be
raised.
If iz is x + iInf where x is non-zero and finite, -i (NaN + iNaN) shall be returned
and the invalid floating-point exception shall be raised.
If iz is 0 + iNaN, -i (0 + iNaN) shall be returned.
If iz is x + iNaN where x is non-zero and finite, -i (NaN + iNaN) shall be returned
and the invalid floating-point exception may be raised.
If iz is +Inf + iy where y is positive-signed and finite, -i (1 + i0 sin(2y))
shall be returned.
If iz is +Inf + iInf, -i (1 ± i0) shall be returned; the sign of the real part of the result is
unspecified.
If iz is +Inf + iNaN, -i (1 ± i0) shall be returned; the sign of the real part of the result is
unspecified.
If iz is NaN + i0, -i (NaN + i0) shall be returned.
If iz is NaN + iy where y is any non-zero number, -i (NaN + iNaN) shall be returned and the
invalid floating-point exception may be raised.
If iz is NaN + iNaN, -i (NaN + iNaN) shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
The MXC special cases for ctan() are derived from those for ctanh() by
applying the formula ctan(z) = -ictanh(iz).
FUTURE DIRECTIONS
None.
SEE ALSO
catan(), ctanh()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getservbyport.html =====
endservent
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
endservent, getservbyname, getservbyport, getservent, setservent — network services database functions
SYNOPSIS
#include
void endservent(void);
struct servent *getservbyname(const char *name, const char *proto);
struct servent *getservbyport(int port, const char *proto);
struct servent *getservent(void);
void setservent(int stayopen);
DESCRIPTION
These functions shall retrieve information about network services. This information is considered to be stored in a database
that can be accessed sequentially or randomly. The implementation of this database is unspecified.
The setservent() function shall open a connection to the database, and set the next entry to the first entry. If the
stayopen argument is non-zero, the net database shall not be closed after each call to the getservent()
function (either directly, or indirectly through one of the other getserv*() functions), and the implementation may maintain
an open file descriptor for the database. If a file descriptor is used, the FD_CLOEXEC flag shall be set; see .
The getservent() function shall read the next entry of the database, opening and closing a connection to the database as
necessary.
The getservbyname() function shall search the database from the beginning and find the first entry for which the service
name specified by name matches the s_name member and the protocol name specified by proto matches the
s_proto member, opening and closing a connection to the database as necessary. If proto is a null pointer, any value
of the s_proto member shall be matched.
The getservbyport() function shall search the database from the beginning and find the first entry for which the port
specified by port matches the s_port member and the protocol name specified by proto matches the
s_proto member, opening and closing a connection to the database as necessary. If proto is a null pointer, any value
of the s_proto member shall be matched. The port argument shall be a value obtained by converting a uint16_t
in network byte order to int.
The getservbyname(), getservbyport(), and getservent() functions shall each return a pointer to a
servent structure, the members of which shall contain the fields of an entry in the network services database.
The endservent() function shall close the database, releasing any open file descriptor.
These functions need not be thread-safe.
RETURN VALUE
Upon successful completion, getservbyname(), getservbyport(), and getservent() return a pointer to a
servent structure if the requested entry was found, and a null pointer if the end of the database was reached or the
requested entry was not found. Otherwise, a null pointer is returned.
The application shall not modify the structure to which the return value points, nor any storage areas pointed to by pointers
within the structure. The returned pointer, and pointers within the structure, might be invalidated or the structure or the storage
areas might be overwritten by a subsequent call to getservbyname(), getservbyport(), or getservent(). The
returned pointer, and pointers within the structure, might also be invalidated if the calling thread is terminated.
ERRORS
The getservbyname(), getservbyport(), getservent(), and setservent() functions may fail if:
[EMFILE]
All file descriptors available to the process are currently open.
[ENFILE]
The maximum allowable number of files is currently open in the system.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The port argument of getservbyport() need not be compatible with the port values of all address families.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
endhostent(), endprotoent(), htonl(), inet_addr()
XBD ,
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
SD5-XBD-ERN-14 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0088 [75] and XSH/TC1-2008/0089 [75] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0095 [656] is applied.
Issue 8
Austin Group Defect 368 is applied, adding a requirement for FD_CLOEXEC to be set if a file descriptor is used, and adding the
[EMFILE] and [ENFILE] errors.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/ungetc.html =====
ungetc
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ungetc — push byte back into input stream
SYNOPSIS
#include
int ungetc(int c, FILE *stream);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The ungetc() function shall push the byte specified by c (converted to an unsigned char) back onto the
input stream pointed to by stream. The pushed-back bytes shall be returned by subsequent reads on that stream in the reverse
order of their pushing. A successful intervening call (with the stream pointed to by stream) to a file-positioning function
(fseek(), [CX]   fseeko(),  fsetpos(), or rewind()) [CX]   or fflush()
shall discard any pushed-back bytes for the stream. The
external storage corresponding to the stream shall be unchanged.
One byte of push-back shall be provided. If ungetc() is called too many times on the same stream without an intervening
read or file-positioning operation on that stream, the operation may fail.
If the value of c equals that of the macro EOF, the operation shall fail and the input stream shall be left
unchanged.
A successful call to ungetc() shall clear the end-of-file indicator for the stream. The file-position indicator for the
stream shall be decremented by each successful call to ungetc(); if its value was 0 before a call, its value is unspecified
after the call. The value of the file-position indicator after all pushed-back bytes have been read shall be the same as it was
before the bytes were pushed back.
RETURN VALUE
Upon successful completion, ungetc() shall return the byte pushed back after conversion. Otherwise, it shall return
EOF.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
The ISO C standard includes the text "The value of the file position indicator for the stream after reading or discarding
all pushed-back characters shall be the same as it was before the characters were pushed back." POSIX.1 omits "or discarding"
from this because it is redundant—in the ISO C standard the discarding is done by file positioning functions and does not
affect the position set by those functions. In particular, a relative seek using fseek() or fseeko() with SEEK_CUR adjusts the
position relative to the position on entry to the function, not the position after the pushed-back bytes have been discarded.
POSIX.1 also requires fflush() to discard pushed back bytes in situations where the
ISO C standard says the behavior of fflush() is undefined.
FUTURE DIRECTIONS
The ISO C standard states that the use of ungetc() on a binary stream where the file position indicator is zero
prior to the call is an obsolescent feature. In POSIX.1 there is no distinction between binary and text streams, so this applies to
all streams. This feature may be removed in a future version of this standard.
SEE ALSO
2.5 Standard I/O Streams, fseek(), getc(), fsetpos(), read(), rewind(), setbuf()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0687 [87,93], XSH/TC1-2008/0688 [87], and XSH/TC1-2008/0689 [14] are
applied.
Issue 8
Austin Group Defect 701 is applied, clarifying how the file-position indicator for the stream is updated.
Austin Group Defect 1302 is applied, changing the FUTURE DIRECTIONS section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getnameinfo.html =====
getnameinfo
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getnameinfo — get name information
SYNOPSIS
#include
#include
int getnameinfo(const struct sockaddr *restrict sa, socklen_t salen,
char *restrict node, socklen_t nodelen, char *restrict
service,
socklen_t servicelen, int flags);
DESCRIPTION
The getnameinfo() function shall translate a socket address to a node name and service location, all of which are defined
as in freeaddrinfo().
The sa argument points to a socket address structure to be translated. The salen argument contains the length of
the address pointed to by sa.
[IP6]
If the socket address structure contains an IPv4-mapped IPv6 address or an IPv4-compatible IPv6 address, the implementation shall
extract the embedded IPv4 address and lookup the node name for that IPv4 address.
If the address is the IPv6 unspecified address ("::"), a lookup shall not be performed and the behavior shall be the
same as when the node's name cannot be located.
If the node argument is non-NULL and the nodelen argument is non-zero, then the node argument points to a
buffer able to contain up to nodelen bytes that receives the node name as a null-terminated string. If the node
argument is NULL or the nodelen argument is zero, the node name shall not be returned. If the node's name cannot be located,
the numeric form of the address contained in the socket address structure pointed to by the sa argument is returned instead
of its name.
If the service argument is non-NULL and the servicelen argument is non-zero, then the service argument
points to a buffer able to contain up to servicelen bytes that receives the service name as a null-terminated string. If the
service argument is NULL or the servicelen argument is zero, the service name shall not be returned. If the service's
name cannot be located, the numeric form of the service address (for example, its port number) shall be returned instead of its
name.
The flags argument is a flag that changes the default actions of the function. By default the fully-qualified domain name
(FQDN) for the host shall be returned, but:
If the flag bit NI_NOFQDN is set, only the node name portion of the FQDN shall be returned for local hosts.
If the flag bit NI_NUMERICHOST is set, the numeric form of the address contained in the socket address structure pointed to by
the sa argument shall be returned instead of its name.
If the flag bit NI_NAMEREQD is set, an error shall be returned if the host's name cannot be located.
If the flag bit NI_NUMERICSERV is set, the numeric form of the service address shall be returned (for example, its port number)
instead of its name.
If the flag bit NI_NUMERICSCOPE is set, the numeric form of the scope identifier shall be returned (for example, interface
index) instead of its name. This flag shall be ignored if the sa argument is not an IPv6 address.
If the flag bit NI_DGRAM is set, this indicates that the service is a datagram service (SOCK_DGRAM). The default behavior shall
assume that the service is a stream service (SOCK_STREAM).
Notes:
The two NI_NUMERICxxx flags are required to support the -n flag that many commands provide.
The NI_DGRAM flag is required for the few AF_INET and AF_INET6 port numbers (for example, [512,514]) that represent different
services for UDP and TCP.
The getnameinfo() function shall be thread-safe.
RETURN VALUE
A zero return value for getnameinfo() indicates successful completion; a non-zero return value indicates failure. The
possible values for the failures are listed in the ERRORS section.
Upon successful completion, getnameinfo() shall return the node and service names, if requested, in the
buffers provided. The returned names are always null-terminated strings.
ERRORS
The getnameinfo() function shall fail and return the corresponding value if:
[EAI_AGAIN]
The name could not be resolved at this time. Future attempts may succeed.
[EAI_BADFLAGS]
The flags had an invalid value.
[EAI_FAIL]
A non-recoverable error occurred.
[EAI_FAMILY]
The address family was not recognized or the address length was invalid for the specified family.
[EAI_MEMORY]
There was a memory allocation failure.
[EAI_NONAME]
The name does not resolve for the supplied parameters.
NI_NAMEREQD is set and the host's name cannot be located, or both nodename and servname were null.
[EAI_OVERFLOW]
An argument buffer overflowed. The buffer pointed to by the node argument or the service argument was too small.
[EAI_SYSTEM]
A system error occurred. The error code can be found in errno.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
If the returned values are to be used as part of any further name resolution (for example, passed to getaddrinfo()), applications should provide buffers large enough to store any result
possible on the system.
Given the IPv4-mapped IPv6 address "::ffff:1.2.3.4", the implementation performs a lookup as if the socket address
structure contains the IPv4 address "1.2.3.4".
The IPv6 unspecified address ("::") and the IPv6 loopback address ("::1") are not IPv4-compatible
addresses.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
endservent(), freeaddrinfo(), gai_strerror(),
inet_ntop(), socket()
XBD ,
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
The restrict keyword is added to the getnameinfo() prototype for alignment with the ISO/IEC 9899:1999
standard.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/23 is applied, making various changes in the SYNOPSIS and
DESCRIPTION for alignment with IPv6.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/24 is applied, adding the [EAI_OVERFLOW] error to the ERRORS
section.
Issue 7
SD5-XSH-ERN-127 is applied, clarifying the behavior if the address is the IPv6 unspecified address.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0246 [284] and XSH/TC1-2008/0247 [285] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/listen.html =====
listen
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
listen — listen for socket connections and limit the queue of incoming connections
SYNOPSIS
#include
int listen(int socket, int backlog);
DESCRIPTION
The listen() function shall mark a connection-mode socket, specified by the socket argument, as accepting
connections.
The backlog argument provides a hint to the implementation which the implementation shall use to limit the number of
outstanding connections in the socket's listen queue. Implementations may impose a limit on backlog and silently reduce the
specified value. Normally, a larger backlog argument value shall result in a larger or equal length of the listen queue.
Implementations shall support values of backlog up to SOMAXCONN, defined in .
The implementation may include incomplete connections in its listen queue. The limits on the number of incomplete connections
and completed connections queued may be different.
The implementation may have an upper limit on the length of the listen queue—either global or per accepting socket. If
backlog exceeds this limit, the length of the listen queue is set to the limit.
If listen() is called with a backlog argument value that is less than 0, the function behaves as if it had been
called with a backlog argument value of 0.
A backlog argument of 0 may allow the socket to accept connections, in which case the length of the listen queue may be
set to an implementation-defined minimum value.
The socket in use may require the process to have appropriate privileges to use the listen() function.
RETURN VALUE
Upon successful completions, listen() shall return 0; otherwise, -1 shall be returned and errno set to indicate
the error.
ERRORS
The listen() function shall fail if:
[EBADF]
The socket argument is not a valid file descriptor.
[EDESTADDRREQ]
The socket is not bound to a local address, and the protocol does not support listening on an unbound socket.
[EINVAL]
The socket is already connected.
[ENOTSOCK]
The socket argument does not refer to a socket.
[EOPNOTSUPP]
The socket protocol does not support listen().
The listen() function may fail if:
[EACCES]
The calling process does not have appropriate privileges.
[EINVAL]
The socket has been shut down.
[ENOBUFS]
Insufficient resources are available in the system to complete the call.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
accept(), connect(), socket()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
The DESCRIPTION is updated to describe the relationship of SOMAXCONN and the backlog argument.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/iswblank.html =====
iswblank
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
iswblank, iswblank_l — test for a blank wide-character code
SYNOPSIS
#include
int iswblank(wint_t wc);
[CX]  int iswblank_l(wint_t wc, locale_t locale);
DESCRIPTION
For iswblank(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The iswblank() [CX]   and iswblank_l()
functions shall test whether wc is a wide-character code representing a character of class blank in the current
locale, [CX]   or in the locale represented by locale,
respectively; see XBD 7. Locale.
The wc argument is a wint_t, the value of which the application shall ensure is a wide-character code
corresponding to a valid character in the locale used by the function, or equal to the value of the macro WEOF. If the argument has
any other value, the behavior is undefined.
[CX]  The
behavior is undefined if the locale argument to iswblank_l() is the special locale object LC_GLOBAL_LOCALE or is not
a valid locale object handle.
RETURN VALUE
The iswblank() [CX]   and iswblank_l()
functions shall return non-zero if wc is a blank wide-character code; otherwise, they shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
To ensure applications portability, especially across natural languages, only these functions and the functions in the reference
pages listed in the SEE ALSO section should be used for character classification.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
iswalnum(), iswalpha(),
iswcntrl(), iswctype(),
iswdigit(), iswgraph(),
iswlower(), iswprint(),
iswpunct(), iswspace(),
iswupper(), iswxdigit(),
setlocale(), uselocale()
XBD 7. Locale, ,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
The iswblank_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0315 [302], XSH/TC1-2008/0316 [283], and XSH/TC1-2008/0317 [283] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0182 [685] is applied.
Issue 8
Austin Group Defect 1770 is applied, changing "iswblank() and iswblank()
functions" to "iswblank() and iswblank_l() functions".
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/mbstowcs.html =====
mbstowcs
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
mbstowcs — convert a character string to a wide-character string
SYNOPSIS
#include
size_t mbstowcs(wchar_t *restrict pwcs, const char *restrict s,
size_t n);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The mbstowcs() function shall convert a sequence of characters that begins in the initial shift state from the array
pointed to by s into a sequence of corresponding wide-character codes and shall store not more than n wide-character
codes into the array pointed to by pwcs. No characters that follow a null byte (which is converted into a wide-character
code with value 0) shall be examined or converted. Each character shall be converted as if by a call to mbtowc(), except that the shift state of mbtowc() is not affected.
No more than n elements shall be modified in the array pointed to by pwcs. If copying takes place between objects
that overlap, the behavior is undefined.
The behavior of this function shall be affected by the LC_CTYPE category of the current locale. [XSI]   If
pwcs is a null pointer, mbstowcs() shall return the length required to convert the entire array regardless of the
value of n, but no values are stored.
RETURN VALUE
If an invalid character is encountered, mbstowcs() shall return (size_t)-1 [CX]   and shall set
errno to indicate the error.
Otherwise, mbstowcs() shall return the number of the array elements modified [XSI]   (or required
if pwcs is null),  not including a terminating 0 code, if
any. The array shall not be zero-terminated if the value returned is n.
ERRORS
The mbstowcs() function shall fail if:
[EILSEQ]
[CX]  An
invalid character sequence is detected. In the POSIX locale an [EILSEQ] error cannot occur since all byte values are valid
characters.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
mblen(), mbtowc(), wctomb(), wcstombs()
XBD
CHANGE HISTORY
First released in Issue 4. Aligned with the ISO C standard.
Issue 6
The mbstowcs() prototype is updated for alignment with the ISO/IEC 9899:1999 standard.
Extensions beyond the ISO C standard are marked.
Issue 7
Austin Group Interpretation 1003.1-2001 #170 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0371 [195] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0208 [663,674] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/open_wmemstream.html =====
open_memstream
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
open_memstream, open_wmemstream — open a dynamic memory buffer stream
SYNOPSIS
[CX]  #include
FILE *open_memstream(char **bufp, size_t *sizep);
#include
FILE *open_wmemstream(wchar_t **bufp, size_t *sizep);
DESCRIPTION
The open_memstream() and open_wmemstream() functions shall create an I/O stream associated with a dynamically
allocated memory buffer. The stream shall be opened for writing and shall be seekable.
The stream associated with a call to open_memstream() shall be byte-oriented.
The stream associated with a call to open_wmemstream() shall be wide-oriented.
The stream shall maintain a current position in the allocated buffer and a current buffer length. The position shall be
initially set to zero (the start of the buffer). Each write to the stream shall start at the current position and move this
position by the number of successfully written bytes for open_memstream() or the number of successfully written wide
characters for open_wmemstream(). The length shall be initially set to zero. If a write moves the position to a value larger
than the current length, the current length shall be set to this position. In this case a null character for
open_memstream() or a null wide character for open_wmemstream() shall be appended to the current buffer. For both
functions the terminating null is not included in the calculation of the buffer length.
After a successful fflush() or fclose(), the pointer referenced by bufp shall contain the address of the buffer, and
the variable pointed to by sizep shall contain the smaller of the current buffer length and the number of bytes for
open_memstream(), or the number of wide characters for open_wmemstream(), between the beginning of the buffer and the
current file position indicator.
The fseek() and fseeko() functions
can be used to set the file position beyond the current buffer length. It is implementation-defined whether this extends the buffer
to the new length. If it extends the buffer, the added buffer contents shall be set to null bytes for open_memstream(), or
null wide characters for open_wmemstream(); if it does not extend the buffer, then if data is later written at this point,
the buffer contents in the gap shall be set to null bytes for open_memstream(), or null wide characters for
open_wmemstream(). If fseek() or fseeko() is called with SEEK_END as the whence argument, it is implementation-defined
whether the file position is adjusted relative to the current buffer length or relative to the buffer size that would be set by an
fflush() call made immediately before the fseek() or fseeko() call.
After a successful fflush() the pointer referenced by bufp and the variable
referenced by sizep remain valid only until the next write operation on the stream or a call to fclose().
After a successful fclose(), the pointer referenced by bufp can be passed
to free().
RETURN VALUE
Upon successful completion, these functions shall return a pointer to the object controlling the stream. Otherwise, a null
pointer shall be returned, and errno shall be set to indicate the error.
ERRORS
These functions shall fail if:
[EMFILE]
{STREAM_MAX} streams are currently open in the calling process.
These functions may fail if:
[EINVAL]
bufp or sizep are NULL.
[EMFILE]
{FOPEN_MAX} streams are currently open in the calling process.
[ENOMEM]
Memory for the stream or the buffer could not be allocated.
The following sections are informative.
EXAMPLES
#include
#include
int
main (void)
{
FILE *stream;
char *buf;
size_t len;
off_t eob;
stream = open_memstream (&buf, &len);
if (stream == NULL)
/* handle error */ ;
fprintf (stream, "hello my world");
fflush (stream);
printf ("buf=%s, len=%zu\n", buf, len);
eob = ftello(stream);
fseeko (stream, 0, SEEK_SET);
fprintf (stream, "good-bye");
fseeko (stream, eob, SEEK_SET);
fclose (stream);
printf ("buf=%s, len=%zu\n", buf, len);
free (buf);
return 0;
}
This program produces the following output:
buf=hello my world, len=14
buf=good-bye world, len=14
APPLICATION USAGE
The buffer created by these functions should be freed by the application after closing the stream, by means of a call to
free().
RATIONALE
These functions are similar to fmemopen() except that the memory is always
allocated dynamically by the function, and the stream is opened only for output.
FUTURE DIRECTIONS
None.
SEE ALSO
fclose(), fdopen(), fflush(), fmemopen(), fopen(), free(), freopen()
XBD ,
CHANGE HISTORY
First released in Issue 7.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0244 [588] and XSH/TC2-2008/0245 [586] are applied.
Issue 8
Austin Group Defect 1406 is applied, clarifying the behavior of fseek() and
fseeko() on streams created by open_memstream() and
open_wmemstream().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/posix_spawnattr_setschedparam.html =====
posix_spawnattr_getschedparam
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
posix_spawnattr_getschedparam, posix_spawnattr_setschedparam — get and set the spawn-schedparam attribute of a spawn
attributes object (ADVANCED REALTIME)
SYNOPSIS
[SPN PS]  #include
#include
int posix_spawnattr_getschedparam(const posix_spawnattr_t
*restrict attr, struct sched_param *restrict schedparam);
int posix_spawnattr_setschedparam(posix_spawnattr_t *restrict attr,
const struct sched_param *restrict schedparam);
DESCRIPTION
The posix_spawnattr_getschedparam() function shall obtain the value of the spawn-schedparam attribute from the
attributes object referenced by attr.
The posix_spawnattr_setschedparam() function shall set the spawn-schedparam attribute in an initialized attributes
object referenced by attr.
The spawn-schedparam attribute represents the scheduling parameters to be assigned to the new process image in a spawn
operation (if POSIX_SPAWN_SETSCHEDULER or POSIX_SPAWN_SETSCHEDPARAM is set in the spawn-flags attribute). The default value
of this attribute is unspecified.
RETURN VALUE
Upon successful completion, posix_spawnattr_getschedparam() shall return zero and store the value of the
spawn-schedparam attribute of attr into the object referenced by the schedparam parameter; otherwise, an error
number shall be returned to indicate the error.
Upon successful completion, posix_spawnattr_setschedparam() shall return zero; otherwise, an error number shall be
returned to indicate the error.
ERRORS
These functions may fail if:
[EINVAL]
The value specified by attr is invalid.
The posix_spawnattr_setschedparam() function may fail if:
[EINVAL]
The value of the attribute being set is not valid.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
These functions are part of the Spawn and Process Scheduling options and need not be provided on all implementations.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
posix_spawn(), posix_spawnattr_destroy(), posix_spawnattr_getsigdefault(), posix_spawnattr_getflags(), posix_spawnattr_getpgroup(), posix_spawnattr_getschedpolicy(), posix_spawnattr_getsigmask()
XBD ,
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1d-1999.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/grantpt.html =====
grantpt
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
grantpt — grant access to the subsidiary pseudo-terminal device
SYNOPSIS
[XSI]  #include
int grantpt(int fildes);
DESCRIPTION
The grantpt() function shall change the mode and ownership of the subsidiary pseudo-terminal device associated with its
manager pseudo-terminal counterpart. The fildes argument is a file descriptor that refers to a manager pseudo-terminal
device. The user ID of the subsidiary shall be set to the real UID of the calling process and the group ID shall be set to an
unspecified group ID. The permission mode of the subsidiary pseudo-terminal shall be set to readable and writable by the owner, and
writable by the group.
The behavior of the grantpt() function is unspecified if the application has installed a signal handler to catch SIGCHLD
signals.
RETURN VALUE
Upon successful completion, grantpt() shall return 0; otherwise, it shall return -1 and set errno to indicate the
error.
ERRORS
The grantpt() function may fail if:
[EACCES]
The corresponding subsidiary pseudo-terminal device could not be accessed.
[EBADF]
The fildes argument is not a valid open file descriptor.
[EINVAL]
The fildes argument is not associated with a manager pseudo-terminal device.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
See the RATIONALE section for posix_openpt().
FUTURE DIRECTIONS
None.
SEE ALSO
open(), posix_openpt(),
ptsname(), unlockpt()
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
The last paragraph of the DESCRIPTION is moved from the APPLICATION USAGE section.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0272 [96] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0177 [506] is applied.
Issue 8
Austin Group Defect 1466 is applied, changing the terminology used for pseudo-terminal devices.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_mutexattr_init.html =====
pthread_mutexattr_destroy
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_mutexattr_destroy, pthread_mutexattr_init — destroy and initialize the mutex attributes object
SYNOPSIS
#include
int pthread_mutexattr_destroy(pthread_mutexattr_t *attr);
int pthread_mutexattr_init(pthread_mutexattr_t *attr);
DESCRIPTION
The pthread_mutexattr_destroy() function shall destroy a mutex attributes object; the object becomes, in effect,
uninitialized. An implementation may cause pthread_mutexattr_destroy() to set the object referenced by attr to an
invalid value.
A destroyed attr attributes object can be reinitialized using pthread_mutexattr_init(); the results of otherwise
referencing the object after it has been destroyed are undefined.
The pthread_mutexattr_init() function shall initialize a mutex attributes object attr with the default value for
all of the attributes defined by the implementation.
Results are undefined if pthread_mutexattr_init() is called specifying an already initialized attr attributes
object.
After a mutex attributes object has been used to initialize one or more mutexes, any function affecting the attributes object
(including destruction) shall not affect any previously initialized mutexes.
The behavior is undefined if the value specified by the attr argument to pthread_mutexattr_destroy() does not
refer to an initialized mutex attributes object.
RETURN VALUE
Upon successful completion, pthread_mutexattr_destroy() and pthread_mutexattr_init() shall return zero; otherwise,
an error number shall be returned to indicate the error.
ERRORS
The pthread_mutexattr_init() function shall fail if:
[ENOMEM]
Insufficient memory exists to initialize the mutex attributes object.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
If an implementation detects that the value specified by the attr argument to pthread_mutexattr_destroy() does not
refer to an initialized mutex attributes object, it is recommended that the function should fail and report an [EINVAL] error.
See pthread_attr_destroy() for a general explanation of attributes.
Attributes objects allow implementations to experiment with useful extensions and permit extension of this volume of POSIX.1-2024
without changing the existing functions. Thus, they provide for future extensibility of this volume of POSIX.1-2024 and reduce the
temptation to standardize prematurely on semantics that are not yet widely implemented or understood.
Examples of possible additional mutex attributes that have been discussed are spin_only, limited_spin,
no_spin, recursive, and metered. (To explain what the latter attributes might mean: recursive mutexes would
allow for multiple re-locking by the current owner; metered mutexes would transparently keep records of queue length, wait time,
and so on.) Since there is not yet wide agreement on the usefulness of these resulting from shared implementation and usage
experience, they are not yet specified in this volume of POSIX.1-2024. Mutex attributes objects, however, make it possible to test
out these concepts for possible standardization at a later time.
Mutex Attributes and Performance
Care has been taken to ensure that the default values of the mutex attributes have been defined such that mutexes initialized
with the defaults have simple enough semantics so that the locking and unlocking can be done with the equivalent of a test-and-set
instruction (plus possibly a few other basic instructions).
There is at least one implementation method that can be used to reduce the cost of testing at lock-time if a mutex has
non-default attributes. One such method that an implementation can employ (and this can be made fully transparent to fully
conforming POSIX applications) is to secretly pre-lock any mutexes that are initialized to non-default attributes. Any later
attempt to lock such a mutex causes the implementation to branch to the "slow path" as if the mutex were unavailable; then, on
the slow path, the implementation can do the "real work" to lock a non-default mutex. The underlying unlock operation is more
complicated since the implementation never really wants to release the pre-lock on this kind of mutex. This illustrates that,
depending on the hardware, there may be certain optimizations that can be used so that whatever mutex attributes are considered
"most frequently used" can be processed most efficiently.
Process Shared Memory and Synchronization
The existence of memory mapping functions in this volume of POSIX.1-2024 leads to the possibility that an application may
allocate the synchronization objects from this section in memory that is accessed by multiple processes (and therefore, by threads
of multiple processes).
In order to permit such usage, while at the same time keeping the usual case (that is, usage within a single process) efficient,
a process-shared option has been defined.
If an implementation supports the _POSIX_THREAD_PROCESS_SHARED option, then the process-shared attribute can be used to
indicate that mutexes or condition variables may be accessed by threads of multiple processes.
The default setting of PTHREAD_PROCESS_PRIVATE has been chosen for the process-shared attribute so that the most
efficient forms of these synchronization objects are created by default.
Synchronization variables that are initialized with the PTHREAD_PROCESS_PRIVATE process-shared attribute may only be
operated on by threads in the process that initialized them. Synchronization variables that are initialized with the
PTHREAD_PROCESS_SHARED process-shared attribute may be operated on by any thread in any process that has access to it. In
particular, these processes may exist beyond the lifetime of the initializing process. For example, the following code implements a
simple counting semaphore in a mapped file that may be used by many processes.
/* sem.h */
struct semaphore {
pthread_mutex_t lock;
pthread_cond_t nonzero;
unsigned count;
};
typedef struct semaphore semaphore_t;
semaphore_t *semaphore_create(char *semaphore_name);
semaphore_t *semaphore_open(char *semaphore_name);
void semaphore_post(semaphore_t *semap);
void semaphore_wait(semaphore_t *semap);
void semaphore_close(semaphore_t *semap);
/* sem.c */
#include
#include
#include
#include
#include
#include "sem.h"
semaphore_t *
semaphore_create(char *semaphore_name)
{
int fd;
semaphore_t *semap;
pthread_mutexattr_t psharedm;
pthread_condattr_t psharedc;
fd = open(semaphore_name, O_RDWR | O_CREAT | O_EXCL, 0666);
if (fd lock, &psharedm);
(void) pthread_cond_init(&semap->nonzero, &psharedc);
semap->count = 0;
return (semap);
}
semaphore_t *
semaphore_open(char *semaphore_name)
{
int fd;
semaphore_t *semap;
fd = open(semaphore_name, O_RDWR, 0666);
if (fd lock);
if (semap->count == 0)
pthread_cond_signal(&semapx->nonzero);
semap->count++;
pthread_mutex_unlock(&semap->lock);
}
void
semaphore_wait(semaphore_t *semap)
{
pthread_mutex_lock(&semap->lock);
while (semap->count == 0)
pthread_cond_wait(&semap->nonzero, &semap->lock);
semap->count--;
pthread_mutex_unlock(&semap->lock);
}
void
semaphore_close(semaphore_t *semap)
{
munmap((void *) semap, sizeof(semaphore_t));
}
The following code is for three separate processes that create, post, and wait on a semaphore in the file /tmp/semaphore.
Once the file is created, the post and wait programs increment and decrement the counting semaphore (waiting and waking as
required) even though they did not initialize the semaphore.
/* create.c */
#include "pthread.h"
#include "sem.h"
int
main(void)
{
semaphore_t *semap;
semap = semaphore_create("/tmp/semaphore");
if (semap == NULL)
exit(1);
semaphore_close(semap);
return (0);
}
/* post.c */
#include "pthread.h"
#include "sem.h"
int
main(void)
{
semaphore_t *semap;
semap = semaphore_open("/tmp/semaphore");
if (semap == NULL)
exit(1);
semaphore_post(semap);
semaphore_close(semap);
return (0);
}
/* wait.c */
#include "pthread.h"
#include "sem.h"
int
main(void)
{
semaphore_t *semap;
semap = semaphore_open("/tmp/semaphore");
if (semap == NULL)
exit(1);
semaphore_wait(semap);
semaphore_close(semap);
return (0);
}
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_cond_destroy(), pthread_create(), pthread_mutex_destroy()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
The pthread_mutexattr_destroy() and pthread_mutexattr_init() functions are marked as part of the Threads
option.
IEEE PASC Interpretation 1003.1c #27 is applied, updating the ERRORS section.
Issue 7
The pthread_mutexattr_destroy() and pthread_mutexattr_init() functions are moved from the Threads option to the
Base.
The [EINVAL] error for an uninitialized mutex attributes object is removed; this condition results in undefined behavior.
Issue 8
Austin Group Defect 1195 is applied, changing "main()" to "main(void)".
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/execvp.html =====
exec
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
environ, execl, execle, execlp, execv, execve, execvp, fexecve — execute a file
SYNOPSIS
#include
extern char **environ;
int execl(const char *path, const char *arg0, ... /*, (char *)0 */);
int execle(const char *path, const char *arg0, ... /*,
(char *)0, char *const envp[]*/);
int execlp(const char *file, const char *arg0, ... /*, (char *)0 */);
int execv(const char *path, char *const argv[]);
int execve(const char *path, char *const argv[], char *const envp[]);
int execvp(const char *file, char *const argv[]);
int fexecve(int fd, char *const argv[], char *const envp[]);
DESCRIPTION
The exec family of functions shall replace the current process image with a new process image. The new image shall be
constructed from a regular, executable file called the new process image file. There shall be no return from a successful
exec, because the calling process image is overlaid by the new process image.
The fexecve() function shall be equivalent to the execve() function except that the file to be executed is
determined by the file descriptor fd instead of a pathname. The file offset of fd is ignored.
When a C-language program is executed as a result of a call to one of the exec family of functions, it shall be entered
as a C-language function call as follows:
int main (int argc, char *argv[]);
where argc is the argument count and argv is an array of character pointers to the arguments themselves. In
addition, the following variable, which needs to be declared by the user if it is to be used directly:
extern char **environ;
is initialized as a pointer to an array of character pointers to the environment strings. The argv and environ
arrays are each terminated by a null pointer. The null pointer terminating the argv array is not counted in argc.
Applications can change the entire environment in a single operation by assigning the environ variable to point to an
array of character pointers to the new environment strings. After assigning a new value to environ, applications should not
rely on the new environment strings remaining part of the environment, as a call to getenv(), secure_getenv(),
[XSI]
putenv(),  setenv(), unsetenv(), or any function that is
dependent on an environment variable may, on noticing that environ has changed, copy the environment strings to a new array
and assign environ to point to it.
Any application that directly modifies the pointers to which the environ variable points has undefined behavior.
Conforming multi-threaded applications shall not use the environ variable to access or modify any environment variable
while any other thread is concurrently modifying any environment variable. A call to any function dependent on any environment
variable shall be considered a use of the environ variable to access that environment variable.
The arguments specified by a program with one of the exec functions shall be passed on to the new process image in the
corresponding main() arguments.
For the execl(), execle(), execv(), and execve() functions, the argument path points to a
pathname that identifies the new process image file.
For the execlp() and execvp() functions, the argument file is used to construct a pathname that identifies
the new process image file. If the file argument contains a  character, the file argument shall be used
as the pathname for this file. Otherwise, the path prefix for this file is obtained by a search of the directories passed as the
environment variable PATH (see XBD 8. Environment Variables). If
this environment variable is not present, the results of the search are implementation-defined.
There are two distinct ways in which the contents of the process image file may cause the execution to fail, distinguished by
the setting of errno to either [ENOEXEC] or [EINVAL] (see the ERRORS section). In the cases where the other members of the
exec family of functions would fail and set errno to [ENOEXEC], the execlp() and execvp() functions
shall execute a command interpreter and the environment of the executed command shall be as if the process invoked the sh utility using execl() as follows:
execl(, , file, , (char *)0);
where  is an unspecified pathname for the sh utility,
is an unspecified string, file is the process image file, and where  is zero or more
parameters corresponding to any initial non-null arguments passed after arg0 for execlp() or to any initial non-null
members of argv starting at argv[1] for execvp().
The arguments represented by arg0,... are pointers to null-terminated character strings. These strings shall constitute
the argument list available to the new process image. The list is terminated by a null pointer. The argument arg0 should
point to a filename string that is associated with the process being started by one of the exec functions.
The argument argv is an array of character pointers to null-terminated strings. The application shall ensure that the
last member of this array is a null pointer. These strings shall constitute the argument list available to the new process image.
The value in argv[0] should point to a filename string that is associated with the process being started by one of the
exec functions.
The argument envp is an array of character pointers to null-terminated strings. These strings shall constitute the
environment for the new process image. The envp array is terminated by a null pointer.
For those forms not containing an envp pointer (execl(), execv(),
execlp(), and execvp()), the environment for the new process image shall be taken from the external variable
environ in the calling process.
The number of bytes available for the new process' combined argument and environment lists is {ARG_MAX}. It is
implementation-defined whether null terminators, pointers, and/or any alignment bytes are included in this total.
File descriptors open in the calling process image shall remain open in the new process image, except for those whose
close-on-exec flag FD_CLOEXEC is set. For those file descriptors that remain open, all attributes of the open file
description shall remain unchanged and the FD_CLOFORK file descriptor flag, if set, shall remain set. For any file descriptor that
is closed for this reason, process-owned file locks that the calling process owns on the file associated with the file descriptor
shall be unlocked as a result of the close, as described in close(). File locks that
are not unlocked by closing of file descriptors remain unchanged.
If file descriptor 0, 1, or 2 would otherwise be closed after a successful call to one of the exec family of functions,
implementations may open an unspecified file for the file descriptor in the new process image. If a standard utility or a
conforming application is executed with file descriptor 0 not open for reading or with file descriptor 1 or 2 not open for writing,
the environment in which the utility or application is executed shall be deemed non-conforming, and consequently the utility or
application might not behave as described in this standard.
Directory streams open in the calling process image shall be closed in the new process image.
The state of the floating-point environment in the initial thread of the new process image shall be set to the default.
The state of conversion descriptors and message catalog descriptors in the new process image is undefined.
For the new process image, the equivalent of:
setlocale(LC_ALL, "C")
shall be executed at start-up.
Signals set to the default action (SIG_DFL) in the calling process image shall be set to the default action in the new process
image. Except for SIGCHLD, signals set to be ignored (SIG_IGN) by the calling process image shall be set to be ignored by the new
process image. Signals set to be caught by the calling process image shall be set to the default action in the new process image
(see ).
If the SIGCHLD signal is set to be ignored by the calling process image, it is unspecified whether the SIGCHLD signal is set to
be ignored or to the default action in the new process image.
[XSI]
After a successful call to any of the exec functions, alternate signal stacks are not preserved and the SA_ONSTACK flag
shall be cleared for all signals.
After a successful call to any of the exec functions, any functions previously registered by the atexit(), at_quick_exit(), or pthread_atfork() functions are no longer registered.
[XSI]
If the ST_NOSUID bit is set for the file system containing the new process image file, then the effective user ID, effective group
ID, saved set-user-ID, and saved set-group-ID are unchanged in the new process image. Otherwise,  if the set-user-ID mode bit of the new process image file is set, the effective user ID of the new
process image shall be set to the user ID of the new process image file. Similarly, if the set-group-ID mode bit of the new process
image file is set, the effective group ID of the new process image shall be set to the group ID of the new process image file. The
real user ID, real group ID, and supplementary group IDs of the new process image shall remain the same as those of the calling
process image. The effective user ID and effective group ID of the new process image shall be saved (as the saved set-user-ID and
the saved set-group-ID) for use by setuid().
[XSI]
Any shared memory segments attached to the calling process image shall not be attached to the new process image.
Any named semaphores open in the calling process shall be closed as if by appropriate calls to sem_close(). Any unnamed semaphores open in the calling process shall be destroyed as if
by calls to sem_destroy().
[TYM]
Any blocks of typed memory that were mapped in the calling process are unmapped, as if munmap() was implicitly called to unmap them.
[ML]
Memory locks established by the calling process via calls to mlockall() or mlock() shall be removed. If locked pages in the address space of the calling process are also
mapped into the address spaces of other processes and are locked by those processes, the locks established by the other processes
shall be unaffected by the call by this process to the exec function. If the exec function fails, the effect on
memory locks is unspecified.
Memory mappings created in the process are unmapped before the address space is rebuilt for the new process image.
When the calling process image does not use the SCHED_FIFO, SCHED_RR, [SS]
or SCHED_SPORADIC   scheduling policies, the scheduling policy and parameters of the new process image and the initial
thread in that new process image are implementation-defined.
[PS]
When the calling process image uses the SCHED_FIFO, SCHED_RR, or SCHED_SPORADIC scheduling policies, the process policy and
scheduling parameter settings shall not be changed by a call to an exec function.  [TPS]   The initial thread in the new process image shall inherit the process scheduling policy and
parameters. It shall have the default system contention scope, but shall inherit its allocation domain from the calling process
image.
Per-process timers created by the calling process shall be deleted before replacing the current process image with the new
process image.
[MSG]
All open message queue descriptors in the calling process shall be closed, as described in mq_close().
Any outstanding asynchronous I/O operations may be canceled. Those asynchronous I/O operations that are not canceled shall
complete as if the exec function had not yet occurred, but any associated signal notifications shall be suppressed. It is
unspecified whether the exec function itself blocks awaiting such I/O completion. In no event, however, shall the new
process image created by the exec function be affected by the presence of outstanding asynchronous I/O operations at the
time the exec function is called. Whether any I/O is canceled, and which I/O may be canceled upon exec, is
implementation-defined.
[CPT]
The new process image shall inherit the CPU-time clock of the calling process image. This inheritance means that the process
CPU-time clock of the process being exec-ed shall not be reinitialized or altered as a result of the exec function
other than to reflect the time spent by the process executing the exec function itself.
[TCT]
The initial value of the CPU-time clock of the initial thread of the new process image shall be set to zero.
The thread ID of the initial thread in the new process image is unspecified.
The size and location of the stack on which the initial thread in the new process image runs is unspecified.
The initial thread in the new process image shall have its cancellation type set to PTHREAD_CANCEL_DEFERRED and its cancellation
state set to PTHREAD_CANCEL_ENABLED.
The initial thread in the new process image shall have all thread-specific data values set to NULL and all thread-specific data
keys shall be removed by the call to exec without running destructors.
The initial thread in the new process image shall be joinable, as if created with the detachstate attribute set to
PTHREAD_CREATE_JOINABLE.
The new process shall inherit at least the following attributes from the calling process image:
[XSI]
Nice value (see nice())
[XSI]
semadj values (see semop())
Process ID
Parent process ID
Process group ID
Session membership
Real user ID
Real group ID
Supplementary group IDs
Time left until an alarm clock signal (see alarm())
Current working directory
Root directory
File mode creation mask (see umask())
File size limit (see getrlimit() and setrlimit())
Process signal mask (see pthread_sigmask())
Pending signal (see sigpending())
tms_utime, tms_stime, tms_cutime, and tms_cstime (see times())
Resource limits
Controlling terminal
The initial thread of the new process shall inherit at least the following attributes from the calling thread:
Signal mask (see sigprocmask() and pthread_sigmask())
Pending signals (see sigpending())
All other process attributes defined in this volume of POSIX.1-2024 shall be inherited in the new process image from the old
process image. All other thread attributes defined in this volume of POSIX.1-2024 shall be inherited in the initial thread in the
new process image from the calling thread in the old process image. The inheritance of process or thread attributes not defined by
this volume of POSIX.1-2024 is implementation-defined.
A call to any exec function from a process with more than one thread shall result in all threads being terminated and the
new executable image being loaded and executed. No destructor functions or cleanup handlers shall be called.
Upon successful completion, the exec functions shall mark for update the last data access timestamp of the file. If an
exec function failed but was able to locate the process image file, whether the last data access timestamp is marked for
update is unspecified. Should the exec function succeed, the process image file shall be considered to have been opened with
open(). The corresponding close() shall be
considered to occur at a time after this open, but before process termination or successful completion of a subsequent call to one
of the exec functions, posix_spawn(), or posix_spawnp(). The argv[] and envp[] arrays of pointers and the strings
to which those arrays point shall not be modified by a call to one of the exec functions, except as a consequence of
replacing the process image.
The saved resource limits in the new process image are set to be a copy of the process' corresponding hard and soft limits.
RETURN VALUE
If one of the exec functions returns to the calling process image, an error has occurred; the return value shall be -1,
and errno shall be set to indicate the error.
ERRORS
The exec functions shall fail if:
[E2BIG]
The number of bytes used by the new process image's argument list and environment list is greater than the system-imposed limit
of {ARG_MAX} bytes.
[EACCES]
The new process image file is not a regular file and the implementation does not support execution of files of its type.
[EINVAL]
The new process image file has appropriate privileges and has a recognized executable binary format, but the system does not
support execution of a file with this format.
The exec functions, except for fexecve(), shall fail if:
[EACCES]
Search permission is denied for a directory listed in the new process image file's path prefix, or the new process image file
denies execution permission.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the path or file argument.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOENT]
A component of path or file does not name an existing file or path or file is an empty string.
[ENOTDIR]
A component of the new process image file's path prefix names an existing file that is neither a directory nor a symbolic link
to a directory, or the new process image file's pathname contains at least one non- character and ends with one or
more trailing  characters and the last pathname component names an existing file that is neither a directory nor a
symbolic link to a directory.
The exec functions, except for execlp() and execvp(), shall fail if:
[ENOEXEC]
The new process image file has the appropriate access permission but has an unrecognized format.
The fexecve() function shall fail if:
[EBADF]
The fd argument is not a valid file descriptor open for executing.
The exec functions may fail if:
[ENOMEM]
The new process image requires more memory than is allowed by the hardware or system-imposed memory management
constraints.
The exec functions, except for fexecve(), may fail if:
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the path or file argument.
[ENAMETOOLONG]
The length of the path argument or the length of the pathname constructed from the file argument exceeds {PATH_MAX},
or pathname resolution of a symbolic link produced an intermediate result with a length that exceeds {PATH_MAX}.
[ETXTBSY]
The new process image file is a pure procedure (shared text) file that is currently open for writing by some process.
The following sections are informative.
EXAMPLES
Using execl()
The following example executes the ls command, specifying the pathname of the
executable (/bin/ls) and using arguments supplied directly to the command to produce single-column output.
#include
int ret;
...
ret = execl ("/bin/ls", "ls", "-1", (char *)0);
Using execle()
The following example is similar to Using execl(). In addition, it specifies the environment
for the new process image using the env argument.
#include
int ret;
char *env[] = { "HOME=/usr/home", "LOGNAME=home", (char *)0 };
...
ret = execle ("/bin/ls", "ls", "-l", (char *)0, env);
Using execlp()
The following example searches for the location of the ls command among the
directories specified by the PATH environment variable.
#include
int ret;
...
ret = execlp ("ls", "ls", "-l", (char *)0);
Using execv()
The following example passes arguments to the ls command in the cmd array.
#include
int ret;
char *cmd[] = { "ls", "-l", (char *)0 };
...
ret = execv ("/bin/ls", cmd);
Using execve()
The following example passes arguments to the ls command in the cmd array, and
specifies the environment for the new process image using the env argument.
#include
int ret;
char *cmd[] = { "ls", "-l", (char *)0 };
char *env[] = { "HOME=/usr/home", "LOGNAME=home", (char *)0 };
...
ret = execve ("/bin/ls", cmd, env);
Using execvp()
The following example searches for the location of the ls command among the
directories specified by the PATH environment variable, and passes arguments to the ls command in the cmd array.
#include
int ret;
char *cmd[] = { "ls", "-l", (char *)0 };
...
ret = execvp ("ls", cmd);
APPLICATION USAGE
As the state of conversion descriptors and message catalog descriptors in the new process image is undefined, conforming
applications should not rely on their use and should close them prior to calling one of the exec functions.
Applications that require other than the default POSIX locale as the global locale in the new process image should call setlocale() with the appropriate parameters.
When assigning a new value to the environ variable, applications should ensure that the environment to which it will
point contains at least the following:
Any implementation-defined variables required by the implementation to provide a conforming environment. See the _CS_V8_ENV
entry in  and confstr() for details.
A value for PATH which finds conforming versions of all standard utilities before any other versions.
The same constraint applies to the envp array passed to execle() or execve(), in order to ensure that the
new process image is invoked in a conforming environment.
Applications should not execute programs with file descriptor 0 not open for reading or with file descriptor 1 or 2 not open for
writing, as this might cause the executed program to misbehave. In order not to pass on these file descriptors to an executed
program, applications should not just close them but should reopen them on, for example, /dev/null. Some implementations may
reopen them automatically, but applications should not rely on this being done.
If an application wants to perform an integrity test of the file being executed before executing it, the file will need to be
opened with read permission to perform the integrity test.
Since execute permission is checked by fexecve(), the file description fd need not have been opened with the
O_EXEC flag. However, if the file to be executed denies read and write permission for the process preparing to do the exec,
the only way to provide the fd to fexecve() will be to use the O_EXEC flag when opening fd. In this case, the
application will not be able to perform an integrity test since it will not be able to read the contents of the file.
Note that when a file descriptor is opened with O_RDONLY, O_RDWR, or O_WRONLY mode, the file descriptor can be used to read,
read and write, or write the file, respectively, even if the mode of the file changes after the file was opened. Using the O_EXEC
open mode is different; fexecve() will ignore the mode that was used when the file descriptor was opened and the exec
will fail if the mode of the file associated with fd does not grant execute permission to the calling process at the time
fexecve() is called.
RATIONALE
Early proposals required that the value of argc passed to main() be "one or greater". This was driven by the
same requirement in drafts of the ISO C standard. In fact, historical implementations have passed a value of zero when no
arguments are supplied to the caller of the exec functions. This requirement was removed from the ISO C standard and
subsequently removed from this volume of POSIX.1-2024 as well. The wording, in particular the use of the word should,
requires a Strictly Conforming POSIX Application to pass at least one argument to the exec function, thus guaranteeing that
argc be one or greater when invoked by such an application. In fact, this is good practice, since many existing applications
reference argv[0] without first checking the value of argc.
The requirement on a Strictly Conforming POSIX Application also states that the value passed as the first argument be a filename
string associated with the process being started. Although some existing applications pass a pathname rather than a filename string
in some circumstances, a filename string is more generally useful, since the common usage of argv[0] is in printing
diagnostics. In some cases the filename passed is not the actual filename of the file; for example, many implementations of the
login utility use a convention of prefixing a  ('-') to the actual filename, which indicates to
the command interpreter being invoked that it is a "login shell".
Also, note that the test and [ utilities require specific strings for the
argv[0] argument to have deterministic behavior across all implementations.
Historically, there have been two ways that implementations can exec shell scripts.
One common historical implementation is that the execl(), execv(), execle(), and execve() functions
return an [ENOEXEC] error for any file not recognizable as executable, including a shell script. When the execlp() and
execvp() functions encounter such a file, they assume the file to be a shell script and invoke a known command interpreter
to interpret such files. This is now required by POSIX.1-2024. These implementations of execvp() and execlp() only
give the [ENOEXEC] error in the rare case of a problem with the command interpreter's executable file. Because of these
implementations, the [ENOEXEC] error is not mentioned for execlp() or execvp(), although implementations can still
give it.
Another way that some historical implementations handle shell scripts is by recognizing the first two bytes of the file as the
character string "#!" and using the remainder of the first line of the file as the name of the command interpreter to
execute.
One potential source of confusion noted by the standard developers is over how the contents of a process image file affect the
behavior of the exec family of functions. The following is a description of the actions taken:
If the process image file is a valid executable (in a format that is executable and valid and having appropriate privileges) for
this system, then the system executes the file.
If the process image file has appropriate privileges and is in a format that is executable but not valid for this system (such
as a recognized binary for another architecture), then this is an error and errno is set to [EINVAL] (see later RATIONALE on
[EINVAL]).
If the process image file has appropriate privileges but is not otherwise recognized:
If this is a call to execlp() or execvp(), then they invoke a command interpreter assuming that the process image
file is a shell script.
If this is not a call to execlp() or execvp(), then an error occurs and errno is set to [ENOEXEC].
Applications that do not require to access their arguments may use the form:
main(void)
as specified in the ISO C standard. However, the implementation will always provide the two arguments argc and
argv, even if they are not used.
Some implementations provide a third argument to main() called envp. This is defined as a pointer to the
environment. The ISO C standard specifies invoking main() with two arguments, so implementations are required to
support applications written this way. Since this volume of POSIX.1-2024 defines the global variable environ, which is also
provided by historical implementations and can be used anywhere that envp could be used, there is no functional need for the
envp argument. Applications should use the getenv() function rather than
accessing the environment directly via either envp or environ. Implementations are required to support the
two-argument calling sequence, but this does not prohibit an implementation from supporting envp as an optional third
argument.
This volume of POSIX.1-2024 specifies that signals set to SIG_IGN remain set to SIG_IGN, and that the new process image inherits
the signal mask of the thread that called exec in the old process image. This is consistent with historical implementations,
and it permits some useful functionality, such as the nohup command. However, it
should be noted that many existing applications wrongly assume that they start with certain signals set to the default action
and/or unblocked. In particular, applications written with a simpler signal model that does not include blocking of signals, such
as the one in the ISO C standard, may not behave properly if invoked with some signals blocked. Therefore, it is best not to
block or ignore signals across execs without explicit reason to do so, and especially not to block signals across
execs of arbitrary (not closely cooperating) programs.
The exec functions always save the value of the effective user ID and effective group ID of the process at the completion
of the exec, whether or not the set-user-ID or the set-group-ID bit of the process image file is set.
The statement about argv[] and envp[] being constants is included to make explicit to future writers of language
bindings that these objects are completely constant. Due to a limitation of the ISO C standard, it is not possible to state
that idea in standard C. Specifying two levels of const-qualification for the argv[] and envp[]
parameters for the exec functions may seem to be the natural choice, given that these functions do not modify either the
array of pointers or the characters to which the function points, but this would disallow existing correct code. Instead, only the
array of pointers is noted as constant. The table of assignment compatibility for dst=src derived from the ISO C
standard summarizes the compatibility:
dst:
char *[]
const char *[]
char *const[]
const char *const[]
src:
char *[]
VALID
—
VALID
—
const char *[]
—
VALID
—
VALID
char * const []
—
—
VALID
—
const char *const[]
—
—
—
VALID
Since all existing code has a source type matching the first row, the column that gives the most valid combinations
is the third column. The only other possibility is the fourth column, but using it would require a cast on the argv or
envp arguments. It is unfortunate that the fourth column cannot be used, because the declaration a non-expert would
naturally use would be that in the second row.
The ISO C standard and this volume of POSIX.1-2024 do not conflict on the use of environ, but some
historical implementations of environ may cause a conflict. As long as environ is treated in the same way as an entry
point (for example, fork()), it conforms to both standards. A library can contain
fork(), but if there is a user-provided fork(), that fork() is given precedence and no
problem ensues. The situation is similar for environ: the definition in this volume of POSIX.1-2024 is to be used if there
is no user-provided environ to take precedence. At least three implementations are known to exist that solve this
problem.
[E2BIG]
The limit {ARG_MAX} applies not just to the size of the argument list, but to the sum of that and the size of the environment
list.
[EFAULT]
Some historical systems return [EFAULT] rather than [ENOEXEC] when the new process image file is corrupted. They are
non-conforming.
[EINVAL]
This error condition was added to POSIX.1-2024 to allow an implementation to detect executable files generated for different
architectures, and indicate this situation to the application. Historical implementations of shells, execvp(), and
execlp() that encounter an [ENOEXEC] error will execute a shell on the assumption that the file is a shell script. This will
not produce the desired effect when the file is a valid executable for a different architecture. An implementation may now choose
to avoid this problem by returning [EINVAL] when a valid executable for a different architecture is encountered. Some historical
implementations return [EINVAL] to indicate that the path argument contains a character with the high order bit set. The
standard developers chose to deviate from historical practice for the following reasons:
The new utilization of [EINVAL] will provide some measure of utility to the user community.
Historical use of [EINVAL] is not acceptable in an internationalized operating environment.
[ENAMETOOLONG]
Since the file pathname may be constructed by taking elements in the PATH variable and putting them together with the
filename, the [ENAMETOOLONG] error condition could also be reached this way.
[ETXTBSY]
System V returns this error when the executable file is currently open for writing by some process. This volume of POSIX.1-2024
neither requires nor prohibits this behavior.
Other systems (such as System V) may return [EINTR] from exec. This is not addressed by this volume of
POSIX.1-2024, but implementations may have a window between the call to exec and the time that a signal could cause one of
the exec calls to return with [EINTR].
An explicit statement regarding the floating-point environment (as defined in the  header) was added to make it clear that the floating-point environment is set
to its default when a call to one of the exec functions succeeds. The requirements for inheritance or setting to the default
for other process and thread start-up functions is covered by more generic statements in their descriptions and can be summarized
as follows:
posix_spawn()
Set to default.
fork()
Inherit.
pthread_create()
Inherit.
The purpose of the fexecve() function is to enable executing a file which has been verified to be the
intended file. It is possible to actively check the file by reading from the file descriptor and be sure that the file is not
exchanged for another between the reading and the execution. Alternatively, a function like openat() can be used to open a file which has been found by reading the content of a
directory using readdir().
When execlp() or execvp() fall back to invoking sh because
of an [ENOEXEC] condition, the standard leaves the process name (what becomes argv[0] in the resulting sh process) unspecified. Existing implementations vary on whether they pass a variation of
"sh", or preserve the original arg0. There are existing implementations of sh that behave differently depending on the contents of argv[0], such that blindly passing
the original arg0 on to the fallback execution can fail to invoke a compliant shell environment. Because of the requirements
on how sh handles its command line arguments, the shell script will see $0
containing the pathname of the script being executed, regardless of the value of argv[0].
FUTURE DIRECTIONS
None.
SEE ALSO
alarm(), atexit(), chmod(), close(), confstr(), exit(), fcntl(), fork(), fstatvfs(), getenv(), getrlimit(), mknod(), mmap(), nice(), open(), posix_spawn(), pthread_atfork(), pthread_sigmask(), putenv(),
readdir(), semop(), setlocale(), shmat(), sigaction(), sigaltstack(),
sigpending(), system(),
times(), umask()
XBD 8. Environment Variables,
XCU test
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Realtime Extension and the POSIX Threads Extension.
Large File Summit extensions are added.
Issue 6
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
In the DESCRIPTION, behavior is defined for when the process image file is not a valid executable.
In this version, _POSIX_SAVED_IDS is mandated, thus the effective user ID and effective group ID of the new
process image shall be saved (as the saved set-user-ID and the saved set-group-ID) for use by the setuid() function.
The [ELOOP] mandatory error condition is added.
A second [ENAMETOOLONG] is added as an optional error condition.
The [ETXTBSY] optional error condition is added.
The following changes were made to align with the IEEE P1003.1a draft standard:
The [EINVAL] mandatory error condition is added.
The [ELOOP] optional error condition is added.
The description of CPU-time clock semantics is added for alignment with IEEE Std 1003.1d-1999.
The DESCRIPTION is updated for alignment with IEEE Std 1003.1j-2000 by adding semantics for typed
memory.
The normative text is updated to avoid use of the term "must" for application requirements.
The description of tracing semantics is added for alignment with IEEE Std 1003.1q-2000.
IEEE PASC Interpretation 1003.1 #132 is applied.
The DESCRIPTION is updated to make it explicit that the floating-point environment in the new process image is set
to the default.
The DESCRIPTION and RATIONALE are updated to include clarifications of how the contents of a process image file
affect the behavior of the exec functions.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/15 is applied, adding a new paragraph to the
DESCRIPTION and text to the end of the APPLICATION USAGE section. This change addresses a security concern, where implementations
may want to reopen file descriptors 0, 1, and 2 for programs with the set-user-id or set-group-id file mode bits calling the
exec family of functions.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/24 is applied, applying changes to the DESCRIPTION,
addressing which attributes are inherited by threads, and behavioral requirements for threads attributes.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/25 is applied, updating text in the RATIONALE from
"the process signal mask be unchanged across an exec" to "the new process image inherits the signal mask of the thread
that called exec in the old process image".
Issue 7
Austin Group Interpretation 1003.1-2001 #047 is applied, adding the description of _CS_V7_ENV to the APPLICATION USAGE.
Austin Group Interpretation 1003.1-2001 #143 is applied.
The fexecve() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 2.
Functionality relating to the Asynchronous Input and Output, Memory Mapped Files, Threads, and Timers options is
moved to the Base.
Changes are made related to support for finegrained timestamps.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0095 [386], XSH/TC1-2008/0096 [167], XSH/TC1-2008/0097 [291],
XSH/TC1-2008/0098 [173], XSH/TC1-2008/0099 [296], XSH/TC1-2008/00100 [324], XSH/TC1-2008/00101 [296], XSH/TC1-2008/00102 [302],
XSH/TC1-2008/00103 [167], XSH/TC1-2008/00104 [173], and XSH/TC1-2008/00105 [291,429] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0097 [584], XSH/TC2-2008/0098 [898], and XSH/TC2-2008/0099
[734] are applied.
Issue 8
Austin Group Defects 51 and 1669 are applied, moving the getrlimit() and
setrlimit() functions from the XSI option to the Base.
Austin Group Defect 368 is applied, adding a requirement for unnamed semaphores to be destroyed.
Austin Group Defect 768 is applied, adding OFD-owned file locks.
Austin Group Defect 922 is applied, adding the secure_getenv()
function.
Austin Group Defect 1284 is applied, changing "checksum test" to "integrity test" in the APPLICATION USAGE
section.
Austin Group Defect 1318 is applied, adding FD_CLOFORK.
Austin Group Defect 1330 is applied, removing obsolescent interfaces and changing "_V7_" to "_V8_".
Austin Group Defect 1435 is applied, adding function lists to the descriptions of the path and file
arguments.
Austin Group Defect 1645 is applied, making it unspecified what string is passed to the shell in argv[0]
when executed by execlp() or execvp().
Austin Group Defect 1646 is applied, adding at_quick_exit() to
the list of registration functions whose registrations are not inherited across exec.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/newlocale.html =====
newlocale
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
newlocale — create or modify a locale object
SYNOPSIS
[CX]  #include
locale_t newlocale(int category_mask, const char *locale,
locale_t base);
DESCRIPTION
The newlocale() function shall create a new locale object or modify an existing one. If the base argument is
(locale_t)0, a new locale object shall be created, otherwise the locale specified by base shall be modified. In the
latter case it is unspecified whether the resulting locale object shall be that pointed to by base modified in place, or
whether that object shall be freed after a new locale object is first created using some values from it.
The category_mask argument specifies the locale categories to be set or modified. Values for category_mask shall
be constructed by a bitwise-inclusive OR of the symbolic constants LC_CTYPE_MASK , LC_NUMERIC_MASK , LC_TIME_MASK
, LC_COLLATE_MASK , LC_MONETARY_MASK , and LC_MESSAGES_MASK , or any of the implementation-defined mask
values defined in .
For each category with the corresponding bit set in category_mask the data from the locale named by locale shall
be used. In the case of modifying an existing locale object, the data from the locale named by locale shall replace the
existing data within the locale object. If a completely new locale object is created, the data for all sections not requested by
category_mask shall be taken from the POSIX locale.
The following preset values of locale are defined for all settings of category_mask:
"POSIX"
Specifies the minimal environment for C-language translation called the POSIX locale.
"C"
Equivalent to "POSIX".
""
Specifies an implementation-defined native environment. This corresponds to the value of the associated environment variables,
LC_* and LANG ; see XBD 7. Locale and 8. Environment Variables.
If the base argument is not (locale_t)0 and the newlocale() function call succeeds, the contents of
base are unspecified. Applications shall ensure that they stop using base as a locale object before calling
newlocale(). If the function call fails and the base argument is not (locale_t)0, the contents of base
shall remain valid and unchanged.
The behavior is undefined if the base argument is the special locale object LC_GLOBAL_LOCALE, or is not a valid locale
object handle and is not (locale_t)0.
RETURN VALUE
Upon successful completion, the newlocale() function shall return a handle which the caller may use on subsequent calls
to duplocale(), freelocale(),
and other functions taking a locale_t argument.
Upon failure, the newlocale() function shall return (locale_t)0 and set errno to indicate the error.
ERRORS
The newlocale() function shall fail if:
[ENOMEM]
There is not enough memory available to create the locale object or load the locale data.
[EINVAL]
The category_mask contains a bit that does not correspond to a valid category.
[ENOENT]
For any of the categories in category_mask, the locale data is not available.
The newlocale() function may fail if:
[EINVAL]
The locale argument is not a valid string pointer.
The following sections are informative.
EXAMPLES
Constructing a Locale Object from Different Locales
The following example shows the construction of a locale where the LC_CTYPE category data comes from a locale loc1
and the LC_TIME category data from a locale loc2:
#include
...
locale_t loc, new_loc;
/* Get the "loc1" data. */
loc = newlocale (LC_CTYPE_MASK, "loc1", (locale_t)0);
if (loc == (locale_t) 0)
abort ();
/* Get the "loc2" data. */
new_loc = newlocale (LC_TIME_MASK, "loc2", loc);
if (new_loc != (locale_t) 0)
/* We don t abort if this fails. In this case this
simply used to unchanged locale object. */
loc = new_loc;
...
Freeing up a Locale Object
The following example shows a code fragment to free a locale object created by newlocale():
#include
...
/* Every locale object allocated with newlocale() should be
* freed using freelocale():
*/
locale_t loc;
/* Get the locale. */
loc = newlocale (LC_CTYPE_MASK | LC_TIME_MASK, "locname", (locale_t)0);
/* ... Use the locale object ... */
...
/* Free the locale object resources. */
freelocale (loc);
APPLICATION USAGE
Handles for locale objects created by the newlocale() function should either be released by a corresponding call to
freelocale(), or be used as a base locale to another newlocale() call.
The special locale object LC_GLOBAL_LOCALE must not be passed for the base argument, even when returned by the uselocale() function.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
duplocale(), freelocale()
, getlocalename_l(), uselocale()
XBD 7. Locale, 8.
Environment Variables,
CHANGE HISTORY
First released in Issue 7.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0403 [227], XSH/TC1-2008/0404 [283], XSH/TC1-2008/0405 [295], and
XSH/TC1-2008/0406 [227] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0232 [781] and XSH/TC2-2008/0233 [673] are applied.
Issue 8
Austin Group Defect 1220 is applied, adding getlocalename_l() to the SEE
ALSO section.
Austin Group Defect 1243 is applied, clarifying the handling of a non-zero base argument.
Austin Group Defect 1264 is applied, changing "default locale" to "POSIX locale".
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/nearbyintf.html =====
nearbyint
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
nearbyint, nearbyintf, nearbyintl — floating-point rounding functions
SYNOPSIS
#include
double nearbyint(double x);
float nearbyintf(float x);
long double nearbyintl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall round their argument to an integer value in floating-point format, using the current rounding direction
and without raising the inexact floating-point exception.
RETURN VALUE
Upon successful completion, these functions shall return the rounded integer value. [MX]   The result
shall have the same sign as x.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0, ±0 shall be returned.
If x is ±Inf, x shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The integral value returned by these functions need not be expressible as an intmax_t. The return value should be tested
before assigning it to an integer type to avoid the undefined results of an integer overflow.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0402 [346,428] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/strnlen.html =====
strlen
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
strlen, strnlen — get length of fixed size string
SYNOPSIS
#include
size_t strlen(const char *s);
[CX]  size_t strnlen(const char *s, size_t maxlen);
DESCRIPTION
For strlen(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The strlen() function shall compute the number of bytes in the string to which s points, not including the
terminating NUL character.
[CX]  The
strnlen() function shall compute the smaller of the number of bytes in the array to which s points, not including any
terminating NUL character, or the value of the maxlen argument. The strnlen() function shall never examine more than
maxlen bytes of the array pointed to by s.
[CX]  The
strlen() and strnlen() functions shall not change the setting of errno on valid input.
RETURN VALUE
The strlen() function shall return the length of s; no return value shall be reserved to indicate an error.
[CX]  The
strnlen() function shall return the number of bytes preceding the first null byte in the array to which s points, if
s contains a null byte within the first maxlen bytes; otherwise, it shall return maxlen.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
Getting String Lengths
The following example sets the maximum length of key and data by using strlen() to get the lengths of those
strings.
#include
...
struct element {
char *key;
char *data;
};
...
char *key, *data;
int len;
*keylength = *datalength = 0;
...
if ((len = strlen(key)) > *keylength)
*keylength = len;
if ((len = strlen(data)) > *datalength)
*datalength = len;
...
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
strlcat(), wcslen()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The RETURN VALUE section is updated to indicate that strlen() returns the length of s, and not s itself as
was previously stated.
Issue 7
The strnlen() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 1.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0344 [560] is applied.
Issue 8
Austin Group Defect 448 is applied, adding a requirement that strlen() and strnlen() do not change the setting of
errno on valid input.
Austin Group Defect 986 is applied, adding strlcat() to the SEE ALSO section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/setnetent.html =====
endnetent
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
endnetent, getnetbyaddr, getnetbyname, getnetent, setnetent — network database functions
SYNOPSIS
#include
void endnetent(void);
struct netent *getnetbyaddr(uint32_t net, int type);
struct netent *getnetbyname(const char *name);
struct netent *getnetent(void);
void setnetent(int stayopen);
DESCRIPTION
These functions shall retrieve information about networks. This information is considered to be stored in a database that can be
accessed sequentially or randomly. The implementation of this database is unspecified.
The setnetent() function shall open and rewind the database. If the stayopen argument is non-zero, the connection
to the net database shall not be closed after each call to getnetent() (either directly, or indirectly through one of
the other getnet*() functions), and the implementation may maintain an open file descriptor to the database. If a file
descriptor is used, the FD_CLOEXEC flag shall be set; see .
The getnetent() function shall read the next entry of the database, opening and closing a connection to the database as
necessary.
The getnetbyaddr() function shall search the database from the beginning, and find the first entry for which the address
family specified by type matches the n_addrtype member and the network number net matches the n_net
member, opening and closing a connection to the database as necessary. The net argument shall be the network number in host
byte order.
The getnetbyname() function shall search the database from the beginning and find the first entry for which the network
name specified by name matches the n_name member, opening and closing a connection to the database as necessary.
The getnetbyaddr(), getnetbyname(), and getnetent() functions shall each return a pointer to a
netent structure, the members of which shall contain the fields of an entry in the network database.
The endnetent() function shall close the database, releasing any open file descriptor.
These functions need not be thread-safe.
RETURN VALUE
Upon successful completion, getnetbyaddr(), getnetbyname(), and getnetent() shall return a pointer to a
netent structure if the requested entry was found, and a null pointer if the end of the database was reached or the
requested entry was not found. Otherwise, a null pointer shall be returned.
The application shall not modify the structure to which the return value points, nor any storage areas pointed to by pointers
within the structure. The returned pointer, and pointers within the structure, might be invalidated or the structure or the storage
areas might be overwritten by a subsequent call to getnetbyaddr(), getnetbyname(), or getnetent(). The
returned pointer, and pointers within the structure, might also be invalidated if the calling thread is terminated.
ERRORS
The getnetbyaddr(), getnetbyname(), getnetent(), and setnetent() functions may fail if:
[EMFILE]
All file descriptors available to the process are currently open.
[ENFILE]
The maximum allowable number of files is currently open in the system.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD ,
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0083 [75] and XSH/TC1-2008/0084 [75] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0090 [656] is applied.
Issue 8
Austin Group Defect 368 is applied, adding a requirement for FD_CLOEXEC to be set if a file descriptor is used, and adding the
[EMFILE] and [ENFILE] errors.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/strxfrm.html =====
strxfrm
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
strxfrm, strxfrm_l — string transformation
SYNOPSIS
#include
size_t strxfrm(char *restrict s1, const char *restrict s2, size_t n);
[CX]  size_t strxfrm_l(char *restrict s1, const char *restrict s2,
size_t n, locale_t locale);
DESCRIPTION
For strxfrm(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The strxfrm() [CX]   and strxfrm_l()
functions shall transform the string pointed to by s2 and place the resulting string into the array pointed to by
s1. The transformation is such that if strcmp() is applied to two transformed
strings, it shall return a value greater than, equal to, or less than 0, corresponding to the result of strcoll() [CX]   or strcoll_l(),
respectively, applied to the same two original strings
[CX]
with the same locale.   No more than n bytes are
placed into the resulting array pointed to by s1, including the terminating NUL character. If n is 0, s1 is
permitted to be a null pointer. If copying takes place between objects that overlap, the behavior is undefined.
[CX]  The
strxfrm() and strxfrm_l() functions shall not change the setting of errno if successful.
Since no return value is reserved to indicate an error, an application wishing to check for error situations should set
errno to 0, then call strxfrm() [CX]   or strxfrm_l(),   then check errno.
[CX]  The
behavior is undefined if the locale argument to strxfrm_l() is the special locale object LC_GLOBAL_LOCALE or is not a
valid locale object handle.
RETURN VALUE
Upon successful completion, strxfrm() [CX]   and strxfrm_l()   shall return the length of the transformed string (not including the terminating NUL character).
If the value returned is n or more, the contents of the array pointed to by s1 are unspecified.
On error, strxfrm() [CX]   and strxfrm_l()   may
set errno but no return value is reserved to indicate an error.
ERRORS
These functions may fail if:
[EINVAL]
[CX]
The string pointed to by the s2 argument contains characters outside the domain of the collating sequence.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The transformation function is such that two transformed strings can be ordered by strcmp() as appropriate to collating sequence information in the current locale (category
LC_COLLATE ).
The fact that when n is 0 s1 is permitted to be a null pointer is useful to determine the size of the s1
array prior to making the transformation.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
strcmp(), strcoll()
XBD
CHANGE HISTORY
First released in Issue 3. Included for alignment with the ISO C standard.
Issue 5
The DESCRIPTION is updated to indicate that errno does not change if the function is successful.
Issue 6
Extensions beyond the ISO C standard are marked.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
In the RETURN VALUE and ERRORS sections, the [EINVAL] optional error condition is added if no conversion could be performed.
The strxfrm() prototype is updated for alignment with the ISO/IEC 9899:1999 standard.
Issue 7
The strxfrm_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0624 [283], XSH/TC1-2008/0625 [283], and XSH/TC1-2008/0626 [302] are
applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/recv.html =====
recv
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
recv — receive a message from a connected socket
SYNOPSIS
#include
ssize_t recv(int socket, void *buffer, size_t length, int
flags);
DESCRIPTION
The recv() function shall receive a message from a connection-mode or connectionless-mode socket. It is normally used
with connected sockets because it does not permit the application to retrieve the source address of received data.
The recv() function takes the following arguments:
socket
Specifies the socket file descriptor.
buffer
Points to a buffer where the message should be stored.
length
Specifies the length in bytes of the buffer pointed to by the buffer argument.
flags
Specifies the type of message reception. Values of this argument are formed by logically OR'ing zero or more of the following
values:
MSG_PEEK
Peeks at an incoming message. The data is treated as unread and the next recv() or similar function shall still return
this data.
MSG_OOB
Requests out-of-band data. The significance and semantics of out-of-band data are protocol-specific.
MSG_WAITALL
On SOCK_STREAM sockets this requests that the function block until the full amount of data can be returned. The function may
return the smaller amount of data if the socket is a message-based socket, if a signal is caught, if the connection is terminated,
if MSG_PEEK was specified, or if an error is pending for the socket.
The recv() function shall return the length of the message written to the buffer pointed to by the buffer
argument. For message-based sockets, such as SOCK_DGRAM and SOCK_SEQPACKET, the entire message shall be read in a single operation.
If a message is too long to fit in the supplied buffer, and MSG_PEEK is not set in the flags argument, the excess bytes
shall be discarded. For stream-based sockets, such as SOCK_STREAM, message boundaries shall be ignored. In this case, data shall be
returned to the user as soon as it becomes available, and no data shall be discarded.
If the MSG_WAITALL flag is not set, data shall be returned only up to the end of the first message.
If no messages are available at the socket and O_NONBLOCK is not set on the socket's file descriptor, recv() shall block
until a message arrives or a timeout occurs (see SO_RCVTIMEO in 2.10.16 Use
of Options). If no messages are available at the socket and O_NONBLOCK is set on the socket's file descriptor,
recv() shall fail and set errno to [EAGAIN] or [EWOULDBLOCK].
RETURN VALUE
Upon successful completion, recv() shall return the length of the message in bytes. If no messages are available to be
received and the peer has performed an orderly shutdown, recv() shall return 0. Otherwise, -1 shall be returned and
errno set to indicate the error.
ERRORS
The recv() function shall fail if:
[EAGAIN] or [EWOULDBLOCK]
The socket's file descriptor is marked O_NONBLOCK and no data is waiting to be received; or MSG_OOB is set and no out-of-band data
is available and either the socket's file descriptor is marked O_NONBLOCK or the socket does not support blocking to await
out-of-band data. See also SO_RCVTIMEO in 2.10.16 Use of Options
.
[EBADF]
The socket argument is not a valid file descriptor.
[ECONNRESET]
A connection was forcibly closed by a peer.
[EINTR]
The recv() function was interrupted by a signal that was caught, before any data was available.
[EINVAL]
The MSG_OOB flag is set and no out-of-band data is available.
[ENOTCONN]
A receive is attempted on a connection-mode socket that is not connected.
[ENOTSOCK]
The socket argument does not refer to a socket.
[EOPNOTSUPP]
The specified flags are not supported for this socket type or protocol.
[ETIMEDOUT]
The connection timed out during connection establishment, or due to a transmission timeout on active connection.
The recv() function may fail if:
[EIO]
An I/O error occurred while reading from or writing to the file system.
[ENOBUFS]
Insufficient resources were available in the system to perform the operation.
[ENOMEM]
Insufficient memory was available to fulfill the request.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The recv() function is equivalent to recvfrom() with null pointer
address and address_len arguments, and to read() if the socket
argument refers to a socket and the flags argument is 0.
The select() and poll() functions can
be used to determine when data is available to be received.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
poll(), pselect(), read(), recvmsg(), recvfrom(), send(), sendmsg(), sendto(), setsockopt(), shutdown(), socket(), write()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0502 [462] is applied.
Issue 8
Austin Group Defect 1429 is applied, clarifying the behavior on timeout by adding references to 2.10.16 Use of Options.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pipe2.html =====
pipe
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pipe, pipe2 — create an interprocess channel
SYNOPSIS
#include
int pipe(int fildes[2]);
int pipe2(int fildes[2], int flag);
DESCRIPTION
The pipe() function shall create a pipe and place two file descriptors, one each into the arguments fildes[0] and
fildes[1], that refer to the open file descriptions for the read and write ends of the pipe, respectively. The file
descriptors shall be allocated as described in 2.6 File Descriptor
Allocation. The FD_CLOEXEC and FD_CLOFORK flags shall be clear on both file descriptors. The O_NONBLOCK flag shall be
clear on both open file descriptions. (The fcntl() function can be used to set this
flag.)
Data can be written to the file descriptor fildes[1] and read from the file descriptor fildes[0]. A read on the
file descriptor fildes[0] shall access data written to the file descriptor fildes[1] on a first-in-first-out basis.
It is unspecified whether fildes[0] is also open for writing and whether fildes[1] is also open for reading.
A process has the pipe open for reading (correspondingly writing) if it has a file descriptor open that refers to the read end,
fildes[0] (write end, fildes[1]).
The pipe's user ID shall be set to the effective user ID of the calling process.
The pipe's group ID shall be set to the effective group ID of the calling process.
Upon successful completion, pipe() shall mark for update the last data access, last data modification, and last file
status change timestamps of the pipe.
The pipe2() function shall be equivalent to the pipe() function, except that the state of O_NONBLOCK on the new
file descriptions and FD_CLOEXEC and FD_CLOFORK on the new file descriptors shall be determined solely by the flag argument,
which can be constructed from a bitwise-inclusive OR of flags from the following list (provided by ):
O_CLOEXEC
Atomically set the FD_CLOEXEC flag on both new file descriptors.
O_CLOFORK
Atomically set the FD_CLOFORK flag on both new file descriptors.
O_NONBLOCK
Set the O_NONBLOCK file status flag on both new file descriptions.
RETURN VALUE
Upon successful completion, 0 shall be returned; otherwise, -1 shall be returned and errno set to indicate the error, no
file descriptors shall be allocated and the contents of fildes shall be left unmodified.
ERRORS
The pipe() and pipe2() functions shall fail if:
[EMFILE]
All, or all but one, of the file descriptors available to the process are currently open.
[ENFILE]
The number of simultaneously open files in the system would exceed a system-imposed limit.
The pipe2() function may fail if:
[EINVAL]
The value of the flag argument is invalid.
The following sections are informative.
EXAMPLES
Using a Pipe to Pass Data Between a Parent Process and a Child
Process
The following example demonstrates the use of a pipe to transfer data between a parent process and a child process. Error
handling is excluded, but otherwise this code demonstrates good practice when using pipes: after the fork() the two processes close the unused ends of the pipe before they commence transferring
data.
#include
#include
...
int fildes[2];
const int BSIZE = 100;
char buf[BSIZE];
ssize_t nbytes;
int status;
status = pipe(fildes);
if (status == -1 ) {
/* an error occurred */
...
}
switch (fork()) {
case -1: /* Handle error */
break;
case 0:  /* Child - reads from pipe */
close(fildes[1]);                       /* Write end is unused */
nbytes = read(fildes[0], buf, BSIZE);   /* Get data from pipe */
/* At this point, a further read would see end-of-file ... */
close(fildes[0]);                       /* Finished with pipe */
exit(EXIT_SUCCESS);
default:  /* Parent - writes to pipe */
close(fildes[0]);                       /* Read end is unused */
write(fildes[1], "Hello world\n", 12);  /* Write data on pipe */
close(fildes[1]);                       /* Child will see EOF */
exit(EXIT_SUCCESS);
}
APPLICATION USAGE
None.
RATIONALE
The wording carefully avoids using the verb "to open" in order to avoid any implication of use of open(); see also write().
The O_CLOEXEC and O_CLOFORK flags of pipe2() are necessary to avoid a data race in multi-threaded applications. Without
O_CLOFORK, a file descriptor is leaked into a child process created by one thread in the window between another thread creating a
file descriptor with pipe() and then using fcntl() to set the FD_CLOFORK flag.
Without O_CLOEXEC, a file descriptor intentionally inherited by child processes is similarly leaked into an executed program if
FD_CLOEXEC is not set atomically.
Since pipes are often used for communication between a parent and child process, O_CLOFORK has to be used with care in order for
the pipe to be usable. If the parent will be writing and the child will be reading, O_CLOFORK should be used when creating the
pipe, and then fcntl() should be used to clear FD_CLOFORK for the read side of the
pipe. This prevents the write side from leaking into other children, ensuring the child will get end-of-file when the parent closes
the write side (although the read side can still be leaked). If the parent will be reading and the child will be writing, there is
no way to prevent the write side being leaked (short of preventing other threads from creating child processes) in order to ensure
the parent gets end-of-file when the child closes the write side, and so the two processes should use an alternative method of
indicating the end of communications.
Arranging for FD_CLOEXEC to be set appropriately is more straightforward. The parent should use O_CLOEXEC when creating the pipe
and the child should clear FD_CLOEXEC on the side to be passed to the new program before calling an exec family function to execute it.
The O_NONBLOCK flag is for convenience in avoiding additional fcntl() calls.
FUTURE DIRECTIONS
None.
SEE ALSO
2.6 File Descriptor Allocation, fcntl(), read(), write()
XBD ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The DESCRIPTION is updated to indicate that certain dispositions of fildes[0] and fildes[1] are unspecified.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/65 is applied, adding the example to the EXAMPLES
section.
Issue 7
SD5-XSH-ERN-156 is applied, updating the DESCRIPTION to state the setting of the pipe's user ID and group ID.
Changes are made related to support for finegrained timestamps.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0247 [835] and XSH/TC2-2008/0248 [467,835] are applied.
Issue 8
Austin Group Defects 411, 1318, and 1577 are applied, adding pipe2() and FD_CLOFORK.
Austin Group Defect 1576 is applied, adding the word "respectively".
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/atomic_fetch_xor.html =====
atomic_fetch_add
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
atomic_fetch_add, atomic_fetch_add_explicit, atomic_fetch_and, atomic_fetch_and_explicit, atomic_fetch_or,
atomic_fetch_or_explicit, atomic_fetch_sub, atomic_fetch_sub_explicit, atomic_fetch_xor, atomic_fetch_xor_explicit — atomically
replace the value of an object with the result of a computation
SYNOPSIS
#include
C atomic_fetch_add(volatile A *object, M operand); C
atomic_fetch_add_explicit(volatile A *object, M operand,
memory_order order); C atomic_fetch_and(volatile A
*object, M operand); C atomic_fetch_and_explicit(volatile A
*object, M operand,
memory_order order); C atomic_fetch_or(volatile A
*object, M operand); C atomic_fetch_or_explicit(volatile A
*object, M operand,
memory_order order); C atomic_fetch_sub(volatile A
*object, M operand); C atomic_fetch_sub_explicit(volatile A
*object, M operand,
memory_order order); C atomic_fetch_xor(volatile A
*object, M operand); C atomic_fetch_xor_explicit(volatile A
*object, M operand,
memory_order order);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
Implementations that define the macro __STDC_NO_ATOMICS__ need not provide the  header nor support these generic functions.
The atomic_fetch_add_explicit() generic function shall atomically replace the value pointed to by object with the
result of adding operand to this value. This operation shall be an atomic read-modify-write operation (see XBD 4.15.1 Memory Ordering). Memory shall be affected according to the value of
order.
The atomic_fetch_add() generic function shall be equivalent to atomic_fetch_add_explicit() called with
order set to memory_order_seq_cst.
The other atomic_fetch_*() generic functions shall be equivalent to atomic_fetch_add_explicit() if their name ends
with explicit, or to atomic_fetch_add() if it does not, respectively, except that they perform the computation
indicated in their name, instead of addition:
sub
subtraction
or
bitwise inclusive OR
xor
bitwise exclusive OR
and
bitwise AND
For addition and subtraction, the application shall ensure that A is an atomic integer type or an atomic pointer type and is not
atomic_bool. For the other operations, the application shall ensure that A is an atomic integer type and is not
atomic_bool.
For signed integer types, the computation shall silently wrap around on overflow; there are no undefined results. For pointer
types, the result can be an undefined address, but the computations otherwise have no undefined behavior.
RETURN VALUE
These generic functions shall return the value pointed to by object immediately before the effects.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The operation of these generic functions is nearly equivalent to the operation of the corresponding compound assignment
operators +=, -=, etc. The only differences are that the compound assignment operators are not guaranteed to
operate atomically, and the value yielded by a compound assignment operator is the updated value of the object, whereas the value
returned by these generic functions is the previous value of the atomic object.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD 4.15.1 Memory Ordering,
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/ldexpl.html =====
ldexp
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ldexp, ldexpf, ldexpl — load exponent of a floating-point number
SYNOPSIS
#include
double ldexp(double x, int exp);
float ldexpf(float x, int exp);
long double ldexpl(long double x, int exp);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the quantity x * 2exp.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return x multiplied by 2, raised to the power exp.
If these functions would cause overflow, a range error shall occur and ldexp(), ldexpf(), and ldexpl()
shall return ±HUGE_VAL, ±HUGE_VALF, and ±HUGE_VALL (according to the sign of x), respectively.
If the correct value would cause underflow, [MXX]   and is not representable,   a range error may occur, and ldexp(), ldexpf(), and ldexpl() shall return
[MXX]
0.0, or   (if IEC 60559 Floating-Point is not supported)
an implementation-defined value no greater in magnitude than DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0 or ±Inf, x shall be returned.
If exp is 0, x shall be returned.
[MXX]
If the correct value would cause underflow, and is representable, a range error may occur and the correct value shall be returned.
ERRORS
These functions shall fail if:
Range Error
The result overflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall be
raised.
These functions may fail if:
Range Error
The result underflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), frexp(), isnan()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The ldexpf() and ldexpl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0352 [68] and XSH/TC1-2008/0353 [68] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_cond_timedwait.html =====
pthread_cond_clockwait
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_cond_clockwait, pthread_cond_timedwait, pthread_cond_wait — wait on a condition
SYNOPSIS
#include
int pthread_cond_clockwait(pthread_cond_t *restrict cond,
pthread_mutex_t *restrict mutex, clockid_t clock_id,
const struct timespec *restrict abstime);
int pthread_cond_timedwait(pthread_cond_t *restrict cond,
pthread_mutex_t *restrict mutex,
const struct timespec *restrict abstime);
int pthread_cond_wait(pthread_cond_t *restrict cond,
pthread_mutex_t *restrict mutex);
DESCRIPTION
The pthread_cond_clockwait(), pthread_cond_timedwait(), and pthread_cond_wait() functions shall block on a
condition variable. The application shall ensure that these functions are called with mutex locked by the calling thread;
otherwise, an error (for PTHREAD_MUTEX_ERRORCHECK and robust mutexes) or undefined behavior (for other mutexes) results.
These functions atomically release mutex and cause the calling thread to block on the condition variable cond;
atomically here means "atomically with respect to access by another thread to the mutex and then the condition variable". That
is, if another thread is able to acquire the mutex after the about-to-block thread has released it, then a subsequent call to
pthread_cond_broadcast() or pthread_cond_signal() in that thread shall behave as if it were issued after the
about-to-block thread has blocked.
Upon successful return, the mutex shall have been locked and shall be owned by the calling thread.
If mutex is a robust mutex where an owner terminated while holding the lock and the state is recoverable, the mutex shall
be acquired even though the function returns [EOWNERDEAD].
When using condition variables there is always a Boolean predicate involving shared variables associated with each condition
wait that is true if the thread should proceed. Spurious wakeups from the pthread_cond_clockwait(),
pthread_cond_timedwait(), or pthread_cond_wait() functions may occur. Since the return from
pthread_cond_clockwait(), pthread_cond_timedwait(), or pthread_cond_wait() does not imply anything about the
value of this predicate, the predicate should be re-evaluated upon such return.
When a thread waits on a condition variable, having specified a particular mutex to the pthread_cond_clockwait(),
pthread_cond_timedwait(), or pthread_cond_wait() operation, a dynamic binding is formed between that mutex and
condition variable that remains in effect as long as at least one thread is blocked on the condition variable. During this time,
the effect of an attempt by any thread to wait on that condition variable using a different mutex is undefined. Once all waiting
threads have been unblocked (as by the pthread_cond_broadcast()
operation), the next wait operation on that condition variable shall form a new dynamic binding with the mutex specified by that
wait operation. Even though the dynamic binding between condition variable and mutex may be removed or replaced between the time a
thread is unblocked from a wait on the condition variable and the time that it returns to the caller or begins cancellation
cleanup, the unblocked thread shall always re-acquire the mutex specified in the condition wait operation call from which it is
returning.
A condition wait (whether timed or not) is a cancellation point. When the cancelability type of a thread is set to
PTHREAD_CANCEL_DEFERRED, a side-effect of acting upon a cancellation request while in a condition wait is that the mutex is (in
effect) re-acquired before calling the first cancellation cleanup handler. The effect is as if the thread were unblocked, allowed
to execute up to the point of returning from the call to pthread_cond_clockwait(), pthread_cond_timedwait(), or
pthread_cond_wait(), but at that point notices the cancellation request and, instead of returning to the caller, starts the
thread cancellation activities, which includes calling cancellation cleanup handlers.
A thread that has been unblocked because it has been canceled while blocked in a call to pthread_cond_clockwait(),
pthread_cond_timedwait(), or pthread_cond_wait() shall not consume any condition signal that may be directed
concurrently at the condition variable if there are other threads blocked on the condition variable.
The pthread_cond_clockwait() function shall be equivalent to pthread_cond_wait(), except that an error is returned
if the absolute time specified by abstime as measured against the clock indicated by clock_id passes (that is, the
current time measured by that clock equals or exceeds abstime) before the condition cond is signaled or broadcasted,
or if the absolute time specified by abstime has already been passed at the time of the call. Implementations shall support
passing CLOCK_REALTIME and CLOCK_MONOTONIC to pthread_cond_clockwait() as the clock_id argument. When such timeouts
occur, pthread_cond_clockwait() shall nonetheless release and re-acquire the mutex referenced by mutex, and may
consume a condition signal directed concurrently at the condition variable.
The pthread_cond_timedwait() function shall be equivalent to pthread_cond_clockwait(), except that it lacks the
clock_id argument. The clock to measure abstime against shall instead come from the condition variable's clock
attribute which can be set by pthread_condattr_setclock() prior to
the condition variable's creation. If no clock attribute has been set, the default shall be CLOCK_REALTIME.
If a signal is delivered to a thread waiting for a condition variable, upon return from the signal handler the thread resumes
waiting for the condition variable as if it was not interrupted, or it shall return zero due to spurious wakeup.
The behavior is undefined if the value specified by the cond or mutex argument to these functions does not refer
to an initialized condition variable or an initialized mutex object, respectively.
RETURN VALUE
Except for [ETIMEDOUT], [ENOTRECOVERABLE], and [EOWNERDEAD], all these error checks shall act as if they were performed
immediately at the beginning of processing for the function and shall cause an error return, in effect, prior to modifying the
state of the mutex specified by mutex or the condition variable specified by cond.
Upon successful completion, a value of zero shall be returned; otherwise, an error number shall be returned to indicate the
error.
ERRORS
These functions shall fail if:
[EAGAIN]
The mutex is a robust mutex and the system resources available for robust mutexes owned would be exceeded.
[ENOTRECOVERABLE]
The state protected by the mutex is not recoverable.
[EOWNERDEAD]
The mutex is a robust mutex and the process containing the previous owning thread terminated while holding the mutex lock. The
mutex lock shall be acquired by the calling thread and it is up to the new owner to make the state consistent.
[EPERM]
The mutex type is PTHREAD_MUTEX_ERRORCHECK or the mutex is a robust mutex, and the current thread does not own the mutex.
The pthread_cond_clockwait() and pthread_cond_timedwait() functions shall fail if:
[ETIMEDOUT]
The time specified by abstime has passed.
[EINVAL]
The abstime argument specified a nanosecond value less than zero or greater than or equal to 1000 million, or the
clock_id argument passed to pthread_cond_clockwait() is invalid or not supported.
These functions may fail if:
[EOWNERDEAD]
The mutex is a robust mutex and the previous owning thread terminated while holding the mutex lock. The mutex lock shall be
acquired by the calling thread and it is up to the new owner to make the state consistent.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Applications that have assumed that non-zero return values are errors will need updating for use with robust mutexes, since a
valid return for a thread acquiring a mutex which is protecting a currently inconsistent state is [EOWNERDEAD]. Applications that
do not check the error returns, due to ruling out the possibility of such errors arising, should not use robust mutexes. If an
application is supposed to work with normal and robust mutexes, it should check all return values for error conditions and if
necessary take appropriate action.
RATIONALE
If an implementation detects that the value specified by the cond argument to pthread_cond_clockwait(),
pthread_cond_timedwait(), or pthread_cond_wait() does not refer to an initialized condition variable, or detects that
the value specified by the mutex argument does not refer to an initialized mutex object, it is recommended that the function
should fail and report an [EINVAL] error.
Condition Wait Semantics
It is important to note that when pthread_cond_clockwait(), pthread_cond_timedwait(), and
pthread_cond_wait() return without error, the associated predicate may still be false. Similarly, when
pthread_cond_clockwait() or pthread_cond_timedwait() returns with the timeout error, the associated predicate may be
true due to an unavoidable race between the expiration of the timeout and the predicate state change.
The application needs to recheck the predicate on any return because it cannot be sure there is another thread waiting on the
thread to handle the signal, and if there is not then the signal is lost. The burden is on the application to check the
predicate.
Some implementations, particularly on a multi-processor, may sometimes cause multiple threads to wake up when the condition
variable is signaled simultaneously on different processors.
In general, whenever a condition wait returns, the thread has to re-evaluate the predicate associated with the condition wait to
determine whether it can safely proceed, should wait again, or should declare a timeout. A return from the wait does not imply that
the associated predicate is either true or false.
It is thus recommended that a condition wait be enclosed in the equivalent of a "while loop" that checks the predicate.
Timed Wait Semantics
An absolute time measure was chosen for specifying the timeout parameter for two reasons. First, a relative time measure can be
easily implemented on top of a function that specifies absolute time, but there is a race condition associated with specifying an
absolute timeout on top of a function that specifies relative timeouts. For example, assume that clock_gettime() returns the current time and cond_relative_timed_wait() uses
relative timeouts:
clock_gettime(CLOCK_REALTIME, &now)
reltime = sleep_til_this_absolute_time -now;
cond_relative_timed_wait(c, m, &reltime);
If the thread is preempted between the first statement and the last statement, the thread blocks for too long. Blocking,
however, is irrelevant if an absolute timeout is used. An absolute timeout also need not be recomputed if it is used multiple times
in a loop, such as that enclosing a condition wait.
For cases when the system clock is advanced discontinuously by an operator, it is expected that implementations process any
timed wait expiring at an intervening time as if that time had actually occurred.
Choice of Clock
Care should be taken to decide which clock is most appropriate when waiting with a timeout. The system clock CLOCK_REALTIME, as
used by default with pthread_cond_timedwait(), may be subject to jumps forwards and backwards in order to correct it against
actual time. CLOCK_MONOTONIC is guaranteed not to jump backwards and must also advance in real time, so using it via
pthread_cond_clockwait() or pthread_condattr_setclock() may
be more appropriate.
Cancellation and Condition Wait
A condition wait, whether timed or not, is a cancellation point. That is, the functions pthread_cond_clockwait(),
pthread_cond_timedwait(), and pthread_cond_wait() are points where a pending (or concurrent) cancellation request is
noticed. The reason for this is that an indefinite wait is possible at these points—whatever event is being waited for, even if the
program is totally correct, might never occur; for example, some input data being awaited might never be sent. By making condition
wait a cancellation point, the thread can be canceled and perform its cancellation cleanup handler even though it may be stuck in
some indefinite wait.
A side-effect of acting on a cancellation request while a thread is blocked on a condition variable is to re-acquire the mutex
before calling any of the cancellation cleanup handlers. This is done in order to ensure that the cancellation cleanup handler is
executed in the same state as the critical code that lies both before and after the call to the condition wait function. This rule
is also required when interfacing to POSIX threads from languages, such as Ada or C++, which may choose to map cancellation onto a
language exception; this rule ensures that each exception handler guarding a critical section can always safely depend upon the
fact that the associated mutex has already been locked regardless of exactly where within the critical section the exception was
raised. Without this rule, there would not be a uniform rule that exception handlers could follow regarding the lock, and so coding
would become very cumbersome.
Therefore, since some statement has to be made regarding the state of the lock when a cancellation is delivered during a
wait, a definition has been chosen that makes application coding most convenient and error free.
When acting on a cancellation request while a thread is blocked on a condition variable, the implementation is required to
ensure that the thread does not consume any condition signals directed at that condition variable if there are any other threads
waiting on that condition variable. This rule is specified in order to avoid deadlock conditions that could occur if these two
independent requests (one acting on a thread and the other acting on the condition variable) were not processed independently.
Performance of Mutexes and Condition Variables
Mutexes are expected to be locked only for a few instructions. This practice is almost automatically enforced by the desire of
programmers to avoid long serial regions of execution (which would reduce total effective parallelism).
When using mutexes and condition variables, one tries to ensure that the usual case is to lock the mutex, access shared data,
and unlock the mutex. Waiting on a condition variable should be a relatively rare situation. For example, when implementing a
read-write lock, code that acquires a read-lock typically needs only to increment the count of readers (under mutual-exclusion) and
return. The calling thread would actually wait on the condition variable only when there is already an active writer. So the
efficiency of a synchronization operation is bounded by the cost of mutex lock/unlock and not by condition wait. Note that in the
usual case there is no context switch.
This is not to say that the efficiency of condition waiting is unimportant. Since there needs to be at least one context switch
per Ada rendezvous, the efficiency of waiting on a condition variable is important. The cost of waiting on a condition variable
should be little more than the minimal cost for a context switch plus the time to unlock and lock the mutex.
Features of Mutexes and Condition Variables
It had been suggested that the mutex acquisition and release be decoupled from condition wait. This was rejected because it is
the combined nature of the operation that, in fact, facilitates realtime implementations. Those implementations can atomically move
a high-priority thread between the condition variable and the mutex in a manner that is transparent to the caller. This can prevent
extra context switches and provide more deterministic acquisition of a mutex when the waiting thread is signaled. Thus, fairness
and priority issues can be dealt with directly by the scheduling discipline. Furthermore, the current condition wait operation
matches existing practice.
Scheduling Behavior of Mutexes and Condition Variables
Synchronization primitives that attempt to interfere with scheduling policy by specifying an ordering rule are considered
undesirable. Threads waiting on mutexes and condition variables are selected to proceed in an order dependent upon the scheduling
policy rather than in some fixed order (for example, FIFO or priority). Thus, the scheduling policy determines which thread(s) are
awakened and allowed to proceed.
Timed Condition Wait
The pthread_cond_clockwait() and pthread_cond_timedwait() functions allow an application to give up waiting for a
particular condition after a given amount of time. An example follows:
(void) pthread_mutex_lock(&t.mn);
t.waiters++;
clock_gettime(CLOCK_MONOTONIC, &ts);
ts.tv_sec += 5;
rc = 0;
while (! mypredicate(&t) && rc == 0)
rc = pthread_cond_clockwait(&t.cond, &t.mn,
CLOCK_MONOTONIC, &ts);
t.waiters--;
if (rc == 0 || mypredicate(&t))
setmystate(&t);
(void) pthread_mutex_unlock(&t.mn);
By making the timeout parameter absolute, it does not need to be recomputed each time the program checks its blocking predicate.
If the timeout was relative, it would have to be recomputed before each call. This would be especially difficult since such code
would need to take into account the possibility of extra wakeups that result from extra broadcasts or signals on the condition
variable that occur before either the predicate is true or the timeout is due. Using CLOCK_MONOTONIC rather than CLOCK_REALTIME
means that the timeout is not influenced by the system clock being changed.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_cond_broadcast()
XBD 4.15.2 Memory Synchronization,
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
The pthread_cond_timedwait() and pthread_cond_wait() functions are marked as part of the Threads option.
The Open Group Corrigendum U021/9 is applied, correcting the prototype for the pthread_cond_wait() function.
The DESCRIPTION is updated for alignment with IEEE Std 1003.1j-2000 by adding semantics for the Clock Selection
option.
The ERRORS section has an additional case for [EPERM] in response to IEEE PASC Interpretation 1003.1c #28.
The restrict keyword is added to the pthread_cond_timedwait() and pthread_cond_wait() prototypes for
alignment with the ISO/IEC 9899:1999 standard.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/89 is applied, updating the DESCRIPTION for consistency with the
pthread_cond_destroy() function that states it is safe to destroy an
initialized condition variable upon which no threads are currently blocked.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/90 is applied, updating words in the DESCRIPTION from "the
cancelability enable state" to "the cancelability type".
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/91 is applied, updating the ERRORS section to remove the error
case related to abstime from the pthread_cond_wait() function, and to make the error case related to abstime
mandatory for pthread_cond_timedwait() for consistency with other functions.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/92 is applied, adding a new paragraph to the RATIONALE section
stating that an application should check the predicate on any return from this function.
Issue 7
SD5-XSH-ERN-44 is applied, changing the definition of the "shall fail" case of the [EINVAL] error.
Changes are made from The Open Group Technical Standard, 2006, Extended API Set Part 3.
The pthread_cond_timedwait() and pthread_cond_wait() functions are moved from the Threads option to the Base.
The [EINVAL] error for an uninitialized condition variable or uninitialized mutex object is removed; this condition results in
undefined behavior"
The [EPERM] error is revised and moved to the "shall fail" list of error conditions for the pthread_cond_timedwait()
function.
The DESCRIPTION is updated to clarify the behavior when mutex is a robust mutex.
The ERRORS section is updated to include "shall fail" cases for PTHREAD_MUTEX_ERRORCHECK mutexes.
The DESCRIPTION is rewritten to clarify that undefined behavior occurs only for mutexes where the [EPERM] error is not
mandated.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0456 [91,286,437] and XSH/TC1-2008/0457 [239] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0271 [749] is applied.
Issue 8
Austin Group Defect 354 is applied, adding the [EAGAIN] error.
Austin Group Defect 1162 is applied, changing "an error code" to "[EOWNERDEAD]".
Austin Group Defects 1216 and 1485 are applied, adding pthread_cond_clockwait().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/statvfs.html =====
fstatvfs
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fstatvfs, statvfs — get file system information
SYNOPSIS
#include
int fstatvfs(int fildes, struct statvfs *buf);
int statvfs(const char *restrict path, struct statvfs *restrict buf);
DESCRIPTION
The fstatvfs() function shall obtain information about the file system containing the file referenced by
fildes.
The statvfs() function shall obtain information about the file system containing the file named by path.
For both functions, the buf argument is a pointer to a statvfs structure that shall be filled. Read, write, or
execute permission of the named file is not required.
The following flags can be returned in the f_flag member:
ST_RDONLY
Read-only file system.
ST_NOSUID
Setuid/setgid bits ignored by exec.
It is unspecified whether all members of the statvfs structure have meaningful values on all file systems.
RETURN VALUE
Upon successful completion, statvfs() shall return 0. Otherwise, it shall return -1 and set errno to indicate the
error.
ERRORS
The fstatvfs() and statvfs() functions shall fail if:
[EIO]
An I/O error occurred while reading the file system.
[EINTR]
A signal was caught during execution of the function.
[EOVERFLOW]
One of the values to be returned cannot be represented correctly in the structure pointed to by buf.
The fstatvfs() function shall fail if:
[EBADF]
The fildes argument is not an open file descriptor.
The statvfs() function shall fail if:
[EACCES]
Search permission is denied on a component of the path prefix.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOENT]
A component of path does not name an existing file or path is an empty string.
[ENOTDIR]
A component of the path prefix names an existing file that is neither a directory nor a symbolic link to a directory, or the
path argument contains at least one non- character and ends with one or more trailing  characters
and the last pathname component names an existing file that is neither a directory nor a symbolic link to a directory.
The statvfs() function may fail if:
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a
length that exceeds {PATH_MAX}.
The following sections are informative.
EXAMPLES
Obtaining File System Information Using fstatvfs()
The following example shows how to obtain file system information for the file system upon which the file named
/home/cnd/mod1 resides, using the fstatvfs() function. The /home/cnd/mod1 file is opened with read/write
privileges and the open file descriptor is passed to the fstatvfs() function.
#include
#include
struct statvfs buffer;
int            status;
...
fildes = open("/home/cnd/mod1", O_RDWR);
status  = fstatvfs(fildes, &buffer);
Obtaining File System Information Using statvfs()
The following example shows how to obtain file system information for the file system upon which the file named
/home/cnd/mod1 resides, using the statvfs() function.
#include
struct statvfs buffer;
int            status;
...
status = statvfs("/home/cnd/mod1", &buffer);
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
chmod(), chown()
, creat(), dup(), exec, fcntl(), futimens(), link(), mknod(), open(), pipe(), read(), time(), unlink(), write()
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Large File Summit extensions are added.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
The restrict keyword is added to the statvfs() prototype for alignment with the ISO/IEC 9899:1999
standard.
The wording of the mandatory [ELOOP] error condition is updated, and a second optional [ELOOP] error condition is added.
Issue 7
Austin Group Interpretation 1003.1-2001 #143 is applied.
SD5-XSH-ERN-68 is applied, correcting the EXAMPLES section.
The fstatvfs() and statvfs() functions are moved from the XSI option to the Base.
The [ENOTDIR] error condition is clarified to cover the condition where the last component of a pathname exists but is not a
directory or a symbolic link to a directory.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0203 [324] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/at_quick_exit.html =====
at_quick_exit
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
at_quick_exit — register a function to to be called from quick_exit()
SYNOPSIS
#include
int at_quick_exit(void (*func)(void));
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The at_quick_exit() function shall register the function pointed to by func, to be called without arguments should
quick_exit() be called. It is unspecified whether a call to the
at_quick_exit() function that does not happen before the quick_exit()
function is called will succeed.
At least 32 functions can be registered with at_quick_exit().
RETURN VALUE
Upon successful completion, at_quick_exit() shall return 0; otherwise, it shall return a non-zero value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The at_quick_exit() function registrations are distinct from the atexit()
registrations, so applications might need to call both registration functions with the same argument.
The functions registered by a call to at_quick_exit() must return to ensure that all registered functions are called.
The application should call sysconf() to obtain the value of {ATEXIT_MAX}, the
number of functions that can be registered. There is no way for an application to tell how many functions have already been
registered with at_quick_exit().
Since the behavior is undefined if the quick_exit() function is called more
than once, portable applications calling at_quick_exit() must ensure that the quick_exit() function is not called when the functions registered by the
at_quick_exit() function are called.
If a function registered by the at_quick_exit() function is called and a portable application needs to stop further
quick_exit() processing, it must call the _exit() function or the _Exit() function or one
of the functions which cause abnormal process termination.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
atexit(), exec, exit(), quick_exit(), sysconf()
XBD
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_attr_setschedpolicy.html =====
pthread_attr_getschedpolicy
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_attr_getschedpolicy, pthread_attr_setschedpolicy — get and set the schedpolicy attribute (REALTIME
THREADS)
SYNOPSIS
[TPS]  #include
int pthread_attr_getschedpolicy(const pthread_attr_t *restrict attr,
int *restrict policy);
int pthread_attr_setschedpolicy(pthread_attr_t *attr, int policy);
DESCRIPTION
The pthread_attr_getschedpolicy() and pthread_attr_setschedpolicy() functions, respectively, shall get and set the
schedpolicy attribute in the attr argument.
The supported values of policy shall include SCHED_FIFO, SCHED_RR, and SCHED_OTHER, which are defined in the  header. When threads executing with the scheduling policy SCHED_FIFO,
SCHED_RR, [TSP]   or SCHED_SPORADIC  are waiting on a mutex, they
shall acquire the mutex in priority order when the mutex is unlocked.
The behavior is undefined if the value specified by the attr argument to pthread_attr_getschedpolicy() or
pthread_attr_setschedpolicy() does not refer to an initialized thread attributes object.
RETURN VALUE
If successful, the pthread_attr_getschedpolicy() and pthread_attr_setschedpolicy() functions shall return zero;
otherwise, an error number shall be returned to indicate the error.
ERRORS
The pthread_attr_setschedpolicy() function shall fail if:
[ENOTSUP]
An attempt was made to set the attribute to an unsupported value.
The pthread_attr_setschedpolicy() function may fail if:
[EINVAL]
The value of policy is not valid.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
After these attributes have been set, a thread can be created with the specified attributes using pthread_create(). Using these routines does not affect the current running
thread.
See 2.9.4 Thread Scheduling for further details on thread
scheduling attributes and their default settings.
RATIONALE
If an implementation detects that the value specified by the attr argument to pthread_attr_getschedpolicy() or
pthread_attr_setschedpolicy() does not refer to an initialized thread attributes object, it is recommended that the function
should fail and report an [EINVAL] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_attr_destroy(), pthread_attr_getscope(), pthread_attr_getinheritsched(), pthread_attr_getschedparam(), pthread_create()
XBD ,
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Marked as part of the Realtime Threads Feature Group.
Issue 6
The pthread_attr_getschedpolicy() and pthread_attr_setschedpolicy() functions are marked as part of the Threads
and Thread Execution Scheduling options.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Thread
Execution Scheduling option.
The SCHED_SPORADIC scheduling policy is added for alignment with IEEE Std 1003.1d-1999.
The restrict keyword is added to the pthread_attr_getschedpolicy() prototype for alignment with the
ISO/IEC 9899:1999 standard.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/79 is applied, adding a reference to 2.9.4 Thread Scheduling in the APPLICATION USAGE section.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/80 is applied, updating the ERRORS section to include optional
errors for the case when attr refers to an uninitialized thread attribute object.
Issue 7
The pthread_attr_getschedpolicy() and pthread_attr_setschedpolicy() functions are marked only as part of the
Thread Execution Scheduling option as the Threads option is now part of the Base.
The [EINVAL] error for an uninitialized thread attributes object is removed; this condition results in undefined behavior.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0452 [314] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0263 [757] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/lfind.html =====
lsearch
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
lsearch, lfind — linear search and update
SYNOPSIS
[XSI]  #include
void *lsearch(const void *key, void *base, size_t *nelp, size_t
width,
int (*compar)(const void *, const void *));
void *lfind(const void *key, const void *base, size_t *nelp,
size_t width, int (*compar)(const void *, const void *));
DESCRIPTION
The lsearch() function shall linearly search the table and return a pointer into the table for the matching entry. If the
entry does not occur, it shall be added at the end of the table. The key argument points to the entry to be sought in the
table. The base argument points to the first element in the table. The width argument is the size of an element in
bytes. The nelp argument points to an integer containing the current number of elements in the table. The integer to which
nelp points shall be incremented if the entry is added to the table. The compar argument points to a comparison
function which the application shall supply (for example, strcmp()). It is called
with two arguments that point to the elements being compared. The application shall ensure that the function returns 0 if the
elements are equal, and non-zero otherwise.
The lfind() function shall be equivalent to lsearch(), except that if the entry is not found, it is not added to
the table. Instead, a null pointer is returned.
RETURN VALUE
If the searched for entry is found, both lsearch() and lfind() shall return a pointer to it. Otherwise,
lfind() shall return a null pointer and lsearch() shall return a pointer to the newly added element.
Both functions shall return a null pointer in case of error.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
Storing Strings in a Table
This fragment reads in less than or equal to TABSIZE strings of length less than or equal to ELSIZE and stores them in a table,
eliminating duplicates.
#include
#include
#include
#define TABSIZE 50
#define ELSIZE 120
...
char line[ELSIZE], tab[TABSIZE][ELSIZE];
size_t nel = 0;
...
while (fgets(line, ELSIZE, stdin) != NULL && nel
#include
...
char line[ELSIZE], tab[TABSIZE][ELSIZE];
size_t nel = 0;
char *findline;
void *entry;
findline = "This is a test.\n";
entry = lfind(findline, tab, &nel, ELSIZE, (
int (*)(const void *, const void *)) strcmp);
APPLICATION USAGE
The comparison function need not compare every byte, so arbitrary data may be contained in the elements in addition to the
values being compared.
Undefined results can occur if there is not enough room in the table to add a new item.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
hcreate(), tdelete()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/ceill.html =====
ceil
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ceil, ceilf, ceill — ceiling value function
SYNOPSIS
#include
double ceil(double x);
float ceilf(float x);
long double ceill(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the smallest integral value not less than x.
[MX]
These functions may raise the inexact floating-point exception for finite non-integer arguments.
RETURN VALUE
[MX]  The
returned value shall be independent of the current rounding direction mode and shall have the same sign as x.
Upon successful completion, ceil(), ceilf(), and ceill() shall return the smallest integral value not less
than x, expressed as a type double, float, or long double, respectively.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0 or ±Inf, x shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The integral value returned by these functions need not be expressible as an intmax_t. The return value should be tested
before assigning it to an integer type to avoid the undefined results of an integer overflow.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), floor(), isnan()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The ceilf() and ceill() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0046 [346] is applied.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/towupper_l.html =====
towupper
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
towupper, towupper_l — transliterate lowercase wide-character code to uppercase
SYNOPSIS
#include
wint_t towupper(wint_t wc);
[CX]  wint_t towupper_l(wint_t wc, locale_t locale);
DESCRIPTION
For towupper(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The towupper() [CX]   and towupper_l()
functions have as a domain a type wint_t, the value of which the application shall ensure is a character representable
as a wchar_t, and a wide-character code corresponding to a valid character in the locale used by the function or the value
of WEOF. If the argument has any other value, the behavior is undefined. If the argument of towupper() [CX]   or
towupper_l()  represents a lowercase wide-character code, and
there exists a corresponding uppercase wide-character code as defined by character type information in the current locale
[CX]
or in the locale represented by locale,
respectively (category LC_CTYPE ), the result shall be the corresponding uppercase wide-character code. All other
arguments in the domain are returned unchanged.
[CX]  The
behavior is undefined if the locale argument to towupper_l() is the special locale object LC_GLOBAL_LOCALE or is not
a valid locale object handle.
RETURN VALUE
Upon successful completion, the towupper() [CX]   and towupper_l()   functions shall return the uppercase letter corresponding to the argument passed. Otherwise, they
shall return the argument unchanged.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
setlocale(), uselocale()
XBD 7. Locale, ,
CHANGE HISTORY
First released in Issue 4.
Issue 5
The following change has been made in this version for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E):
The SYNOPSIS has been changed to indicate that this function and associated data types are now made visible by inclusion of the
header rather than .
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
The towupper_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0681 [302], XSH/TC1-2008/0682 [283], and XSH/TC1-2008/0683 [283] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0374 [685] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/atof.html =====
atof
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
atof — convert a string to a double-precision number
SYNOPSIS
#include
double atof(const char *str);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The call atof(str) shall be equivalent to:
strtod(str,(char **)NULL),
except that the handling of errors may differ. If the value cannot be represented, the behavior is undefined.
RETURN VALUE
The atof() function shall return the converted value if the value can be represented.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The atof() function is subsumed by strtod() but is retained because it is
used extensively in existing code. If the number is not known to be in range, strtod() should be used because atof() is not required to perform any error
checking.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
strtod()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/erff.html =====
erf
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
erf, erff, erfl — error functions
SYNOPSIS
#include
double erf(double x);
float erff(float x);
long double erfl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the error function of their argument x, defined as:
\( \frac{2}{\sqrt{\pi}} \int_0^x e^{-t^2} d t\)
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the value of the error function.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0, ±0 shall be returned.
If x is ±Inf, ±1 shall be returned.
If the correct value would cause underflow, a range error may occur, and erf(), erff(), and erfl() shall
return an implementation-defined value no greater in magnitude than DBL_MIN, FLT_MIN, and LDBL_MIN, respectively. [MXX]   If the IEC
60559 Floating-Point option is supported, 2* x/ sqrt() should be returned.
ERRORS
These functions may fail if:
Range Error
[MX]
The result underflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If
the integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception
shall be raised.
The following sections are informative.
EXAMPLES
Computing the Probability for a Normal Variate
This example shows how to use erf() to compute the probability that a normal variate assumes a value in the range
[x1,x2] with x1
double
Phi(const double x1, const double x2)
{
return ( erf(x2*M_SQRT1_2) - erf(x1*M_SQRT1_2) ) / 2;
}
APPLICATION USAGE
Underflow occurs when |x|
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The erf() function is no longer marked as an extension.
The erfc() function is split out onto its own reference page.
The erff() and erfl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/22 is applied, adding the example to the EXAMPLES section.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0092 [68] is applied.
Issue 8
Austin Group Defect 1178 is applied, joining two paragraphs in the RETURN VALUE section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/a64l.html =====
a64l
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
a64l, l64a — convert between a 32-bit integer and a radix-64 ASCII string
SYNOPSIS
[XSI]  #include
long a64l(const char *s);
char *l64a(long value);
DESCRIPTION
These functions maintain numbers stored in radix-64 ASCII characters. This is a notation by which 32-bit integers can be
represented by up to six characters; each character represents a digit in radix-64 notation. If the type long contains more
than 32 bits, only the low-order 32 bits shall be used for these operations.
The characters used to represent digits are '.' (dot) for 0, '/' for 1, '0' through '9' for
[2,11], 'A' through 'Z' for [12,37], and 'a' through 'z' for [38,63].
The a64l() function shall take a pointer to a radix-64 representation, in which the first digit is the least significant,
and return the corresponding long value. If the string pointed to by s contains more than six characters,
a64l() shall use the first six. If the first six characters of the string contain a null terminator, a64l() shall use
only characters preceding the null terminator. The a64l() function shall scan the character string from left to right with
the least significant digit on the left, decoding each character as a 6-bit radix-64 number. If the type long contains more
than 32 bits, the resulting value is sign-extended. The behavior of a64l() is unspecified if s is a null pointer or
the string pointed to by s was not generated by a previous call to l64a().
The l64a() function shall take a long argument and return a pointer to the corresponding radix-64 representation.
The behavior of l64a() is unspecified if value is negative.
The value returned by l64a() may be a pointer into a static buffer. Subsequent calls to l64a() may overwrite the
buffer.
The l64a() function need not be thread-safe.
RETURN VALUE
Upon successful completion, a64l() shall return the long value resulting from conversion of the input string. If a
string pointed to by s is an empty string, a64l() shall return 0L.
The l64a() function shall return a pointer to the radix-64 representation. If value is 0L, l64a() shall
return a pointer to an empty string.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
If the type long contains more than 32 bits, the result of a64l(l64a(x)) is x in the
low-order 32 bits.
RATIONALE
This is not the same encoding as used by either encoding variant of the uuencode
utility.
FUTURE DIRECTIONS
None.
SEE ALSO
strtoul()
XBD
XCU uuencode
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Normative text previously in the APPLICATION USAGE section is moved to the DESCRIPTION.
A note indicating that the l64a() function need not be reentrant is added to the DESCRIPTION.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/posix_spawnattr_getschedparam.html =====
posix_spawnattr_getschedparam
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
posix_spawnattr_getschedparam, posix_spawnattr_setschedparam — get and set the spawn-schedparam attribute of a spawn
attributes object (ADVANCED REALTIME)
SYNOPSIS
[SPN PS]  #include
#include
int posix_spawnattr_getschedparam(const posix_spawnattr_t
*restrict attr, struct sched_param *restrict schedparam);
int posix_spawnattr_setschedparam(posix_spawnattr_t *restrict attr,
const struct sched_param *restrict schedparam);
DESCRIPTION
The posix_spawnattr_getschedparam() function shall obtain the value of the spawn-schedparam attribute from the
attributes object referenced by attr.
The posix_spawnattr_setschedparam() function shall set the spawn-schedparam attribute in an initialized attributes
object referenced by attr.
The spawn-schedparam attribute represents the scheduling parameters to be assigned to the new process image in a spawn
operation (if POSIX_SPAWN_SETSCHEDULER or POSIX_SPAWN_SETSCHEDPARAM is set in the spawn-flags attribute). The default value
of this attribute is unspecified.
RETURN VALUE
Upon successful completion, posix_spawnattr_getschedparam() shall return zero and store the value of the
spawn-schedparam attribute of attr into the object referenced by the schedparam parameter; otherwise, an error
number shall be returned to indicate the error.
Upon successful completion, posix_spawnattr_setschedparam() shall return zero; otherwise, an error number shall be
returned to indicate the error.
ERRORS
These functions may fail if:
[EINVAL]
The value specified by attr is invalid.
The posix_spawnattr_setschedparam() function may fail if:
[EINVAL]
The value of the attribute being set is not valid.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
These functions are part of the Spawn and Process Scheduling options and need not be provided on all implementations.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
posix_spawn(), posix_spawnattr_destroy(), posix_spawnattr_getsigdefault(), posix_spawnattr_getflags(), posix_spawnattr_getpgroup(), posix_spawnattr_getschedpolicy(), posix_spawnattr_getsigmask()
XBD ,
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1d-1999.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/posix_devctl.html =====
posix_devctl
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
posix_devctl — device control
SYNOPSIS
[DC]  #include
int posix_devctl(int fildes, int dcmd, void *restrict dev_data_ptr,
size_t nbyte, int *restrict dev_info_ptr);
DESCRIPTION
The posix_devctl() function shall cause the device control command dcmd to be passed to the driver identified by
fildes. Associated data shall be passed to and/or from the driver depending on direction information encoded in the
dcmd argument or as implied in the dcmd argument by the design and implementation of the driver.
If the dev_data_ptr argument is not a null pointer, it shall be a pointer to a buffer that is provided by the caller and
that contains data bytes to be passed to the driver or provides space for receiving data bytes to be passed back from the driver,
or both.
If the data bytes are to be passed to the driver, at least nbyte bytes of associated data shall be made available to the
driver; if the data bytes are to be passed from the driver, no more than nbyte bytes shall be passed.
The driver may be executing in an address space different from the address space of the calling thread. Therefore, if the data
bytes passed to the driver (i.e., the contents of the memory area starting at dev_data_ptr and continuing for nbyte
bytes) contain pointers to memory in the address space of the calling thread and the driver uses these pointers to access that
memory, the effects are unspecified.
[OB]  If
dev_data_ptr is not a null pointer and nbyte is zero, the amount of data passed to and/or from the driver is
unspecified. This feature is obsolescent and is only provided for compatibility with existing device drivers.
If dev_data_ptr is a null pointer, there shall be no data bytes passed between the caller and the driver other than the
data specified in the rest of the arguments to posix_devctl() and in its return value.
The dev_info_ptr argument provides the opportunity to return an integer number containing additional device information,
instead of just a success/failure indication. For implementation-provided dcmd values, it is implementation-defined whether
each such value causes the int pointed to by dev_info_ptr to be set and, if set, what value it is set to.
For each supported device, the set of valid dcmd commands, the associated data interpretation, and the effects of the
command on the device are all defined by the driver for the device identified by fildes, and are therefore
implementation-defined for implementation-provided device drivers.
RETURN VALUE
Upon successful completion, posix_devctl() shall return zero; otherwise an error number shall be returned to indicate the
error. The value returned in the int value pointed to by dev_info_ptr is driver dependent.
ERRORS
The posix_devctl() function shall fail if:
[EBADF]
The fildes argument is not a valid open file descriptor.
The posix_devctl() function may fail if:
[EINTR]
The posix_devctl() function was interrupted by a signal.
[EINVAL]
The nbyte argument exceeds an implementation-defined maximum or is less than the minimum number of bytes required for
this command.
[EINVAL]
The dcmd argument is not valid for this device.
[ENOTTY]
The fildes argument is not associated with a character special file that accepts control functions.
[EPERM]
The requesting process does not have the appropriate privilege to request the device to perform the specified command.
Driver code may detect other errors, but the error numbers returned are driver dependent. See "Recommended Practice for
Driver-Detected Errors" in RATIONALE.
If the posix_devctl() function fails, the effect of this failed function on the device is driver dependent. Corresponding
data might be transferred, partially transferred, or not transferred at all.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
Background
An interface to be included in the POSIX standard should improve source code portability of application programs. In traditional
UNIX practice, ioctl() was used to handle special devices. Therefore, a general specification of its arguments cannot be
written. Based on this fact, in the past many people claimed that ioctl(), or something close to it, had no place in the
POSIX standards.
Against this perception stood the widespread use of ioctl() to interface to all sorts of drivers for a vast variety of
hardware used in all areas of general-purpose, realtime, and embedded computing, such as analog-digital converters, counters, and
video graphic devices. These devices provide a set of services that cannot be represented or used in terms of read() or write() calls.
The arguments in favor of ioctl() standardization can be summarized as follows:
Even if ioctl() addresses very different hardware, many of these devices either are actually the same, interfaced to
different computer systems with different implementations of operating systems, or belong to classes of devices with rather high
commonality in their functions, e.g., analog-digital converters or digital-analog converters. Growing standardization of the
control and status register (CSR) space of these devices allows exploitation of a growing similarity of control codes and data for
these devices. A general mechanism is needed to control these devices.
In all these cases, a standardized interface from the application program to drivers for these devices will improve source code
portability.
Even if control codes and device data have to be changed when porting applications from one system to another, the definition of
ioctl() largely improves readability of a program handling special devices. Changes are confined to more clearly labeled
places.
A driver for a specific device normally cannot be considered portable per se, but an application that uses this driver
can be made portable if all interfaces needed are well defined and standardized. Users and integrators of realtime systems often
add device drivers for specific devices, and a standard interface simplifies this process. Also, device drivers often follow their
special hardware from system to system.
In recognition of these reasons, The Open Group included ioctl() in the The Single UNIX Specification, Version 1, and the
interface was later incorporated into POSIX.1 under the XSI STREAMS option (although that option was subsequently removed).
The posix_devctl() interface defined in this standard provides an alternative to the the various ioctl()
implementations with a standard interface that captures the extensibility of ioctl(), but avoids several of its
deficiencies, which is mentioned in "Relationship to ioctl() and the Perceived Needs for Improvement" below.
Existing Practice
The ioctl() interface is widely used. It has provided the generality mentioned above. Existing practice encodes into the
second parameter information about data size and direction in some systems. An example of such an encoding is the use in BSD 4.3 of
two bits of the command word as read/write bits. However, ioctl() has definite problems with the way that its sometimes
optional third parameter can be interpreted.
This practice is similar to the existing POSIX fcntl() function, in which the third
parameter can be optional for the F_GETFD and F_GETFL commands, an int when used with the F_DUPFD, F_SETFD, or F_SETFL
commands, or a struct flock when used with the F_GETLK, F_SETLK, or F_SETLKW commands. However, the fcntl() interface defines two distinct and known data types as possible for the third
parameter. This is not the case in the ioctl() interface, where any number of device driver specific structures and commands
are used.
Relationship to ioctl() and the Perceived Needs for Improvement
A.11 General Terminal Interface briefly mentions some of the perceived
deficiencies in existing implementations of the ioctl() function, in the context of those ioctl() commands used to
implement terminal control. The standard developers decided that, since the set of such control operations was fairly well defined,
suitable encapsulations such as tcsetattr(), tcsendbreak(), and tcdrain() could be
standardized. These interfaces, while successfully standardizing portable terminal control operations, are not extensible to
arbitrary user-supplied devices.
There are several perceived deficiencies with the ioctl() function that drove the development of the
posix_devctl() interface as an alternative:
The major problem with ioctl() is that the third argument (when one is passed) varies in both size and type according to
the second (command) argument. It is not unprecedented in POSIX, or standards in general, for a function to accept a generic
pointer; consider the ISO C function fread(), or the POSIX functions read() and mmap(). However, in all such instances,
the generic pointer is accompanied by a size argument that specifies the size of the pointed-to object. Unlike the Ada language, it
is, and has always been, the C programmer's responsibility to ensure that these two arguments form a consistent specification of
the passed object. But traditional ioctl() implementations do not allow the user to specify the size of the pointed-to
object; that size is instead fixed implicitly by the specified command (passed as another argument). The posix_devctl()
interface improves upon ioctl() in that it allows the user to specify the object size, thereby restoring the familiar C
paradigm for passing a generic object by pointer/size pair.
A secondary problem with ioctl() is that the third argument is sometimes permitted to be interpreted as an integer
(int). The posix_devctl() interface clearly requires the dev_data_ptr argument to be a pointer.
A related problem with ioctl() is that the direction(s) in which data are transferred to or from the pointed-to object is
neither specified explicitly as an argument (as with mmap()), nor implied by the
ioctl() function (as with read()/write(), fread()/fwrite(), or fgets()/fputs()). Instead, the direction is implied by the command argument. In traditional
implementations, only the device driver knows the interpretation of the commands and whether data bytes are to be transferred to or
from the pointed-to object. But in networked implementations, generic portions of the operating system may need to know the
direction to ensure that data bytes are passed properly between a client and a server, separately from device driver concerns. Two
implementation-specific solutions to this problem are to always assume data bytes need to be transferred in both directions, or to
encode the implied direction into the command word along with the fixed data size. The posix_devctl() interface already
provides the implementation with an explicit size parameter. Since the direction is already known implicitly to both the
application and the driver and since workable methods exist for implementations to ascertain that direction if required, this
perceived problem is strictly an implementation issue and solvable without further impact on the interface.
Finally, posix_devctl() improves upon ioctl() by adopting the new style of error return, avoiding all the problems
errno brings to multi-threaded applications. Because the driver-specific information carried by the non-error return values
of ioctl() still potentially needs to be passed to the application, posix_devctl() adds the dev_info_ptr
argument to specify where this information should be stored.
Which Differences Between posix_devctl() and ioctl() Are Acceptable?
Any differences between the definitions of posix_devctl() and ioctl() have to be perceived as a clear improvement
by the community of potential users. Drivers for normal peripherals are typically written by highly specialized professionals.
Drivers for the special devices are very often written by the application developer or by the hardware designer. Any interface
definition that can be seen as overly complicated will simply not be accepted.
Nevertheless, a few simple and useful improvements to ioctl() are possible, specifically the improvement of type
checking, and justify the definition of a new interface.
The major difference between the two interfaces is the addition of the size of the device data. For enhanced compatibility with
existing ioctl() implementations, this size can be specified as zero; in this case the amount of data passed is unspecified.
(This allows a macro definition of ioctl() that converts it into a posix_devctl() call.) In any case, the data size
argument does not contradict the general goal of being able to implement posix_devctl() using the existing ioctl()
interfaces provided in current UNIX systems and other POSIX implementations because the standard allows but does not require
checking the size of the device data. Although the third argument of the ioctl() function does not specify a size, it is
implicit in the specific combination of control command and driver and, therefore, known to the driver implementation.
The method of indicating error return values differs from traditional ioctl() implementations, but it does not preclude
the construction of posix_devctl() as a macro built upon ioctl(), which was one of the original design goals.
Rationale for the dev_info_ptr Argument
The POSIX.26 developers felt that it was important to preserve the current ioctl() functionality of allowing a device
driver to return some arbitrary piece of information instead of just a success/failure indication. Such information might be, for
example, the number of bytes received, the number of bytes that would not fit into the buffer pointed at by dev_data_ptr,
the data type indication, or the device status. Current practice for device drivers and ioctl() usage allows such a
device-dependent return value. Thus, the concept of an additional output argument, dev_info_ptr, was born.
Rationale for No direction Argument
The initial specification for posix_devctl() contained an additional argument that specified the direction of data flow,
i.e., to the driver and/or from the driver. This argument was later removed for the following reasons:
The argument was redundant. Most (if not all) existing implementations encode the direction data either explicitly or implicitly
in the command word.
The argument increased the probability of programming errors, since it must be made to agree with the direction information
already encoded or implied in the command word or an error would occur.
The only real use of the argument would be if new drivers were written that supported generic commands such as
TRANSFER_CONTROL_DATA, which was modified by the direction argument to indicate in which direction the data should be transferred.
This is contrary to current practice that uses command pairs such as GET_CONTROL_DATA and PUT_CONTROL_DATA.
The primary purpose of the direction argument was to allow higher levels of the system to identify the direction of data
transfers, particularly in the case of remote devices, without having to understand all the commands of all the devices on the
system. Implementations that need to ascertain the direction of data transfer from a command word will define a consistent
convention for encoding the direction into each command word, and all device drivers supplied by the user must adhere to this
convention.
Thus, the data direction argument was removed.
Rationale for Not Defining the Direction Encoding in the dcmd
Argument
The POSIX.26 developers gave consideration to defining the direction encoding in the dcmd argument, but decided against
doing so. No particular benefit was seen to a predefined encoding, as long as the encoding was used consistently across the entire
implementation and was well known to the implementation.
In addition, although only one encoding (BSD's) employed for ioctl() was known among the members of the small working
group, it could not be ruled out that other encodings already existed, and no reason for precluding these encodings was seen.
Finally, system or architectural constraints might make a chosen standard encoding difficult to use on a given
implementation.
Thus, this standard does not define a direction encoding. Specifying a standard encoding is actually a small part of a larger
and more contentious objective, that of specifying a complete set of interfaces for portable device drivers. If a future POSIX
standard specifies such interfaces, the issue of device control direction encoding will necessarily be addressed as part of that
specification.
Recommended Practice for Handling Data Size Errors
In the event that the amount of data from the device is too large to fit into the specified buffer, as much data as will fit
should be transferred, and the error posted. The retained data will aid in debugging, even if some of the data is lost.
Recommended Practice for nbyte == 0
The feature that permits an unspecified amount of control data to be transferred if nbyte is zero exists only for
compatibility with existing device driver usage of ioctl(), i.e., when ioctl() is implemented on top of
posix_devctl() and the device driver transfers an amount of data implied by the command.
Implementations in which posix_devctl() is built as a library routine on top of ioctl() may not be able to make
checks on the nbyte argument. However, newly developed applications using posix_devctl() should always use an
appropriate value for the nbyte argument, for portability to implementations directly supporting posix_devctl() in
which the device drivers may be able to honor the application's nbyte argument or return the error [EINVAL] if the argument
is an unacceptable value. Device drivers designed for those systems should interpret a zero value of nbyte as no data to be
transferred.
Recommended Practice for Driver-Detected Errors
If the driver detects the following error conditions, it is recommended that the posix_devctl() function fail and return
the corresponding error number:
[EBUSY]
The control operation could not complete successfully because the device was in use by another process, or the driver was
unable to carry out the request due to an outstanding operation in progress.
[EINVAL]
The arguments dev_data_ptr and nbyte define a buffer too small to hold the amount of data expected by or to be
returned by this driver.
[EIO]
The control operation could not complete successfully because the driver detected a hardware error.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD 4.21 Special Device Drivers,
CHANGE HISTORY
First released in Issue 8. Derived from POSIX.26.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/coshf.html =====
cosh
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
cosh, coshf, coshl — hyperbolic cosine functions
SYNOPSIS
#include
double cosh(double x);
float coshf(float x);
long double coshl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the hyperbolic cosine of their argument x.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the hyperbolic cosine of x.
If the correct value would cause overflow, a range error shall occur and cosh(), coshf(), and coshl() shall
return the value of the macro HUGE_VAL, HUGE_VALF, and HUGE_VALL, respectively.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0, the value 1.0 shall be returned.
If x is ±Inf, +Inf shall be returned.
ERRORS
These functions shall fail if:
Range Error
The result would cause an overflow.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
acosh(), feclearexcept(),
fetestexcept(), isnan(),
sinh(), tanh()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The coshf() and coshl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0072 [630] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/y1.html =====
y0
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
y0, y1, yn — Bessel functions of the second kind
SYNOPSIS
[XSI]  #include
double y0(double x);
double y1(double x);
double yn(int n, double x);
DESCRIPTION
The y0(), y1(), and yn() functions shall compute Bessel functions of x of the second kind of orders
0, 1, and n, respectively. y0(x) shall be equivalent to yn(0, x), and y1(x) shall
be equivalent to yn(1, x).
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the relevant Bessel value of x of the second kind.
[MXX]
If x is NaN, NaN shall be returned.
If the x argument to these functions is negative, [MXX]   either NaN (if supported) or  the same return value as when x is 0.0 (see below) shall be returned, and a domain error may
occur.
If x is 0.0, y0() and y1() shall return -HUGE_VAL and a pole error may occur. If x is 0.0 and
n is not both negative and odd, yn() shall return -HUGE_VAL and a pole error may occur. If x is 0.0 and
n is negative and odd, yn() shall return +HUGE_VAL and a pole error may occur.
[MXX]
If x is +Inf, +0 shall be returned.
If the correct result would cause underflow [MXX]   and is not representable,  a range error may occur, and the function shall return [MXX]   0.0, or
(if the IEC 60559 Floating-Point option is not supported) an
implementation-defined value no greater in magnitude than DBL_MIN.
[MXX]  If
the correct result would cause underflow, and is representable, a range error may occur and the correct value shall be returned.
If the correct result of calling y1() would cause overflow, -HUGE_VAL shall be returned and a range error may occur. If
n is not both negative and odd, and the correct result of calling yn() would cause overflow, -HUGE_VAL shall be
returned and a range error may occur. If n is negative and odd, and the correct result of calling yn() would cause
overflow, +HUGE_VAL shall be returned and a range error may occur.
ERRORS
These functions may fail if:
Domain Error
The value of x is negative.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
Pole Error
The value of x is zero.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the divide-by-zero floating-point exception shall
be raised.
Range Error
The value of x is too large in magnitude, or the correct result would cause underflow.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The y1() and yn() functions may fail if:
Range Error
The correct result would cause overflow.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), isnan(), j0()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
The RETURN VALUE and ERRORS sections are reworked for alignment of the error handling with the ISO/IEC 9899:1999
standard.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/148 is applied, updating the RETURN VALUE and ERRORS sections.
The changes are made for consistency with the general rules stated in "Treatment of Error Conditions for Mathematical Functions"
in the Base Definitions volume of POSIX.1-2024.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0746 [68] is applied.
Issue 8
Austin Group Defect 714 is applied, changing the behavior of these functions for special cases to be a better match for their
mathematical behavior.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/posix_spawn_file_actions_addchdir.html =====
posix_spawn_file_actions_addchdir
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
posix_spawn_file_actions_addchdir, posix_spawn_file_actions_addfchdir — add chdir or fchdir action to spawn file
actions object (ADVANCED REALTIME)
SYNOPSIS
[SPN]  #include
int posix_spawn_file_actions_addchdir(posix_spawn_file_actions_t
*restrict file_actions, const char *restrict path);
int posix_spawn_file_actions_addfchdir(posix_spawn_file_actions_t
*file_actions, int fildes);
DESCRIPTION
The posix_spawn_file_actions_addchdir() function shall add a chdir action to the object referenced by
file_actions that shall cause the working directory to be set to path (as if chdir(path) had been
called) when a new process is spawned using this file actions object. A relative path shall be interpreted in relation to
the working directory determined by any prior actions. The string pointed to by path shall be copied by the
posix_spawn_file_actions_addchdir() function.
The posix_spawn_file_actions_addfchdir() function shall add an fchdir action to the object referenced by
file_actions that shall cause the working directory to be set to fildes (as if fchdir(fildes) had been
called) when a new process is spawned using this file actions object.
A spawn file actions object is as defined in posix_spawn_file_actions_addclose().
RETURN VALUE
Upon successful completion, these functions shall return zero; otherwise, an error number shall be returned to indicate the
error.
ERRORS
The posix_spawn_file_actions_addfchdir() function shall fail if:
[EBADF]
The value specified by fildes is negative.
These functions shall fail if:
[ENOMEM]
Insufficient memory exists to add to the spawn file actions object.
These functions may fail if:
[EINVAL]
The value specified by file_actions is invalid.
It shall not be considered an error for the path or fildes argument passed to these functions to specify a
pathname or file descriptor for which the specified operation could not be performed at the time of the call. Any such error shall
be detected when the associated file actions object is later used during a posix_spawn() or posix_spawnp()
operation.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The posix_spawn_file_actions_addchdir() and posix_spawn_file_actions_addfchdir() functions are part of the Spawn
option and need not be provided on all implementations.
Changing the working directory of a child process can be useful when invoking utilities such as pax. Furthermore, the ability to add fchdir actions to posix_spawn() gives the caller as much control over relative pathnames processed in the
context of the child as it would otherwise have using openat(), since all file
actions are processed in sequence in the context of the child at a point where the child process is still single-threaded. Without
chdir or fchdir actions, changing the working directory of the child would require a shim utility (some
implementations provide
env -C /new/path program args...
as an extension, but the standard does not require this extension), or else temporarily changing the working directory in the
parent process prior to calling posix_spawn() (but this requires locking in a
multi-threaded process, to ensure that no other thread is impacted by the temporary change to global state).
File actions are performed in a new process created by posix_spawn() or
posix_spawnp() in the same order that they were added to the file actions
object. Thus, the execution of an open action that was created by a call to posix_spawn_file_actions_addopen() that specifies a relative path
will be affected by the execution of a chdir or fchdir action that was created by a previous call to
posix_spawn_file_actions_addchdir() or posix_spawn_file_actions_addfchdir(). Likewise, a relative path passed to
posix_spawn() will be affected by the last chdir or fchdir action
in the file action list.
RATIONALE
Refer to the RATIONALE section in posix_spawn_file_actions_addclose().
FUTURE DIRECTIONS
None.
SEE ALSO
chdir(), fchdir(), posix_spawn(), posix_spawn_file_actions_addclose(), posix_spawn_file_actions_destroy()
XBD
CHANGE HISTORY
First released in Issue 8. Derived from Solaris posix_spawn_file_actions_addchdir_np.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/twalk.html =====
tdelete
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
tdelete, tfind, tsearch, twalk — manage a binary search tree
SYNOPSIS
[XSI]  #include
void *tdelete(const void *restrict key,
posix_tnode **restrict rootp,
int(*compar)(const void *, const void *));
posix_tnode *tfind(const void *key,
posix_tnode *const *rootp,
int(*compar)(const void *, const void *));
posix_tnode *tsearch(const void *key,
posix_tnode **rootp,
int (*compar)(const void *, const void *));
void twalk(const posix_tnode *root,
void (*action)(const posix_tnode *, VISIT, int));
DESCRIPTION
The tdelete(), tfind(), tsearch(), and twalk() functions manipulate binary search trees. Comparisons
are made with a user-supplied routine, the address of which is passed as the compar argument. This routine is called with
two arguments, which are the pointers to the elements being compared. The application shall ensure that the user-supplied routine
returns an integer less than, equal to, or greater than 0, according to whether the first argument is to be considered less than,
equal to, or greater than the second argument. The comparison function need not compare every byte, so arbitrary data may be
contained in the elements in addition to the values being compared.
The tsearch() function shall build and access the tree. The key argument is a pointer to an element to be accessed
or stored. If there is a node in the tree whose element is equal to the value pointed to by key, a pointer to this found
node shall be returned. Otherwise, the value pointed to by key shall be inserted (that is, a new node is created and the
value of key is copied to this node), and a pointer to this node returned. Only pointers are copied, so the application
shall ensure that the calling routine stores the data. The rootp argument points to a variable that points to the root node
of the tree. A null pointer value for the variable pointed to by rootp denotes an empty tree; in this case, the variable
shall be set to point to the node which shall be at the root of the new tree.
Like tsearch(), tfind() shall search for a node in the tree, returning a pointer to it if found. However, if it is
not found, tfind() shall return a null pointer. The arguments for tfind() are the same as for tsearch().
The tdelete() function shall delete a node from a binary search tree. The arguments are the same as for tsearch().
The variable pointed to by rootp shall be set to a pointer to the new root of the tree if the root of the tree was changed.
If the deleted node was the root of the tree and had no children, the variable pointed to by rootp shall be set to a null
pointer. The tdelete() function shall return a pointer to the parent of the deleted node, or an unspecified non-null pointer
if the deleted node was the root node, or a null pointer if the node is not found.
If tsearch() adds an element to a tree, or tdelete() successfully deletes an element from a tree, the concurrent
use of that tree in another thread, or use of pointers produced by a previous call to tfind() or tsearch(), produces
undefined results.
The twalk() function shall traverse a binary search tree. The root argument is a pointer to the root node of the
tree to be traversed. (Any node in a tree may be used as the root for a walk below that node.) The argument action is the
name of a routine to be invoked at each node. This routine is, in turn, called with three arguments. The first argument shall be
the address of the node being visited. The structure pointed to by this argument is unspecified and shall not be modified by the
application, but it shall be possible to cast a pointer-to-node into a pointer-to-pointer-to-element to access the element stored
in the node. The second argument shall be a value from an enumeration data type:
typedef enum { preorder, postorder, endorder, leaf } VISIT;
(defined in ), depending on whether this is the first, second, or
third time that the node is visited (during a depth-first, left-to-right traversal of the tree), or whether the node is a leaf. The
third argument shall be the level of the node in the tree, with the root being level 0.
If the calling function alters the pointer to the root, the result is undefined.
If the functions pointed to by action or compar (for any of these binary search functions) change the tree, the
results are undefined.
These functions are thread-safe only as long as multiple threads do not access the same tree.
RETURN VALUE
If the node is found, both tsearch() and tfind() shall return a pointer to it. If not, tfind() shall return
a null pointer, and tsearch() shall return a pointer to the inserted item.
A null pointer shall be returned by tsearch() if there is not enough space available to create a new node.
A null pointer shall be returned by tdelete(), tfind(), and tsearch() if rootp is a null pointer on
entry.
The tdelete() function shall return a pointer to the parent of the deleted node, or an unspecified non-null pointer if
the deleted node was the root node, or a null pointer if the node is not found.
The twalk() function shall not return a value.
In all cases where a pointer to a node is returned, the structure pointed to by the return value is unspecified and shall not be
modified by the application, but it shall be possible to cast a pointer-to-node into a pointer-to-pointer-to-element to access the
element stored in the node.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
The following code reads in strings and stores structures containing a pointer to each string and a count of its length. It then
walks the tree, printing out the stored strings and their lengths in alphabetical order.
#include
#include
#include
#include
#include
struct element {      /* Pointers to these are stored in the tree. */
int     count;
char    string[];
};
posix_tnode  *root = NULL;          /* This points to the root. */
int main(void)
{
char   str[_POSIX2_LINE_MAX+1];
int    length = 0;
struct element *elementptr;
posix_tnode *node;
void   print_node(const posix_tnode *, VISIT, int);
int    node_compare(const void *, const void *);
while (fgets(str, sizeof(str), stdin))  {
/* Set element. */
length = strlen(str);
if (str[length-1] == '\n')
str[--length] = '\0';
elementptr = malloc(sizeof(struct element) + length + 1);
strcpy(elementptr->string, str);
elementptr->count = 1;
/* Put element into the tree. */
node = tsearch((void *)elementptr, &root, node_compare);
if (node == NULL) {
fprintf(stderr,
"tsearch: Not enough space available\n");
exit(EXIT_FAILURE);
}
else if (*(struct element **)node != elementptr) {
/* A node containing the element already exists */
(*(struct element **)node)->count++;
free(elementptr);
}
}
twalk(root, print_node);
/* Delete all nodes in the tree */
while (root != NULL) {
elementptr = *(struct element **)root;
printf("deleting node: string = %s,  count = %d\n",
elementptr->string,
elementptr->count);
tdelete((void *)elementptr, &root, node_compare);
free(elementptr);
}
return 0;
}
/*
*  This routine compares two nodes, based on an
*  alphabetical ordering of the string field.
*/
int
node_compare(const void *node1, const void *node2)
{
return strcmp(((const struct element *) node1)->string,
((const struct element *) node2)->string);
}
/*
*  This routine prints out a node, the second time
*  twalk encounters it or if it is a leaf.
*/
void
print_node(const posix_tnode *ptr, VISIT order, int level)
{
const struct element *p = *(const struct element **) ptr;
if (order == postorder || order == leaf)  {
(void) printf("string = %s,  count = %d\n",
p->string, p->count);
}
}
APPLICATION USAGE
The root argument to twalk() is one level of indirection less than the rootp arguments to tdelete()
and tsearch().
There are two nomenclatures used to refer to the order in which tree nodes are visited. The twalk() function uses
preorder, postorder, and endorder to refer respectively to visiting a node before any of its children, after
its left child and before its right, and after both its children. The alternative nomenclature uses preorder,
inorder, and postorder to refer to the same visits, which could result in some confusion over the meaning of
postorder.
Since the return value of tdelete() is an unspecified non-null pointer in the case that the root of the tree has been
deleted, applications should only use the return value of tdelete() as indication of success or failure in this case and
should not assume it can be dereferenced. However, the only way that applications can tell if this case may have occurred is by
checking whether the variable pointed to by rootp changed. Since this variable can change for other reasons (for example,
tree balancing), using the return value of tdelete() as anything other than a boolean indicator is unreliable at best and is
discouraged. Some implementations in this case will return a pointer to the new root of the tree (or to an empty tree if the
deleted root node was the only node in the tree); other implementations return arbitrary non-null pointers.
RATIONALE
Implementations are encouraged to use balanced trees to reduce the depth of the trees that are created and improve tree search
times.
FUTURE DIRECTIONS
None.
SEE ALSO
hcreate(), lsearch()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The last paragraph of the DESCRIPTION was included as an APPLICATION USAGE note in previous issues.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
The restrict keyword is added to the tdelete() prototype for alignment with the ISO/IEC 9899:1999
standard.
Issue 7
Austin Group Interpretation 1003.1-2001 #149 is applied, clarifying concurrent use of the tree in another thread.
Austin Group Interpretation 1003.1-2001 #151 is applied, clarifying behavior for tdelete() when the deleted node is the
root node.
Austin Group Interpretation 1003.1-2001 #153 is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0366 [551] is applied.
Issue 8
Austin Group Defect 1011 is applied, changing some prototypes to use posix_tnode instead of void, and changing the
required behavior for tdelete() when the root of the tree changes.
Austin Group Defect 1470 is applied, changing the EXAMPLES section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/tss_set.html =====
tss_get
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
tss_get, tss_set — thread-specific data management
SYNOPSIS
#include
void *tss_get(tss_t key);
int tss_set(tss_t key, void *val);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The tss_get() function shall return the value for the current thread held in the thread-specific storage identified by
key.
The tss_set() function shall set the value for the current thread held in the thread-specific storage identified by
key to val. This action shall not invoke the destructor associated with the key on the value being
replaced.
The application shall ensure that the tss_get() and tss_set() functions are only called with a value for
key that was returned by a call to tss_create() before the thread
commenced executing destructors.
The effect of calling tss_get() or tss_set() after key has been deleted with tss_delete() is undefined.
[CX]
Both tss_get() and tss_set() can be called from a thread-specific data destructor function. A call to
tss_get() for the thread-specific data key being destroyed shall return a null pointer, unless the value is changed (after
the destructor starts) by a call to tss_set(). Calling tss_set() from a thread-specific data destructor function may
result either in lost storage (after at least {PTHREAD_DESTRUCTOR_ITERATIONS} attempts at destruction) or in an infinite loop.
These functions shall not be affected if the calling thread executes a signal handler during the call.
RETURN VALUE
The tss_get() function shall return the value for the current thread. If no thread-specific data value is associated with
key, then a null pointer shall be returned.
The tss_set() function shall return thrd_success on success or thrd_error if the request could not be
honored.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
These functions are not affected by signal handlers for the reasons stated in XRAT B.2.3 Error Numbers.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_getspecific(), tss_create()
XBD
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sem_post.html =====
sem_post
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sem_post — unlock a semaphore
SYNOPSIS
#include
int sem_post(sem_t *sem);
DESCRIPTION
The sem_post() function shall unlock the semaphore referenced by sem by performing a semaphore unlock operation on
that semaphore.
If the semaphore value resulting from this operation is positive, then no threads were blocked waiting for the semaphore to
become unlocked; the semaphore value is simply incremented.
If the value of the semaphore resulting from this operation is zero, then one of the threads blocked waiting for the semaphore
shall be allowed to return successfully from its call to sem_wait(). [PS]   If the Process
Scheduling option is supported, the thread to be unblocked shall be chosen in a manner appropriate to the scheduling policies and
parameters in effect for the blocked threads. In the case of the schedulers SCHED_FIFO and SCHED_RR, the highest priority waiting
thread shall be unblocked, and if there is more than one highest priority thread blocked waiting for the semaphore, then the
highest priority thread that has been waiting the longest shall be unblocked. If the Process Scheduling option is not defined, the
choice of a thread to unblock is unspecified.
[SS]  If
the Process Sporadic Server option is supported, and the scheduling policy is SCHED_SPORADIC, the semantics are as per SCHED_FIFO
above.
The sem_post() function shall be async-signal-safe and may be invoked from a signal-catching function.
RETURN VALUE
If successful, the sem_post() function shall return zero; otherwise, the function shall return -1 and set errno to
indicate the error.
ERRORS
The sem_post() function shall fail if:
[EOVERFLOW]
The maximum allowable value of the semaphore would be exceeded.
The sem_post() function may fail if:
[EINVAL]
The sem argument does not refer to a valid semaphore.
The following sections are informative.
EXAMPLES
See sem_clockwait().
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
semctl(), semget(), semop(), sem_clockwait(), sem_trywait()
XBD 4.15.2 Memory Synchronization,
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Issue 6
The sem_post() function is marked as part of the Semaphores option.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Semaphores
option.
The sem_timedwait() function is added to the SEE ALSO section for alignment
with IEEE Std 1003.1d-1999.
SCHED_SPORADIC is added to the list of scheduling policies for which the thread that is to be unblocked is specified for
alignment with IEEE Std 1003.1d-1999.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/119 is applied, updating the ERRORS section so that the [EINVAL]
error becomes optional.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
The sem_post() function is moved from the Semaphores option to the Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0528 [37] is applied.
Issue 8
Austin Group Defect 315 is applied, adding the [EOVERFLOW] error.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/accept.html =====
accept
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
accept, accept4 — accept a new connection on a socket
SYNOPSIS
#include
int accept(int socket, struct sockaddr *restrict address,
socklen_t *restrict address_len);
int accept4(int socket, struct sockaddr *restrict address,
socklen_t *restrict address_len, int flag);
DESCRIPTION
The accept() function shall extract the first connection on the queue of pending connections, create a new socket with
the same socket type protocol and address family as the specified socket, and allocate a new file descriptor for that socket. The
file descriptor shall be allocated as described in 2.6 File Descriptor
Allocation.
The accept() function takes the following arguments:
socket
Specifies a socket that was created with socket(), has been bound to an address
with bind(), and has issued a successful call to listen().
address
Either a null pointer, or a pointer to a sockaddr structure where the address of the connecting socket shall be
returned.
address_len
Either a null pointer, if address is a null pointer, or a pointer to a socklen_t object which on input specifies
the length of the supplied sockaddr structure, and on output specifies the length of the address of the connecting
socket.
If address is not a null pointer, the address of the peer for the accepted connection shall be stored in the
sockaddr structure pointed to by address, and the length of this address shall be stored in the object pointed to by
address_len.
If the actual length of the address is greater than the length of the supplied sockaddr structure, the stored address
shall be truncated.
If the protocol permits connections by unbound clients, and the peer is not bound, then the value stored in the object pointed
to by address is unspecified.
If the listen queue is empty of connection requests and O_NONBLOCK is not set on the file descriptor for the socket,
accept() shall block until a connection is present. If the listen() queue is
empty of connection requests and O_NONBLOCK is set on the file descriptor for the socket, accept() shall fail and set
errno to [EAGAIN] or [EWOULDBLOCK].
The accepted socket cannot itself accept more connections. The original socket remains open and can accept more connections.
If O_NONBLOCK is set on the file description for socket, it is implementation-defined whether O_NONBLOCK will be set on
the file description created by accept(). FD_CLOEXEC and FD_CLOFORK for the new file descriptor shall be clear, regardless
of how they are currently set for socket.
It is implementation-defined which socket options, if any, on the accepted socket will have a default value determined by a
value previously customized by setsockopt() on socket, rather than the
default value used for other new sockets.
The accept4() function shall be equivalent to the accept() function, except that the state of O_NONBLOCK on the
new file description, and FD_CLOEXEC and FD_CLOFORK on the returned file descriptor shall be determined solely by the flag
argument, which can be constructed from a bitwise-inclusive OR of flags from the following list:
SOCK_CLOEXEC
Atomically set the FD_CLOEXEC flag on the new file descriptor.
SOCK_CLOFORK
Atomically set the FD_CLOFORK flag on the new file descriptor.
SOCK_NONBLOCK
Set the O_NONBLOCK file status flag on the new file description.
Implementations may define additional flags.
RETURN VALUE
Upon successful completion, accept() and accept4() shall return the non-negative file descriptor of the accepted
socket. Otherwise, -1 shall be returned, errno shall be set to indicate the error, and any object pointed to by
address_len shall remain unchanged.
ERRORS
The accept() and accept4() functions shall fail if:
[EAGAIN] or [EWOULDBLOCK]
O_NONBLOCK is set for the socket file descriptor and no connections are present to be accepted.
[EBADF]
The socket argument is not a valid file descriptor.
[ECONNABORTED]
A connection has been aborted.
[EINTR]
The accept() function was interrupted by a signal that was caught before a valid connection arrived.
[EINVAL]
The socket is not accepting connections.
[EMFILE]
All file descriptors available to the process are currently open.
[ENFILE]
The maximum number of file descriptors in the system are already open.
[ENOBUFS]
No buffer space is available.
[ENOMEM]
There was insufficient memory available to complete the operation.
[ENOTSOCK]
The socket argument does not refer to a socket.
[EOPNOTSUPP]
The socket type of the specified socket does not support accepting connections.
The accept() and accept4() functions may fail if:
[EPROTO]
A protocol error has occurred.
The accept4() function may fail if:
[EINVAL]
The value of the flag argument is invalid.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
When a connection is available, select() indicates that the file descriptor for
the socket is ready for reading.
Many socket options are described as having implementation-defined default values, which may differ according to the protocol in
use by the socket. Existing practice differs on whether socket options such as SO_SNDBUF that were customized on the original
listening socket will impact the corresponding option on the newly returned socket. Implementations are permitted to allow
inheritance of customized settings where it makes sense, although the most portable approach for applications is to limit setsockopt() customizations to only the accepted socket.
For AF_UNIX sockets, it is recommended that address points to a buffer of length greater than sizeof(struct
sockaddr_un) which has been initialized with null bytes. That way, even if the implementation supports the use of all bytes of
sun_path without a terminating null byte, the larger buffer guarantees that the sun_path member can then be passed to
other interfaces that expect a null-terminated string. If no truncation occurred based on the input value of address_len, it
is unspecified whether the returned address_len will be sizeof(struct sockaddr_un), or merely a value at least as
large as offsetof(struct sockaddr_un, sun_path) plus the number of non-null bytes stored in sun_path.
RATIONALE
The SOCK_CLOEXEC and SOCK_CLOFORK flags of accept4() are necessary to avoid a data race in multi-threaded applications.
Without SOCK_CLOFORK, a file descriptor is leaked into a child process created by one thread in the window between another thread
creating a file descriptor with accept() and then using fcntl() to set the
FD_CLOFORK flag. Without SOCK_CLOEXEC, a file descriptor intentionally inherited by child processes is similarly leaked into an
executed program if FD_CLOEXEC is not set atomically.
Two designs often used for network servers are multi-threaded servers with a pre-created pool of worker threads, where the
thread that accepts the connection request hands over the new file descriptor to a worker thread for servicing, and pre-fork
servers with a pre-created pool of worker processes, where the process that accepts the connection request passes the new file
descriptor (for example via sendmsg()) to a worker process. In both of these
designs, accept4() should be used with the SOCK_CLOFORK flag set. Simpler designs are also sometimes used that do not
pre-create a pool. For a multi-threaded server that creates a thread to handle each request, SOCK_CLOFORK should still be used. For
a forking server that creates a child to service each request, clearly SOCK_CLOFORK cannot be used if the child is to inherit the
file descriptor to be serviced, and therefore this type of server needs to use an alternative method of indicating the end of
communications, for example using shutdown(), to ensure the client sees
end-of-file, rather than just closing the socket. Such child processes should set FD_CLOFORK on the inherited file descriptor
before they attempt to start any additional child processes to avoid leakage into those children.
The SOCK_NONBLOCK flag is for convenience in avoiding additional fcntl() calls, as
well as providing specific control over the O_NONBLOCK flag, since traditional implementations of accept() differ on whether
O_NONBLOCK is inherited from the socket argument.
FUTURE DIRECTIONS
None.
SEE ALSO
2.6 File Descriptor Allocation, bind(), connect(), listen(), socket()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
The restrict keyword is added to the accept() prototype for alignment with the ISO/IEC 9899:1999
standard.
Issue 7
SD5-XBD-ERN-4 is applied, changing the definition of the [EMFILE] error.
Austin Group Interpretation 1003.1-2001 #044 is applied, changing the "may fail" [ENOBUFS] and [ENOMEM] errors to become
"shall fail" errors.
Functionality relating to XSI STREAMS is marked obsolescent.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0018 [464] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0035 [835] and XSH/TC2-2008/0036 [836] are applied.
Issue 8
Austin Group Defects 411 and 1318 are applied, adding accept4(), requiring FD_CLOEXEC and FD_CLOFORK to be clear for the
file descriptor returned by accept(), and clarifying the requirements for O_NONBLOCK on the file description created by
accept().
Austin Group Defect 561 is applied, adding a paragraph about sun_path to APPLICATION USAGE.
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
Austin Group Defect 1337 is applied, clarifying socket option default values.
Austin Group Defect 1565 is applied, changing the description of address_len.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/iswlower_l.html =====
iswlower
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
iswlower, iswlower_l — test for a lowercase letter wide-character code
SYNOPSIS
#include
int iswlower(wint_t wc);
[CX]  int iswlower_l(wint_t wc, locale_t locale);
DESCRIPTION
For iswlower(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The iswlower() [CX]   and iswlower_l()
functions shall test whether wc is a wide-character code representing a character of class lower in the current
locale, [CX]   or in the locale represented by locale,
respectively; see XBD 7. Locale.
The wc argument is a wint_t, the value of which the application shall ensure is a wide-character code
corresponding to a valid character in the locale used by the function, or equal to the value of the macro WEOF. If the argument has
any other value, the behavior is undefined.
[CX]  The
behavior is undefined if the locale argument to iswlower_l() is the special locale object LC_GLOBAL_LOCALE or is not
a valid locale object handle.
RETURN VALUE
The iswlower() [CX]   and iswlower_l()
functions shall return non-zero if wc is a lowercase letter wide-character code; otherwise, they shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
To ensure applications portability, especially across natural languages, only these functions and the functions in the reference
pages listed in the SEE ALSO section should be used for character classification.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
iswalnum(), iswalpha(),
iswcntrl(), iswctype(),
iswdigit(), iswgraph(),
iswprint(), iswpunct(),
iswspace(), iswupper(),
iswxdigit(), setlocale(),
uselocale() 1
XBD 7. Locale, ,
CHANGE HISTORY
First released in Issue 4.
Issue 5
The following change has been made in this version for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E):
The SYNOPSIS has been changed to indicate that this function and associated data types are now made visible by inclusion of the
header rather than .
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
The iswlower_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0329 [302], XSH/TC1-2008/0330 [283], and XSH/TC1-2008/0331 [283] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0188 [685] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/V2_chap02.html =====
General Information
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
2. General Information
This chapter covers information that is relevant to all the functions specified in 3. System Interfaces and XBD 14.
Headers.
2.1 Use and Implementation of Interfaces
2.1.1 Use and Implementation of Functions
Each of the following statements shall apply to all functions unless explicitly stated otherwise in the detailed descriptions
that follow:
If an argument to a function has an invalid value, such as a value outside the domain of the function, a pointer to an object
whose lifetime has ended (even if a new object now has the same address), a pointer outside the address space of the program, or a
null pointer, the behavior is undefined.
Any function declared in a header may also be implemented as a macro defined in the header, so a function should not be declared
explicitly if its header is included. Any macro definition of a function can be suppressed locally by enclosing the name of the
function in parentheses, because the name is then not followed by the  that indicates expansion of a macro
function name. For the same syntactic reason, it is permitted to take the address of a function even if it is also defined as a
macro. The use of the C-language #undef construct to remove any such macro definition shall also ensure that an actual
function is referred to.
Any invocation of a function that is implemented as a macro shall expand to code that evaluates each of its arguments exactly
once, fully protected by parentheses where necessary, so it is generally safe to use arbitrary expressions as arguments.
For functions from the ISO C standard only, provided that the function can be declared without reference to any type
defined in a header from the ISO C standard, it is also permissible to declare the function explicitly and use it without
including its associated header.
If a function that accepts a variable number of arguments is not declared (explicitly or by including its associated header),
the behavior is undefined.
Functions shall prevent data races as follows: A function shall not directly or indirectly access objects accessible by threads
other than the current thread unless the objects are accessed directly or indirectly via the function's arguments. A function shall
not directly or indirectly modify objects accessible by threads other than the current thread unless the objects are accessed
directly or indirectly via the function's non-const arguments. Implementations may share their own internal objects between threads
if the objects are not visible to applications and are protected against data races.
Functions shall perform all operations solely within the current thread if those operations have effects that are visible to
applications.
2.1.2 Use and Implementation of Macros
Each of the following statements shall apply to all macros unless explicitly stated otherwise:
Any definition of an object-like macro in a header shall expand to code that is fully protected by parentheses where necessary,
so that it groups in an arbitrary expression as if it were a single identifier.
All object-like macros listed as expanding to integer constant expressions shall additionally be suitable for use in #if
preprocessing directives.
Any definition of a function-like macro in a header shall expand to code that evaluates each of its arguments exactly once,
fully protected by parentheses where necessary, so that it is generally safe to use arbitrary expressions as arguments.
Any definition of a function-like macro in a header can be invoked in an expression anywhere a function with a compatible return
type could be called.
2.2 The Compilation Environment
2.2.1 POSIX.1 Symbols
Certain symbols in this volume of POSIX.1-2024 are defined in headers (see XBD 14. Headers). Some of those headers could also define symbols other than those
defined by POSIX.1-2024, potentially conflicting with symbols used by the application. Also, POSIX.1-2024 defines symbols that are
not permitted by other standards to appear in those headers without some control on the visibility of those symbols.
Symbols called "feature test macros" are used to control the visibility of symbols that might be included in a header.
Implementations, future versions of this standard, and other standards may define additional feature test macros.
In the compilation of an application that #defines a feature test macro specified by POSIX.1-2024, no header defined by
POSIX.1-2024 shall be included prior to the definition of the feature test macro. This restriction also applies to any
implementation-provided header in which these feature test macros are used. If the definition of the macro does not precede the
#include, the result is undefined.
Feature test macros shall begin with the  character ('_').
2.2.1.1 The _POSIX_C_SOURCE Feature Test Macro
A POSIX-conforming application shall ensure that the feature test macro _POSIX_C_SOURCE is defined before inclusion of any
header.
When an application includes a header described by POSIX.1-2024, and when this feature test macro is defined to have the value
202405L:
All symbols required by POSIX.1-2024 to appear when the header is included shall be made visible.
Symbols that are explicitly permitted, but not required, by POSIX.1-2024 to appear in that header (including those in reserved
name spaces) may be made visible.
Additional symbols not required or explicitly permitted by POSIX.1-2024 to be in that header shall not be made visible, except
when enabled by another feature test macro.
Identifiers in POSIX.1-2024 may only be undefined using the #undef directive as described in 2.1 Use
and Implementation of Interfaces or 2.2.2 The Name Space. These #undef directives shall
follow all #include directives of any header in POSIX.1-2024.
Note:
The POSIX.1-1990 standard specified a macro called _POSIX_SOURCE. This has been superseded by _POSIX_C_SOURCE.
2.2.1.2 The _XOPEN_SOURCE Feature Test Macro
[XSI]
An XSI-conforming application shall ensure that the feature test macro _XOPEN_SOURCE is defined with the value 800 before inclusion
of any header. This is needed to enable the functionality described in 2.2.1.1 The _POSIX_C_SOURCE
Feature Test Macro and to ensure that the XSI option is enabled.
Since this volume of POSIX.1-2024 is aligned with the ISO C standard, and since all functionality enabled by
_POSIX_C_SOURCE set equal to 202405L is enabled by _XOPEN_SOURCE set equal to 800, there should be no need to define
_POSIX_C_SOURCE if _XOPEN_SOURCE is so defined. Therefore, if _XOPEN_SOURCE is set equal to 800 and _POSIX_C_SOURCE is set equal to
202405L, the behavior is the same as if only _XOPEN_SOURCE is defined and set equal to 800. However, should _POSIX_C_SOURCE be set
to a value greater than 202405L, the behavior is unspecified.
If _XOPEN_SOURCE is defined with the value 800 and _POSIX_C_SOURCE is undefined before inclusion of any header, then the header
may define the _POSIX_C_SOURCE macro with the value 202405L.
2.2.1.3 The __STDC_WANT_LIB_EXT1__ Feature Test Macro
A POSIX-conforming [XSI]   or XSI-conforming
application can define the feature test macro __STDC_WANT_LIB_EXT1__ before inclusion of any header.
When an application includes a header described by POSIX.1-2024, and when this feature test macro is defined to have the value
1, the header may make visible those symbols specified for the header in Annex K of the ISO C standard that are not already
explicitly permitted by POSIX.1-2024 to be made visible in the header. These symbols are listed in 2.2.2
The Name Space below.
When an application includes a header described by POSIX.1-2024, and when this feature test macro is either undefined or defined
to have the value 0, the header shall not make any additional symbols visible that are not already made visible by the feature test
macro _POSIX_C_SOURCE [XSI]   or _XOPEN_SOURCE   as
described above, except when enabled by another feature test macro.
2.2.2 The Name Space
All identifiers in this volume of POSIX.1-2024, except environ, are defined in at least one of the headers, as shown in
XBD 14. Headers. When [XSI]
_XOPEN_SOURCE or  _POSIX_C_SOURCE is defined, each header
defines or declares some identifiers, potentially conflicting with identifiers used by the application. The set of identifiers
visible to the application consists of precisely those identifiers from the header pages of the included headers, as well as
additional identifiers reserved for the implementation. In addition, some headers may make visible identifiers from other headers
as indicated on the relevant header pages.
Implementations may also add members to a structure or union without controlling the visibility of those members with a feature
test macro, as long as a user-defined macro with the same name cannot interfere with the correct interpretation of the program. The
identifiers reserved for use by the implementation are described below:
Each identifier with external linkage described in the header section is reserved for use as an identifier with external linkage
if the header is included.
Each macro described in the header section is reserved for any use if the header is included.
Each identifier with file scope described in the header section is reserved for use as a macro name and as an identifier with
file scope in the same name space if the header is included.
As described in 13. Namespace and Future Directions, the prefixes
posix_, POSIX_, and _POSIX_ are reserved for use by POSIX.1-2024 and other POSIX standards. Implementations may add symbols to the
headers shown in the following table, provided the identifiers for those symbols either:
Begin with the corresponding reserved prefixes in the table, or
Have one of the corresponding complete names in the table, or
End in the string indicated as a reserved suffix in the table and do not use the reserved prefixes posix_, POSIX_, or _POSIX_,
as long as the reserved suffix is in that part of the name considered significant by the implementation.
Symbols that use the reserved prefix _POSIX_ may be made visible by implementations in any header defined by POSIX.1-2024.
Header
Prefix
Suffix
Complete Name
aio_, lio_, AIO_, LIO_
inet_
to[a-z], is[a-z]
RTLD_, dli_
d_, DT_
l_
[XSI]
MM_
FNM_
[XSI]
FTW
gl_, GLOB_
gr_
TEXTDOMAINMAX
_MAX, _MIN
[XSI]
M_
[MSG]
mq_, MQ_
[XSI]
dbm_, DBM_
ai_, h_, n_, p_, s_
if_, IF_
in_, ip_, s_, sin_, INADDR_,
IPPROTO_
[IP6]
in6_, in6addr_, s6_, sin6_, IPV6_
TCP_
NL_
pd_, ph_, ps_, POLL
pthread_, PTHREAD_
pw_
re_, rm_, REG_
sched_, SCHED_
sem_, SEM_
[CX]
sa_, si_, sigev_, sival_, uc_, BUS_,
CLD_, FPE_, ILL_, SA_, SEGV_, SI_,
SIGEV_,
[XSI]
ss_, sv_, SS_, TRAP_
atomic_[a-z], memory_[a-z]
str[a-z]
str[a-z], mem[a-z], wcs[a-z]
[XSI]
ipc_, IPC_
key, pad, seq
shm_, MAP_, MCL_, MS_,
PROT_
[XSI]
msg, MSG_[A-Z]
msg
[XSI]
rlim_, ru_, PRIO_, RLIMIT_,
RUSAGE_
fd_, fds_, FD_
Header
Prefix
Suffix
Complete Name
[XSI]
sem, SEM_
sem
[XSI]
shm, SHM[A-Z], SHM_[A-Z]
cmsg_, if_, ifc_, ifra_, ifru_,
infu_, l_, msg_, sa_, ss_,
[XSI]
AF_, MSG_, PF_, SCM_,
SHUT_, SO
st_
f_, ST_
[XSI]
tv_
tms_
[XSI]
iov_
UIO_MAXIOV
sun_
uts_
P_, W[A-Z]
[XSI]
LOG_
c_, B[0-9], TC, ws_
cnd_[a-z], mtx_[a-z], thrd_[a-z],
tss_[a-z]
[CX]
clock_, it_, timer_, tm_, tv_,
CLOCK_, TIMER_
[XSI]
ut_
_LVL, _PROCESS,
_TIME
wcs[a-z]
is[a-z], to[a-z]
we_, WRDE_
[CX]  ANY header
_t
Note:
The notation [0-9] indicates any digit. The notation [A-Z] indicates any uppercase letter in the portable character set. The
notation [a-z] indicates any lowercase letter in the portable character set. Commas and spaces in the lists of prefixes and
complete names in the above table are not part of any prefix or complete name. The ISO C standard reserves int[0-9a-z_]*_t and
uint[0-9a-z_]*_t in ; this is not included in the table above
because it is covered by the reserved _t suffix for any header.
Additional symbolic constants with the prefix _CS_, _PC_, and _SC_ may be defined by the inclusion of , but as these are already reserved for the implementation, they are not
included in the table above. Extensions with these prefixes should be compatible with use by confstr(), pathconf(), and sysconf(), respectively.
Implementations may also add symbols to the
header with the following complete names or the same names suffixed with 'f' or 'l':
cerf
cexpm1
clog2
cerfc
clog10
clgamma
cexp2
clog1p
ctgamma
If any header in the following table is included, macros with the prefixes or suffixes shown may be defined. After
the last inclusion of a given header, an application may use identifiers with the corresponding prefixes for its own purpose,
provided their use is preceded by a #undef of the corresponding macro.
Header
Prefix
Suffix
_ENDIAN
E[0-9], E[A-Z]
F_, O_
FE_[A-Z]
PRI[Xa-z], SCN[Xa-z]
LC_[A-Z]
FP_[A-Z]
IMPLINK_, IN_, IP_, IPPORT_, SOCK_,
[IP6]
IN6_
SIG_, SIG[A-Z],
[XSI]
SV_
ATOMIC_[A-Z]
[CX]
SEEK_
[XSI]
RLIM_
[XSI]
CMSG_
S_
[XSI]
IOV_
I, O, V (See below.)
TIME_[A-Z]
SEEK_
The following are used to reserve complete names for the  header:
INT[0-9A-Za-z_]*_MIN
INT[0-9A-Za-z_]*_MAX
INT[0-9A-Za-z_]*_C
UINT[0-9A-Za-z_]*_MIN
UINT[0-9A-Za-z_]*_MAX
UINT[0-9A-Za-z_]*_C
Note:
The notation [0-9] indicates any digit. The notation [A-Z] indicates any uppercase letter in the portable character set. The
notation [Xa-z] indicates the character 'X' or any lowercase letter in the portable character set. The notation
[0-9A-Za-z_]* indicates zero or more occurrences of any of the following: a digit, an uppercase or lowercase letter in the portable
character set, or an .
[XSI]  The following reserved names are used as exact matches for :
CBAUD
EXTB
VDSUSP
DEFECHO
FLUSHO
VLNEXT
ECHOCTL
LOBLK
VREPRINT
ECHOKE
PENDIN
VSTATUS
ECHOPRT
SWTCH
VWERASE
EXTA
VDISCARD
When the feature test macro__STDC_WANT_LIB_EXT1__ is defined with the value 1 (see 2.2.1
POSIX.1 Symbols), implementations may add symbols to the headers shown in the following table provided the identifiers for
those symbols have one of the corresponding complete names in the table.
Header
Complete Name
fopen_s, fprintf_s, freopen_s, fscanf_s, gets_s, printf_s, scanf_s, snprintf_s, sprintf_s, sscanf_s, tmpfile_s,
tmpnam_s, vfprintf_s, vfscanf_s, vprintf_s, vscanf_s, vsnprintf_s, vsprintf_s, vsscanf_s
abort_handler_s, bsearch_s, getenv_s, ignore_handler_s, mbstowcs_s, qsort_s, set_constraint_handler_s, wcstombs_s,
wctomb_s
asctime_s, ctime_s, gmtime_s, localtime_s
fwprintf_s, fwscanf_s, mbsrtowcs_s, snwprintf_s, swprintf_s, swscanf_s, vfwprintf_s, vfwscanf_s, vsnwprintf_s,
vswprintf_s, vswscanf_s, vwprintf_s, vwscanf_s, wcrtomb_s, wmemcpy_s, wmemmove_s, wprintf_s, wscanf_s
When the feature test macro__STDC_WANT_LIB_EXT1__ is defined with the value 1 (see 2.2.1
POSIX.1 Symbols), if any header in the following table is included, macros with the complete names shown may be defined.
Header
Complete Name
RSIZE_MAX
L_tmpnam_s, TMP_MAX_S
Note:
The above two tables only include those symbols from Annex K of the ISO C standard that are not already allowed to be
visible by entries in earlier tables in this section.
The following identifiers are reserved regardless of the inclusion of headers:
1.
With the exception of identifiers beginning with the prefix _POSIX_ and those identifiers which are lexically identical to
keywords defined by the ISO C standard (for example _Bool), all identifiers that begin with an  and
either an uppercase letter or another  are always reserved for any use by the implementation.
2.
All identifiers that begin with an  are always reserved for use as identifiers with file scope in both the
ordinary identifier and tag name spaces.
3.
All identifiers in the table below are reserved for use as identifiers with external linkage. Some of these identifiers do not
appear in this volume of POSIX.1-2024, but are reserved for future use by the ISO C standard.
4.
All functions and external identifiers defined in XBD 14. Headers are
reserved for use as identifiers with external linkage.
5.
All the identifiers defined in this volume of POSIX.1-2024 that have external linkage and errno are always reserved for
use as identifiers with external linkage.
Note:
The notation [a-z] indicates any lowercase letter in the portable character set. The notation '*' indicates any
combination of digits, letters in the portable character set, or .
No other identifiers are reserved.
_Exit
abort
abs
acos
acosf
acosh
acoshf
acoshl
acosl
aligned_alloc
asctime
asin
asinf
asinh
asinhf
asinhl
asinl
at_quick_exit
atan
atan2
atan2f
atan2l
atanf
atanh
atanhf
atanhl
atanl
atexit
atof
atoi
atol
atoll
atomic_compare_exchange_strong
atomic_compare_exchange_strong_explicit
atomic_compare_exchange_weak
atomic_compare_exchange_weak_explicit
atomic_exchange
atomic_exchange_explicit
atomic_fetch_add
atomic_fetch_add_explicit
atomic_fetch_and
atomic_fetch_and_explicit
atomic_fetch_or
atomic_fetch_or_explicit
atomic_fetch_sub
atomic_fetch_sub_explicit
atomic_fetch_xor
atomic_fetch_xor_explicit
atomic_flag_clear
atomic_flag_clear_explicit
atomic_flag_test_and_set
atomic_flag_test_and_set_explicit
atomic_init
atomic_is_lock_free
atomic_load
atomic_load_explicit
atomic_signal_fence
atomic_store
atomic_store_explicit
atomic_thread_fence
bsearch
btowc
c16rtomb
c32rtomb
cabs
cabsf
cabsl
cacos
cacosf
cacosh
cacoshf
cacoshl
cacosl
call_once
calloc
carg
cargf
cargl
casin
casinf
casinh
casinhf
casinhl
casinl
catan
catanf
catanh
catanhf
catanhl
catanl
cbrt
cbrtf
cbrtl
ccos
ccosf
ccosh
ccoshf
ccoshl
ccosl
ceil
ceilf
ceill
cerf
cerfc
cerfcf
cerfcl
cerff
cerfl
cexpm1
cexpm1f
cexpm1l
cexp
cexp2
cexp2f
cexp2l
cexpf
cexpl
cimag
cimagf
cimagl
clearerr
clgamma
clgammaf
clgammal
clock
clog
clog10
clog10f
clog10l
clog1p
clog1pf
clog1pl
clog2
clog2f
clog2l
clogf
clogl
cnd_broadcast
cnd_destroy
cnd_init
cnd_signal
cnd_timedwait
cnd_wait
conj
conjf
conjl
copysign
copysignf
copysignl
cos
cosf
cosh
coshf
coshl
cosl
cpow
cpowf
cpowl
cproj
cprojf
cprojl
creal
crealf
creall
csin
csinf
csinh
csinhf
csinhl
csinl
csqrt
csqrtf
csqrtl
ctan
ctanf
ctanh
ctanhf
ctanhl
ctanl
ctgamma
ctgammaf
ctgammal
ctime
difftime
div
erf
erfc
erfcf
erfcl
erff
erfl
errno
exit
exp
exp2
exp2f
exp2l
expf
expl
expm1
expm1f
expm1l
fabs
fabsf
fabsl
fclose
fdim
fdimf
fdiml
feclearexcept
fegetenv
fegetexceptflag
fegetround
feholdexcept
feof
feraiseexcept
ferror
fesetenv
fesetexceptflag
fesetround
fetestexcept
feupdateenv
fflush
fgetc
fgetpos
fgets
fgetwc
fgetws
floor
floorf
floorl
fma
fmaf
fmal
fmax
fmaxf
fmaxl
fmin
fminf
fminl
fmod
fmodf
fmodl
fopen
fprintf
fputc
fputs
fputwc
fputws
fread
free
freopen
frexp
frexpf
frexpl
fscanf
fseek
fsetpos
ftell
fwide
fwprintf
fwrite
fwscanf
getc
getchar
getenv
getwc
getwchar
gmtime
hypot
hypotf
hypotl
ilogb
ilogbf
ilogbl
imaxabs
imaxdiv
is[a-z]*
kill_dependency
labs
ldexp
ldexpf
ldexpl
ldiv
lgamma
lgammaf
lgammal
llabs
lldiv
llrint
llrintf
llrintl
llround
llroundf
llroundl
localeconv
localtime
log
log10
log10f
log10l
log1p
log1pf
log1pl
log2
log2f
log2l
logb
logbf
logbl
logf
logl
longjmp
lrint
lrintf
lrintl
lround
lroundf
lroundl
malloc
math_errhandling
mblen
mbrlen
mbrtoc16
mbrtoc32
mbrtowc
mbsinit
mbsrtowcs
mbstowcs
mbtowc
mem[a-z]*
mktime
modf
modff
modfl
mtx_destroy
mtx_init
mtx_lock
mtx_timedlock
mtx_trylock
mtx_unlock
nan
nanf
nanl
nearbyint
nearbyintf
nearbyintl
nextafter
nextafterf
nextafterl
nexttoward
nexttowardf
nexttowardl
perror
pow
powf
powl
printf
putc
putchar
puts
putwc
putwchar
qsort
quick_exit
raise
rand
realloc
remainder
remainderf
remainderl
remove
remquo
remquof
remquol
rename
rewind
rint
rintf
rintl
round
roundf
roundl
scalbln
scalblnf
scalblnl
scalbn
scalbnf
scalbnl
scanf
setbuf
setjmp
setlocale
setvbuf
signal
sin
sinf
sinh
sinhf
sinhl
sinl
snprintf
sprintf
sqrt
sqrtf
sqrtl
srand
sscanf
str[a-z]*
swprintf
swscanf
system
tan
tanf
tanh
tanhf
tanhl
tanl
tgamma
tgammaf
tgammal
thrd_create
thrd_current
thrd_detach
thrd_equal
thrd_exit
thrd_join
thrd_sleep
thrd_yield
time
timespec_get
tmpfile
tmpnam
to[a-z]*
trunc
truncf
truncl
tss_create
tss_delete
tss_get
tss_set
ungetc
ungetwc
va_copy
va_end
vfprintf
vfscanf
vfwprintf
vfwscanf
vprintf
vscanf
vsnprintf
vsprintf
vsscanf
vswprintf
vswscanf
vwprintf
vwscanf
wcrtomb
wcs[a-z]*
wctob
wctomb
wctrans
wctype
wmemchr
wmemcmp
wmemcpy
wmemmove
wmemset
wprintf
wscanf
Note:
The notation [a-z] indicates any lowercase letter in the portable character set. The notation '*' indicates any
sequence of zero or more characters that are valid in identifiers with external linkage.
Applications shall not declare or define identifiers with the same name as an identifier reserved in the same
context. Since macro names are replaced whenever found, independent of scope and name space, macro names matching any of the
reserved identifier names shall not be defined by an application if any associated header is included.
Except that the effect of each inclusion of  depends
on the definition of NDEBUG, headers may be included in any order, and each may be included more than once in a given scope, with
no difference in effect from that of being included only once.
If used, the application shall ensure that a header is included outside of any external declaration or definition,
and it shall be first included before the first reference to any type or macro it defines, or to any function or object it
declares. However, if an identifier is declared or defined in more than one header, the second and subsequent associated headers
may be included after the initial reference to the identifier. Prior to the inclusion of a header, or when any macro defined in the
header is expanded, the application shall not define any macros with names lexically identical to symbols defined by that
header.
2.3 Error Numbers
Most functions can provide an error number. The means by which each function provides its error numbers is
specified in its description.
Some functions provide the error number in a variable accessed through the symbol errno, defined by
including the  header. The value of errno should only be
examined when it is indicated to be valid by a function's return value. No function in this volume of POSIX.1-2024 shall set
errno to zero. For each thread of a process, the value of errno shall not be affected by function calls or
assignments to errno by other threads.
Some functions return an error number directly as the function value. These functions return a value of zero to
indicate success.
If more than one error occurs in processing a function call, any one of the possible errors may be returned, as the
order of detection is undefined.
Implementations may support additional errors not included in this list, may generate errors included in this list
under circumstances other than those described here, or may contain extensions or limitations that prevent some errors from
occurring.
The ERRORS section on each reference page specifies which error conditions shall be detected by all implementations
("shall fail") and which may be optionally detected by an implementation ("may fail"). If no error condition is detected, the
action requested shall be successful. If an error condition is detected, the action requested may have been partially performed,
unless otherwise stated.
Implementations may generate error numbers listed here under circumstances other than those described, if and only
if all those error conditions can always be treated identically to the error conditions as described in this volume of
POSIX.1-2024. Implementations shall not generate a different error number from one required by this volume of POSIX.1-2024 for an
error condition described in this volume of POSIX.1-2024, but may generate additional errors unless explicitly disallowed for a
particular function.
Each implementation shall document, in the conformance document, situations in which each of the optional
conditions defined in POSIX.1-2024 is detected. The conformance document may also contain statements that one or more of the
optional error conditions are not detected.
Certain threads-related functions are not allowed to return an error code of [EINTR]. Where this applies it is
stated in the ERRORS section on the individual function pages.
The following macro names identify the possible error numbers, in the context of the functions specifically defined
in this volume of POSIX.1-2024; these general descriptions are more precisely defined in the ERRORS sections of the functions that
return them. Only these macro names should be used in programs, since the actual value of the error number is unspecified. All
values listed in this section shall be unique, except as noted below. The values for all these macros shall be found in the
header defined in the Base Definitions volume of POSIX.1-2024. The
actual values are unspecified by this volume of POSIX.1-2024.
[E2BIG]
Argument list too long. The sum of the number of bytes used by the new process image's argument list and environment list is
greater than the system-imposed limit of {ARG_MAX} bytes.
or:
Lack of space in an output buffer.
or:
Argument is greater than the system-imposed maximum.
[EACCES]
Permission denied. An attempt was made to access a file in a way forbidden by its file access permissions.
[EADDRINUSE]
Address in use. The specified address is in use.
[EADDRNOTAVAIL]
Address not available. The specified address is not available from the local system.
[EAFNOSUPPORT]
Address family not supported. The implementation does not support the specified address family, or the specified address is not a
valid address for the address family of the specified socket.
[EAGAIN]
Resource temporarily unavailable. This is a temporary condition and later calls to the same routine may complete normally.
[EALREADY]
Connection already in progress. A connection request is already in progress for the specified socket.
[EBADF]
Bad file descriptor. A file descriptor argument is out of range, refers to no open file, or a read (write) request is made to a
file that is only open for writing (reading).
[EBADMSG]
Bad Message. The implementation has detected a corrupted message.
[EBUSY]
Resource busy. An attempt was made to make use of a system resource that is not currently available, as it is being used by another
process in a manner that would have conflicted with the request being made by this process.
[ECANCELED]
Operation canceled. The associated asynchronous operation was canceled before completion.
[ECHILD]
No child process. A wait(), waitid(), or
waitpid() function was executed by a process that had no existing or unwaited-for
child process.
[ECONNABORTED]
Connection aborted. The connection has been aborted.
[ECONNREFUSED]
Connection refused. An attempt to connect to a socket was refused because there was no process listening or because the queue of
connection requests was full and the underlying protocol does not support retransmissions.
[ECONNRESET]
Connection reset. The connection was forcibly closed by the peer.
[EDEADLK]
Resource deadlock would occur. An attempt was made to lock a system resource that would have resulted in a deadlock situation.
[EDESTADDRREQ]
Destination address required. No bind address was established.
[EDOM]
Domain error. An input argument is outside the defined domain of the mathematical function (defined in the ISO C
standard).
[EDQUOT]
Reserved.
[EEXIST]
File exists. An existing file was mentioned in an inappropriate context; for example, as a new link name in the link() function.
[EFAULT]
Bad address. The system detected an invalid address in attempting to use an argument of a call. The reliable detection of this
error cannot be guaranteed, and when not detected may result in the generation of a signal, indicating an address violation, which
is sent to the process.
[EFBIG]
File too large. The size of a file would exceed the implementation's maximum file size, the file size limit of the process, or the
offset maximum established in the corresponding open file description.
[EHOSTUNREACH]
Host is unreachable. The destination host cannot be reached (probably because the host is down or a remote router cannot reach
it).
[EIDRM]
Identifier removed. Returned during XSI interprocess communication if an identifier has been removed from the system.
[EILSEQ]
Illegal byte sequence. A wide-character code has been detected that does not correspond to a valid character, or a byte sequence
does not form a valid wide-character code (defined in the ISO C standard).
[EINPROGRESS]
Operation in progress. This code is used to indicate that an asynchronous operation has not yet completed.
or:
O_NONBLOCK is set for the socket file descriptor and the connection cannot be immediately established.
[EINTR]
Interrupted function call. An asynchronous signal was caught by the process during the execution of an interruptible function. If
the signal handler performs a normal return, the interrupted function call may return this condition (see the Base Definitions
volume of POSIX.1-2024, ).
[EINVAL]
Invalid argument. Some invalid argument was supplied; for example, specifying an undefined signal in a signal() function or a kill() function.
[EIO]
Input/output error. Some physical input or output error has occurred. This error may be reported on a subsequent operation on the
same file descriptor. Any other error-causing operation on the same file descriptor may cause the [EIO] error indication to be
lost.
[EISCONN]
Socket is connected. The specified socket is already connected.
[EISDIR]
Is a directory. An attempt was made to open a directory with write mode specified.
[ELOOP]
Symbolic link loop. A loop exists in symbolic links encountered during pathname resolution. This error may also be returned if more
than {SYMLOOP_MAX} symbolic links are encountered during pathname resolution.
[EMFILE]
File descriptor value too large or too many open streams. An attempt was made to open a file descriptor with a value greater than
or equal to {OPEN_MAX}, [XSI]   or greater than or equal to the soft limit RLIMIT_NOFILE for the process (if smaller than
{OPEN_MAX});   or an attempt was made to open more than the
maximum number of streams allowed in the process.
[EMLINK]
Too many hard links. An attempt was made to have the link count of a single file exceed {LINK_MAX}.
[EMSGSIZE]
Message too large. A message sent on a transport provider was larger than an internal message buffer or some other network limit.
or:
Inappropriate message buffer length.
[EMULTIHOP]
Reserved.
[ENAMETOOLONG]
Filename too long. The length of a pathname exceeds {PATH_MAX} and the implementation considers this to be an error, or a pathname
component is longer than {NAME_MAX}. This error may also occur when pathname substitution, as a result of encountering a symbolic
link during pathname resolution, results in a pathname string the size of which exceeds {PATH_MAX}.
[ENETDOWN]
Network is down. The local network interface used to reach the destination is down.
[ENETRESET]
The connection was aborted by the network.
[ENETUNREACH]
Network unreachable. No route to the network is present.
[ENFILE]
Too many files open in system. Too many files are currently open in the system. The system has reached its predefined limit for
simultaneously open files and temporarily cannot accept requests to open another one.
[ENOBUFS]
No buffer space available. Insufficient buffer resources were available in the system to perform the socket operation.
[ENODEV]
No such device. An attempt was made to apply an inappropriate function to a device; for example, trying to read a write-only device
such as a printer.
[ENOENT]
No such file or directory. A component of a specified pathname does not exist, or the pathname is an empty string.
[ENOEXEC]
Executable file format error. A request is made to execute a file that, although it has appropriate privileges, is not in the
format required by the implementation for executable files.
[ENOLCK]
No locks available. A system-imposed limit on the number of simultaneous file and record locks has been reached and no more are
currently available.
[ENOLINK]
Reserved.
[ENOMEM]
Not enough space. The new process image requires more memory than is allowed by the hardware or system-imposed memory management
constraints.
[ENOMSG]
No message of the desired type. The message queue does not contain a message of the required type during XSI interprocess
communication.
[ENOPROTOOPT]
Protocol not available. The protocol option specified to setsockopt() is not
supported by the implementation.
[ENOSPC]
No space left on a device. During the write() function on a regular file or when
extending a directory, there is no free space left on the device.
[ENOSYS]
Functionality not supported. An attempt was made to use optional functionality that is not supported in this implementation.
[ENOTCONN]
Socket not connected. The socket is not connected.
[ENOTDIR]
Not a directory. A component of the specified pathname exists, but it is not a directory, when a directory was expected; or an
attempt was made to create a non-directory file, and the specified pathname contains at least one non- character and
ends with one or more trailing  characters.
[ENOTEMPTY]
Directory not empty. A directory other than an empty directory was supplied when an empty directory was expected.
[ENOTRECOVERABLE]
State not recoverable. The state protected by a robust mutex is not recoverable.
[ENOTSOCK]
Not a socket. The file descriptor does not refer to a socket.
[ENOTSUP]
Not supported. The implementation does not support the requested feature or value.
[ENOTTY]
Inappropriate I/O control operation. A control function has been attempted for a file or special file for which the operation is
inappropriate.
[ENXIO]
No such device or address. Input or output on a special file refers to a device that does not exist, or makes a request beyond the
capabilities of the device. It may also occur when, for example, a tape drive is not on-line.
[EOPNOTSUPP]
Operation not supported on socket. The type of socket (address family or protocol) does not support the requested operation. A
conforming implementation may assign the same values for [EOPNOTSUPP] and [ENOTSUP].
[EOVERFLOW]
Value too large to be stored in data type. An operation was attempted which would generate a value that is outside the range of
values that can be represented in the relevant data type or that are allowed for a given data item.
[EOWNERDEAD]
[EPERM]
Operation not permitted. An attempt was made to perform an operation limited to processes with appropriate privileges or to the
owner of a file or other resource.
[EPIPE]
Broken pipe. A write was attempted on a socket, pipe, or FIFO for which there is no process to read the data.
[EPROTO]
Protocol error. Some protocol error occurred. This error is device-specific, but is generally not related to a hardware
failure.
[EPROTONOSUPPORT]
Protocol not supported. The protocol is not supported by the address family, or the protocol is not supported by the
implementation.
[EPROTOTYPE]
Protocol wrong type for socket. The socket type is not supported by the protocol.
[ERANGE]
Result too large or too small. The result of the function is too large (overflow) or too small (underflow) to be represented in the
available space (defined in the ISO C standard).
[EROFS]
Read-only file system. An attempt was made to modify a file or directory on a file system that is read-only.
[ESOCKTNOSUPPORT]
Socket type not supported. The socket type is not supported by the address family, or the socket type is not supported by the
implementation.
[ESPIPE]
Invalid seek. An attempt was made to access the file offset associated with a pipe or FIFO.
[ESRCH]
No such process. No process can be found corresponding to that specified by the given process ID.
[ESTALE]
Reserved.
[ETIMEDOUT]
Connection timed out. The connection to a remote machine has timed out. If the connection timed out during execution of the
function that reported this error (as opposed to timing out prior to the function being called), it is unspecified whether the
function has completed some or all of the documented behavior associated with a successful completion of the function.
or:
Operation timed out. The time limit associated with the operation was exceeded before the operation completed.
[ETXTBSY]
Text file busy. An attempt was made to execute a pure-procedure program that is currently open for writing, or an attempt has been
made to open for writing a pure-procedure program that is being executed.
[EWOULDBLOCK]
Operation would block. An operation on a socket marked as non-blocking has encountered a situation such as no data available that
otherwise would have caused the function to suspend execution.
A conforming implementation may assign the same values for [EWOULDBLOCK] and [EAGAIN].
[EXDEV]
Improper hard link. Creation of a hard link to a file on another file system was attempted.
2.3.1 Additional Error Numbers
Additional implementation-defined error numbers may be defined in .
2.4 Signal Concepts
2.4.1 Signal Generation and Delivery
A signal is said to be "generated" for (or sent to) a process or thread when the event that causes the signal
first occurs. Examples of such events include detection of hardware faults, timer expiration, signals generated via the
sigevent structure and terminal activity, as well as invocations of the kill()
and sigqueue() functions. In some circumstances, the same event generates signals
for multiple processes.
At the time of generation, a determination shall be made whether the signal has been generated for the process or
for a specific thread within the process. Signals which are generated by some action attributable to a particular thread, such as a
hardware fault, shall be generated for the thread that caused the signal to be generated. Signals that are generated in association
with a process ID or process group ID or an asynchronous event, such as terminal activity, shall be generated for the process.
Each process has an action to be taken in response to each signal defined by the system (see 2.4.3 Signal Actions). A signal is said to be "delivered" to a process when the appropriate action for the
process and signal is taken. A signal is said to be "accepted" by a process when the signal is selected and returned by one of
the sigwait() functions.
During the time between the generation of a signal and its delivery or acceptance, the signal is said to be
"pending". Ordinarily, this interval cannot be detected by an application. However, a signal can be "blocked" from delivery to
a thread. If the action associated with a blocked signal is anything other than to ignore the signal, and if that signal is
generated for the thread, the signal shall remain pending until it is unblocked, it is accepted when it is selected and returned by
a call to the sigwait() function, or the action associated with it is set to ignore
the signal. Signals generated for the process shall be delivered to exactly one of those threads within the process which is in a
call to a sigwait() function selecting that signal or has not blocked delivery of
the signal. If there are no threads in a call to a sigwait() function selecting that
signal, and if all threads within the process block delivery of the signal, the signal shall remain pending on the process until a
thread calls a sigwait() function selecting that signal, a thread unblocks delivery
of the signal, or the action associated with the signal is set to ignore the signal. If the action associated with a blocked signal
is to ignore the signal and if that signal is generated for the process, it is unspecified whether the signal is discarded
immediately upon generation or remains pending.
Each thread has a "signal mask" that defines the set of signals currently blocked from delivery to it. The signal
mask for a thread shall be initialized from that of its parent or creating thread, or from the corresponding thread in the parent
process if the thread was created as the result of a call to fork(). The pthread_sigmask(), sigaction(),
sigprocmask(), and sigsuspend() functions control the manipulation of the signal mask.
The determination of which action is taken in response to a signal is made at the time the signal is delivered,
allowing for any changes since the time of generation. This determination is independent of the means by which the signal was
originally generated. If a subsequent occurrence of a pending signal is generated, it is implementation-defined as to whether the
signal is delivered or accepted more than once in circumstances other than those in which queuing is required. The order in which
multiple, simultaneously pending signals outside the range SIGRTMIN to SIGRTMAX are delivered to or accepted by a process is
unspecified.
When any stop signal (SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU) is generated for a process or thread, all pending SIGCONT
signals for that process or any of the threads within that process shall be discarded. Conversely, when SIGCONT is generated for a
process or thread, all pending stop signals for that process or any of the threads within that process shall be discarded. When
SIGCONT is generated for a process that is stopped, the process shall be continued, even if the SIGCONT signal is ignored by the
process or is blocked by all threads within the process and there are no threads in a call to a sigwait() function selecting SIGCONT. If SIGCONT is blocked by all threads within the
process, there are no threads in a call to a sigwait() function selecting SIGCONT,
and SIGCONT is not ignored by the process, the SIGCONT signal shall remain pending on the process until it is either unblocked by a
thread or a thread calls a sigwait() function selecting SIGCONT, or a stop signal is
generated for the process or any of the threads within the process.
An implementation shall document any condition not specified by this volume of POSIX.1-2024 under which the
implementation generates signals.
2.4.2 Realtime Signal Generation and Delivery
This section describes functionality to support realtime signal generation and delivery.
Some signal-generating functions, such as high-resolution timer expiration, asynchronous I/O completion,
interprocess message arrival, and the sigqueue() function, support the
specification of an application-defined value, either explicitly as a parameter to the function or in a sigevent structure
parameter. The sigevent structure is defined in  and contains
at least the following members:
Member Type
Member Name
Description
int
sigev_notify
Notification type.
int
sigev_signo
Signal number.
union sigval
sigev_value
Signal value.
void(*)(union sigval)
sigev_notify_function
Notification function.
(pthread_attr_t*)
sigev_notify_attributes
Notification attributes.
The sigev_notify member specifies the notification mechanism to use when an asynchronous event occurs. This
volume of POSIX.1-2024 defines the following values for the sigev_notify member:
SIGEV_NONE
No asynchronous notification shall be delivered when the event of interest occurs.
SIGEV_SIGNAL
The signal specified in sigev_signo shall be generated for the process when the event of interest occurs. If the
SA_SIGINFO flag is set for that signal number, then the signal shall be queued to the process and the value specified in
sigev_value shall be the si_value component of the generated signal. If SA_SIGINFO is not set for that signal number,
it is unspecified whether the signal is queued and what value, if any, is sent.
SIGEV_THREAD
A notification function shall be called to perform notification.
An implementation may define additional notification mechanisms.
The sigev_signo member specifies the signal to be generated. The sigev_value member is the
application-defined value to be passed to the signal-catching function at the time of the signal delivery or to be returned at
signal acceptance as the si_value member of the siginfo_t structure.
The sigval union is defined in  and contains
at least the following members:
Member Type
Member Name
Description
int
sival_int
Integer signal value.
void*
sival_ptr
Pointer signal value.
The sival_int member shall be used when the application-defined value is of type int; the
sival_ptr member shall be used when the application-defined value is a pointer.
When a signal is generated by the sigqueue() function or any
signal-generating function that supports the specification of an application-defined value, the signal shall be marked pending and,
if the SA_SIGINFO flag is set for that signal, the signal shall be queued to the process along with the application-specified
signal value. Multiple occurrences of signals so generated are queued in FIFO order. It is unspecified whether signals so generated
are queued when the SA_SIGINFO flag is not set for that signal.
Signals generated by the kill() function or other events that cause
signals to occur, such as detection of hardware faults, alarm() timer expiration, or
terminal activity, and for which the implementation does not support queuing, shall have no effect on signals already queued for
the same signal number.
When multiple unblocked signals, all in the range SIGRTMIN to SIGRTMAX, are pending, the behavior shall be as if
the implementation delivers the pending unblocked signal with the lowest signal number within that range. No other ordering of
signal delivery is specified.
If, when a pending signal is delivered, there are additional signals queued to that signal number, the signal shall
remain pending. Otherwise, the pending indication shall be reset.
Multi-threaded programs can use an alternate event notification mechanism. When a notification is processed, and
the sigev_notify member of the sigevent structure has the value SIGEV_THREAD, the function
sigev_notify_function is called with parameter sigev_value.
The function shall be executed in a newly created thread as if it were the start_routine for a call to
pthread_create() with the thread attributes specified by
sigev_notify_attributes. If sigev_notify_attributes is NULL, the behavior shall be as if the thread were created with
the detachstate attribute set to PTHREAD_CREATE_DETACHED. Supplying an attributes structure with a detachstate
attribute of PTHREAD_CREATE_JOINABLE results in undefined behavior. It is implementation-defined whether the signal mask of this
thread has all signals except SIGKILL and SIGSTOP blocked, or is the same as the mask that was in effect for the thread which
installed the sigevent notification handler at the time of the call that installed the handler.
2.4.3 Signal Actions
There are three types of action that can be associated with a signal: SIG_DFL, SIG_IGN, or a pointer to a function.
Initially, all signals shall be set to SIG_DFL or SIG_IGN prior to entry of the main() routine (see the exec functions). The actions prescribed by these values are as follows.
SIG_DFL
Signal-specific default action.
The default actions for the signals defined in this volume of POSIX.1-2024 are specified under . The default actions for the realtime signals in the range SIGRTMIN to
SIGRTMAX shall be to terminate the process abnormally.
If the default action is to terminate the process abnormally, the process is terminated as if by a call to _exit(), except that the status made available to wait(), waitid(), and waitpid() indicates abnormal termination by the signal. If the default action is to
terminate the process abnormally with additional actions, implementation-defined abnormal termination actions, such as creation of
a core image, may also occur.
If the default action is to stop the process, the execution of that process is temporarily suspended. When a
process stops, a SIGCHLD signal shall be generated for its parent process, unless the parent process has set the SA_NOCLDSTOP flag.
While a process is stopped, any additional signals that are sent to the process shall not be delivered until the process is
continued, except SIGKILL which always terminates the receiving process. A process that is a member of an orphaned process group
shall not be allowed to stop in response to the SIGTSTP, SIGTTIN, or SIGTTOU signals. In cases where delivery of one of these
signals would stop such a process, the signal shall be discarded.
If the default action is to ignore the signal, delivery of the signal shall have no effect on the process.
Setting a signal action to SIG_DFL for a signal that is pending, and whose default action is to ignore the signal
(for example, SIGCHLD), shall cause the pending signal to be discarded, whether or not it is blocked. Any queued values pending
shall be discarded and the resources used to queue them shall be released and returned to the system for other use.
The default action for SIGCONT is to resume execution at the point where the process was stopped, after first
handling any pending unblocked signals.
[XSI]  When a stopped process is continued, a SIGCHLD signal may be generated for its parent process, unless the parent
process has set the SA_NOCLDSTOP flag.
SIG_IGN
Ignore signal.
Delivery of the signal shall have no effect on the process. The behavior of a process is undefined after it ignores
a SIGFPE, SIGILL, SIGSEGV, or SIGBUS signal that was not generated by kill(), sigqueue(), or raise().
The system shall not allow the action for the signals SIGKILL or SIGSTOP to be set to SIG_IGN.
Setting a signal action to SIG_IGN for a signal that is pending shall cause the pending signal to be discarded,
whether or not it is blocked.
If a process sets the action for the SIGCHLD signal to SIG_IGN, the behavior is unspecified,
[XSI]
except as specified under "Consequences of Process Termination" in the description of the _Exit() function (see XSH _Exit()).
Any queued values pending shall be discarded and the resources used to queue them shall be released and made
available to queue other signals.
Pointer to a Function
Catch signal.
On delivery of the signal, the receiving process is to execute the signal-catching function at the specified
address. After returning from the signal-catching function, the receiving process shall resume execution at the point at which it
was interrupted.
If the SA_SIGINFO flag for the signal is cleared, the signal-catching function shall be entered as a C-language
function call as follows:
void func(int signo);
If the SA_SIGINFO flag for the signal is set, the signal-catching function shall be entered as a C-language
function call as follows:
void func(int signo, siginfo_t *info, void *context);
where func is the specified signal-catching function, signo is the signal number of the signal being
delivered, and info is a pointer to a siginfo_t structure defined in  containing at least the following members:
Member Type
Member Name
Description
int
si_signo
Signal number.
int
si_code
Cause of the signal.
pid_t
si_pid
Sending process ID.
uid_t
si_uid
Real user ID of sending process.
void *
si_addr
Address of faulting instruction.
int
si_status
Exit value or signal.
union sigval
si_value
Signal value.
The si_signo member shall contain the signal number. This shall be the same as the signo parameter.
The si_code member shall contain a code identifying the cause of the signal. The following non-signal-specific values are
defined for si_code:
SI_USER
The signal was sent by the kill() function. The implementation may set
si_code to SI_USER if the signal was sent by the raise() or abort() functions or any similar functions provided as implementation extensions.
SI_QUEUE
The signal was sent by the sigqueue() function.
SI_TIMER
The signal was generated by the expiration of a timer set by timer_settime().
SI_ASYNCIO
The signal was generated by the completion of an asynchronous I/O request.
SI_MESGQ
[MSG]
The signal was generated by the arrival of a message on an empty message queue.
Signal-specific values for si_code are also defined, as described in XBD .
If the signal was not generated by one of the functions or events listed above, si_code shall be set either
to one of the signal-specific values described in XBD , or to an
implementation-defined value that is not equal to any of the values defined above.
If si_code is SI_USER or SI_QUEUE, [XSI]   or any value less than or equal to 0,   then the signal was generated by a process and si_pid and
si_uid shall be set to the process ID and the real user ID of the sender, respectively.
In addition, si_addr, si_pid, si_status, and si_uid shall be set for certain
signal-specific values of si_code, as described in XBD .
If si_code is one of SI_QUEUE, SI_TIMER, SI_ASYNCIO, or SI_MESGQ, then si_value shall contain the
application-specified signal value. Otherwise, the contents of si_value are undefined.
The behavior of a process is undefined after it returns normally from a signal-catching function for a SIGBUS,
SIGFPE, SIGILL, or SIGSEGV signal that was not generated by kill(), sigqueue(), or raise().
The system shall not allow a process to catch the signals SIGKILL and SIGSTOP.
If a process establishes a signal-catching function for the SIGCHLD signal while it has a terminated child process
for which it has not waited, it is unspecified whether a SIGCHLD signal is generated to indicate that child process.
If the process is multi-threaded, or if the process is single-threaded and a signal handler is executed other than
as the result of:
The process calling abort(), raise(), kill(), pthread_kill(), or sigqueue() to
generate a signal that is not blocked
A pending signal being unblocked and being delivered before the call that unblocked it returns
the behavior is undefined if:
The signal handler refers to any object other than errno with static or thread storage duration that is not
a lock-free atomic object, and not a non-modifiable object (for example, string literals, objects that were defined with a
const-qualified type, and objects in memory that is mapped read-only), other than by assigning a value to an object declared as
volatile sig_atomic_t, unless the previous modification (if any) to the object happens before the signal handler is called
and the return from the signal handler happens before the next modification (if any) to the object.
The signal handler calls any function or function-like macro defined in this standard other than one of the
functions and macros specified below as being async-signal-safe.
The following table defines a set of functions and function-like macros that shall be async-signal-safe. Therefore,
applications can call them, without restriction, from signal-catching functions. Note that, although there is no restriction on the
calls themselves, for certain functions there are restrictions on subsequent behavior after the function is called from a
signal-catching function (see longjmp()).
_Exit()
_Fork()
_exit()
abort()
accept()
accept4()
access()
aio_error()
aio_return()
aio_suspend()
alarm()
be16toh()
be32toh()
be64toh()
bind()
cfgetispeed()
cfgetospeed()
cfsetispeed()
cfsetospeed()
chdir()
chmod()
chown()
clock_gettime()
close()
connect()
creat()
dup()
dup2()
dup3()
execl()
execle()
execv()
execve()
faccessat()
fchdir()
fchmod()
fchmodat()
fchown()
fchownat()
fcntl()
fdatasync()
fexecve()
ffs()
fstat()
fstatat()
fsync()
ftruncate()
futimens()
getegid()
geteuid()
getgid()
getgroups()
getpeername()
getpgrp()
getpid()
getppid()
getresgid()
getresuid()
getsockname()
getsockopt()
getuid()
htobe16()
htobe32()
htobe64()
htole16()
htole32()
htole64()
htonl()
htons()
kill()
killpg()
le16toh()
le32toh()
le64toh()
link()
linkat()
listen()
longjmp()
lseek()
lstat()
memccpy()
memchr()
memcmp()
memcpy()
memmove()
memset()
mkdir()
mkdirat()
mkfifo()
mkfifoat()
mknod()
mknodat()
ntohl()
ntohs()
open()
openat()
pause()
pipe()
pipe2()
poll()
posix_close()
ppoll()
pread()
pselect()
pthread_kill()
pthread_self()
pthread_setcancelstate()
pthread_sigmask()
pwrite()
quick_exit()
raise()
read()
readv()
readlink()
readlinkat()
recv()
recvfrom()
recvmsg()
rename()
renameat()
rmdir()
select()
sem_post()
send()
sendmsg()
sendto()
setegid()
seteuid()
setgid()
setpgid()
setregid()
setresgid()
setresuid()
setreuid()
setsid()
setsockopt()
setuid()
shutdown()
sig2str()
sigaction()
sigaddset()
sigdelset()
sigemptyset()
sigfillset()
sigismember()
siglongjmp()
signal()
sigpending()
sigprocmask()
sigqueue()
sigsuspend()
sleep()
sockatmark()
socket()
socketpair()
stat()
stpcpy()
stpncpy()
strcat()
strchr()
strcmp()
strcpy()
strcspn()
strlcat()
strlcpy()
strlen()
strncat()
strncmp()
strncpy()
strnlen()
strpbrk()
strrchr()
strspn()
strstr()
strtok_r()
symlink()
symlinkat()
tcdrain()
tcflow()
tcflush()
tcgetattr()
tcgetpgrp()
tcgetwinsize()
tcsendbreak()
tcsetattr()
tcsetpgrp()
tcsetwinsize()
time()
timer_getoverrun()
timer_gettime()
timer_settime()
times()
umask()
uname()
unlink()
unlinkat()
utimensat()
utimes()
va_arg()
va_copy()
va_end()
va_start()
wait()
waitid()
waitpid()
wcpcpy()
wcpncpy()
wcscat()
wcschr()
wcscmp()
wcscpy()
wcscspn()
wcslcat()
wcslcpy()
wcslen()
wcsncat()
wcsncmp()
wcsncpy()
wcsnlen()
wcspbrk()
wcsrchr()
wcsspn()
wcsstr()
wcstok()
wmemchr()
wmemcmp()
wmemcpy()
wmemmove()
wmemset()
write()
writev()
In addition, the functions in  other than
atomic_init() shall be async-signal-safe when the atomic arguments are
lock-free, and the atomic_is_lock_free() function shall be
async-signal-safe when called with an atomic argument.
All other functions (including generic functions) and function-like macros may be unsafe with respect to signals.
It is implementation-defined which additional interfaces, if any, are also async-signal-safe. In the presence of signals, all
functions defined by this volume of POSIX.1-2024 shall behave as defined when called from or interrupted by a signal-catching
function, with the exception that when a signal interrupts an unsafe function or function-like macro, or equivalent (such as the
processing equivalent to exit() performed after a return from the initial call to
main()), and the signal-catching function calls an unsafe function or function-like macro, the behavior is undefined.
Additional exceptions are specified in the descriptions of individual functions such as longjmp().
Operations which obtain the value of errno and operations which assign a value to errno shall be
async-signal-safe, provided that the signal-catching function saves the value of errno upon entry and restores it before it
returns.
When a signal is delivered to a thread, if the action of that signal specifies termination, stop, or continue, the
entire process shall be terminated, stopped, or continued, respectively.
2.4.4 Signal Effects on Other Functions
Signals affect the behavior of certain functions defined by this volume of POSIX.1-2024 if delivered to a process
while it is executing such a function. If the action of the signal is to terminate the process, the process shall be terminated and
the function shall not return. If the action of the signal is to stop the process, the process shall stop until continued or
terminated. Generation of a SIGCONT signal for the process shall cause the process to be continued, and the original function shall
continue at the point the process was stopped. If the action of the signal is to invoke a signal-catching function, the
signal-catching function shall be invoked; in this case the original function is said to be "interrupted" by the signal. If the
signal-catching function executes a return statement, the behavior of the interrupted function shall be as described
individually for that function, except as noted for unsafe functions. After returning from a signal-catching function, the value of
errno is unspecified if the signal-catching function or any function it called assigned a value to errno and the
signal-catching function did not save and restore the original value of errno. Signals that are ignored shall not affect the
behavior of any function; signals that are blocked shall not affect the behavior of any function until they are unblocked and then
delivered, except as specified for the sigpending() and sigwait() functions.
2.5 Standard I/O Streams
A stream is associated with an external file (which may be a physical device) [CX]   or memory
buffer   by "opening" a file [CX]   or buffer.
This may involve "creating" a new file. Creating an existing file
causes its former contents to be discarded if necessary. If a file can support positioning requests (such as a disk file, as
opposed to a terminal), then a "file position indicator" associated with the stream is positioned at the start (byte number 0) of
the file, unless the file is opened with append mode, in which case it is implementation-defined whether the file position
indicator is initially positioned at the beginning or end of the file. The file position indicator is maintained by subsequent
reads, writes, and positioning requests, to facilitate an orderly progression through the file.
The wide-character input functions shall read characters from the stream and convert them to wide characters as if
they were read by successive calls to the fgetwc() function. Each conversion shall
occur as if by a call to the mbrtowc() function, with the conversion state described
by the stream's own mbstate_t object (see 2.5.2 Stream Orientation and Encoding Rules). The
byte input functions shall read characters from the stream as if by successive calls to the fgetc() function.
The wide-character output functions shall convert wide characters to characters and write them to the stream as if
they were written by successive calls to the fputwc() function. Each conversion shall
occur as if by a call to the wcrtomb() function, with the conversion state described
by the stream's own mbstate_t object (see 2.5.2 Stream Orientation and Encoding Rules). The
byte output functions shall write characters to the stream as if by successive calls to the fputc() function.
The perror(), psiginfo(), and psignal() functions shall
behave as described above for the byte output functions if the stream is already byte-oriented, and shall behave as described above
for the wide-character output functions if the stream is already wide-oriented. If the stream has no orientation, they shall behave
as described for the byte output functions except that they shall not change the orientation of the stream.
Functions other than perror(), psiginfo(), and psignal() that write to
streams but are neither wide-character output nor byte output functions (getopt() and
wordexp()), shall behave as described above for the byte output functions, except
that if the stream has no orientation, it is unspecified whether they set the stream to byte orientation or leave it with no
orientation.
When a stream is "unbuffered", bytes are intended to appear from the source or at the destination as soon as
possible; otherwise, bytes may be accumulated and transmitted as a block. When a stream is "fully buffered", bytes are intended
to be transmitted as a block when a buffer is filled. When a stream is "line buffered", bytes are intended to be transmitted as a
block when a  byte is encountered. Furthermore, bytes are intended to be transmitted as a block when a buffer is
filled, when input is requested on an unbuffered stream, or when input is requested on a line-buffered stream that requires the
transmission of bytes. Support for these characteristics is implementation-defined, and may be affected via setbuf() and setvbuf().
A file may be disassociated from a controlling stream by "closing" the file. Output streams are flushed (any
unwritten buffer contents are transmitted) before the stream is disassociated from the file. The value of a pointer to a
FILE object is unspecified after the associated file is closed (including the standard streams).
A file may be subsequently reopened, by the same or another program execution, and its contents reclaimed or
modified (if it can be repositioned at its start). If the main() function returns to its original caller, or if the exit() function is called, all open files are closed (hence all output streams are flushed)
before program termination. Other paths to program termination, such as calling abort(), need not close all files properly.
The address of the FILE object used to control a stream may be significant; a copy of a FILE object
need not necessarily serve in place of the original.
At program start-up, three streams shall be predefined and already open: stdin (standard input, for
conventional input) for reading, stdout (standard output, for conventional output) for writing, and stderr (standard
error, for diagnostic output) for writing. When opened, stderr shall not be fully buffered; stdin and stdout
shall be fully buffered if and only if [CX]   the file descriptor associated with the stream is determined not to be associated with an
interactive device.
Each stream shall have an associated lock that is used to prevent data races when multiple threads of execution
access a stream, and to restrict the interleaving of stream operations performed by multiple threads. Only one thread can hold this
lock at a time. The lock shall be reentrant: a single thread can hold the lock multiple times at a given time. All functions that
read, write, position, or query the position of a stream, [CX]   except those with names ending _unlocked,   shall lock the stream [CX]   as if by a
call to flockfile()   before accessing it and release the lock [CX]   as if by a call to funlockfile()   when
the access is complete.
[CX]  If the lock is not immediately available, the function shall wait for it to become available, except in the following
circumstances. If the stream is line buffered and is open for writing or for update, and the reason the function is attempting to
lock the stream is because it is going to request input on another stream that is unbuffered, or is line buffered and requires the
transmission of characters from the host environment (see above), then the function shall attempt to determine whether a deadlock
situation exists. If a deadlock situation is found to exist, the function shall fail. If the function is able to establish that a
deadlock situation does not exist, it shall wait for the lock to become available. If the function does not establish whether or
not a deadlock situation exists, it shall continue as if it had already locked the stream, found its buffer to be empty, and
released the lock.
[CX]  A stream associated with a memory buffer shall have the same operations for text files that a stream associated with an
external file would have. In addition, the stream orientation shall be determined in exactly the same fashion.
Input and output operations on a stream associated with a memory buffer by a call to fmemopen() shall be constrained by the implementation to take place within the bounds of
the memory buffer. In the case of a stream opened by open_memstream() or
open_wmemstream(), the memory area shall grow dynamically to accommodate
write operations as necessary. For output, if the stream is fully buffered or line buffered, data shall be moved from the stream's
internal buffer, or a buffer provided by setvbuf(), to the memory buffer during a
flush or close operation. For input, it is unspecified whether a buffer provided by setvbuf() is used or whether read operations read directly from the memory buffer provided
to or allocated by fmemopen().
When a standard I/O stream has an associated memory buffer (whether allocated internally, supplied to setvbuf(), or supplied to fmemopen()), the
behavior is undefined if that buffer overlaps with the destination buffer passed to a call that reads from the stream or with the
source buffer passed to a call that writes to the stream.
2.5.1 Interaction of File Descriptors and Standard I/O Streams
[CX]  This section describes the interaction of file descriptors and standard I/O streams. The functionality described in
this section is an extension to the ISO C standard (and the rest of this section is not further CX shaded).
An open file description may be accessed through a file descriptor, which is created using functions such as
open() or pipe(), or through a stream,
which is created using functions such as fopen() or popen(). Either a file descriptor or a stream is called a "handle" on the open file
description to which it refers; an open file description may have several handles.
Handles can be created or destroyed by explicit user action, without affecting the underlying open file
description. Some of the ways to create them include fcntl(), dup(), fdopen(), fileno(), and fork(). They can be destroyed by at
least fclose(), close(), and the
exec functions.
A file descriptor that is never used in an operation that could affect the file offset (for example, read(), write(), or lseek()) is not considered a handle for this discussion, but could give rise to one (for
example, as a consequence of fdopen(), dup(), or fork()). This exception does not include
the file descriptor underlying a stream, whether created with fopen() or fdopen(), so long as it is not used directly by the application to affect the file offset.
The read() and write() functions
implicitly affect the file offset; lseek() explicitly affects it.
The result of function calls involving any one handle (the "active handle") is defined elsewhere in this volume
of POSIX.1-2024, but if two or more handles are used, and any one of them is a stream, the application shall ensure that their
actions are coordinated as described below. If this is not done, the result is undefined.
A handle which is a stream is considered to be closed when either an fclose(), or freopen() with non-null filename,
is executed on it (for freopen() with a null filename, it is implementation-defined
whether a new handle is created or the existing one reused), or when the process owning that stream terminates with exit(), abort(), or due to a signal. Several
functions close file descriptors, including close(), dup2(), _exit(), the exec functions when FD_CLOEXEC is set on a file descriptor, fork() when FD_CLOFORK is set on a file descriptor, and posix_spawn() when either FD_CLOEXEC or FD_CLOFORK is set.
For a handle to become the active handle, the application shall ensure that the actions below are performed between
the last use of the handle (the current active handle) and the first use of the second handle (the future active handle). The
second handle then becomes the active handle. All activity by the application affecting the file offset on the first handle shall
be suspended until it again becomes the active file handle. (If a stream function has as an underlying function one that affects
the file offset, the stream function shall be considered to affect the file offset.)
The handles need not be in the same process for these rules to apply.
Note that after a fork(), two handles exist where one existed before.
The application shall ensure that, if both handles can ever be accessed, they are both in a state where the other could become the
active handle first. The application shall prepare for a fork() exactly as if it were a
change of active handle. (If the only action performed by one of the processes is one of the exec functions or _exit() (not exit()), the handle is never accessed in that process.)
For the first handle, the first applicable condition below applies. After the actions required below are taken, if
the handle is still open, the application can close it.
If it is a file descriptor, no action is required.
If the only further action to be performed on any handle to this open file descriptor is to close it, no action
need be taken.
If it is a stream which is unbuffered, no action need be taken.
If it is a stream which is line buffered, and the last byte written to the stream was a  (that is,
as if a:
putc('\n')
was the most recent operation on that stream), no action need be taken.
If it is a stream which is open for writing or appending (but not also open for reading), the application shall
either perform an fflush(), or the stream shall be closed.
If the stream is open for reading and it is at the end of the file (feof() is true), no action need be taken.
If the stream is open with a mode that allows reading and the underlying open file description refers to a device
that is capable of seeking, the application shall either perform an fflush(), or the
stream shall be closed.
For the second handle:
If any previous active handle has been used by a function that explicitly changed the file offset, except as
required above for the first handle, the application shall perform an lseek() or
fseek() (as appropriate to the type of handle) to an appropriate location.
If the active handle ceases to be accessible before the requirements on the first handle, above, have been met, the
state of the open file description becomes undefined. This might occur during functions such as a fork() or _exit().
The exec functions make inaccessible all streams that are open at the
time they are called, independent of which streams or file descriptors may be available to the new process image.
When these rules are followed, regardless of the sequence of handles used, no data shall be lost or duplicated when
writing, and all data shall be written in order, except as requested by seeks. It is implementation-defined whether, and under what
conditions, all input is seen exactly once.
Each function that operates on a stream is said to have zero or more "underlying functions". This means that the
stream function shares certain traits with the underlying functions, but does not require that there be any relation between the
implementations of the stream function and its underlying functions.
2.5.2 Stream Orientation and Encoding Rules
The definition of a stream includes an "orientation". After a stream is associated with an external file, but
before any operations are performed on it, the stream is without orientation. Once a wide-character input/output function has been
applied to a stream without orientation, the stream shall become "wide-oriented". Similarly, once a byte input/output function
has been applied to a stream without orientation, the stream shall become "byte-oriented". Only a call to the freopen() function or the fwide() function can
otherwise alter the orientation of a stream.
A successful call to freopen() shall remove any orientation. The
three predefined streams standard input, standard output, and standard error shall be unoriented at program
start-up.
Byte input/output functions cannot be applied to a wide-oriented stream, and wide-character input/output functions
cannot be applied to a byte-oriented stream. The remaining stream operations shall not affect and shall not be affected by a
stream's orientation, except for the following additional restriction:
For wide-oriented streams, after a successful call to a file-positioning function that leaves the file position
indicator prior to the end-of-file, a wide-character output function can overwrite a partial character; any file contents beyond
the byte(s) written are henceforth undefined.
Each wide-oriented stream [CX]   that was not opened with open_wmemstream()
has an associated mbstate_t object that stores the current parse state of the stream. A successful call to fgetpos() shall store a representation of the value of this mbstate_t object as part
of the value of the fpos_t object. A later successful call to fsetpos() using
the same stored fpos_t value shall restore the value of the associated mbstate_t object as well as the position
within the controlled stream.
Implementations that support multiple encoding rules associate an encoding rule with the stream. The encoding rule
shall be determined by the setting of the LC_CTYPE category in the current locale at the time when the stream becomes
wide-oriented. As with the stream's orientation, the encoding rule associated with a stream cannot be changed once it has been set,
except by a successful call to freopen() which clears the encoding rule and resets
the orientation to unoriented.
Although wide-oriented streams are conceptually sequences of wide characters, the external file associated with a
wide-oriented stream [CX]   that was not opened with open_wmemstream()  is
a sequence of (possibly multi-byte) characters generalized as follows:
Multi-byte encodings within files may contain embedded null bytes (unlike multi-byte encodings valid for use
internal to the program).
A file need not begin nor end in the initial shift state.
Moreover, the encodings used for characters may differ among files. Both the nature and choice of such encodings
are implementation-defined.
[CX]  On streams that were not opened with open_wmemstream(),
the wide-character input functions read characters from the stream
and convert them to wide characters as if they were read by successive calls to the fgetwc() function. Each conversion shall occur as if by a call to the mbrtowc() function, with the conversion state described by the stream's own mbstate_t
object, [CX]   except the encoding rule associated with the stream is used instead of the encoding rule implied by the LC_CTYPE
category of the current locale.
[CX]  On streams that were not opened with open_wmemstream(),
the wide-character output functions convert wide characters to
(possibly multi-byte) characters and write them to the stream as if they were written by successive calls to the fputwc() function. Each conversion shall occur as if by a call to the wcrtomb() function, with the conversion state described by the stream's own mbstate_t
object, [CX]   except the encoding rule associated with the stream is used instead of the encoding rule implied by the LC_CTYPE
category of the current locale.
An "encoding error" shall occur if the character sequence presented to the underlying mbrtowc() function does not form a valid (generalized) character, or if the code value
passed to the underlying wcrtomb() function does not correspond to a valid
(generalized) character. The wide-character input/output functions and the byte input/output functions store the value of the macro
[EILSEQ] in errno if and only if an encoding error occurs.
2.6 File Descriptor Allocation
All functions that open one or more file descriptors shall, unless specified otherwise, atomically allocate the
lowest numbered available (that is, not already open in the calling process) file descriptor at the time of each allocation. Where
a single function allocates two file descriptors (for example, pipe() or socketpair()), the allocations may be independent and therefore applications should not
expect them to have adjacent values or depend on which has the higher value.
2.7 XSI Interprocess Communication
[XSI]  This section describes extensions to support interprocess communication. The functionality described in this section
shall be provided on implementations that support the XSI option (and the rest of this section is not further marked).
The following message passing, semaphore, and shared memory services form an XSI interprocess communication
facility. Certain aspects of their operation are common, and are defined as follows.
IPC Functions
msgctl()
msgget()
msgrcv()
msgsnd()
semctl()
semget()
semop()
shmat()
shmctl()
shmdt()
shmget()
Another interprocess communication facility is provided by functions in the Realtime Option Group; see 2.8 Realtime.
2.7.1 IPC General Description
Each individual shared memory segment, message queue, and semaphore set shall be identified by a unique positive
integer, called, respectively, a shared memory identifier, shmid, a semaphore identifier, semid, and a message queue
identifier, msqid. The identifiers shall be returned by calls to shmget(),
semget(), and msgget(),
respectively.
Associated with each identifier is a data structure which contains data related to the operations which may be or
may have been performed; see the Base Definitions volume of POSIX.1-2024, , , and
for their descriptions.
Each of the data structures contains both ownership information and an ipc_perm structure (see the Base
Definitions volume of POSIX.1-2024, ) which are used in
conjunction to determine whether or not read/write (read/alter for semaphores) permissions should be granted to processes using the
IPC facilities. The mode member of the ipc_perm structure acts as a bit field which determines the permissions.
The values of the bits are given below in octal notation along with the symbolic constants defined in  that can be used to represent them.
Octal Value
Symbolic Constant
Meaning
0400
S_IRUSR
Read by user.
0200
S_IWUSR
Write (for shared memory & message queues) or alter (for semaphores) by user.
0040
S_IRGRP
Read by group.
0020
S_IWGRP
Write or alter by group.
0004
S_IROTH
Read by others.
0002
S_IWOTH
Write or alter by others.
The name of the ipc_perm structure is shm_perm, sem_perm, or msg_perm, depending on
which service is being used. In each case, read and write/alter permissions shall be granted to a process if one or more of the
following are true ("xxx" is replaced by shm, sem, or msg, as appropriate):
The process has appropriate privileges.
The effective user ID of the process matches xxx_perm.cuid or xxx_perm.uid in the data structure
associated with the IPC identifier, and the appropriate bit of the user field in xxx_perm.mode is set.
The effective user ID of the process does not match xxx_perm.cuid or xxx_perm.uid but the effective
group ID of the process matches xxx_perm.cgid or xxx_perm.gid in the data structure associated with the IPC
identifier, and the appropriate bit of the group field in xxx_perm.mode is set.
The effective user ID of the process does not match xxx_perm.cuid or xxx_perm.uid and the effective
group ID of the process does not match xxx_perm.cgid or xxx_perm.gid in the data structure associated with the IPC
identifier, but the appropriate bit of the other field in xxx_perm.mode is set.
Otherwise, the permission shall be denied.
In addition to the ipc_perm structure, each associated data structure includes several time_t fields
for recording timestamps of particular operations. When an operation is described as setting a timestamp to the current time, that
particular timestamp member of the associated data structure shall be set to the largest time_t value which is not greater
than the current time.
2.8 Realtime
This section defines functions to support the source portability of applications with realtime requirements. The
presence of some of these functions is dependent on support for implementation options described in the text.
The specific functional areas included in this section and their scope include the following. Full definitions of
these terms can be found in XBD 3. Definitions.
Semaphores
Process Memory Locking
Memory Mapped Files and Shared Memory Objects
Priority Scheduling
Realtime Signal Extension
Timers
Interprocess Communication
Synchronized Input and Output
Asynchronous Input and Output
All the realtime functions defined in this volume of POSIX.1-2024 are portable, although some of the numeric
parameters used by an implementation may have hardware dependencies.
2.8.1 Realtime Signals
See 2.4.2 Realtime Signal Generation and Delivery.
2.8.2 Asynchronous I/O
An asynchronous I/O control block structure aiocb is used in many asynchronous I/O functions. It is defined
in the Base Definitions volume of POSIX.1-2024,  and has at least the
following members:
Member Type
Member Name
Description
int
aio_fildes
File descriptor.
off_t
aio_offset
File offset.
volatile void*
aio_buf
Location of buffer.
size_t
aio_nbytes
Length of transfer.
int
aio_reqprio
Request priority offset.
struct sigevent
aio_sigevent
Signal number and value.
int
aio_lio_opcode
Operation to be performed.
The aio_fildes element is the file descriptor on which the asynchronous operation is performed.
If O_APPEND is not set for the file descriptor aio_fildes and if aio_fildes is associated with a
device that is capable of seeking, then the requested operation takes place at the absolute position in the file as given by
aio_offset, as if lseek() were called immediately prior to the operation with
an offset argument equal to aio_offset and a whence argument equal to SEEK_SET. If O_APPEND is set for the
file descriptor, or if aio_fildes is associated with a device that is incapable of seeking, write operations append to the
file in the same order as the calls were made, with the following exception: under implementation-defined circumstances, such as
operation on a multi-processor or when requests of differing priorities are submitted at the same time, the ordering restriction
may be relaxed. Since there is no way for a strictly conforming application to determine whether this relaxation applies, all
strictly conforming applications which rely on ordering of output shall be written in such a way that they operate correctly if the
relaxation applies. After a successful call to enqueue an asynchronous I/O operation, the value of the file offset for the file is
unspecified. The aio_nbytes and aio_buf elements are the same as the nbyte and buf arguments defined by
read() and write(), respectively.
If _POSIX_PRIORITIZED_IO and _POSIX_PRIORITY_SCHEDULING are defined, then asynchronous I/O is queued in priority
order, with the priority of each asynchronous operation based on the current scheduling priority of the calling process. The
aio_reqprio member can be used to lower (but not raise) the asynchronous I/O operation priority and is within the range zero
through {AIO_PRIO_DELTA_MAX}, inclusive. Unless both _POSIX_PRIORITIZED_IO and _POSIX_PRIORITY_SCHEDULING are defined, the order of
processing asynchronous I/O requests is unspecified. When both _POSIX_PRIORITIZED_IO and _POSIX_PRIORITY_SCHEDULING are defined,
the order of processing of requests submitted by processes whose schedulers are not SCHED_FIFO, SCHED_RR, or SCHED_SPORADIC is
unspecified. The priority of an asynchronous request is computed as (process scheduling priority) minus aio_reqprio. The
priority assigned to each asynchronous I/O request is an indication of the desired order of execution of the request relative to
other asynchronous I/O requests for this file. If _POSIX_PRIORITIZED_IO is defined, requests issued with the same priority to a
character special file are processed by the underlying device in FIFO order; the order of processing of requests of the same
priority issued to files that are not character special files is unspecified. Numerically higher priority values indicate requests
of higher priority. The value of aio_reqprio has no effect on process scheduling priority. When prioritized asynchronous I/O
requests to the same file are blocked waiting for a resource required for that I/O operation, the higher-priority I/O requests
shall be granted the resource before lower-priority I/O requests are granted the resource. The relative priority of asynchronous
I/O and synchronous I/O is implementation-defined. If _POSIX_PRIORITIZED_IO is defined, the implementation shall define for which
files I/O prioritization is supported.
The aio_sigevent determines how the calling process shall be notified upon I/O completion, as specified in
2.4.1 Signal Generation and Delivery. If aio_sigevent.sigev_notify is SIGEV_NONE, then no
signal shall be posted upon I/O completion, but the error status for the operation and the return status for the operation shall be
set appropriately.
The aio_lio_opcode field is used only by the lio_listio()
call. The lio_listio() call allows multiple asynchronous I/O operations to be
submitted at a single time. The function takes as an argument an array of pointers to aiocb structures. Each aiocb
structure indicates the operation to be performed (read or write) via the aio_lio_opcode field.
The address of the aiocb structure is used as a handle for retrieving the error status and return status of
the asynchronous operation while it is in progress.
The aiocb structure and the data buffers associated with the asynchronous I/O operation are being used by
the system for asynchronous I/O while, and only while, the error status of the asynchronous operation is equal to [EINPROGRESS].
Applications shall not modify the aiocb structure while the structure is being used by the system for asynchronous I/O.
The return status of the asynchronous operation is the number of bytes transferred by the I/O operation. If the
error status is set to indicate an error completion, then the return status is set to the return value that the corresponding
read(), write(), or fsync() call would have returned. When the error status is not equal to [EINPROGRESS], the
return status shall reflect the return status of the corresponding synchronous operation.
2.8.3 Memory Management
2.8.3.1 Memory Locking
[MLR]  Range memory locking operations are defined in terms of pages. Implementations may restrict the size and alignment of
range lockings to be on page-size boundaries. The page size, in bytes, is the value of the configurable system variable {PAGESIZE}.
If an implementation has no restrictions on size or alignment, it may specify a 1-byte page size.
[ML|MLR]  Memory locking guarantees the residence of portions of the address space. It is implementation-defined
whether locking memory guarantees fixed translation between virtual addresses (as seen by the process) and physical addresses.
Per-process memory locks are not inherited across a fork(), and all memory locks owned
by a process are unlocked upon exec or process termination. Unmapping of an address
range removes any memory locks established on that address range by this process.
2.8.3.2 Memory Mapped Files
Range memory mapping operations are defined in terms of pages. Implementations may restrict the size and alignment
of range mappings to be on page-size boundaries. The page size, in bytes, is the value of the configurable system variable
{PAGESIZE}. If an implementation has no restrictions on size or alignment, it may specify a 1-byte page size.
Memory mapped files provide a mechanism that allows a process to access files by directly incorporating file data
into its address space. Once a file is mapped into a process address space, the data can be manipulated as memory. If more than one
process maps a file, its contents are shared among them. If the mappings allow shared write access, then data written into the
memory object through the address space of one process appears in the address spaces of all processes that similarly map the same
portion of the memory object.
[SHM]  Shared memory objects are named regions of storage that may be independent of the file system and can be mapped into
the address space of one or more processes to allow them to share the associated memory.
An unlink() of a file [SHM]   or shm_unlink() of a shared memory object,  while causing the removal of the name, does not unmap any mappings established for the object. Once the
name has been removed, the contents of the memory object are preserved as long as it is referenced. The memory object remains
referenced as long as a process has the memory object open or has some area of the memory object mapped.
2.8.3.3 Memory Protection
When an object is mapped, various application accesses to the mapped region may result in signals. In this context,
SIGBUS is used to indicate an error using the mapped object, and SIGSEGV is used to indicate a protection violation or misuse of an
address:
A mapping may be restricted to disallow some types of access.
Write attempts to memory that was mapped without write access, or any access to memory mapped PROT_NONE, shall
result in a SIGSEGV signal.
References to unmapped addresses shall result in a SIGSEGV signal.
Reference to whole pages within the mapping, but beyond the current length of the object, shall result in a SIGBUS
signal.
The size of the object is unaffected by access beyond the end of the object (even if a SIGBUS is not
generated).
2.8.3.4 Typed Memory Objects
[TYM]  The functionality described in this section shall be provided on implementations that support the Typed Memory Objects
option (and the rest of this section is not further marked for this option).
Implementations may support the Typed Memory Objects option independently of support for memory mapped files or
shared memory objects. Typed memory objects are implementation-configurable named storage pools accessible from one or more
processors in a system, each via one or more ports, such as backplane buses, LANs, I/O channels, and so on. Each valid combination
of a storage pool and a port is identified through a name that is defined at system configuration time, in an
implementation-defined manner; the name may be independent of the file system. Using this name, a typed memory object can be opened
and mapped into process address space. For a given storage pool and port, it is necessary to support both dynamic allocation from
the pool as well as mapping at an application-supplied offset within the pool; when dynamic allocation has been performed,
subsequent deallocation shall be supported. Lastly, accessing typed memory objects from different ports requires a method for
obtaining the offset and length of contiguous storage of a region of typed memory (dynamically allocated or not); this allows typed
memory to be shared among processes and/or processors while being accessed from the desired port.
2.8.4 Process Scheduling
[PS]  The functionality described in this section shall be provided on implementations that support the Process Scheduling
option (and the rest of this section is not further marked for this option).
Scheduling Policies
The scheduling semantics described in this volume of POSIX.1-2024 are defined in terms of a conceptual model that
contains a set of thread lists. No implementation structures are necessarily implied by the use of this conceptual model. It is
assumed that no time elapses during operations described using this model, and therefore no simultaneous operations are possible.
This model discusses only processor scheduling for runnable threads, but it should be noted that greatly enhanced predictability of
realtime applications results if the sequencing of other resources takes processor scheduling policy into account.
There is, conceptually, one thread list for each priority. A runnable thread shall be on the thread list for that
thread's priority. Multiple scheduling policies shall be provided. Each non-empty thread list is ordered, contains a head as one
end of its order, and a tail as the other. The purpose of a scheduling policy is to define the allowable operations on this set of
lists (for example, moving threads between and within lists).
The POSIX model treats a "process" as an aggregation of system resources, including one or more threads that may
be scheduled by the operating system on the processor(s) it controls. Although a process has its own set of scheduling attributes,
these have an indirect effect (if any) on the scheduling behavior of individual threads as described below.
Each thread shall be controlled by an associated scheduling policy and priority. These parameters may be specified
by explicit application execution of the pthread_setschedparam()
function. Additionally, the scheduling parameters of a thread (but not its scheduling policy) may be changed by application
execution of the pthread_setschedprio() function.
Each process shall be controlled by an associated scheduling policy and priority. These parameters may be specified
by explicit application execution of the sched_setscheduler() or sched_setparam() functions.
The effect of the process scheduling attributes on individual threads in the process is dependent on the scheduling
contention scope of the threads (see 2.9.4 Thread Scheduling):
For threads with system scheduling contention scope, the process scheduling attributes shall have no effect on the
scheduling attributes or behavior either of the thread or an underlying kernel scheduling entity dedicated to that thread.
For threads with process scheduling contention scope, the process scheduling attributes shall have no effect on
the scheduling attributes of the thread. However, any underlying kernel scheduling entity used by these threads shall at all times
behave as specified by the scheduling attributes of the containing process, and this behavior may affect the scheduling behavior of
the process contention scope threads. For example, a process contention scope thread with scheduling policy SCHED_FIFO and the
system maximum priority H (the value returned by sched_get_priority_max(SCHED_FIFO)) in a process with scheduling
policy SCHED_RR and system minimum priority L (the value returned by sched_get_priority_min(SCHED_RR)) shall be
subject to timeslicing and to preemption by any thread with an effective priority higher than L.
Associated with each policy is a priority range. Each policy definition shall specify the minimum priority range
for that policy. The priority ranges for each policy may but need not overlap the priority ranges of other policies.
A conforming implementation shall select the thread that is defined as being at the head of the highest priority
non-empty thread list to become a running thread, regardless of its associated policy. This thread is then removed from its thread
list.
Four scheduling policies are specifically required. Other implementation-defined scheduling policies may be
defined. The following symbols are defined in the Base Definitions volume of POSIX.1-2024, :
SCHED_FIFO
First in, first out (FIFO) scheduling policy.
SCHED_RR
Round robin scheduling policy.
SCHED_SPORADIC
[SS]
Sporadic server scheduling policy.
SCHED_OTHER
Another scheduling policy.
The values of these symbols shall be distinct.
SCHED_FIFO
Conforming implementations shall include a scheduling policy called the FIFO scheduling policy.
Threads scheduled under this policy are chosen from a thread list that is ordered by the time its threads have been
on the list without being executed; generally, the head of the list is the thread that has been on the list the longest time, and
the tail is the thread that has been on the list the shortest time.
Under the SCHED_FIFO policy, the modification of the definitional thread lists is as follows:
When a running thread becomes a preempted thread, it becomes the head of the thread list for its priority.
When a blocked thread becomes a runnable thread, it becomes the tail of the thread list for its priority.
When a running thread calls the sched_setscheduler()
function, the process specified in the function call is modified to the specified policy and the priority specified by the
param argument.
When a running thread calls the sched_setparam() function,
the priority of the process specified in the function call is modified to the priority specified by the param argument.
When a running thread calls the pthread_setschedparam() function, the thread specified in the function call is
modified to the specified policy and the priority specified by the param argument.
When a running thread calls the pthread_setschedprio()
function, the thread specified in the function call is modified to the priority specified by the prio argument.
If a thread whose policy or priority has been modified other than by pthread_setschedprio() is a running thread or is runnable, it then becomes the
tail of the thread list for its new priority.
If a thread whose priority has been modified by pthread_setschedprio() is a running thread or is runnable, the effect on its
position in the thread list depends on the direction of the modification, as follows:
If the priority is raised, the thread becomes the tail of the thread list.
If the priority is unchanged, the thread does not change position in the thread list.
If the priority is lowered, the thread becomes the head of the thread list.
When a running thread issues the sched_yield() or thrd_yield() function, the thread becomes the tail of the thread list for its
priority.
At no other time is the position of a thread with this scheduling policy within the thread lists affected.
While a thread is executing at a temporarily elevated priority as a consequence of owning a mutex initialized with
the PTHREAD_PRIO_INHERIT or PTHREAD_PRIO_PROTECT protocol (see pthread_mutexattr_getprotocol()), the effects of the above
requirements on thread priority shall apply only to the thread's normal priority, not to its elevated priority, and those of the
above requirements that describe the thread being placed on any thread list as a result of a priority change shall not apply.
Likewise, when such a thread reverts to its normal priority as a consequence of unlocking such a mutex, those of the above
requirements that describe the thread being placed on any thread list as a result of a priority change shall not apply.
For this policy, valid priorities shall be within the range returned by the sched_get_priority_max() and sched_get_priority_min() functions when SCHED_FIFO is provided as the
parameter. Conforming implementations shall provide a priority range of at least 32 priorities for this policy.
SCHED_RR
Conforming implementations shall include a scheduling policy called the "round robin" scheduling policy. This
policy shall be identical to the SCHED_FIFO policy with the additional condition that when the implementation detects that a
running thread has been executing as a running thread for a time period of the length returned by the sched_rr_get_interval() function or longer, the thread shall become the tail
of its thread list and the head of that thread list shall be removed and made a running thread.
The effect of this policy is to ensure that if there are multiple SCHED_RR threads at the same priority, one of
them does not monopolize the processor. An application should not rely only on the use of SCHED_RR to ensure application progress
among multiple threads if the application includes threads using the SCHED_FIFO policy at the same or higher priority levels or
SCHED_RR threads at a higher priority level.
A thread under this policy that is preempted and subsequently resumes execution as a running thread completes the
unexpired portion of its round robin interval time period.
For this policy, valid priorities shall be within the range returned by the sched_get_priority_max() and sched_get_priority_min() functions when SCHED_RR is provided as the
parameter. Conforming implementations shall provide a priority range of at least 32 priorities for this policy.
SCHED_SPORADIC
[SS|TSP]  The functionality described in this section shall be provided on implementations that support the
Process Sporadic Server or Thread Sporadic Server options (and the rest of this section is not further marked for these options).
If _POSIX_SPORADIC_SERVER or _POSIX_THREAD_SPORADIC_SERVER is defined, the implementation shall include a
scheduling policy identified by the value SCHED_SPORADIC.
The sporadic server policy is based primarily on two time parameters: the replenishment period and the available
execution capacity. The replenishment period is given by the sched_ss_repl_period member of the sched_param
structure. The available execution capacity is initialized to the value given by the sched_ss_init_budget member of the same
parameter. The sporadic server policy is identical to the SCHED_FIFO policy with some additional conditions that cause the thread's
assigned priority to be switched between the values specified by the sched_priority and sched_ss_low_priority members
of the sched_param structure.
The priority assigned to a thread using the sporadic server scheduling policy is determined in the following
manner: if the available execution capacity is greater than zero and the number of pending replenishment operations is strictly
less than sched_ss_max_repl, the thread is assigned the priority specified by sched_priority; otherwise, the assigned
priority shall be sched_ss_low_priority. If the value of sched_priority is less than or equal to the value of
sched_ss_low_priority, the results are undefined. When active, the thread shall belong to the thread list corresponding to
its assigned priority level, according to the mentioned priority assignment. The modification of the available execution capacity
and, consequently of the assigned priority, is done as follows:
When the thread at the head of the sched_priority list becomes a running thread, its execution time shall
be limited to at most its available execution capacity, plus the resolution of the execution time clock used for this scheduling
policy. This resolution shall be implementation-defined.
Each time the thread is inserted at the tail of the list associated with sched_priority—because as a
blocked thread it became runnable with priority sched_priority or because a replenishment operation was performed—the time
at which this operation is done is posted as the activation_time.
When the running thread with assigned priority equal to sched_priority becomes a preempted thread, it
becomes the head of the thread list for its priority, and the execution time consumed is subtracted from the available execution
capacity. If the available execution capacity would become negative by this operation, it shall be set to zero.
When the running thread with assigned priority equal to sched_priority becomes a blocked thread, the
execution time consumed is subtracted from the available execution capacity, and a replenishment operation is scheduled, as
described in 6 and 7. If the available execution capacity would become negative by this operation, it shall be set to zero.
When the running thread with assigned priority equal to sched_priority reaches the limit imposed on its
execution time, it becomes the tail of the thread list for sched_ss_low_priority, the execution time consumed is subtracted
from the available execution capacity (which becomes zero), and a replenishment operation is scheduled, as described in 6 and
7.
Each time a replenishment operation is scheduled, the amount of execution capacity to be replenished,
replenish_amount, is set equal to the execution time consumed by the thread since the activation_time. The
replenishment is scheduled to occur at activation_time plus sched_ss_repl_period. If the scheduled time obtained is
before the current time, the replenishment operation is carried out immediately. Several replenishment operations can be pending at
the same time, each of which shall be serviced at its respective scheduled time. With the above rules, the number of replenishment
operations simultaneously pending for a given thread that is scheduled under the sporadic server policy shall not be greater than
sched_ss_max_repl.
A replenishment operation consists of adding the corresponding replenish_amount to the available execution
capacity at the scheduled time. If, as a consequence of this operation, the execution capacity would become larger than
sched_ss_initial_budget, it shall be rounded down to a value equal to sched_ss_initial_budget. Additionally, if the
thread was runnable or running, and had assigned priority equal to sched_ss_low_priority, then it becomes the tail of the
thread list for sched_priority.
Execution time is defined in XBD 3.90 CPU Time (Execution
Time).
For this policy, changing the value of a CPU-time clock via clock_settime() shall have no effect on its behavior.
For this policy, valid priorities shall be within the range returned by the sched_get_priority_min() and sched_get_priority_max() functions when SCHED_SPORADIC is provided as the
parameter. Conforming implementations shall provide a priority range of at least 32 distinct priorities for this policy.
If the scheduling policy of the target process is either SCHED_FIFO or SCHED_RR, the sched_ss_low_priority,
sched_ss_repl_period, and sched_ss_init budget members of the param argument shall have no effect on the
scheduling behavior. If the scheduling policy of this process is not SCHED_FIFO, SCHED_RR, or SCHED_SPORADIC, the effects of these
members are implementation-defined; this case includes the SCHED_OTHER policy.
SCHED_OTHER
Conforming implementations shall include one scheduling policy identified as SCHED_OTHER (which may execute
identically with either the FIFO or round robin scheduling policy). The effect of scheduling threads with the SCHED_OTHER policy in
a system in which other threads are executing under SCHED_FIFO, SCHED_RR, [SS]
or SCHED_SPORADIC  is implementation-defined.
This policy is defined to allow strictly conforming applications to be able to indicate in a portable manner that
they no longer need a realtime scheduling policy.
For threads executing under this policy, the implementation shall use only priorities within the range returned by
the sched_get_priority_max() and sched_get_priority_min() functions when SCHED_OTHER is provided as the
parameter.
2.8.5 Clocks and Timers
The  header defines the types and manifest constants
used by the timing facility.
Time Value Specification Structures
Many of the timing facility functions accept or return time value specifications. A time value structure
timespec specifies a single time value and includes at least the following members:
Member Type
Member Name
Description
time_t
tv_sec
Seconds.
long
tv_nsec
Nanoseconds.
The tv_nsec member is only valid if greater than or equal to zero, and less than the number of nanoseconds
in a second (1000 million). The time interval described by this structure is (tv_sec * 109 +
tv_nsec) nanoseconds.
A time value structure itimerspec specifies an initial timer value and a repetition interval for use by the
per-process timer functions. This structure includes at least the following members:
Member Type
Member Name
Description
struct timespec
it_interval
Timer period.
struct timespec
it_value
Timer expiration.
If the value described by it_value is non-zero, it indicates the time to or time of the next timer
expiration (for relative and absolute timer values, respectively). If the value described by it_value is zero, the timer
shall be disarmed.
If the value described by it_interval is non-zero, it specifies an interval which shall be used in reloading
the timer when it expires; that is, a periodic timer is specified. If the value described by it_interval is zero, the timer
is disarmed after its next expiration; that is, a one-shot timer is specified.
Timer Event Notification Control Block
Per-process timers may be created that notify the process of timer expirations by queuing a realtime extended
signal. The sigevent structure, defined in the Base Definitions volume of POSIX.1-2024, , is used in creating such a timer. The sigevent structure contains
the signal number and an application-specific data value which shall be used when notifying the calling process of timer expiration
events.
Manifest Constants
The following constants are defined in the Base Definitions volume of POSIX.1-2024, :
CLOCK_REALTIME
The identifier for the system-wide realtime clock.
TIMER_ABSTIME
Flag indicating time is absolute with respect to the clock associated with a timer.
CLOCK_MONOTONIC
The identifier for the system-wide monotonic clock, which is defined as a clock whose value cannot be set via clock_settime() and which cannot have backward clock jumps. The maximum possible clock
jump is implementation-defined.
The maximum allowable resolution for CLOCK_REALTIME and CLOCK_MONOTONIC clocks and all time services based on these
clocks is represented by {_POSIX_CLOCKRES_MIN} and shall be defined as 20 ms (1/50 of a second). Implementations may support
smaller values of resolution for these clocks to provide finer granularity time bases. The actual resolution supported by an
implementation for a specific clock is obtained using the clock_getres()
function. If the actual resolution supported for a time service based on one of these clocks differs from the resolution supported
for that clock, the implementation shall document this difference.
The minimum allowable maximum value for CLOCK_REALTIME and CLOCK_MONOTONIC clocks and all absolute time services
based on them is the same as that defined by the ISO C standard for the time_t type. If the maximum value supported by
a time service based on one of these clocks differs from the maximum value supported by that clock, the implementation shall
document this difference.
Execution Time Monitoring
[CPT]  If _POSIX_CPUTIME is defined, process CPU-time clocks shall be supported in addition to the clocks described in
Manifest Constants.
[TCT]  If _POSIX_THREAD_CPUTIME is defined, thread CPU-time clocks shall be supported.
[CPT|TCT]  CPU-time clocks measure execution or CPU time, which is defined in XBD 3.90 CPU Time (Execution Time). The mechanism used to measure execution time is
described in XBD 4.14 Measurement of Execution Time.
[CPT]  If _POSIX_CPUTIME is defined, the following constant of the type clockid_t is defined in :
CLOCK_PROCESS_CPUTIME_ID
When this value of the type clockid_t is used in a clock() or timer*()
function call, it is interpreted as the identifier of the CPU-time clock associated with the process making the function call.
[TCT]  If _POSIX_THREAD_CPUTIME is defined, the following constant of the type clockid_t is defined in :
CLOCK_THREAD_CPUTIME_ID
When this value of the type clockid_t is used in a clock() or timer*()
function call, it is interpreted as the identifier of the CPU-time clock associated with the thread making the function call.
2.9 Threads
This section defines functionality to support multiple flows of control, called "threads", within a process. For
the definition of threads, see XBD 3.388 Thread.
The specific functional areas covered by threads and their scope include:
Thread management: the creation, control, and termination of multiple flows of control in the same process under
the assumption of a common shared address space
Synchronization primitives optimized for tightly coupled operation of multiple control flows in a common, shared
address space
2.9.1 Thread-Safety
All functions defined by this volume of POSIX.1-2024 shall be thread-safe, except that the following
functions1 need not be thread-safe.
asctime()
atomic_init()
catgets()
crypt()
ctime()
dbm_clearerr()
dbm_close()
dbm_delete()
dbm_error()
dbm_fetch()
dbm_firstkey()
dbm_nextkey()
dbm_open()
dbm_store()
dlerror()
drand48()
encrypt()
endgrent()
endpwent()
endutxent()
getdate()
getgrent()
getgrgid()
getgrnam()
gethostent()
getlogin()
getnetbyaddr()
getnetbyname()
getnetent()
getopt()
getprotobyname()
getprotobynumber()
getprotoent()
getpwent()
getpwnam()
getpwuid()
getservbyname()
getservbyport()
getservent()
getutxent()
getutxid()
getutxline()
gmtime()
hcreate()
hdestroy()
hsearch()
inet_ntoa()
l64a()
localeconv()
localtime()
lrand48()
mblen()
mbtowc()
mrand48()
nftw()
nl_langinfo()
ptsname()
putenv()
pututxline()
rand()
setenv()
setgrent()
setkey()
setlocale()
setpwent()
setutxent()
srand()
strerror()
strsignal()
strtok()
ttyname()
unsetenv()
wctomb()
The ctermid() and tmpnam() functions need not be thread-safe if passed a null pointer argument. The c16rtomb(), c32rtomb(), mbrlen(), mbrtoc16(), mbrtoc32(), mbrtowc(), mbsnrtowcs(), mbsrtowcs(), wcrtomb(), wcsnrtombs(), and wcsrtombs() functions need not be thread-safe if passed a null ps argument. The
lgamma(), lgammaf(), and lgammal() functions shall be thread-safe [XSI]  except that they
need not avoid data races when storing a value in the signgam variable.  The getc_unlocked(), getchar_unlocked(), putc_unlocked(), and putchar_unlocked() functions need not be thread-safe unless the invoking thread
owns the (FILE *) object accessed by the call, as is the case after a successful call to the flockfile() or ftrylockfile()
functions. The readdir() function need not be thread-safe if concurrent calls are
made for the same directory stream.
Some functions that are not required to be thread-safe are nevertheless required to avoid data races with either
all or some other functions, as specified on their individual reference pages.
Implementations shall provide internal synchronization as necessary in order to satisfy thread-safety
requirements.
Since multi-threaded applications are not allowed to use the environ variable to access or modify any
environment variable while any other thread is concurrently modifying any environment variable, the getenv() and secure_getenv() functions
and any function dependent on any environment variable are not thread-safe if another thread modifies the environment; see XSH
exec.
2.9.2 Thread IDs
Although implementations may have thread IDs that are unique in a system, applications should only assume that
thread IDs are usable and unique within a single process. The effect of calling any of the functions defined in this volume of
POSIX.1-2024 and passing as an argument the thread ID of a thread from another process is unspecified. The lifetime of a thread ID
ends after the later of thread termination (see 3.392 Thread Termination
) and the point when the thread is no longer joinable (see 3.183 Joinable
Thread). A conforming implementation is free to reuse a thread ID after its lifetime has ended. If an application attempts
to use a thread ID whose lifetime has ended, the behavior is undefined.
If a thread is detached, its thread ID is invalid for use as an argument in a call to pthread_detach(), pthread_join(),
thrd_detach(), or thrd_join().
2.9.3 Thread Mutexes
A thread that has blocked shall not prevent any unblocked thread that is eligible to use the same processing
resources from eventually making forward progress in its execution. Eligibility for processing resources is determined by the
scheduling policy.
A thread shall become the owner of a mutex, m, of type pthread_mutex_t when one of the following
occurs:
It calls pthread_mutex_clocklock(), pthread_mutex_lock(), pthread_mutex_timedlock(), or pthread_mutex_trylock() with m as the mutex argument and the
call returns zero or [EOWNERDEAD].
It calls pthread_mutex_setprioceiling() with
m as the mutex argument and the call returns [EOWNERDEAD].
It calls pthread_cond_clockwait(), pthread_cond_timedwait(), or pthread_cond_wait() with m as the mutex argument and the call
returns zero or certain error numbers (see pthread_cond_clockwait()
).
The thread shall remain the owner of m until one of the following occurs:
It executes pthread_mutex_unlock() with m as
the mutex argument
It blocks in a call to pthread_cond_clockwait(),
pthread_cond_timedwait(), or pthread_cond_wait() with m as the mutex argument.
A thread shall become the owner of a mutex, m, of type mtx_t when one of the following occurs:
It calls mtx_lock() with m as the mtx argument and
the call returns thrd_success.
It calls mtx_trylock() with m as the mtx argument
and the call returns thrd_success.
It calls mtx_timedlock() with m as the mtx
argument and the call returns thrd_success.
It calls cnd_wait() with m as the mtx argument and
the call returns thrd_success.
It calls cnd_timedwait() with m as the mtx
argument and the call returns thrd_success or thrd_timedout.
The thread shall remain the owner of m until one of the following occurs:
It executes mtx_unlock() with m as the mtx
argument.
It blocks in a call to cnd_wait() with m as the mtx
argument.
It blocks in a call to cnd_timedwait() with m as the
mtx argument.
The implementation shall behave as if at all times there is at most one owner of any mutex.
A thread that becomes the owner of a mutex is said to have "acquired" the mutex and the mutex is said to have
become "locked"; when a thread gives up ownership of a mutex it is said to have "released" the mutex and the mutex is said to
have become "unlocked".
A problem can occur if a process terminates while one of its threads holds a mutex lock. Depending on the mutex
type, it might be possible for another thread to unlock the mutex and recover the state of the mutex. However, it is difficult to
perform this recovery reliably.
Robust mutexes provide a means to enable the implementation to notify other threads in the event of a process
terminating while one of its threads holds a lock on a mutex of type pthread_mutex_t. The next thread that acquires the
mutex is notified about the termination by the return value [EOWNERDEAD] from the locking function. The notified thread can then
attempt to recover the state protected by the mutex, and if successful mark the state protected by the mutex as consistent by a
call to pthread_mutex_consistent(). If the notified thread is
unable to recover the state, it can declare the state as not recoverable by a call to pthread_mutex_unlock() without a prior call to pthread_mutex_consistent().
Whether or not the state protected by a mutex can be recovered is dependent solely on the application using robust
mutexes. The robust mutex support provided in the implementation provides notification only that a mutex owner has terminated while
holding a lock, or that the state of the mutex is not recoverable.
2.9.4 Thread Scheduling
[TPS]  The functionality described in this section shall be provided on implementations that support the Thread Execution
Scheduling option (and the rest of this section is not further marked for this option).
Thread Scheduling Attributes
In support of the scheduling function, threads have attributes which are accessed through the pthread_attr_t
thread creation attributes object.
The contentionscope attribute defines the scheduling contention scope of the thread to be either
PTHREAD_SCOPE_PROCESS or PTHREAD_SCOPE_SYSTEM.
The inheritsched attribute specifies whether a newly created thread is to inherit the scheduling attributes
of the creating thread or to have its scheduling values set according to the other scheduling attributes in the
pthread_attr_t object.
The schedpolicy attribute defines the scheduling policy for the thread. The schedparam attribute
defines the scheduling parameters for the thread. The interaction of threads having different policies within a process is
described as part of the definition of those policies.
If the Thread Execution Scheduling option is defined, and the schedpolicy attribute specifies one of the
priority-based policies defined under this option, the schedparam attribute contains the scheduling priority of the thread.
A conforming implementation ensures that the priority value in schedparam is in the range associated with the scheduling
policy when the thread attributes object is used to create a thread, or when the scheduling attributes of a thread are dynamically
modified. The meaning of the priority value in schedparam is the same as that of priority.
[TSP]  If _POSIX_THREAD_SPORADIC_SERVER is defined, the schedparam attribute supports four new members that are used
for the sporadic server scheduling policy. These members are sched_ss_low_priority, sched_ss_repl_period,
sched_ss_init_budget, and sched_ss_max_repl. The meaning of these attributes is the same as in the definitions that
appear under 2.8.4 Process Scheduling.
When a process is created, its single thread has a scheduling policy and associated attributes equal to the policy
and attributes of the process. The default scheduling contention scope value is implementation-defined. The default values of other
scheduling attributes are implementation-defined.
Thread Scheduling Contention Scope
The scheduling contention scope of a thread defines the set of threads with which the thread competes for use of
the processing resources. The scheduling operation selects at most one thread to execute on each processor at any point in time and
the thread's scheduling attributes (for example, priority), whether under process scheduling contention scope or system
scheduling contention scope, are the parameters used to determine the scheduling decision.
The scheduling contention scope, in the context of scheduling a mixed scope environment, affects threads as
follows:
A thread created with PTHREAD_SCOPE_SYSTEM scheduling contention scope contends for resources with all other
threads in the same scheduling allocation domain relative to their system scheduling attributes. The system scheduling attributes
of a thread created with PTHREAD_SCOPE_SYSTEM scheduling contention scope are the scheduling attributes with which the thread was
created. The system scheduling attributes of a thread created with PTHREAD_SCOPE_PROCESS scheduling contention scope are the
implementation-defined mapping into system attribute space of the scheduling attributes with which the thread was created.
Threads created with PTHREAD_SCOPE_PROCESS scheduling contention scope contend directly with other threads within
their process that were created with PTHREAD_SCOPE_PROCESS scheduling contention scope. The contention is resolved based on the
threads' scheduling attributes and policies. It is unspecified how such threads are scheduled relative to threads in other
processes or threads with PTHREAD_SCOPE_SYSTEM scheduling contention scope.
Conforming implementations shall support the PTHREAD_SCOPE_PROCESS scheduling contention scope, the
PTHREAD_SCOPE_SYSTEM scheduling contention scope, or both.
Scheduling Allocation Domain
Implementations shall support scheduling allocation domains containing one or more processors. It should be noted
that the presence of multiple processors does not automatically indicate a scheduling allocation domain size greater than one.
Conforming implementations on multi-processors may map all or any subset of the CPUs to one or multiple scheduling allocation
domains, and could define these scheduling allocation domains on a per-thread, per-process, or per-system basis, depending on the
types of applications intended to be supported by the implementation. The scheduling allocation domain is independent of scheduling
contention scope, as the scheduling contention scope merely defines the set of threads with which a thread contends for processor
resources, while scheduling allocation domain defines the set of processors for which it contends. The semantics of how this
contention is resolved among threads for processors is determined by the scheduling policies of the threads.
The choice of scheduling allocation domain size and the level of application control over scheduling allocation
domains is implementation-defined. Conforming implementations may change the size of scheduling allocation domains and the binding
of threads to scheduling allocation domains at any time.
For application threads with scheduling allocation domains of size equal to one, the scheduling rules defined for
SCHED_FIFO and SCHED_RR shall be used; see Scheduling Policies. All threads with system scheduling
contention scope, regardless of the processes in which they reside, compete for the processor according to their priorities.
Threads with process scheduling contention scope compete only with other threads with process scheduling contention scope within
their process.
For application threads with scheduling allocation domains of size greater than one, the rules defined for
SCHED_FIFO, SCHED_RR, [TSP]   and SCHED_SPORADIC  shall be used
in an implementation-defined manner. Each thread with system scheduling contention scope competes for the processors in its
scheduling allocation domain in an implementation-defined manner according to its priority. Threads with process scheduling
contention scope are scheduled relative to other threads within the same scheduling contention scope in the process.
[TSP]  If _POSIX_THREAD_SPORADIC_SERVER is defined, the rules defined for SCHED_SPORADIC in Scheduling Policies shall be used in an implementation-defined manner for application threads whose
scheduling allocation domain size is greater than one.
Scheduling Documentation
If _POSIX_PRIORITY_SCHEDULING is defined, then any scheduling policies beyond SCHED_OTHER, SCHED_FIFO, SCHED_RR,
[TSP]
and SCHED_SPORADIC,  as well as the effects of the scheduling
policies indicated by these other values, and the attributes required in order to support such a policy, are
implementation-defined. Furthermore, the implementation shall document the effect of all processor scheduling allocation domain
values supported for these policies.
2.9.5 Thread Cancellation
The thread cancellation mechanism allows a thread to terminate the execution of any other thread in the process,
except for threads created using thrd_create(), in a controlled manner. The
target thread (that is, the one that is being canceled) is allowed to hold cancellation requests pending in a number of ways and to
perform application-specific cleanup processing when the notice of cancellation is acted upon.
Cancellation is controlled by the cancellation control functions. Each thread maintains its own cancelability
state. Cancellation may only occur at cancellation points or when the thread is asynchronously cancelable.
The thread cancellation mechanism described in this section depends upon programs having set deferred
cancelability state, which is specified as the default. Applications shall also carefully follow static lexical scoping rules in
their execution behavior. For example, use of setjmp(), return, goto,
and so on, to leave user-defined cancellation scopes without doing the necessary scope pop operation results in undefined
behavior.
Use of asynchronous cancelability while holding resources which potentially need to be released may result in
resource loss. Similarly, cancellation scopes may only be safely manipulated (pushed and popped) when the thread is in the
deferred or disabled cancelability states.
2.9.5.1 Cancelability States
The cancelability state of a thread determines the action taken upon receipt of a cancellation request. The thread
may control cancellation in a number of ways.
Each thread maintains its own cancelability state, which may be encoded in two bits:
Cancelability-Enable: When cancelability is PTHREAD_CANCEL_DISABLE (as defined in the Base Definitions volume of
POSIX.1-2024, ), cancellation requests against the target thread
are held pending. By default, cancelability is set to PTHREAD_CANCEL_ENABLE (as defined in ).
Cancelability Type: When cancelability is enabled and the cancelability type is PTHREAD_CANCEL_ASYNCHRONOUS (as
defined in ), new or pending cancellation requests may be acted
upon at any time. When cancelability is enabled and the cancelability type is PTHREAD_CANCEL_DEFERRED (as defined in ), cancellation requests are held pending until a cancellation point (see
below) is reached. If cancelability is disabled, the setting of the cancelability type has no immediate effect as all cancellation
requests are held pending; however, once cancelability is enabled again the new type is in effect. The cancelability type is
PTHREAD_CANCEL_DEFERRED in all newly created threads including the thread in which main() was first invoked.
2.9.5.2 Cancellation Points
Cancellation points shall occur when a thread is executing the following functions:
accept()
accept4()
aio_suspend()
clock_nanosleep()
close()
cnd_timedwait()
cnd_wait()
connect()
creat()
fcntl()†
fdatasync()
fsync()
lockf()††
mq_receive()
mq_send()
mq_timedreceive()
mq_timedsend()
msgrcv()
msgsnd()
msync()
nanosleep()
open()
openat()
pause()
poll()
posix_close()
ppoll()
pread()
pselect()
pthread_cond_clockwait()
pthread_cond_timedwait()
pthread_cond_wait()
pthread_join()
pthread_testcancel()
pwrite()
read()
readv()
recv()
recvfrom()
recvmsg()
select()
send()
sendmsg()
sendto()
sigsuspend()
sigtimedwait()
sigwait()
sigwaitinfo()
sleep()
tcdrain()
thrd_join()
thrd_sleep()
wait()
waitid()
waitpid()
write()
writev()
A cancellation point may also occur when a thread is executing the following functions:
access()
bindtextdomain()
catclose()
catopen()
chmod()
chown()
closedir()
closelog()
ctermid()
dcgettext()
dcgettext_l()
dcngettext()
dcngettext_l()
dgettext()
dgettext_l()
dlclose()
dlopen()
dngettext()
dngettext_l()
dprintf()
endhostent()
endnetent()
endprotoent()
endservent()
faccessat()
fchmod()
fchmodat()
fchown()
fchownat()
fclose()
fcntl()†††
fflush()
fgetc()
fgetpos()
fgets()
fgetwc()
fgetws()
fmtmsg()
fopen()
fpathconf()
fprintf()
fputc()
fputs()
fputwc()
fputws()
fread()
freopen()
fscanf()
fseek()
fseeko()
fsetpos()
fstat()
fstatat()
ftell()
ftello()
futimens()
fwprintf()
fwrite()
fwscanf()
getaddrinfo()
getc()
getc_unlocked()
getchar()
getchar_unlocked()
getcwd()
getdelim()
getgrgid_r()
getgrnam_r()
gethostid()
gethostname()
getline()
getlogin_r()
getnameinfo()
getpwnam_r()
getpwuid_r()
gettext()
gettext_l()
getwc()
getwchar()
glob()
iconv_close()
iconv_open()
link()
linkat()
lio_listio()
localtime_r()
lockf()
lseek()
lstat()
mkdir()
mkdirat()
mkdtemp()
mkfifo()
mkfifoat()
mknod()
mknodat()
mkstemp()
mktime()
ngettext()
ngettext_l()
opendir()
openlog()
pathconf()
perror()
popen()
posix_devctl()
posix_fadvise()
posix_fallocate()
posix_getdents()
posix_madvise()
posix_openpt()
posix_spawn()
posix_spawnp()
posix_typed_mem_open()
printf()
psiginfo()
psignal()
pthread_rwlock_clockrdlock()
pthread_rwlock_clockwrlock()
pthread_rwlock_rdlock()
pthread_rwlock_timedrdlock()
pthread_rwlock_timedwrlock()
pthread_rwlock_wrlock()
ptsname()
ptsname_r()
putc()
putc_unlocked()
putchar()
putchar_unlocked()
puts()
putwc()
putwchar()
readdir_r()
readlink()
readlinkat()
remove()
rename()
renameat()
rewind()
rewinddir()
scandir()
scanf()
seekdir()
sem_clockwait()
sem_timedwait()
sem_wait()
semop()
sethostent()
setnetent()
setprotoent()
setservent()
stat()
strerror_l()
strerror_r()
strftime()
strftime_l()
symlink()
symlinkat()
sync()
syslog()
tmpfile()
tmpnam()
ttyname_r()
tzset()
ungetc()
ungetwc()
unlink()
unlinkat()
utimensat()
utimes()
vdprintf()
vfprintf()
vfwprintf()
vprintf()
vwprintf()
wcsftime()
wordexp()
wprintf()
wscanf()
In addition, a cancellation point may occur when a thread is executing any function that this standard does not
require to be thread-safe but the implementation documents as being thread-safe. If a thread is cancelled while executing a
non-thread-safe function, the behavior is undefined.
An implementation shall not introduce cancellation points into any other functions specified in this volume of
POSIX.1-2024.
The side-effects of acting upon a cancellation request while suspended during a call of a function are the same as
the side-effects that may be seen in a single-threaded program when a call to a function is interrupted by a signal and the given
function returns [EINTR]. Any such side-effects occur before any cancellation cleanup handlers are called. For functions that are
explicitly required not to return when interrupted (for example, pclose()), if a
thread is canceled while executing the function, the behavior is undefined.
Whenever a thread has cancelability enabled and a cancellation request has been made with that thread as the
target, and the thread then calls any function that is a cancellation point (such as pthread_testcancel() or read()), the
cancellation request shall be acted upon before the function returns. If a thread has cancelability enabled and a cancellation
request is made with the thread as a target while the thread is suspended at a cancellation point, the thread shall be awakened and
the cancellation request shall be acted upon. It is unspecified whether the cancellation request is acted upon or whether the
cancellation request remains pending and the thread resumes normal execution if the thread is suspended at a cancellation point and
either:
The event for which it is waiting occurs
A specified timeout expires
before the cancellation request is acted upon.
2.9.5.3 Thread Cancellation Cleanup Handlers
Each thread that was not created using thrd_create() maintains a
list of cancellation cleanup handlers. The programmer uses the pthread_cleanup_push() and pthread_cleanup_pop() functions to place routines on and remove routines from
this list.
When a cancellation request is acted upon, or when a thread calls pthread_exit(), the thread first disables cancellation by setting its cancelability
state to PTHREAD_CANCEL_DISABLE and its cancelability type to PTHREAD_CANCEL_DEFERRED. The cancelability state shall remain set to
PTHREAD_CANCEL_DISABLE until the thread has terminated. The behavior is undefined if a cancellation cleanup handler or
thread-specific data destructor routine changes the cancelability state to PTHREAD_CANCEL_ENABLE.
The routines in the thread's list of cancellation cleanup handlers shall be invoked one by one in LIFO sequence;
that is, the last routine pushed onto the list (Last In) is the first to be invoked (First Out). When the cancellation cleanup
handler for a scope is invoked, the storage for that scope remains valid. If the last cancellation cleanup handler returns,
thread-specific data destructors (if any) associated with thread-specific data keys for which the thread has non-NULL values shall
be run, in unspecified order, as described for pthread_key_create() and
tss_create().
After all cancellation cleanup handlers and thread-specific data destructors have returned, thread execution is
terminated. If the thread has terminated because of a call to pthread_exit(),
the value_ptr argument is made available to any threads joining with the target. If the thread has terminated by acting on a
cancellation request, a status of PTHREAD_CANCELED is made available to any threads joining with the target. The symbolic constant
PTHREAD_CANCELED expands to a constant expression of type (void *) whose value matches no pointer to an object in memory nor
the value NULL.
A side-effect of acting upon a cancellation request while in a condition variable wait is that the mutex is
re-acquired before calling the first cancellation cleanup handler. In addition, the thread is no longer considered to be waiting
for the condition and the thread shall not have consumed any pending condition signals on the condition.
A cancellation cleanup handler cannot exit via longjmp() or siglongjmp().
2.9.5.4 Async-Cancel Safety
The pthread_cancel(), pthread_setcancelstate(), and pthread_setcanceltype() functions are defined to be async-cancel safe.
No other functions in this volume of POSIX.1-2024 are required to be async-cancel-safe.
If a thread has asynchronous cancellation enabled and is cancelled during execution of a function that is not
async-cancel-safe, the behavior is undefined.
If a thread has deferred cancellation enabled, a signal-catching function is called in that thread during execution
of a function that is not async-cancel-safe, and the signal-catching function calls any function that is a cancellation point while
a cancellation is pending for the thread, without first disabling cancellation, the behavior is undefined.
2.9.6 Thread Read-Write Locks
Multiple readers, single writer (read-write) locks allow many threads to have simultaneous read-only access to data
while allowing only one thread to have exclusive write access at any given time. They are typically used to protect data that is
read more frequently than it is changed.
One or more readers acquire read access to the resource by performing a read lock operation on the associated
read-write lock. A writer acquires exclusive write access by performing a write lock operation. Basically, all readers exclude any
writers and a writer excludes all readers and any other writers.
A thread that has blocked on a read-write lock (for example, has not yet returned from a pthread_rwlock_rdlock() or pthread_rwlock_wrlock() call) shall not prevent any unblocked thread that is
eligible to use the same processing resources from eventually making forward progress in its execution. Eligibility for processing
resources shall be determined by the scheduling policy.
Read-write locks can be used to synchronize threads in the current process and other processes if they are
allocated in memory that is writable and shared among the cooperating processes and have been initialized for this behavior.
2.9.7 Thread Interactions with File Operations
All of the following functions shall be atomic with respect to each other in the effects specified in POSIX.1-2024
when they operate on files in the file hierarchy:
chmod()
chown()
creat()
fchmod()
fchmodat()
fchown()
fchownat()
fstat()
fstatat()
ftruncate()
futimens()
lchown()
link()
linkat()
lstat()
open()
openat()
readlink()
readlinkat()
rename()
renameat()
stat()
symlink()
symlinkat()
truncate()
unlink()
unlinkat()
utimensat()
utimes()
If two threads each call one of these functions, each call shall either see all of the specified effects of the
other call, or none of them.
Except where specified otherwise, all of the following functions shall be atomic with respect to each other in the
effects specified in POSIX.1-2024 when they operate on file descriptors that are open, or being opened, to files in the file
hierarchy:
close()
dup2()
dup3()
fcntl()
fstat()
fstatat()
ftruncate()
futimens()
lseek()
open()
openat()
pread()
read()
readv()
pwrite()
write()
writev()
If two threads each call one of these functions, each call shall either see all of the specified effects of the
other call, or none of them. The requirement on the close() function shall also apply
whenever a file descriptor is successfully closed, however caused (for example, as a consequence of calling close(), calling dup2(), or of process
termination).
2.9.8 Use of Application-Managed Thread Stacks
An "application-managed thread stack" is a region of memory allocated by the application—for example, memory
returned by the malloc() or mmap()
functions—and designated as a stack through the act of passing the address and size of the stack, respectively, as the
stackaddr and stacksize arguments to pthread_attr_setstack(). Application-managed stacks allow the application to
precisely control the placement and size of a stack.
The application grants to the implementation permanent ownership of and control over the application-managed stack
when the attributes object in which the stack or stackaddr attribute has been set is used, either by presenting that
attribute's object as the attr argument in a call to pthread_create()
that completes successfully, or by storing a pointer to the attributes object in the sigev_notify_attributes member of a
struct sigevent and passing that struct sigevent to a function accepting such argument that completes successfully.
The application may thereafter utilize the memory within the stack only within the normal context of stack usage within or properly
synchronized with a thread that has been scheduled by the implementation with stack pointer value(s) that are within the range of
that stack. In particular, the region of memory cannot be freed, nor can it be later specified as the stack for another thread.
When specifying an attributes object with an application-managed stack through the sigev_notify_attributes
member of a struct sigevent, the results are undefined if the requested signal is generated multiple times (as for a
repeating timer).
Until an attributes object in which the stack or stackaddr attribute has been set is used, the
application retains ownership of and control over the memory allocated to the stack. It may free or reuse the memory as long as it
either deletes the attributes object, or before using the attributes object replaces the stack by making an additional call to
pthread_attr_setstack(), that was used originally to designate the
stack. There is no mechanism to retract the reference to an application-managed stack by an existing attributes object.
Once an attributes object with an application-managed stack has been used, that attributes object cannot be used
again by a subsequent call to pthread_create() or any function accepting a
struct sigevent with sigev_notify_attributes containing a pointer to the attributes object, without designating an
unused application-managed stack by making an additional call to pthread_attr_setstack().
2.9.9 Synchronization Object Copies and Alternative Mappings
For barriers, condition variables, mutexes, and read-write locks, [TSH]   if the
process-shared attribute is set to PTHREAD_PROCESS_PRIVATE,
only the synchronization object at the address used to initialize it can be used for performing synchronization. The effect
of referring to another mapping of the same object when locking, unlocking, or destroying the object is undefined. [TSH]   If the
process-shared attribute is set to PTHREAD_PROCESS_SHARED, only the synchronization object itself can be used for performing
synchronization; however, it need not be referenced at the address used to initalize it (that is, another mapping of the same
object can be used).   The effect of referring to a copy of the
object when locking, unlocking, or destroying it is undefined.
For spin locks, the above requirements shall apply as if spin locks have a process-shared attribute that is set
from the pshared argument to pthread_spin_init(). For semaphores,
the above requirements shall apply as if semaphores have a process-shared attribute that is set to PTHREAD_PROCESS_PRIVATE if the
pshared argument to sem_init() is zero and set to PTHREAD_PROCESS_SHARED if
pshared is non-zero.
For ISO C functions declared in , the above
requirements shall apply as if condition variables of type cnd_t and mutexes of type mtx_t have a process-shared
attribute that is set to PTHREAD_PROCESS_PRIVATE.
2.10 Sockets
A socket is an endpoint for communication using the facilities described in this section. A socket is created with
a specific socket type, described in 2.10.6 Socket Types, and is associated with a specific protocol,
detailed in 2.10.3 Protocols. A socket is accessed via a file descriptor obtained when the socket is
created.
2.10.1 Address Families
All network protocols are associated with a specific address family. An address family provides basic services to
the protocol implementation to allow it to function within a specific network environment. These services may include packet
fragmentation and reassembly, routing, addressing, and basic transport. An address family is normally comprised of a number of
protocols, one per socket type. Each protocol is characterized by an abstract socket type. It is not required that an address
family support all socket types. An address family may contain multiple protocols supporting the same socket abstraction.
2.10.17 Use of Sockets for Local UNIX Connections, 2.10.19 Use
of Sockets over Internet Protocols Based on IPv4, and 2.10.20 Use of Sockets over Internet Protocols
Based on IPv6, respectively, describe the use of sockets for local UNIX connections, for Internet protocols based on IPv4, and
for Internet protocols based on IPv6.
2.10.2 Addressing
An address family defines the format of a socket address. All network addresses are described using a general
structure, called a sockaddr, as defined in the Base Definitions volume of POSIX.1-2024, . However, each address family imposes finer and more specific
structure, generally defining a structure with fields specific to the address family. The field sa_family in the
sockaddr structure contains the address family identifier, specifying the format of the sa_data area. The size of the
sa_data area is unspecified.
2.10.3 Protocols
A protocol supports one of the socket abstractions detailed in 2.10.6 Socket Types.
Selecting a protocol involves specifying the address family, socket type, and protocol number to the socket() function. Certain semantics of the basic socket abstractions are protocol-specific.
All protocols are expected to support the basic model for their particular socket type, but may, in addition, provide non-standard
facilities or extensions to a mechanism.
2.10.4 Routing
Sockets provides packet routing facilities. A routing information database is maintained, which is used in
selecting the appropriate network interface when transmitting packets.
2.10.5 Interfaces
Each network interface in a system corresponds to a path through which messages can be sent and received. A network
interface usually has a hardware device associated with it, though certain interfaces such as the loopback interface, do not.
2.10.6 Socket Types
A socket is created with a specific type, which defines the communication semantics and which allows the selection
of an appropriate communication protocol. Four types are defined: SOCK_DGRAM, [RS]   SOCK_RAW,
SOCK_SEQPACKET, and SOCK_STREAM. Implementations may specify
additional socket types.
The SOCK_STREAM socket type provides reliable, sequenced, full-duplex octet streams between the socket and a peer
to which the socket is connected. A socket of type SOCK_STREAM needs to be in a connected state before any data can be sent or
received. Record boundaries are not maintained; data sent on a stream socket using output operations of one size can be received
using input operations of smaller or larger sizes without loss of data. Data may be buffered; successful return from an output
function does not imply that the data has been delivered to the peer or even transmitted from the local system. If data cannot be
successfully transmitted within a given time then the connection is considered broken, and subsequent operations shall fail. A
SIGPIPE signal is raised if a thread attempts to send data on a broken stream (one that is no longer connected), except that the
signal is suppressed if the MSG_NOSIGNAL flag is used in calls to send(), sendto(), and sendmsg(). Support for an
out-of-band data transmission facility is protocol-specific.
The SOCK_SEQPACKET socket type is similar to the SOCK_STREAM type, and is also connection-oriented. The only
difference between these types is that record boundaries are maintained using the SOCK_SEQPACKET type. A record can be sent using
one or more output operations and received using one or more input operations, but a single operation never transfers parts of more
than one record. Record boundaries are visible to the receiver via the MSG_EOR flag in the received message flags returned by the
recvmsg() function. It is protocol-specific whether a maximum record size is
imposed.
The SOCK_DGRAM socket type supports connectionless data transfer which is not necessarily acknowledged or reliable.
Datagrams can be sent to the address specified (possibly multicast or broadcast) in each output operation, and incoming datagrams
can be received from multiple sources. The source address of each datagram is available when receiving the datagram. An application
can also pre-specify a peer address, in which case calls to output functions that do not specify a peer address shall send to the
pre-specified peer. If a peer has been specified, only datagrams from that peer shall be received. A datagram shall be sent in a
single output operation, and needs to be received in a single input operation. The maximum size of a datagram is protocol-specific;
with some protocols, the limit is implementation-defined. Output datagrams may be buffered within the system; thus, a successful
return from an output function does not guarantee that a datagram is actually sent or received. However, implementations should
attempt to detect any errors possible before the return of an output function, reporting any error by an unsuccessful return
value.
[RS]  The SOCK_RAW socket type is similar to the SOCK_DGRAM type. It differs in that it is normally used with communication
providers that underlie those used for the other socket types. For this reason, the creation of a socket with type SOCK_RAW shall
require appropriate privileges. The format of datagrams sent and received with this socket type generally include specific protocol
headers, and the formats are protocol-specific and implementation-defined.
2.10.7 Socket I/O Mode
The I/O mode of a socket is described by the O_NONBLOCK file status flag which pertains to the open file
description for the socket. This flag is initially off when a socket is created, but may be set and cleared by the use of the
F_SETFL command of the fcntl() function.
When the O_NONBLOCK flag is set, certain functions that would normally block until they are complete shall return
immediately.
The bind() function initiates an address assignment and shall return
without blocking when O_NONBLOCK is set; if the socket address cannot be assigned immediately, bind() shall return the [EINPROGRESS] error to indicate that the assignment was initiated
successfully, but that it has not yet completed.
The connect() function initiates a connection and shall return
without blocking when O_NONBLOCK is set; it shall return the error [EINPROGRESS] to indicate that the connection was initiated
successfully, but that it has not yet completed.
Data transfer operations (the read(), write(), send(), and recv() functions) shall complete immediately, transfer only as much as is available, and then
return without blocking, or return an error indicating that no transfer could be made without blocking.
2.10.8 Socket Owner
The owner of a socket is unset when a socket is created. The owner may be set to a process ID or process group ID
using the F_SETOWN command of the fcntl() function.
2.10.9 Socket Queue Limits
The transmit and receive queue sizes for a socket are set when the socket is created. The default sizes used are
both protocol-specific and implementation-defined. The sizes may be changed using the setsockopt() function.
2.10.10 Pending Error
Errors may occur asynchronously, and be reported to the socket in response to input from the network protocol. The
socket stores the pending error to be reported to a user of the socket at the next opportunity. The error is returned in response
to a subsequent send(), recv(), or getsockopt() operation on the socket, and the pending error is then cleared.
2.10.11 Socket Receive Queue
A socket has a receive queue that buffers data when it is received by the system until it is removed by a receive
call. Depending on the type of the socket and the communication provider, the receive queue may also contain ancillary data such as
the addressing and other protocol data associated with the normal data in the queue, and may contain out-of-band or expedited data.
The limit on the queue size includes any normal, out-of-band data, datagram source addresses, and ancillary data in the queue. The
description in this section applies to all sockets, even though some elements cannot be present in some instances.
The contents of a receive buffer are logically structured as a series of data segments with associated ancillary
data and other information. A data segment may contain normal data or out-of-band data, but never both. A data segment may complete
a record if the protocol supports records (always true for types SOCK_SEQPACKET and SOCK_DGRAM). A record may be stored as more
than one segment; the complete record might never be present in the receive buffer at one time, as a portion might already have
been returned to the application, and another portion might not yet have been received from the communications provider. A data
segment may contain ancillary protocol data, which is logically associated with the segment. Ancillary data is received as if it
were queued along with the first normal data octet in the segment (if any). A segment may contain ancillary data only, with no
normal or out-of-band data. For the purposes of this section, a datagram is considered to be a data segment that terminates a
record, and that includes a source address as a special type of ancillary data. Data segments are placed into the queue as data is
delivered to the socket by the protocol. Normal data segments are placed at the end of the queue as they are delivered. If a new
segment contains the same type of data as the preceding segment and includes no ancillary data, and if the preceding segment does
not terminate a record, the segments are logically merged into a single segment.
The receive queue is logically terminated if an end-of-file indication has been received or a connection has been
terminated. A segment shall be considered to be terminated if another segment follows it in the queue, if the segment completes a
record, or if an end-of-file or other connection termination has been reported. The last segment in the receive queue shall also be
considered to be terminated while the socket has a pending error to be reported.
A receive operation shall never return data or ancillary data from more than one segment.
2.10.12 Socket Out-of-Band Data State
The handling of received out-of-band data is protocol-specific. Out-of-band data may be placed in the socket
receive queue, either at the end of the queue or before all normal data in the queue. In this case, out-of-band data is returned to
an application program by a normal receive call. Out-of-band data may also be queued separately rather than being placed in the
socket receive queue, in which case it shall be returned only in response to a receive call that requests out-of-band data. It is
protocol-specific whether an out-of-band data mark is placed in the receive queue to demarcate data preceding the out-of-band data
and following the out-of-band data. An out-of-band data mark is logically an empty data segment that cannot be merged with other
segments in the queue. An out-of-band data mark is never returned in response to an input operation. The sockatmark() function can be used to test whether an out-of-band data mark is the first
element in the queue. If an out-of-band data mark is the first element in the queue when an input function is called without the
MSG_PEEK option, the mark is removed from the queue and the following data (if any) is processed as if the mark had not been
present.
2.10.13 Connection Indication Queue
Sockets that are used to accept incoming connections maintain a queue of outstanding connection indications. This
queue is a list of connections that are awaiting acceptance by the application; see listen().
2.10.14 Signals
One category of event at the socket interface is the generation of signals. These signals report protocol events or
process errors relating to the state of the socket. The generation or delivery of a signal does not change the state of the socket,
although the generation of the signal may have been caused by a state change.
The SIGPIPE signal shall be sent to a thread that attempts to send data on a socket that is no longer able to send
(one that is no longer connected), except that the signal is suppressed if the MSG_NOSIGNAL flag is used in calls to send(), sendto(), and sendmsg(). Regardless of whether the generation of the signal is suppressed, the send
operation shall fail with the [EPIPE] error.
If a socket has an owner, the SIGURG signal is sent to the owner of the socket when it is notified of expedited or
out-of-band data. The socket state at this time is protocol-dependent, and the status of the socket is specified in 2.10.17 Use of Sockets for Local UNIX Connections, 2.10.19 Use of Sockets over
Internet Protocols Based on IPv4, and 2.10.20 Use of Sockets over Internet Protocols Based on IPv6
. Depending on the protocol, the expedited data may or may not have arrived at the time of signal generation.
2.10.15 Asynchronous Errors
If any of the following conditions occur asynchronously for a socket, the corresponding value listed below shall
become the pending error for the socket:
[ECONNABORTED]
The connection was aborted locally.
[ECONNREFUSED]
For a connection-mode socket attempting a non-blocking connection, the attempt to connect was forcefully rejected. For a
connectionless-mode socket, an attempt to deliver a datagram was forcefully rejected.
[ECONNRESET]
The peer has aborted the connection.
[EHOSTUNREACH]
The destination host is not reachable.
[EMSGSIZE]
For a connectionless-mode socket, the size of a previously sent datagram prevented delivery.
[ENETDOWN]
The local network connection is not operational.
[ENETRESET]
The connection was aborted by the network.
[ENETUNREACH]
The destination network is not reachable.
2.10.16 Use of Options
There are a number of socket options which either specialize the behavior of a socket or provide useful
information. These options may be set at different protocol levels and are always present at the uppermost "socket" level.
Socket options are manipulated by two functions, getsockopt() and
setsockopt(). These functions allow an application program to customize the
behavior and characteristics of a socket to provide the desired effect.
All of the options usable with setsockopt() have defaults. For
each option where a default value is listed as implementation-defined, the implementation also controls whether a socket created by
accept() or accept4() starts with the
option reset to the original default value, or inherited as the value previously customized on the original listening socket. The
type and meaning of these values is defined by the protocol level to which they apply. Instead of using the default values, an
application program may choose to customize one or more of the options. However, in the bulk of cases, the default values are
sufficient for the application.
Some of the options are used to enable or disable certain behavior within the protocol modules (for example, turn
on debugging) while others may be used to set protocol-specific information (for example, IP time-to-live on all the application's
outgoing packets). As each of the options is introduced, its effect on the underlying protocol modules is described.
Value of Level for Socket Options shows the value for the socket level.
Table: Value of Level for Socket Options
Name
Description
SOL_SOCKET
Options are intended for the sockets level.
Socket-Level Options lists those options present at the socket level; that is, when the
level parameter of the getsockopt() or setsockopt() function is SOL_SOCKET, the types of the option value parameters associated
with each option, and a brief synopsis of the meaning of the option value parameter. Unless otherwise noted, each may be examined
with getsockopt() and set with setsockopt() on all types of socket. Options at other protocol levels vary in format and
name.
Table: Socket-Level Options
Option
Parameter Type
Parameter Meaning
SO_ACCEPTCONN
int
Non-zero indicates that socket listening is enabled (getsockopt()
only).
SO_BROADCAST
int
Non-zero requests permission to transmit broadcast datagrams (SOCK_DGRAM sockets only).
SO_DEBUG
int
Non-zero requests debugging in underlying protocol modules.
SO_DOMAIN
int
Identify socket domain (getsockopt() only).
SO_DONTROUTE
int
Non-zero requests bypass of normal routing; route based on destination address only.
SO_ERROR
int
Requests and clears pending error information on the socket (getsockopt() only).
SO_KEEPALIVE
int
Non-zero requests periodic transmission of keepalive messages (protocol-specific).
SO_LINGER
struct linger
Specify actions to be taken for queued, unsent data on close(): linger
on/off and linger time in seconds.
SO_OOBINLINE
int
Non-zero requests that out-of-band data be placed into normal data input queue as received.
SO_PROTOCOL
int
Identify socket protocol (getsockopt() only).
SO_RCVBUF
int
Size of receive buffer (in bytes).
SO_RCVLOWAT
int
Minimum amount of data to return to application for input operations (in bytes).
SO_RCVTIMEO
struct timeval
Timeout value for a socket receive operation.
SO_REUSEADDR
int
Non-zero requests reuse of local addresses in bind()
(protocol-specific).
SO_SNDBUF
int
Size of send buffer (in bytes).
SO_SNDLOWAT
int
Minimum amount of data to send for output operations (in bytes).
SO_SNDTIMEO
struct timeval
Timeout value for a socket send operation.
SO_TYPE
int
Identify socket type (getsockopt() only).
The SO_ACCEPTCONN option is used only on getsockopt(). When this
option is specified, getsockopt() shall report whether socket listening is
enabled for the socket. A value of zero shall indicate that socket listening is disabled; non-zero that it is enabled.
SO_ACCEPTCONN has no default value.
The SO_BROADCAST option requests permission to send broadcast datagrams on the socket. Support for SO_BROADCAST is
protocol-specific. The default for SO_BROADCAST is that the ability to send broadcast datagrams on a socket is disabled.
The SO_DEBUG option enables debugging in the underlying protocol modules. This can be useful for tracing the
behavior of the underlying protocol modules during normal system operation. The semantics of the debug reports are
implementation-defined. The default value for SO_DEBUG is for debugging to be turned off.
The SO_DOMAIN option is used only on getsockopt(). When this
option is specified, getsockopt() shall return the domain of the socket (for
example, AF_INET6). SO_DOMAIN has no default value.
The SO_DONTROUTE option requests that outgoing messages bypass the standard routing facilities. The destination
needs to be on a directly-connected network, and messages are directed to the appropriate network interface according to the
destination address. It is protocol-specific whether this option has any effect and how the outgoing network interface is chosen.
Support for this option with each protocol is implementation-defined.
The SO_ERROR option is used only on getsockopt(). When this
option is specified, getsockopt() shall return any pending error on the socket
and clear the error status. It shall return a value of 0 if there is no pending error. SO_ERROR may be used to check for
asynchronous errors on connected connectionless-mode sockets or for other types of asynchronous errors. SO_ERROR has no default
value.
The SO_KEEPALIVE option enables the periodic transmission of messages on a connected socket. The behavior of this
option is protocol-specific. On a connection-mode socket for which a connection has been established, if SO_KEEPALIVE is enabled
and the connected socket fails to respond to the keep-alive messages, the connection shall be broken. The default value for
SO_KEEPALIVE is zero, specifying that this capability is turned off.
The SO_LINGER option controls the action of the interface when unsent messages are queued on a socket and a
close() is performed. The details of this option are protocol-specific. If SO_LINGER
is enabled, the system shall block the calling thread during close() until it can
transmit the data or until the end of the interval indicated by the l_linger member, whichever comes first. If SO_LINGER is
not specified, and close() is issued, the system handles the call in a way that allows
the calling thread to continue as quickly as possible. The default value for SO_LINGER is zero, or off, for the l_onoff
element of the option value and zero seconds for the linger time specified by the l_linger element.
The SO_OOBINLINE option is valid only on protocols that support out-of-band data. The SO_OOBINLINE option requests
that out-of-band data be placed in the normal data input queue as received; it is then accessible using the read() or recv() functions without the MSG_OOB flag
set. The default for SO_OOBINLINE is off; that is, for out-of-band data not to be placed in the normal data input queue.
The SO_PROTOCOL option is used only on getsockopt(). When this
option is specified, getsockopt() shall return the socket protocol (for example,
IPPROTO_TCP). SO_PROTOCOL has no default value.
The SO_RCVBUF option requests that the buffer space allocated for receive operations on this socket be set to the
value, in bytes, of the option value. Applications may wish to increase buffer size for high volume connections, or may decrease
buffer size to limit the possible backlog of incoming data. The default value for the SO_RCVBUF option value is
implementation-defined, and may vary by protocol.
The SO_RCVLOWAT option sets the minimum number of bytes to process for socket input operations. In general, receive
calls block until any (non-zero) amount of data is received, then return the smaller of the amount available or the amount
requested. The default value for SO_RCVLOWAT is 1, and does not affect the general case. If SO_RCVLOWAT is set to a larger value,
blocking receive calls normally wait until they have received the smaller of the low water mark value or the requested amount.
Receive calls may still return less than the low water mark if an error occurs, a signal is caught, or the type of data next in the
receive queue is different from that returned (for example, out-of-band data). As mentioned previously, the default value for
SO_RCVLOWAT is 1 byte. It is implementation-defined whether the SO_RCVLOWAT option can be set.
The SO_RCVTIMEO option is an option to set a timeout value for input operations. It accepts a timeval
structure with the number of seconds and microseconds specifying the limit on how long to wait for an input operation to complete.
If a receive operation has blocked for this much time without receiving additional data, it shall return with a partial count or
errno shall be set to [EAGAIN] or [EWOULDBLOCK] if no data were received. The default for this option is the value zero,
which indicates that a receive operation will not time out. It is implementation-defined whether the SO_RCVTIMEO option can be
set.
The SO_REUSEADDR option indicates that the rules used in validating addresses supplied in a bind() should allow reuse of local addresses. Operation of this option is protocol-specific.
The default value for SO_REUSEADDR is off; that is, reuse of local addresses is not permitted.
The SO_SNDBUF option requests that the buffer space allocated for send operations on this socket be set to the
value, in bytes, of the option value. The default value for the SO_SNDBUF option value is implementation-defined, and may vary by
protocol.
The SO_SNDLOWAT option sets the minimum number of bytes to process for socket output operations. Most output
operations process all of the data supplied by the call, delivering data to the protocol for transmission and blocking as necessary
for flow control. Non-blocking output operations process as much data as permitted subject to flow control without blocking, but
process no data if flow control does not allow the smaller of the send low water mark value or the entire request to be processed.
A select() operation testing the ability to write to a socket shall return true only
if the send low water mark could be processed. The default value for SO_SNDLOWAT is implementation-defined and protocol-specific.
It is implementation-defined whether the SO_SNDLOWAT option can be set.
The SO_SNDTIMEO option is an option to set a timeout value for the amount of time that an output function shall
block because flow control prevents data from being sent. As noted in Socket-Level Options, the option
value is a timeval structure with the number of seconds and microseconds specifying the limit on how long to wait for an
output operation to complete. If a send operation has blocked for this much time, it shall return with a partial count or
errno set to [EAGAIN] or [EWOULDBLOCK] if no data were sent. The default for this option is the value zero, which indicates
that a send operation will not time out. It is implementation-defined whether the SO_SNDTIMEO option can be set.
The SO_TYPE option is used only on getsockopt(). When this option
is specified, getsockopt() shall return the type of the socket (for example,
SOCK_STREAM). This option is useful to servers that inherit sockets on start-up. SO_TYPE has no default value.
2.10.17 Use of Sockets for Local UNIX Connections
Support for UNIX domain sockets is mandatory.
UNIX domain sockets provide process-to-process communication in a single system.
2.10.17.1 Headers
The symbolic constant AF_UNIX defined in the  header is used to identify the UNIX domain address family. The
header contains other definitions used in connection with UNIX
domain sockets. See XBD 14. Headers.
The sockaddr_storage structure defined in  shall be large enough to accommodate a sockaddr_un structure
(see the  header defined in XBD 14. Headers) and shall be aligned at an appropriate boundary so that pointers to it
can be cast as pointers to sockaddr_un structures and used to access the fields of those structures without alignment
problems. When a sockaddr_storage structure is cast as a sockaddr_un structure, the ss_family field maps onto
the sun_family field.
2.10.18 Use of Sockets over Internet Protocols
When a socket is created in the Internet family with a protocol value of zero, the implementation shall use the
protocol listed below for the type of socket created.
SOCK_STREAM
IPPROTO_TCP.
SOCK_DGRAM
IPPROTO_UDP.
SOCK_RAW
[RS]
IPPROTO_RAW.
SOCK_SEQPACKET
Unspecified.
[RS]  A raw interface to IP is available by creating an Internet socket of type SOCK_RAW. The default protocol for type
SOCK_RAW shall be identified in the IP header with the value IPPROTO_RAW. Applications should not use the default protocol when
creating a socket with type SOCK_RAW, but should identify a specific protocol by value. The ICMP control protocol is accessible
from a raw socket by specifying a value of IPPROTO_ICMP for protocol.
2.10.19 Use of Sockets over Internet Protocols Based on IPv4
Support for sockets over Internet protocols based on IPv4 is mandatory. IPv4 is described in RFC 791.
2.10.19.1 Headers
The symbolic constant AF_INET defined in the  header is used to identify the IPv4 Internet address family. The
header contains other definitions used in connection with
IPv4 Internet sockets. See XBD 14. Headers.
The sockaddr_storage structure defined in  shall be large enough to accommodate a sockaddr_in structure
(see the  header defined in XBD 14. Headers) and shall be aligned at an appropriate boundary so that pointers to it
can be cast as pointers to sockaddr_in structures and used to access the fields of those structures without alignment
problems. When a sockaddr_storage structure is cast as a sockaddr_in structure, the ss_family field maps onto
the sin_family field.
2.10.20 Use of Sockets over Internet Protocols Based on IPv6
[IP6]  This section describes extensions to support sockets over Internet protocols based on IPv6. The functionality described
in this section shall be provided on implementations that support the IPV6 option (and the rest of this section is not further
shaded for this option).
IPv6 is described in RFC 8200.
To enable smooth transition from IPv4 to IPv6, the features defined in this section may, in certain circumstances,
also be used in connection with IPv4; see 2.10.20.2 Compatibility with IPv4.
2.10.20.1 Addressing
IPv6 overcomes the addressing limitations of earlier versions by using 128-bit addresses instead of 32-bit
addresses. The IPv6 address architecture is described in RFC 4291.
There are three kinds of IPv6 address:
Unicast
Identifies a single interface.
A unicast address can be global, link-local (designed for use on a single link), or site-local (designed for
systems not connected to the Internet). Link-local and site-local addresses need not be globally unique.
Anycast
Identifies a set of interfaces such that a packet sent to the address can be delivered to any member of the set.
An anycast address is similar to a unicast address; the nodes to which an anycast address is assigned need to be
explicitly configured to know that it is an anycast address.
Multicast
Identifies a set of interfaces such that a packet sent to the address should be delivered to every member of the set.
An application can send multicast datagrams by simply specifying an IPv6 multicast address in the address
argument of sendto(). To receive multicast datagrams, an application needs to join
the multicast group (using setsockopt() with IPV6_JOIN_GROUP) and bind to the
socket the UDP port on which datagrams are to be received. Some applications should also bind the multicast group address to the
socket, to prevent other datagrams destined to that port from being delivered to the socket.
A multicast address can be global, node-local, link-local, site-local, or organization-local.
The following special IPv6 addresses are defined:
Unspecified
An address that is not assigned to any interface and is used to indicate the absence of an address.
Loopback
A unicast address that is not assigned to any interface and can be used by a node to send packets to itself.
Two sets of IPv6 addresses are defined to correspond to IPv4 addresses:
IPv4-compatible addresses
These are assigned to nodes that support IPv6 and can be used when traffic is "tunneled" through IPv4.
IPv4-mapped addresses
These are used to represent IPv4 addresses in IPv6 address format; see 2.10.20.2 Compatibility with
IPv4.
The unspecified address and the loopback address shall not be treated as IPv4-compatible addresses.
2.10.20.2 Compatibility with IPv4
The API provides the ability for IPv6 applications to interoperate with applications using IPv4, by using
IPv4-mapped IPv6 addresses. These addresses can be generated automatically by the getaddrinfo() function when the specified host has only IPv4 addresses.
Applications can use AF_INET6 sockets to open TCP connections to IPv4 nodes, or send UDP packets to IPv4 nodes, by
simply encoding the destination's IPv4 address as an IPv4-mapped IPv6 address, and passing that address, within a
sockaddr_in6 structure, in the connect(), sendto(), or sendmsg() function. When
applications use AF_INET6 sockets to accept TCP connections from IPv4 nodes, or receive UDP packets from IPv4 nodes, the system
shall return the peer's address to the application in the accept(), accept4(), recvfrom(), recvmsg(), or getpeername() function
using a sockaddr_in6 structure encoded this way. If a node has an IPv4 address, then the implementation shall allow
applications to communicate using that address via an AF_INET6 socket. In such a case, the address shall be represented at the API
by the corresponding IPv4-mapped IPv6 address. Also, the implementation may allow an AF_INET6 socket bound to in6addr_any to
receive inbound connections and packets destined to one of the node's IPv4 addresses.
An application can use AF_INET6 sockets to bind to a node's IPv4 address by specifying the address as an
IPv4-mapped IPv6 address in a sockaddr_in6 structure in the bind() function. For
an AF_INET6 socket bound to a node's IPv4 address, the system shall return the address in the getsockname() function as an IPv4-mapped IPv6 address in a sockaddr_in6
structure.
2.10.20.3 Interface Identification
Each local interface is assigned a unique positive integer as a numeric index. Indexes start at 1; zero is not
used. There may be gaps so that there is no current interface for a particular positive index. Each interface also has a unique
implementation-defined name.
2.10.20.4 Options
The following options apply at the IPPROTO_IPV6 level:
IPV6_JOIN_GROUP
When set via setsockopt(), it joins the application to a multicast group on an
interface (identified by its index) and addressed by a given multicast address, enabling packets sent to that address to be read
via the socket. If the interface index is specified as zero, the system selects the interface (for example, by looking up the
address in a routing table and using the resulting interface).
An attempt to read this option using getsockopt() shall result in
an [EOPNOTSUPP] error.
The parameter type of this option is a pointer to an ipv6_mreq structure.
IPV6_LEAVE_GROUP
When set via setsockopt(), it removes the application from the multicast group on
an interface (identified by its index) and addressed by a given multicast address.
An attempt to read this option using getsockopt() shall result in
an [EOPNOTSUPP] error.
The parameter type of this option is a pointer to an ipv6_mreq structure.
IPV6_MULTICAST_HOPS
The value of this option is the hop limit for outgoing multicast IPv6 packets sent via the socket. Its possible values are the same
as those of IPV6_UNICAST_HOPS. If the IPV6_MULTICAST_HOPS option is not set, a value of 1 is assumed. This option can be set via
setsockopt() and read via getsockopt().
The parameter type of this option is a pointer to an int. (Default value: 1)
IPV6_MULTICAST_IF
The index of the interface to be used for outgoing multicast packets. It can be set via setsockopt() and read via getsockopt().
If the interface index is specified as zero, the system selects the interface (for example, by looking up the address in a routing
table and using the resulting interface).
The parameter type of this option is a pointer to an unsigned int. (Default value: 0)
IPV6_MULTICAST_LOOP
This option controls whether outgoing multicast packets should be delivered back to the local application when the sending
interface is itself a member of the destination multicast group. If it is set to 1 they are delivered. If it is set to 0 they are
not. Other values result in an [EINVAL] error. This option can be set via setsockopt() and read via getsockopt().
The parameter type of this option is a pointer to an unsigned int which is used as a Boolean value. (Default
value: 1)
IPV6_UNICAST_HOPS
The value of this option is the hop limit for outgoing unicast IPv6 packets sent via the socket. If the option is not set, or is
set to -1, the system selects a default value. Attempts to set a value less than -1 or greater than 255 shall result in an [EINVAL]
error. This option can be set via setsockopt() and read via getsockopt().
The parameter type of this option is a pointer to an int. (Default value: Unspecified)
IPV6_V6ONLY
This socket option restricts AF_INET6 sockets to IPv6 communications only. AF_INET6 sockets may be used for both IPv4 and IPv6
communications. Some applications may want to restrict their use of an AF_INET6 socket to IPv6 communications only. For these
applications, the IPv6_V6ONLY socket option is defined. When this option is turned on, the socket can be used to send and receive
IPv6 packets only. This is an IPPROTO_IPV6-level option.
The parameter type of this option is a pointer to an int which is used as a Boolean value. (Default value:
0)
An [EOPNOTSUPP] error shall result if IPV6_JOIN_GROUP or IPV6_LEAVE_GROUP is used with getsockopt().
2.10.20.5 Headers
The symbolic constant AF_INET6 is defined in the  header to identify the IPv6 Internet address family. See XBD
14. Headers.
The sockaddr_storage structure defined in  shall be large enough to accommodate a sockaddr_in6
structure (see the  header defined in XBD 14. Headers) and shall be aligned at an appropriate boundary so that pointers to it
can be cast as pointers to sockaddr_in6 structures and used to access the fields of those structures without alignment
problems. When a sockaddr_storage structure is cast as a sockaddr_in6 structure, the ss_family field maps onto
the sin6_family field.
The , , and
headers contain other definitions used in connection with IPv6 Internet sockets; see XBD 14. Headers.
2.11 Data Types
2.11.1 Defined Types
All of the data types used by various functions are defined by the implementation. The following table describes
some of these types. Other types referenced in the description of a function, not mentioned here, can be found in the appropriate
header for that function.
Defined Type
Description
cc_t
Type used for terminal special characters.
clock_t
Integer or real-floating type used for processor times, as defined in the ISO C standard.
clockid_t
Used for clock ID type in some timer functions.
dev_t
Integer type used for device numbers.
DIR
Type representing a directory stream.
div_t
Structure type returned by the div() function.
FILE
Structure containing information about a file.
glob_t
Structure type used in pathname pattern matching.
fpos_t
Type containing all information needed to specify uniquely every position within a file.
gid_t
Integer type used for group IDs.
iconv_t
Type used for conversion descriptors.
id_t
Integer type used as a general identifier; can be used to contain at least the largest of a pid_t,
uid_t, or gid_t.
ino_t
Unsigned integer type used for file serial numbers.
key_t
Arithmetic type used for XSI interprocess communication.
ldiv_t
Structure type returned by the ldiv() function.
mode_t
Integer type used for file attributes.
mqd_t
Used for message queue descriptors.
nfds_t
Integer type used for the number of file descriptors.
nlink_t
Integer type used for link counts.
off_t
Signed integer type used for file sizes.
pid_t
Signed integer type used for process and process group IDs.
pthread_attr_t
Used to identify a thread attribute object.
pthread_cond_t, cnd_t
Used for condition variables.
pthread_condattr_t
Used to identify a condition attribute object.
pthread_key_t, tss_t
Used for thread-specific data keys.
pthread_mutex_t, mtx_t
Used for mutexes.
pthread_mutexattr_t
Used to identify a mutex attribute object.
pthread_once_t, once_flag
Used for dynamic package initialization.
pthread_rwlock_t
Used for read-write locks.
pthread_rwlockattr_t
Used for read-write lock attributes.
pthread_t, thrd_t
Used to identify a thread.
ptrdiff_t
Signed integer type of the result of subtracting two pointers.
reclen_t
Unsigned integer type used for directory entry lengths.
regex_t
Structure type used in regular expression matching.
regmatch_t
Structure type used in regular expression matching.
rlim_t
Unsigned integer type used for limit values, to which objects of type int and off_t can be cast
without loss of value.
sem_t
Type used in performing semaphore operations.
sig_atomic_t
Possibly volatile-qualified integer type of an object that can be accessed as an atomic entity, even in the
presence of asynchronous interrupts.
sigset_t
Integer or structure type of an object used to represent sets of signals.
size_t
Unsigned integer type used for size of objects.
speed_t
Type used for terminal baud rates.
ssize_t
Signed integer type used for a count of bytes or an error indication.
suseconds_t
Signed integer type used for time in microseconds.
tcflag_t
Type used for terminal modes.
time_t
Integer type used for time in seconds, as defined in the ISO C standard.
timer_t
Used for timer ID returned by the timer_create() function.
uid_t
Integer type used for user IDs.
va_list
Type used for traversing variable argument lists.
wchar_t
Integer type whose range of values can represent distinct codes for all members of the largest extended character
set specified by the supported locales.
wctype_t
Scalar type which represents a character class descriptor.
wint_t
Integer type capable of storing any valid value of wchar_t or WEOF.
wordexp_t
Structure type used in word expansion.
2.11.2 The char Type
The type char is defined as a single byte; see XBD 3.
Definitions (Byte and Character).
2.12 Status Information
Status information is data associated with a process detailing a change in the state of the process. It shall
consist of:
The state the process transitioned into (stopped, continued, or terminated)
The information necessary to populate the siginfo_t structure provided by waitid()
If the new state is terminated:
The low-order 8 bits of the status argument that the process passed to _Exit(), _exit(), or exit(), or the low-order 8 bits of the value the process returned from main()
Note that these 8 bits are part of the complete value that is used to set the si_status member of the
siginfo_t structure provided by waitid()
Whether the process terminated due to the receipt of a signal that was not caught and, if so, the number of the
signal that caused the termination of the process
If the new state is stopped:
The number of the signal that caused the process to stop
A process might not have any status information (such as immediately after a process has started).
Status information for a process shall be generated (made available to the parent process) when the process stops,
continues, or terminates except in the following case:
If the parent process sets the action for the SIGCHLD signal to SIG_IGN, or if the parent sets the SA_NOCLDWAIT
flag for the SIGCHLD signal action, process termination shall not generate new status information but shall cause any existing
status information for the process to be discarded.
If new status information is generated, and the process already had status information, the existing status
information shall be discarded and replaced with the new status information.
Only the process' parent process can obtain the process' status information. The parent obtains a child's status
information by calling wait(), waitid(),
or waitpid(). Except when waitid() is
called with the WNOWAIT flag set in the options argument, the status information obtained by a wait function shall be
consumed (discarded) by that wait function; no two calls to wait(), waitid() (without WNOWAIT), or waitpid() shall
obtain the same status information.
When status information becomes available to the parent process and more than one thread in the parent process is
waiting for the status information (blocked in a call to wait(), waitid(), or waitpid() with arguments that
would match the status information):
If none of the matching threads is in a call to waitid() with the
WNOWAIT flag set in the options argument, the thread that obtains the status information is unspecified.
Otherwise (at least one of the matching threads is in a call to waitid() with the WNOWAIT flag set), the matching thread or threads that obtain the status
information is unspecified except that at least one of the matching threads shall obtain the status information and at most one of
the matching threads that are not calling waitid() with the WNOWAIT flag set shall
obtain it.
Footnotes
1. The functions in the table are not shaded to denote applicable options. Individual
reference pages should be consulted. †
When the cmd argument is F_SETLKW or F_OFD_SETLKW. †† When the function argument is F_LOCK. ††† For any value of the
cmd argument.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getppid.html =====
getppid
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getppid — get the parent process ID
SYNOPSIS
#include
pid_t getppid(void);
DESCRIPTION
The getppid() function shall return the parent process ID of the calling process.
RETURN VALUE
The getppid() function shall always be successful and no return value is reserved to indicate an error.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
exec, fork(), getpgid(), getpgrp(), getpid(), kill(), setpgid(), setsid()
XBD ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
In the SYNOPSIS, the optional include of the  header is
removed.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The requirement to include  has been removed. Although
was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/isdigit_l.html =====
isdigit
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
isdigit, isdigit_l — test for a decimal digit
SYNOPSIS
#include
int isdigit(int c);
[CX]  int isdigit_l(int c, locale_t locale);
DESCRIPTION
For isdigit(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The isdigit() [CX]   and isdigit_l()
functions shall test whether c is a character of class digit in the current locale, [CX]   or in the
locale represented by locale,  respectively; see XBD 7. Locale.
The c argument is an int, the value of which the application shall ensure is a character representable as an
unsigned char or equal to the value of the macro EOF. If the argument has any other value, the behavior is undefined.
[CX]  The
behavior is undefined if the locale argument to isdigit_l() is the special locale object LC_GLOBAL_LOCALE or is not a
valid locale object handle.
RETURN VALUE
The isdigit() [CX]   and isdigit_l()
functions shall return non-zero if c is a decimal digit; otherwise, they shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
To ensure applications portability, especially across natural languages, only these functions and the functions in the reference
pages listed in the SEE ALSO section should be used for character classification.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
isalnum(), isalpha(), isblank(), iscntrl(), isgraph(), islower(), isprint(), ispunct(), isspace(), isupper(), isxdigit()
XBD 7. Locale, ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
The isdigit_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0286 [302], XSH/TC1-2008/0287 [283], and XSH/TC1-2008/0288 [283] are
applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/strcoll_l.html =====
strcoll
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
strcoll, strcoll_l — string comparison using collating information
SYNOPSIS
#include
int strcoll(const char *s1, const char *s2);
[CX]  int strcoll_l(const char *s1, const char *s2,
locale_t locale);
DESCRIPTION
For strcoll(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The strcoll() [CX]   and strcoll_l()
functions shall compare the string pointed to by s1 to the string pointed to by s2, both interpreted as
appropriate to the LC_COLLATE category of the current locale, [CX]
or of the locale represented by locale,   respectively.
The strcoll() [CX]   and strcoll_l()
functions shall not change the setting of errno if successful.
Since no return value is reserved to indicate an error, an application wishing to check for error situations should set
errno to 0, then call strcoll(), [CX]   or strcoll_l()   then check errno.
[CX]  The
behavior is undefined if the locale argument to strcoll_l() is the special locale object LC_GLOBAL_LOCALE or is not a
valid locale object handle.
RETURN VALUE
Upon successful completion, strcoll() shall return an integer greater than, equal to, or less than 0, according to
whether the string pointed to by s1 is greater than, equal to, or less than the string pointed to by s2 when both are
interpreted as appropriate to the current locale. [CX]   On error, strcoll() may set errno, but no return
value is reserved to indicate an error.
Upon successful completion, strcoll_l() shall return an integer greater than, equal to, or less than 0, according to
whether the string pointed to by s1 is greater than, equal to, or less than the string pointed to by s2 when both are
interpreted as appropriate to the locale represented by locale. On error, strcoll_l() may set errno, but no
return value is reserved to indicate an error.
ERRORS
These functions may fail if:
[EINVAL]
[CX]
The s1 or s2 arguments contain characters outside the domain of the collating sequence.
The following sections are informative.
EXAMPLES
Comparing Nodes
The following example uses an application-defined function, node_compare(), to compare two nodes based on an alphabetical
ordering of the string field.
#include
...
struct node { /* These are stored in the table. */
char *string;
int length;
};
...
int node_compare(const void *node1, const void *node2)
{
return strcoll(((const struct node *)node1)->string,
((const struct node *)node2)->string);
}
...
APPLICATION USAGE
The strxfrm() and strcmp()
functions should be used for sorting large lists.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
alphasort(), strcmp(),
strxfrm()
XBD
CHANGE HISTORY
First released in Issue 3.
Issue 5
The DESCRIPTION is updated to indicate that errno does not change if the function is successful.
Issue 6
Extensions beyond the ISO C standard are marked.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The [EINVAL] optional error condition is added.
An example is added.
Issue 7
The strcoll_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0593 [283] and XSH/TC1-2008/0594 [283] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/mkdirat.html =====
mkdir
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
mkdir, mkdirat — make a directory
SYNOPSIS
#include
int mkdir(const char *path, mode_t mode);
[OH] #include
int mkdirat(int fd, const char *path, mode_t mode);
DESCRIPTION
The mkdir() function shall create a new directory with name path. The file permission bits [XSI]   and S_ISVTX
bit   of the new directory shall be initialized from
mode. The file permission bits of the mode argument shall be modified by the file creation mask of the process.
When bits in mode other than the file permission bits [XSI]
and S_ISVTX   are set, the meaning of these additional bits is implementation-defined.
The directory's user ID shall be set to the process' effective user ID. The directory's group ID shall be set to the group ID of
the parent directory or to the effective group ID of the process. Implementations shall provide a way to initialize the directory's
group ID to the group ID of the parent directory. Implementations may, but need not, provide an implementation-defined way to
initialize the directory's group ID to the effective group ID of the calling process.
The newly created directory shall be an empty directory.
If path names a symbolic link, mkdir() shall fail and set errno to [EEXIST].
Upon successful completion, mkdir() shall mark for update the last data access, last data modification, and last file
status change timestamps of the directory. Also, the last data modification and last file status change timestamps of the directory
that contains the new entry shall be marked for update.
The mkdirat() function shall be equivalent to the mkdir() function except in the case where path specifies
a relative path. In this case the newly created directory is created relative to the directory associated with the file descriptor
fd instead of the current working directory. If the access mode of the open file description associated with the file
descriptor is not O_SEARCH, the function shall check whether directory searches are permitted using the current permissions of the
directory underlying the file descriptor. If the access mode is O_SEARCH, the function shall not perform the check.
If mkdirat() is passed the special value AT_FDCWD in the fd parameter, the current working directory shall be used
and the behavior shall be identical to a call to mkdir().
RETURN VALUE
Upon successful completion, these functions shall return 0. Otherwise, these functions shall return -1 and set errno to
indicate the error. If -1 is returned, no directory shall be created.
ERRORS
These functions shall fail if:
[EACCES]
Search permission is denied on a component of the path prefix, or write permission is denied on the parent directory of the
directory to be created.
[EEXIST]
The named file exists.
[EILSEQ]
The last pathname component of path is not a portable filename, and cannot be created in the target directory.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the path argument.
[EMLINK]
The link count of the parent directory would exceed {LINK_MAX}.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOENT]
A component of the path prefix of path does not name an existing file or path is an empty string.
[ENOSPC]
The file system does not contain enough space to hold the contents of the new directory or to extend the parent directory of
the new directory.
[ENOTDIR]
A component of the path prefix names an existing file that is neither a directory nor a symbolic link to a directory.
[EROFS]
The parent directory resides on a read-only file system.
In addition, the mkdirat() function shall fail if:
[EACCES]
The access mode of the open file description associated with fd is not O_SEARCH and the permissions of the directory
underlying fd do not permit directory searches.
[EBADF]
The path argument does not specify an absolute path and the fd argument is neither AT_FDCWD nor a valid file
descriptor open for reading or searching.
[ENOTDIR]
The path argument is not an absolute path and fd is a file descriptor associated with a non-directory file.
These functions may fail if:
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a
length that exceeds {PATH_MAX}.
The following sections are informative.
EXAMPLES
Creating a Directory
The following example shows how to create a directory named /home/cnd/mod1, with read/write/search permissions for owner
and group, and with read/search permissions for others.
#include
#include
int status;
...
status = mkdir("/home/cnd/mod1", S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);
APPLICATION USAGE
None.
RATIONALE
The mkdir() function originated in 4.2 BSD and was added to System V in Release 3.0.
4.3 BSD detects [ENAMETOOLONG].
The POSIX.1-1990 standard required that the group ID of a newly created directory be set to the group ID of its parent directory
or to the effective group ID of the creating process. FIPS 151-2 required that implementations provide a way to have the group ID
be set to the group ID of the containing directory, but did not prohibit implementations also supporting a way to set the group ID
to the effective group ID of the creating process. Conforming applications should not assume which group ID will be used. If it
matters, an application can use chown() to set the group ID after the directory is
created, or determine under what conditions the implementation will set the desired group ID.
The purpose of the mkdirat() function is to create a directory in directories other than the current working directory
without exposure to race conditions. Any part of the path of a file could be changed in parallel to the call to mkdir(),
resulting in unspecified behavior. By opening a file descriptor for the target directory and using the mkdirat() function it
can be guaranteed that the newly created directory is located relative to the desired directory.
Implementations are encouraged to have mkdir() and mkdirat() report an [EILSEQ] error if the last component of
path contains any bytes that have the encoded value of a  character.
FUTURE DIRECTIONS
None.
SEE ALSO
chmod(), mkdtemp(),
mknod(), umask()
XBD , ,
CHANGE HISTORY
First released in Issue 3. Included for alignment with the POSIX.1-1988 standard.
Issue 6
In the SYNOPSIS, the optional include of the  header is
removed.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The requirement to include  has been removed. Although
was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.
The [ELOOP] mandatory error condition is added.
A second [ENAMETOOLONG] is added as an optional error condition.
The following changes were made to align with the IEEE P1003.1a draft standard:
The [ELOOP] optional error condition is added.
Issue 7
Austin Group Interpretation 1003.1-2001 #143 is applied.
The mkdirat() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 2.
Changes are made related to support for finegrained timestamps.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0375 [461], XSH/TC1-2008/0376 [324], XSH/TC1-2008/0377 [277],
XSH/TC1-2008/0378 [278], and XSH/TC1-2008/0379 [278] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0210 [873], XSH/TC2-2008/0211 [591], XSH/TC2-2008/0212 [817],
XSH/TC2-2008/0213 [817], and XSH/TC2-2008/0214 [591] are applied.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to disallow the creation of filenames containing any bytes that
have the encoded value of a  character.
Austin Group Defects 293 and 1734 are applied, adding the [EILSEQ] error.
Austin Group Defect 1522 is applied, adding requirements relating to the S_ISVTX bit.
Austin Group Defect 1729 is applied, changing the description of the [ENOENT] error.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wcstombs.html =====
wcstombs
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wcstombs — convert a wide-character string to a character string
SYNOPSIS
#include
size_t wcstombs(char *restrict s, const wchar_t *restrict pwcs,
size_t n);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The wcstombs() function shall convert the sequence of wide-character codes that are in the array pointed to by
pwcs into a sequence of characters that begins in the initial shift state and store these characters into the array pointed
to by s, stopping if a character would exceed the limit of n total bytes or if a null byte is stored. Each
wide-character code shall be converted as if by a call to wctomb(), except that the
shift state of wctomb() shall not be affected.
The behavior of this function shall be affected by the LC_CTYPE category of the current locale.
No more than n bytes shall be modified in the array pointed to by s. If copying takes place between objects that
overlap, the behavior is undefined. [CX]   If s is a null pointer, wcstombs() shall return the length required to convert
the entire array regardless of the value of n, but no values are stored.
RETURN VALUE
If a wide-character code is encountered that does not correspond to a valid character (of one or more bytes each),
wcstombs() shall return (size_t)-1. Otherwise, wcstombs() shall return the number of bytes stored in the
character array, not including any terminating null byte. The array shall not be null-terminated if the value returned is
n.
ERRORS
The wcstombs() function shall fail if:
[EILSEQ]
[CX]  A
wide-character code does not correspond to a valid character.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
mblen(), mbtowc(), mbstowcs(), wctomb()
XBD
CHANGE HISTORY
First released in Issue 4. Derived from the ISO C standard.
Issue 6
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The DESCRIPTION states the effect of when s is a null pointer.
The [EILSEQ] error condition is added.
The wcstombs() prototype is updated for alignment with the ISO/IEC 9899:1999 standard.
Issue 7
Austin Group Interpretations 1003.1-2001 #156 and #170 are applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0726 [109] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sem_destroy.html =====
sem_destroy
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sem_destroy — destroy an unnamed semaphore
SYNOPSIS
#include
int sem_destroy(sem_t *sem);
DESCRIPTION
The sem_destroy() function shall destroy the unnamed semaphore indicated by sem. If an unnamed semaphore is
implemented using a file descriptor, the file descriptor shall be closed. Only a semaphore that was created using sem_init() can be destroyed using sem_destroy(); the effect of calling
sem_destroy() with a named semaphore is undefined. The effect of subsequent use of the semaphore sem is undefined
until sem is reinitialized by another call to sem_init().
It is safe to destroy an initialized semaphore upon which no threads are currently blocked. The effect of destroying a semaphore
upon which other threads are currently blocked is undefined.
RETURN VALUE
Upon successful completion, a value of zero shall be returned. Otherwise, a value of -1 shall be returned and errno set
to indicate the error.
ERRORS
The sem_destroy() function may fail if:
[EINVAL]
The sem argument is not a valid semaphore.
[EBUSY]
There are currently processes blocked on the semaphore.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
semctl(), semget(), semop(), sem_init(), sem_open()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Issue 6
The sem_destroy() function is marked as part of the Semaphores option.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Semaphores
option.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/114 is applied, updating the ERRORS section so that the [EINVAL]
error becomes optional.
Issue 7
The sem_destroy() function is moved from the Semaphores option to the Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0524 [37] is applied.
Issue 8
Austin Group Defect 368 is applied, adding a requirement that if an unnamed semaphore is implemented using a file descriptor,
sem_destroy() closes the file descriptor.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/posix_fallocate.html =====
posix_fallocate
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
posix_fallocate — file space control (ADVANCED REALTIME)
SYNOPSIS
[ADV]  #include
int posix_fallocate(int fd, off_t offset, off_t len);
DESCRIPTION
The posix_fallocate() function shall ensure that any required storage for regular file data starting at offset and
continuing for len bytes is allocated on the file system storage media. If posix_fallocate() returns successfully,
subsequent writes to the specified file data shall not fail due to the lack of free space on the file system storage media.
If the offset+len is beyond the current file size, then posix_fallocate() shall adjust the file size to
offset+len. Otherwise, the file size shall not be changed.
It is implementation-defined whether a previous posix_fadvise() call
influences allocation strategy.
Space allocated via posix_fallocate() shall be freed by a successful call to creat() or open() that truncates the size of the
file. Space allocated via posix_fallocate() may be freed by a successful call to ftruncate() that reduces the file size to a size smaller than
offset+len.
RETURN VALUE
Upon successful completion, posix_fallocate() shall return zero; otherwise, an error number shall be returned to indicate
the error.
ERRORS
The posix_fallocate() function shall fail if:
[EBADF]
The fd argument is not a valid file descriptor.
[EBADF]
The fd argument references a file that was opened without write permission.
[EFBIG]
The value of offset+len is greater than the maximum file size.
[EFBIG]
The value of offset+len exceeds the file size limit of the process. [XSI]   A SIGXFSZ
signal shall also be generated for the thread.
[EINTR]
A signal was caught during execution.
[EINVAL]
The len argument is less than zero, or the offset argument is less than zero.
[EIO]
An I/O error occurred while reading from or writing to a file system.
[ENODEV]
The fd argument does not refer to a regular file.
[ENOSPC]
There is insufficient free space remaining on the file system storage media.
[ENOTSUP]
The underlying file system does not support this operation.
[ESPIPE]
The fd argument is associated with a pipe or FIFO.
The posix_fallocate() function may fail if:
[EINVAL]
The len argument is zero.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The posix_fallocate() function is part of the Advisory Information option and need not be provided on all
implementations.
Not all file systems are capable of supporting posix_fallocate(), in which case the function will return [ENOTSUP].
However, if a system supports the Advisory Information option, there must be at least one file system that is capable of supporting
this function and is available for use in conforming environments. The pathconf()
and fpathconf() functions can be used to determine whether a file in a particular
file system supports posix_fallocate().
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
creat(), ftruncate(), open(), unlink()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1d-1999.
In the SYNOPSIS, the inclusion of  is no longer
required.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/69 is applied, changing the function prototype in the SYNOPSIS
section. The previous prototype was not large file-aware, and the standard developers felt it acceptable to make this change before
implementations of this function become widespread.
Issue 7
Austin Group Interpretations 1003.1-2001 #022, #024, and #162 are applied, changing the definition of the [EINVAL] error.
Issue 8
Austin Group Defect 308 is applied, clarifying the handling of [EFBIG] errors.
Austin Group Defect 684 is applied, requiring an [ENOTSUP] error instead of [EINVAL] when the underlying file system does not
support posix_fallocate().
Austin Group Defect 687 is applied, changing the APPLICATION USAGE section.
Austin Group Defect 1669 is applied, removing XSI shading from part of the [EFBIG] error relating to the file size limit for the
process.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/tgamma.html =====
tgamma
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
tgamma, tgammaf, tgammal — compute gamma() function
SYNOPSIS
#include
double tgamma(double x);
float tgammaf(float x);
long double tgammal(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute Γ(x) where Γ(x) is defined as
\(\int_0^{\infty} e^{-t} t^{x-1} d t\)
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the gamma of x.
If x is a negative integer, either a domain error or a pole error may occur and either a NaN (if supported) or ±Inf (if
supported), respectively, or an implementation-defined value shall be returned. [MX]   On systems
that support the IEC 60559 Floating-Point option, a domain error shall occur and a NaN shall be returned.
If x is ±0, tgamma(), tgammaf(), and tgammal() shall return ±HUGE_VAL, ±HUGE_VALF, and ±HUGE_VALL,
respectively. [MX]   On systems that support the IEC 60559 Floating-Point option, a pole error shall occur;   otherwise, a [CX]
pole  error may occur.
If the correct value would cause overflow, a range error shall occur and tgamma(), tgammaf(), and tgammal()
shall return ±HUGE_VAL, ±HUGE_VALF, or ±HUGE_VALL, respectively, with the same sign as the correct value of the function.
If the correct value would cause underflow, [MXX]   and is not representable,   a range error may occur, and tgamma(), tgammaf(), and tgammal() shall return
[MXX]
0.0, or   (if IEC 60559 Floating-Point is not supported)
an implementation-defined value no greater in magnitude than DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
[MXX]
If the correct value would cause underflow, and is representable, a range error may occur and the correct value shall be
returned.
If x is subnormal and 1/ x is representable, 1/ x should be returned.
[MX]  If
x is NaN, a NaN shall be returned.
If x is +Inf, x shall be returned.
If x is -Inf, a domain error shall occur, and a NaN shall be returned.
ERRORS
These functions shall fail if:
Domain Error
[MX]
The value of x is a negative integer, or x is -Inf.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If
the integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall
be raised.
Pole Error
[MX]
The value of x is zero.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If
the integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the divide-by-zero floating-point exception
shall be raised.
Range Error
The value overflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If
the integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall
be raised.
These functions may fail if:
Domain Error
The value of x is a negative integer.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If
the integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall
be raised.
Pole Error
The value of x is zero or a negative integer.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If
the integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the divide-by-zero floating-point exception
shall be raised.
Range Error
The result underflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If
the integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception
shall be raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are
independent of each other, but at least one of them must be non-zero.
RATIONALE
This function is named tgamma() in order to avoid conflicts with the historical gamma() and lgamma() functions.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept, fetestexcept, lgamma
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/65 is applied, correcting the third paragraph in the RETURN
VALUE section.
Issue 7
ISO/IEC 9899:1999 standard, Technical Corrigendum 2 #52 (SD5-XSH-ERN-85) is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0660 [68], XSH/TC1-2008/0661 [320], and XSH/TC1-2008/0662 [68] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0367 [604] and XSH/TC2-2008/0368 [630] are applied.
Issue 8
Austin Group Defect 1461 is applied, changing the requirements for a negative integer argument to match the ISO C
standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pipe.html =====
pipe
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pipe, pipe2 — create an interprocess channel
SYNOPSIS
#include
int pipe(int fildes[2]);
int pipe2(int fildes[2], int flag);
DESCRIPTION
The pipe() function shall create a pipe and place two file descriptors, one each into the arguments fildes[0] and
fildes[1], that refer to the open file descriptions for the read and write ends of the pipe, respectively. The file
descriptors shall be allocated as described in 2.6 File Descriptor
Allocation. The FD_CLOEXEC and FD_CLOFORK flags shall be clear on both file descriptors. The O_NONBLOCK flag shall be
clear on both open file descriptions. (The fcntl() function can be used to set this
flag.)
Data can be written to the file descriptor fildes[1] and read from the file descriptor fildes[0]. A read on the
file descriptor fildes[0] shall access data written to the file descriptor fildes[1] on a first-in-first-out basis.
It is unspecified whether fildes[0] is also open for writing and whether fildes[1] is also open for reading.
A process has the pipe open for reading (correspondingly writing) if it has a file descriptor open that refers to the read end,
fildes[0] (write end, fildes[1]).
The pipe's user ID shall be set to the effective user ID of the calling process.
The pipe's group ID shall be set to the effective group ID of the calling process.
Upon successful completion, pipe() shall mark for update the last data access, last data modification, and last file
status change timestamps of the pipe.
The pipe2() function shall be equivalent to the pipe() function, except that the state of O_NONBLOCK on the new
file descriptions and FD_CLOEXEC and FD_CLOFORK on the new file descriptors shall be determined solely by the flag argument,
which can be constructed from a bitwise-inclusive OR of flags from the following list (provided by ):
O_CLOEXEC
Atomically set the FD_CLOEXEC flag on both new file descriptors.
O_CLOFORK
Atomically set the FD_CLOFORK flag on both new file descriptors.
O_NONBLOCK
Set the O_NONBLOCK file status flag on both new file descriptions.
RETURN VALUE
Upon successful completion, 0 shall be returned; otherwise, -1 shall be returned and errno set to indicate the error, no
file descriptors shall be allocated and the contents of fildes shall be left unmodified.
ERRORS
The pipe() and pipe2() functions shall fail if:
[EMFILE]
All, or all but one, of the file descriptors available to the process are currently open.
[ENFILE]
The number of simultaneously open files in the system would exceed a system-imposed limit.
The pipe2() function may fail if:
[EINVAL]
The value of the flag argument is invalid.
The following sections are informative.
EXAMPLES
Using a Pipe to Pass Data Between a Parent Process and a Child
Process
The following example demonstrates the use of a pipe to transfer data between a parent process and a child process. Error
handling is excluded, but otherwise this code demonstrates good practice when using pipes: after the fork() the two processes close the unused ends of the pipe before they commence transferring
data.
#include
#include
...
int fildes[2];
const int BSIZE = 100;
char buf[BSIZE];
ssize_t nbytes;
int status;
status = pipe(fildes);
if (status == -1 ) {
/* an error occurred */
...
}
switch (fork()) {
case -1: /* Handle error */
break;
case 0:  /* Child - reads from pipe */
close(fildes[1]);                       /* Write end is unused */
nbytes = read(fildes[0], buf, BSIZE);   /* Get data from pipe */
/* At this point, a further read would see end-of-file ... */
close(fildes[0]);                       /* Finished with pipe */
exit(EXIT_SUCCESS);
default:  /* Parent - writes to pipe */
close(fildes[0]);                       /* Read end is unused */
write(fildes[1], "Hello world\n", 12);  /* Write data on pipe */
close(fildes[1]);                       /* Child will see EOF */
exit(EXIT_SUCCESS);
}
APPLICATION USAGE
None.
RATIONALE
The wording carefully avoids using the verb "to open" in order to avoid any implication of use of open(); see also write().
The O_CLOEXEC and O_CLOFORK flags of pipe2() are necessary to avoid a data race in multi-threaded applications. Without
O_CLOFORK, a file descriptor is leaked into a child process created by one thread in the window between another thread creating a
file descriptor with pipe() and then using fcntl() to set the FD_CLOFORK flag.
Without O_CLOEXEC, a file descriptor intentionally inherited by child processes is similarly leaked into an executed program if
FD_CLOEXEC is not set atomically.
Since pipes are often used for communication between a parent and child process, O_CLOFORK has to be used with care in order for
the pipe to be usable. If the parent will be writing and the child will be reading, O_CLOFORK should be used when creating the
pipe, and then fcntl() should be used to clear FD_CLOFORK for the read side of the
pipe. This prevents the write side from leaking into other children, ensuring the child will get end-of-file when the parent closes
the write side (although the read side can still be leaked). If the parent will be reading and the child will be writing, there is
no way to prevent the write side being leaked (short of preventing other threads from creating child processes) in order to ensure
the parent gets end-of-file when the child closes the write side, and so the two processes should use an alternative method of
indicating the end of communications.
Arranging for FD_CLOEXEC to be set appropriately is more straightforward. The parent should use O_CLOEXEC when creating the pipe
and the child should clear FD_CLOEXEC on the side to be passed to the new program before calling an exec family function to execute it.
The O_NONBLOCK flag is for convenience in avoiding additional fcntl() calls.
FUTURE DIRECTIONS
None.
SEE ALSO
2.6 File Descriptor Allocation, fcntl(), read(), write()
XBD ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The DESCRIPTION is updated to indicate that certain dispositions of fildes[0] and fildes[1] are unspecified.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/65 is applied, adding the example to the EXAMPLES
section.
Issue 7
SD5-XSH-ERN-156 is applied, updating the DESCRIPTION to state the setting of the pipe's user ID and group ID.
Changes are made related to support for finegrained timestamps.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0247 [835] and XSH/TC2-2008/0248 [467,835] are applied.
Issue 8
Austin Group Defects 411, 1318, and 1577 are applied, adding pipe2() and FD_CLOFORK.
Austin Group Defect 1576 is applied, adding the word "respectively".
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/send.html =====
send
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
send — send a message on a socket
SYNOPSIS
#include
ssize_t send(int socket, const void *buffer, size_t length, int
flags);
DESCRIPTION
The send() function shall initiate transmission of a message from the specified socket to its peer. The send()
function shall send a message only when the socket is connected. If the socket is a connectionless-mode socket, the message shall
be sent to the pre-specified peer address.
The send() function takes the following arguments:
socket
Specifies the socket file descriptor.
buffer
Points to the buffer containing the message to send.
length
Specifies the length of the message in bytes.
flags
Specifies the type of message transmission. Values of this argument are formed by logically OR'ing zero or more of the
following flags:
MSG_EOR
Terminates a record (if supported by the protocol).
MSG_OOB
Sends out-of-band data on sockets that support out-of-band communications. The significance and semantics of out-of-band data
are protocol-specific.
MSG_NOSIGNAL
Requests not to send the SIGPIPE signal if an attempt to send is made on a stream-oriented socket that is no longer connected.
The [EPIPE] error shall still be returned.
The length of the message to be sent is specified by the length argument. If the message is too long to pass through the
underlying protocol, send() shall fail and no data shall be transmitted.
Successful completion of a call to send() does not guarantee delivery of the message. A return value of -1 indicates only
locally-detected errors.
If space is not available at the sending socket to hold the message to be transmitted, and the socket file descriptor does not
have O_NONBLOCK set, send() shall block until space is available or a timeout occurs (see SO_SNDTIMEO in 2.10.16 Use of Options). If space is not available at the sending socket to
hold the message to be transmitted, and the socket file descriptor does have O_NONBLOCK set, send() shall fail. The select() and poll() functions can be used to
determine when it is possible to send more data.
The socket in use may require the process to have appropriate privileges to use the send() function.
RETURN VALUE
Upon successful completion, send() shall return the number of bytes sent. Otherwise, -1 shall be returned and
errno set to indicate the error.
ERRORS
The send() function shall fail if:
[EAGAIN] or [EWOULDBLOCK]
The socket's file descriptor is marked O_NONBLOCK and the requested operation would block. See also SO_SNDTIMEO in 2.10.16 Use of Options.
[EBADF]
The socket argument is not a valid file descriptor.
[ECONNRESET]
A connection was forcibly closed by a peer.
[EDESTADDRREQ]
The socket is not connection-mode and no peer address is set.
[EINTR]
A signal interrupted send() before any data was transmitted.
[EMSGSIZE]
The message is too large to be sent all at once, as the socket requires.
[ENOTCONN]
The socket is not connected.
[ENOTSOCK]
The socket argument does not refer to a socket.
[EOPNOTSUPP]
The socket argument is associated with a socket that does not support one or more of the values set in
flags.
[EPIPE]
The socket is shut down for writing, or the socket is connection-mode and is no longer connected. In the latter case, and if
the socket is of type SOCK_STREAM or SOCK_SEQPACKET and the MSG_NOSIGNAL flag is not set, the SIGPIPE signal is generated to the
calling thread.
The send() function may fail if:
[EACCES]
The calling process does not have appropriate privileges.
[EIO]
An I/O error occurred while reading from or writing to the file system.
[ENETDOWN]
The local network interface used to reach the destination is down.
[ENETUNREACH]
No route to the network is present.
[ENOBUFS]
Insufficient resources were available in the system to perform the operation.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
If the socket argument refers to a connection-mode socket, the send() function is equivalent to sendto() (with any value for the dest_addr and dest_len arguments, as they are
ignored in this case). If the socket argument refers to a socket and the flags argument is 0, the send()
function is equivalent to write().
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
connect(), getsockopt(),
poll(), pselect(), recv(), recvfrom(), recvmsg(), sendmsg(), sendto(), setsockopt(), shutdown(), socket(), write()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
Issue 7
Austin Group Interpretation 1003.1-2001 #035 is applied, updating the DESCRIPTION to clarify the behavior when the socket is a
connectionless-mode socket.
The MSG_NOSIGNAL flag is added from The Open Group Technical Standard, 2006, Extended API Set Part 2.
The [EPIPE] error is modified.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0543 [463] is applied.
Issue 8
Austin Group Defect 1429 is applied, clarifying the behavior on timeout by adding references to 2.10.16 Use of Options.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fgetpos.html =====
fgetpos
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fgetpos — get current file position information
SYNOPSIS
#include
int fgetpos(FILE *restrict stream, fpos_t *restrict pos);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The fgetpos() function shall store the current values of the parse state (if any) and file position indicator for the
stream pointed to by stream in the object pointed to by pos. The value stored contains unspecified information usable
by fsetpos() for repositioning the stream to its position at the time of the call to
fgetpos().
The fgetpos() function shall not change the setting of errno if successful.
RETURN VALUE
Upon successful completion, fgetpos() shall return 0; otherwise, it shall return a non-zero value and set errno to
indicate the error.
ERRORS
The fgetpos() function shall fail if:
[EBADF]
[CX]
The file descriptor underlying stream is not valid.
[EOVERFLOW]
[CX]
The current value of the file position cannot be represented correctly in an object of type fpos_t.
[ESPIPE]
[CX]
The file descriptor underlying stream is associated with a pipe, FIFO, or socket.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, fopen(), ftell(), rewind(), ungetc()
XBD
CHANGE HISTORY
First released in Issue 4. Derived from the ISO C standard.
Issue 5
Large File Summit extensions are added.
Issue 6
Extensions beyond the ISO C standard are marked.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The [EBADF] and [ESPIPE] optional error conditions are added.
An additional [ESPIPE] error condition is added for sockets.
The prototype for fgetpos() is changed for alignment with the ISO/IEC 9899:1999 standard.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0131 [105], XSH/TC1-2008/0132 [122], and XSH/TC1-2008/0133 [14] are
applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_atfork.html =====
pthread_atfork
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_atfork — register fork handlers
SYNOPSIS
[OB]  #include
int pthread_atfork(void (*prepare)(void), void (*parent)(void),
void (*child)(void));
DESCRIPTION
The pthread_atfork() function shall declare fork handlers to be called before and after fork(), in the context of the thread that called fork(). The prepare fork handler shall be called before fork() processing commences. The parent fork handle shall be called after fork() processing completes in the parent process. The child fork handler shall be
called after fork() processing completes in the child process. If no handling is
desired at one or more of these three points, the corresponding fork handler address(es) may be set to NULL.
If a fork() call in a multi-threaded process leads to a child fork handler
calling any function that is not async-signal-safe, the behavior is undefined.
The order of calls to pthread_atfork() is significant. The parent and child fork handlers shall be called
in the order in which they were established by calls to pthread_atfork(). The prepare fork handlers shall be called
in the opposite order.
RETURN VALUE
Upon successful completion, pthread_atfork() shall return a value of zero; otherwise, an error number shall be returned
to indicate the error.
ERRORS
The pthread_atfork() function shall fail if:
[ENOMEM]
Insufficient table space exists to record the fork handler addresses.
The pthread_atfork() function shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The original usage pattern envisaged for pthread_atfork() was for the prepare fork handler to lock mutexes and
other locks, and for the parent and child handlers to unlock them. However, since all of the relevant unlocking
functions, except sem_post(), are not async-signal-safe, this usage results in
undefined behavior in the child process unless the only such unlocking function it calls is sem_post().
RATIONALE
There are at least two serious problems with the semantics of fork() in a
multi-threaded program. One problem has to do with state (for example, memory) covered by mutexes. Consider the case where one
thread has a mutex locked and the state covered by that mutex is inconsistent while another thread calls fork(). In the child, the mutex is in the locked state (locked by a nonexistent thread and thus
can never be unlocked). Having the child simply reinitialize the mutex is unsatisfactory since this approach does not resolve the
question about how to correct or otherwise deal with the inconsistent state in the child.
It is suggested that programs that use fork() call an exec function very soon afterwards in the child process, thus resetting all states. In the
meantime, only a short list of async-signal-safe library routines are promised to be available.
Unfortunately, this solution does not address the needs of multi-threaded libraries. Application programs may not be aware that
a multi-threaded library is in use, and they feel free to call any number of library routines between the fork() and exec calls, just as they always have.
Indeed, they may be extant single-threaded programs and cannot, therefore, be expected to obey new restrictions imposed by the
threads library.
On the other hand, the multi-threaded library needs a way to protect its internal state during fork() in case it is re-entered later in the child process. The problem arises especially in
multi-threaded I/O libraries, which are almost sure to be invoked between the fork()
and exec calls to effect I/O redirection. The solution may require locking mutex
variables during fork(), or it may entail simply resetting the state in the child after
the fork() processing completes.
The pthread_atfork() function was intended to provide multi-threaded libraries with a means to protect themselves from
innocent application programs that call fork(), and to provide multi-threaded
application programs with a standard mechanism for protecting themselves from fork()
calls in a library routine or the application itself.
The expected usage was that the prepare handler would acquire all mutex locks and the other two fork handlers would release
them.
For example, an application could have supplied a prepare routine that acquires the necessary mutexes the library maintains and
supplied child and parent routines that release those mutexes, thus ensuring that the child would have got a consistent snapshot of
the state of the library (and that no mutexes would have been left stranded). This is good in theory, but in reality not practical.
Each and every mutex and lock in the process must be located and locked. Every component of a program including third-party
components must participate and they must agree who is responsible for which mutex or lock. This is especially problematic for
mutexes and locks in dynamically allocated memory. All mutexes and locks internal to the implementation must be locked, too. This
possibly delays the thread calling fork() for a long time or even indefinitely since
uses of these synchronization objects may not be under control of the application. A final problem to mention here is the problem
of locking streams. At least the streams under control of the system (like stdin, stdout, stderr) must be
protected by locking the stream with flockfile(). But the application itself could
have done that, possibly in the same thread calling fork(). In this case, the process
will deadlock.
Alternatively, some libraries might have been able to supply just a child routine that reinitializes the mutexes in the
library and all associated states to some known value (for example, what it was when the image was originally executed). This
approach is not possible, though, because implementations are allowed to fail *_init() and *_destroy() calls for
mutexes and locks if the mutex or lock is still locked. In this case, the child routine is not able to reinitialize the
mutexes and locks.
When fork() is called, only the calling thread is duplicated in the child process.
Synchronization variables remain in the same state in the child as they were in the parent at the time fork() was called. Thus, for example, mutex locks may be held by threads that no longer exist
in the child process, and any associated states may be inconsistent. The intention was that the parent process could have avoided
this by explicit code that acquires and releases locks critical to the child via pthread_atfork(). In addition, any critical
threads would have needed to be recreated and reinitialized to the proper state in the child (also via
pthread_atfork()).
A higher-level package may acquire locks on its own data structures before invoking lower-level packages. Under this scenario,
the order specified for fork handler calls allows a simple rule of initialization for avoiding package deadlock: a package
initializes all packages on which it depends before it calls the pthread_atfork() function for itself.
As explained, there is no suitable solution for functionality which requires non-atomic operations to be protected through
mutexes and locks. This is why the POSIX.1 standard since the 1996 release requires that the child process after fork() in a multi-threaded process only calls async-signal-safe interfaces.
An additional problem arises when pthread_atfork() is called to register a function in a library that was loaded using
dlopen(). If the library is unloaded using dlclose(), and the implementation of dlclose() does not unregister the function, then when fork() tries to call it the result will be undefined behavior. Some implementations of dlclose() do unregister pthread_atfork() handlers, but this cannot be relied upon by
portable applications. The standard provides no portable method for unregistering a function installed as a handler via
pthread_atfork().
FUTURE DIRECTIONS
The pthread_atfork() function may be removed in a future version of this standard.
SEE ALSO
atexit(), exec, fork()
XBD ,
CHANGE HISTORY
First released in Issue 5. Derived from the POSIX Threads Extension.
IEEE PASC Interpretation 1003.1c #4 is applied.
Issue 6
The pthread_atfork() function is marked as part of the Threads option.
The  header is added to the SYNOPSIS.
Issue 7
The pthread_atfork() function is moved from the Threads option to the Base.
SD5-XSH-ERN-145 is applied, updating the RATIONALE.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0261 [858] is applied.
Issue 8
Austin Group Defect 851 is applied, marking pthread_atfork() as obsolescent.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/nexttowardl.html =====
nextafter
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
nextafter, nextafterf, nextafterl, nexttoward, nexttowardf, nexttowardl — next representable floating-point
number
SYNOPSIS
#include
double nextafter(double x, double y);
float nextafterf(float x, float y);
long double nextafterl(long double x, long double y);
double nexttoward(double x, long double y);
float nexttowardf(float x, long double y);
long double nexttowardl(long double x, long double y);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The nextafter(), nextafterf(), and nextafterl() functions shall compute the next representable
floating-point value following x in the direction of y. Thus, if y is less than x, nextafter()
shall return the largest representable floating-point number less than x. The nextafter(), nextafterf(), and
nextafterl() functions shall return y if x equals y.
The nexttoward(), nexttowardf(), and nexttowardl() functions shall be equivalent to the corresponding
nextafter() functions, except that the second parameter shall have type long double and the functions shall return
y converted to the type of the function if x equals y.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the next representable floating-point value following x in the
direction of y.
If x==y, y (of the type x) shall be returned.
[MX]
Even though underflow or overflow can occur, the returned value shall be independent of the current rounding direction mode.
If x is finite and the correct function value would overflow, a range error shall occur and ±HUGE_VAL, ±HUGE_VALF, and
±HUGE_VALL (with the same sign as x) shall be returned as appropriate for the return type of the function.
[MX]  If
x or y is NaN, a NaN shall be returned.
[MX]  If
x!=y and the correct function value is subnormal, zero, or underflows, a range error shall occur, and
[MXX]
the correct function value (if representable) or
[MX]  0.0 shall be returned.
ERRORS
These functions shall fail if:
Range Error
The correct value overflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall be
raised.
Range Error
[MX]
The correct value is subnormal or underflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
When  is included, note that the return type of
nextafter() depends on the generic typing deduced from both arguments, while the return type of nexttoward() depends
only on the generic typing of the first argument.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
The nextafter() function is no longer marked as an extension.
The nextafterf(), nextafterl(), nexttoward(), nexttowardf(), and nexttowardl() functions are
added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0407 [68] and XSH/TC1-2008/0408 [357] are applied.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/asinl.html =====
asin
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
asin, asinf, asinl — arc sine function
SYNOPSIS
#include
double asin(double x);
float asinf(float x);
long double asinl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the principal value of the arc sine of their argument x. The value of x should be in
the range [-1,1].
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the arc sine of x, in the range [-ℼ/2,ℼ/2] radians.
For finite values of x not in the range [-1,1], a domain error shall occur, and [MX]   either a NaN
(if supported), or   an implementation-defined value shall be
returned.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0, x shall be returned.
If x is ±Inf, a domain error shall occur, and a NaN shall be returned.
[MXX]
If x is subnormal, x should be returned.
[MX]  If x is subnormal, a range error may occur and, if x is
not returned, asin(), asinf(), and asinl() shall return an implementation-defined value no greater in
magnitude than DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
ERRORS
These functions shall fail if:
Domain Error
The x argument is finite and is not in the range [-1,1], [MX]
or is ±Inf.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
These functions may fail if:
Range Error
[MX]
The value of x is subnormal.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), isnan(), sin()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The asinf() and asinl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0034 [320] and XSH/TC1-2008/0035 [68] are applied.
Issue 8
Austin Group Defect 1382 is applied, rearranging the text describing the behavior when x is subnormal to avoid the need
for two shading changes.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/ffsl.html =====
ffs
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ffs, ffsl, ffsll — find first set bit
SYNOPSIS
[XSI]  #include
int ffs(int i);
int ffsl(long i);
int ffsll(long long i);
DESCRIPTION
The ffs(), ffsl(), and ffsll() functions shall find the first bit set (beginning with the least significant
bit) in i, and return the index of that bit. Bits are numbered starting at one (the least significant bit).
RETURN VALUE
The ffs(), ffsl(), and ffsll() functions shall return the index of the first bit set. If i is 0,
then these functions shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 8
Austin Group Defect 617 is applied, adding ffsl() and ffsll().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/clock_settime.html =====
clock_getres
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
clock_getres, clock_gettime, clock_settime — clock and timer functions
SYNOPSIS
[CX]  #include
int clock_getres(clockid_t clock_id, struct timespec *res);
int clock_gettime(clockid_t clock_id, struct timespec *tp);
int clock_settime(clockid_t clock_id, const struct timespec *tp);
DESCRIPTION
The clock_getres() function shall return the resolution of any clock. Clock resolutions are implementation-defined and
cannot be set by a process. If the argument res is not NULL, the resolution of the specified clock shall be stored in the
location pointed to by res. If res is NULL, the clock resolution is not returned. If the time argument of
clock_settime() is not a multiple of res, then the value is truncated to a multiple of res.
The clock_gettime() function shall return the current value tp for the specified clock, clock_id.
The clock_settime() function shall set the specified clock, clock_id, to the value specified by tp. Time
values that are between two consecutive non-negative integer multiples of the resolution of the specified clock shall be truncated
down to the smaller multiple of the resolution.
A clock may be system-wide (that is, visible to all processes) or per-process (measuring time that is meaningful only within a
process). All implementations shall support a clock_id of CLOCK_REALTIME as defined in . This clock represents the clock measuring real time for the system. For this
clock, the values returned by clock_gettime() and specified by clock_settime() represent the amount of time (in
seconds and nanoseconds) since the Epoch. An implementation may also support additional clocks. The interpretation of time values
for these clocks is unspecified.
If the value of the CLOCK_REALTIME clock is set via clock_settime(), the new value of the clock shall be used to
determine the time of expiration for absolute time services based upon the CLOCK_REALTIME clock. This applies to the time at which
armed absolute timers expire. If the absolute time requested at the invocation of such a time service is before the new value of
the clock, the time service shall expire immediately as if the clock had reached the requested time normally.
Setting the value of the CLOCK_REALTIME clock via clock_settime() shall have no effect on threads that are blocked
waiting for a relative time service based upon this clock, including the nanosleep() and thrd_sleep() functions;
nor on the expiration of relative timers based upon this clock. Consequently, these time services shall expire when the requested
relative interval elapses, independently of the new or old value of the clock.
All implementations shall support a clock_id of CLOCK_MONOTONIC defined in . This clock represents the monotonic clock for the system. For this clock, the
value returned by clock_gettime() represents the amount of time (in seconds and nanoseconds) since an unspecified point in
the past (for example, system start-up time, or the Epoch). This point does not change after system start-up time. The value of the
CLOCK_MONOTONIC clock cannot be set via clock_settime(). This function shall fail if it is invoked with a clock_id
argument of CLOCK_MONOTONIC.
The effect of setting a clock via clock_settime() on armed per-process timers associated with a clock other than
CLOCK_REALTIME is implementation-defined.
If the value of the CLOCK_REALTIME clock is set via clock_settime(), the new value of the clock shall be used to
determine the time at which the system shall awaken a thread blocked on an absolute clock_nanosleep() call based upon the CLOCK_REALTIME clock. If the absolute time
requested at the invocation of such a time service is before the new value of the clock, the call shall return immediately as if
the clock had reached the requested time normally.
Setting the value of the CLOCK_REALTIME clock via clock_settime() shall have no effect on any thread that is blocked on a
relative clock_nanosleep() call. Consequently, the call shall return when
the requested relative interval elapses, independently of the new or old value of the clock.
Appropriate privileges to set a particular clock are implementation-defined.
[CPT]
If _POSIX_CPUTIME is defined, implementations shall support clock ID values obtained by invoking clock_getcpuclockid(), which represent the CPU-time clock of a given process.
Implementations shall also support the special clockid_t value CLOCK_PROCESS_CPUTIME_ID, which represents the CPU-time clock
of the calling process when invoking one of the clock_*() or timer_*() functions. For these clock IDs, the values
returned by clock_gettime() and specified by clock_settime() represent the amount of execution time of the process
associated with the clock. Changing the value of a CPU-time clock via clock_settime() shall have no effect on the behavior
of the sporadic server scheduling policy (see Scheduling Policies
).
[TCT]
If _POSIX_THREAD_CPUTIME is defined, implementations shall support clock ID values obtained by invoking pthread_getcpuclockid(), which represent the CPU-time clock of a given thread.
Implementations shall also support the special clockid_t value CLOCK_THREAD_CPUTIME_ID, which represents the CPU-time clock
of the calling thread when invoking one of the clock_*() or timer_*() functions. For these clock IDs, the values
returned by clock_gettime() and specified by clock_settime() shall represent the amount of execution time of the
thread associated with the clock. Changing the value of a CPU-time clock via clock_settime() shall have no effect on the
behavior of the sporadic server scheduling policy (see Scheduling
Policies).
RETURN VALUE
A return value of 0 shall indicate that the call succeeded. A return value of -1 shall indicate that an error occurred, and
errno shall be set to indicate the error.
ERRORS
The clock_getres(), clock_gettime(), and clock_settime() functions shall fail if:
[EINVAL]
The clock_id argument does not specify a known clock.
The clock_gettime() function shall fail if:
[EOVERFLOW]
The number of seconds will not fit in an object of type time_t.
The clock_settime() function shall fail if:
[EINVAL]
The tp argument to clock_settime() is outside the range for the given clock ID.
[EINVAL]
The tp argument specified a nanosecond value less than zero or greater than or equal to 1000 million.
[EINVAL]
The value of the clock_id argument is CLOCK_MONOTONIC.
The clock_settime() function may fail if:
[EPERM]
The requesting process does not have appropriate privileges to set the specified clock.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Note that the absolute value of the monotonic clock is meaningless (because its origin is arbitrary), and thus there is no need
to set it. Furthermore, realtime applications can rely on the fact that the value of this clock is never set and, therefore, that
time intervals measured with this clock will not be affected by calls to clock_settime().
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
Scheduling Policies, clock_getcpuclockid(), clock_nanosleep(), ctime(),
mq_receive(), mq_send(),
nanosleep(), pthread_mutex_clocklock(), sem_clockwait(), thrd_sleep(),
time(), timer_create()
, timer_getoverrun()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Issue 6
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Timers
option.
The APPLICATION USAGE section is added.
The following changes were made to align with the IEEE P1003.1a draft standard:
Clarification is added of the effect of resetting the clock resolution.
CPU-time clocks and the clock_getcpuclockid() function are added for
alignment with IEEE Std 1003.1d-1999.
The following changes are added for alignment with IEEE Std 1003.1j-2000:
The DESCRIPTION is updated as follows:
The value returned by clock_gettime() for CLOCK_MONOTONIC is specified.
The clock_settime() function failing for CLOCK_MONOTONIC is specified.
The effects of clock_settime() on the clock_nanosleep() function
with respect to CLOCK_REALTIME are specified.
An [EINVAL] error is added to the ERRORS section, indicating that clock_settime() fails for CLOCK_MONOTONIC.
The APPLICATION USAGE section notes that the CLOCK_MONOTONIC clock need not and shall not be set by clock_settime() since
the absolute value of the CLOCK_MONOTONIC clock is meaningless.
The clock_nanosleep(), mq_timedreceive(), mq_timedsend(), pthread_mutex_timedlock(), sem_timedwait(), timer_create(),
and timer_settime() functions are added to the SEE ALSO section.
Issue 7
Functionality relating to the Clock Selection option is moved to the Base.
The clock_getres(), clock_gettime(), and clock_settime() functions are moved from the Timers option to the
Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0058 [106] is applied.
Issue 8
Austin Group Defect 1302 is applied, changing "the nanosleep() function" to
"the nanosleep() and thrd_sleep() functions".
Austin Group Defect 1346 is applied, requiring support for Monotonic Clock.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/rewinddir.html =====
rewinddir
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
rewinddir — reset the position of a directory stream to the beginning of a directory
SYNOPSIS
#include
void rewinddir(DIR *dirp);
DESCRIPTION
The rewinddir() function shall reset the position of the directory stream to which dirp refers to the beginning of
the directory. It shall also cause the directory stream to refer to the current state of the corresponding directory, as a call to
opendir() would have done. If dirp does not refer to a directory stream, the
effect is undefined.
After a call to the fork() function, either the parent or child (but not both) may
continue processing the directory stream using readdir(), rewinddir(), or
[XSI]
seekdir().  If both
the parent and child processes use these functions, the result is undefined.
RETURN VALUE
The rewinddir() function shall not return a value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The rewinddir() function should be used in conjunction with opendir(),
readdir(), and closedir() to examine
the contents of the directory. This method is recommended for portability.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
closedir(), fdopendir(),
readdir()
XBD ,
CHANGE HISTORY
First released in Issue 2.
Issue 6
In the SYNOPSIS, the optional include of the  header is
removed.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The requirement to include  has been removed. Although
was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/memchr.html =====
memchr
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
memchr — find byte in memory
SYNOPSIS
#include
void *memchr(const void *s, int c, size_t n);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The memchr() function shall locate the first occurrence of c (converted to an unsigned char) in the initial
n bytes (each interpreted as unsigned char) pointed to by s.
The implementation shall behave as if it reads the bytes sequentially and stops as soon as a matching byte is found.
[CX]  The
memchr() function shall not change the setting of errno on valid input.
RETURN VALUE
The memchr() function shall return a pointer to the located byte, or a null pointer if the byte is not found.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0374 [110] is applied.
Issue 8
Austin Group Defect 448 is applied, adding a requirement that memchr() does not change the setting of errno on
valid input.
Austin Group Defect 1302 is applied, aligning this function with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getuid.html =====
getuid
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getuid — get a real user ID
SYNOPSIS
#include
uid_t getuid(void);
DESCRIPTION
The getuid() function shall return the real user ID of the calling process. The getuid() function shall not modify
errno.
RETURN VALUE
The getuid() function shall always be successful and no return value is reserved to indicate the error.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
Setting the Effective User ID to the Real User ID
The following example sets the effective user ID of the calling process to the real user ID.
#include
...
seteuid(getuid());
APPLICATION USAGE
None.
RATIONALE
In a conforming environment, getuid() will always succeed. It is possible for implementations to provide an extension
where a process in a non-conforming environment will not be associated with a user or group ID. It is recommended that such
implementations return (uid_t)-1 and set errno to indicate such an environment; doing so does not violate this
standard, since such an environment is already an extension.
FUTURE DIRECTIONS
None.
SEE ALSO
getegid(), geteuid(), getgid(), getresgid(), getresuid(), setegid(), seteuid(), setgid(), setregid(), setresgid(), setresuid(), setreuid(), setuid()
XBD ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
In the SYNOPSIS, the optional include of the  header is
removed.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The requirement to include  has been removed. Although
was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.
Issue 7
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0175 [511] and XSH/TC2-2008/0176 [897] are applied.
Issue 8
Austin Group Defect 1344 is applied, adding getresgid(), getresuid(), setresgid(), and setresuid() to SEE ALSO.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/ceil.html =====
ceil
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ceil, ceilf, ceill — ceiling value function
SYNOPSIS
#include
double ceil(double x);
float ceilf(float x);
long double ceill(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the smallest integral value not less than x.
[MX]
These functions may raise the inexact floating-point exception for finite non-integer arguments.
RETURN VALUE
[MX]  The
returned value shall be independent of the current rounding direction mode and shall have the same sign as x.
Upon successful completion, ceil(), ceilf(), and ceill() shall return the smallest integral value not less
than x, expressed as a type double, float, or long double, respectively.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0 or ±Inf, x shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The integral value returned by these functions need not be expressible as an intmax_t. The return value should be tested
before assigning it to an integer type to avoid the undefined results of an integer overflow.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), floor(), isnan()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The ceilf() and ceill() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0046 [346] is applied.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/putchar.html =====
putchar
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
putchar — put a byte on a stdout stream
SYNOPSIS
#include
int putchar(int c);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The function call putchar(c) shall be equivalent to putc(c,stdout).
RETURN VALUE
Refer to fputc().
ERRORS
Refer to fputc().
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, putc()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0471 [14] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/acoshf.html =====
acosh
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
acosh, acoshf, acoshl — inverse hyperbolic cosine functions
SYNOPSIS
#include
double acosh(double x);
float acoshf(float x);
long double acoshl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the inverse hyperbolic cosine of their argument x.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the inverse hyperbolic cosine of their argument.
For finite values of x
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
The acosh() function is no longer marked as an extension.
The acoshf() and acoshl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0025 [320] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/unlockpt.html =====
unlockpt
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
unlockpt — unlock a pseudo-terminal manager/subsidiary pair
SYNOPSIS
[XSI]  #include
int unlockpt(int fildes);
DESCRIPTION
The unlockpt() function shall unlock the subsidiary pseudo-terminal device associated with the manager device to which
fildes refers.
Conforming applications shall ensure that they call unlockpt() before opening the subsidiary side of a pseudo-terminal
device.
RETURN VALUE
Upon successful completion, unlockpt() shall return 0. Otherwise, it shall return -1 and set errno to indicate the
error.
ERRORS
The unlockpt() function may fail if:
[EBADF]
The fildes argument is not a file descriptor open for writing.
[EINVAL]
The fildes argument is not associated with a manager pseudo-terminal device.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
See the RATIONALE section for posix_openpt().
FUTURE DIRECTIONS
None.
SEE ALSO
grantpt(), open(), posix_openpt(), ptsname()
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0697 [96] is applied.
Issue 8
Austin Group Defect 1466 is applied, changing the terminology used for pseudo-terminal devices.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/hypot.html =====
hypot
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
hypot, hypotf, hypotl — Euclidean distance function
SYNOPSIS
#include
double hypot(double x, double y);
float hypotf(float x, float y);
long double hypotl(long double x, long double y);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the value of the square root of
x2+y2 without undue overflow or underflow.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the length of the hypotenuse of a right-angled triangle with sides of
length x and y.
If the correct value would cause overflow, a range error shall occur and hypot(), hypotf(), and hypotl()
shall return the value of the macro HUGE_VAL, HUGE_VALF, and HUGE_VALL, respectively.
[MX]  If
x or y is ±Inf, +Inf shall be returned (even if one of x or y is NaN).
If x or y is NaN, and the other is not ±Inf, a NaN shall be returned.
[MXX]
If both arguments are subnormal and the correct result is subnormal, a range error may occur and the correct result shall be
returned.
ERRORS
These functions shall fail if:
Range Error
The result overflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall be
raised.
These functions may fail if:
Range Error
[MX]
The result underflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
See the EXAMPLES section in atan2().
APPLICATION USAGE
hypot(x,y), hypot(y,x), and hypot(x, -y) are equivalent.
hypot(x, ±0) is equivalent to fabs(x).
Underflow only happens when both x and y are subnormal and the (inexact) result is also subnormal.
These functions take precautions against overflow during intermediate steps of the computation.
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
atan2(), feclearexcept(),
fetestexcept(), isnan(),
sqrt()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The hypot() function is no longer marked as an extension.
The hypotf() and hypotl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/49 is applied, updating the EXAMPLES section.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0273 [68] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/j0.html =====
j0
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
j0, j1, jn — Bessel functions of the first kind
SYNOPSIS
[XSI]  #include
double j0(double x);
double j1(double x);
double jn(int n, double x);
DESCRIPTION
The j0(), j1(), and jn() functions shall compute Bessel functions of x of the first kind of orders
0, 1, and n, respectively.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the relevant Bessel value of x of the first kind.
If the x argument is finite and too large in magnitude, or the correct result would cause underflow [MXX]   and is not
representable,  a range error may occur, and the function shall
return [MXX]   0.0, or  (if the IEC 60559 Floating-Point option is not
supported) an implementation-defined value no greater in magnitude than DBL_MIN.
[MXX]  If
the correct result would cause underflow, and is representable, a range error may occur and the correct value shall be returned.
[MXX]
If x is +Inf, +0 shall be returned.
[MXX]
If x is NaN, a NaN shall be returned.
ERRORS
These functions may fail if:
Range Error
The value of x was too large in magnitude, or an underflow occurred.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
No other errors shall occur.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), isnan(), y0()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The may fail [EDOM] error is removed for the case for NaN.
The RETURN VALUE and ERRORS sections are reworked for alignment of the error handling with the ISO/IEC 9899:1999
standard.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0350 [68] is applied.
Issue 8
Austin Group Defect 714 is applied, changing the behavior of these functions for special cases to be a better match for their
mathematical behavior.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/ctanf.html =====
ctan
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ctan, ctanf, ctanl — complex tangent functions
SYNOPSIS
#include
double complex ctan(double complex z);
float complex ctanf(float complex z);
long double complex ctanl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex tangent of z.
RETURN VALUE
These functions shall return the complex tangent value.
[MXC]
ctan(conj(iz)), ctanf(conjf(iz)), and ctanl(conjl(iz)) shall return
exactly the same value as conj(ctan(iz)), conjf(ctanf(iz)), and
conjl(ctanl(iz)), respectively, and ctan(-iz), ctanf(-iz), and
ctanl(-iz) shall return exactly the same value as -ctan(iz), -ctanf(iz), and
-ctanl(iz), respectively, including for the special values of iz below.
If iz is +0 + i0, -i (+0 + i0) shall be returned.
If iz is 0 + iInf, -i (0 + iNaN) shall be returned and the invalid floating-point exception shall be
raised.
If iz is x + iInf where x is non-zero and finite, -i (NaN + iNaN) shall be returned
and the invalid floating-point exception shall be raised.
If iz is 0 + iNaN, -i (0 + iNaN) shall be returned.
If iz is x + iNaN where x is non-zero and finite, -i (NaN + iNaN) shall be returned
and the invalid floating-point exception may be raised.
If iz is +Inf + iy where y is positive-signed and finite, -i (1 + i0 sin(2y))
shall be returned.
If iz is +Inf + iInf, -i (1 ± i0) shall be returned; the sign of the real part of the result is
unspecified.
If iz is +Inf + iNaN, -i (1 ± i0) shall be returned; the sign of the real part of the result is
unspecified.
If iz is NaN + i0, -i (NaN + i0) shall be returned.
If iz is NaN + iy where y is any non-zero number, -i (NaN + iNaN) shall be returned and the
invalid floating-point exception may be raised.
If iz is NaN + iNaN, -i (NaN + iNaN) shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
The MXC special cases for ctan() are derived from those for ctanh() by
applying the formula ctan(z) = -ictanh(iz).
FUTURE DIRECTIONS
None.
SEE ALSO
catan(), ctanh()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fesetround.html =====
fegetround
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fegetround, fesetround — get and set current rounding direction
SYNOPSIS
#include
int fegetround(void);
int fesetround(int round);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The fegetround() function shall get the current rounding direction.
The fesetround() function shall establish the rounding direction represented by its argument round. If the
argument is not equal to the value of a rounding direction macro, the rounding direction is not changed.
RETURN VALUE
The fegetround() function shall return the value of the rounding direction macro representing the current rounding
direction or a negative value if there is no such rounding direction macro or the current rounding direction is not
determinable.
The fesetround() function shall return a zero value if and only if the requested rounding direction was established.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
The following example saves, sets, and restores the rounding direction, reporting an error and aborting if setting the rounding
direction fails:
#include
#include
void f(int round_dir)
{
#pragma STDC FENV_ACCESS ON
int save_round;
int setround_ok;
save_round = fegetround();
setround_ok = fesetround(round_dir);
assert(setround_ok == 0);
/* ... */
fesetround(save_round);
/* ... */
}
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
ISO/IEC 9899:1999 standard, Technical Corrigendum 1 is incorporated.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/logl.html =====
log
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
log, logf, logl — natural logarithm function
SYNOPSIS
#include
double log(double x);
float logf(float x);
long double logl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the natural logarithm of their argument x,
loge(x).
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the natural logarithm of x.
If x is ±0, a pole error shall occur and log(), logf(), and logl() shall return -HUGE_VAL,
-HUGE_VALF, and -HUGE_VALL, respectively.
For finite values of x that are less than 0, [MX]   or if x is -Inf,  a domain error shall occur, and [MX]   either a NaN (if supported), or   an implementation-defined value shall be returned.
[MX]  If
x is NaN, a NaN shall be returned.
If x is 1, +0 shall be returned.
If x is +Inf, x shall be returned.
ERRORS
These functions shall fail if:
Domain Error
The finite value of x is negative, [MX]   or x is -Inf.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
Pole Error
The value of x is zero.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the divide-by-zero floating-point exception shall
be raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
exp(), feclearexcept(),
fetestexcept(), isnan(),
log10(), log1p()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
The logf() and logl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/ldexp.html =====
ldexp
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ldexp, ldexpf, ldexpl — load exponent of a floating-point number
SYNOPSIS
#include
double ldexp(double x, int exp);
float ldexpf(float x, int exp);
long double ldexpl(long double x, int exp);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the quantity x * 2exp.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return x multiplied by 2, raised to the power exp.
If these functions would cause overflow, a range error shall occur and ldexp(), ldexpf(), and ldexpl()
shall return ±HUGE_VAL, ±HUGE_VALF, and ±HUGE_VALL (according to the sign of x), respectively.
If the correct value would cause underflow, [MXX]   and is not representable,   a range error may occur, and ldexp(), ldexpf(), and ldexpl() shall return
[MXX]
0.0, or   (if IEC 60559 Floating-Point is not supported)
an implementation-defined value no greater in magnitude than DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0 or ±Inf, x shall be returned.
If exp is 0, x shall be returned.
[MXX]
If the correct value would cause underflow, and is representable, a range error may occur and the correct value shall be returned.
ERRORS
These functions shall fail if:
Range Error
The result overflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall be
raised.
These functions may fail if:
Range Error
The result underflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), frexp(), isnan()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The ldexpf() and ldexpl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0352 [68] and XSH/TC1-2008/0353 [68] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/lgammal.html =====
lgamma
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
lgamma, lgammaf, lgammal, signgam — log gamma function
SYNOPSIS
#include
double lgamma(double x);
float lgammaf(float x);
long double lgammal(long double x);
[XSI]  extern int signgam;
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute
\(
\log _e \mid \Gamma(x) \mid \text { where } \Gamma(x) \text { is defined as } \int_0^{\infty} e^{-t} t^{x-1} d t \text {. }
\)
The argument \(x\) need not be a non-positive integer \( (\Gamma(x) \) is defined over the reals,
except the non-positive integers).
[XSI]
The sign of
\( \Gamma(x) \)
shall be returned in the external integer signgam. If \(x\) is NaN,
-Inf, or a negative integer, the value of signgam is unspecified.
If concurrent calls are made to these functions, the value of signgam is indeterminate.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the logarithmic gamma of \(x\).
If \(x\) is a non-positive integer, a pole error shall occur and lgamma(), lgammaf(), and lgammal()
shall return +HUGE_VAL, +HUGE_VALF, and +HUGE_VALL, respectively.
If the correct value would cause overflow, a range error shall occur and lgamma(), lgammaf(), and lgammal()
shall return ±HUGE_VAL, ±HUGE_VALF, and ±HUGE_VALL (having the same sign as the correct value), respectively.
[MX]  If
\(x\) is NaN, a NaN shall be returned.
If \(x\) is 1 or 2, +0 shall be returned.
If \(x\) is ±Inf, +Inf shall be returned.
ERRORS
These functions shall fail if:
Pole Error
The \(x\) argument is a negative integer or zero.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If
the integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the divide-by-zero floating-point exception
shall be raised.
Range Error
The result overflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If
the integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall
be raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are
independent of each other, but at least one of them must be non-zero.
If the value of signgam will be obtained after a call to lgamma(), lgammaf(), or lgammal(), in order
to ensure that the value will not be altered by another call in a different thread, applications should either restrict calls to
these functions to be from a single thread or use a lock such as a mutex or spin lock to protect a critical section starting before
the function call and ending after the value of signgam has been obtained.
RATIONALE
Earlier versions of this standard did not require lgamma(), lgammaf(), and lgammal() to be thread-safe
because signgam was a global variable. They are now required to be thread-safe to align with the ISO C standard (which,
since the introduction of threads in 2011, requires that they avoid data races), with the exception that they need not avoid data
races when storing a value in the signgam variable. Since signgam is not specified by the ISO C standard, this
exception is not a conflict with that standard.
FUTURE DIRECTIONS
None.
SEE ALSO
exp, feclearexcept, fetestexcept, isnan
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 3.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
A note indicating that this function need not be reentrant is added to the DESCRIPTION.
Issue 6
The lgamma() function is no longer marked as an extension.
The lgammaf() and lgammal() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Functionality relating to the XSI option is marked.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
The DESCRIPTION is clarified regarding the value of signgam when \(x\) is Nan, -Inf, or a negative integer.
Issue 8
Austin Group Defect 1002 is applied, reinstating the requirement for the sign of \( \Gamma(x) \) to be
returned in signgam, which had been accidentally removed in Issue 7.
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/funlockfile.html =====
flockfile
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
flockfile, ftrylockfile, funlockfile — stdio locking functions
SYNOPSIS
[CX]  #include
void flockfile(FILE *file);
int ftrylockfile(FILE *file);
void funlockfile(FILE *file);
DESCRIPTION
These functions shall provide for explicit application-level locking of the locks associated with standard I/O streams (see
2.5 Standard I/O Streams). These functions can be used by a thread to
delineate a sequence of I/O statements that are executed as a unit.
The flockfile() function shall acquire for a thread ownership of a (FILE *) object.
The ftrylockfile() function shall acquire for a thread ownership of a (FILE *) object if the object is available;
ftrylockfile() is a non-blocking version of flockfile().
The funlockfile() function shall relinquish the ownership granted to the thread. The behavior is undefined if a thread
other than the current owner calls the funlockfile() function.
The functions shall behave as if there is a lock count associated with each (FILE *) object. This count is implicitly
initialized to zero when the (FILE *) object is created. The (FILE *) object is unlocked when the count is zero. When
the count is positive, a single thread owns the (FILE *) object. When the flockfile() function is called, if the
count is zero or if the count is positive and the caller owns the (FILE *) object, the count shall be incremented.
Otherwise, the calling thread shall be suspended, waiting for the count to return to zero. Each call to funlockfile() shall
decrement the count. This allows matching calls to flockfile() (or successful calls to ftrylockfile()) and
funlockfile() to be nested.
RETURN VALUE
None for flockfile() and funlockfile().
The ftrylockfile() function shall return zero for success and non-zero to indicate that the lock cannot be acquired.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Applications using these functions may be subject to priority inversion, as discussed in XBD 3.275 Priority Inversion.
A call to exit() can block until locked streams are unlocked because a thread having
ownership of a (FILE*) object blocks all function calls that reference that (FILE*) object (except those with names
ending in _unlocked) from other threads, including calls to exit().
Note: a FILE lock is not a file lock (see XBD 3.143 File Lock
).
RATIONALE
The flockfile() and funlockfile() functions provide an orthogonal mutual-exclusion lock for each FILE. The
ftrylockfile() function provides a non-blocking attempt to acquire a FILE lock, analogous to pthread_mutex_trylock().
These locks behave as if they are the same as those used internally by stdio for thread-safety. This both provides
thread-safety of these functions without requiring a second level of internal locking and allows functions in stdio to be
implemented in terms of other stdio functions.
Application developers and implementors should be aware that there are potential deadlock problems on FILE objects. For
example, the line-buffered flushing semantics of stdio (requested via {_IOLBF}) require that certain input operations
sometimes cause the buffered contents of implementation-defined line-buffered output streams to be flushed. If two threads each
hold the lock on the other's FILE, deadlock ensues. This type of deadlock can be avoided by acquiring FILE locks in a
consistent order. In particular, the line-buffered output stream deadlock can typically be avoided by acquiring locks on input
streams before locks on output streams if a thread would be acquiring both.
In summary, threads sharing stdio streams with other threads can use flockfile() and funlockfile() to cause
sequences of I/O performed by a single thread to be kept bundled. The only case where the use of flockfile() and
funlockfile() is required is to provide a scope protecting uses of the *_unlocked functions/macros. This moves the
cost/performance tradeoff to the optimal point.
FUTURE DIRECTIONS
None.
SEE ALSO
exit(), getc_unlocked()
XBD 3.275 Priority Inversion,
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
These functions are marked as part of the Thread-Safe Functions option.
Issue 7
The flockfile(), ftrylockfile(), and funlockfile() functions are moved from the Thread-Safe Functions
option to the Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0140 [118] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0116 [611] is applied.
Issue 8
Austin Group Defect 1118 is applied, clarifying that a FILE lock is not a file lock.
Austin Group Defect 1302 is applied, replacing parts of the text with a reference to 2.5 Standard I/O Streams.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sscanf.html =====
fscanf
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fscanf, scanf, sscanf — convert formatted input
SYNOPSIS
#include
int fscanf(FILE *restrict stream, const char *restrict format, ...);
int scanf(const char *restrict format, ...);
int sscanf(const char *restrict s, const char *restrict format, ...);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The fscanf() function shall read from the named input stream. The scanf() function shall read from the
standard input stream stdin. The sscanf() function shall read from the string s. Each function reads bytes,
interprets them according to a format, and stores the results in its arguments. Each expects, as arguments, a control string
format described below, and a set of pointer arguments indicating where the converted input should be stored. The
result is undefined if there are insufficient arguments for the format. If the format is exhausted while arguments remain, the
excess arguments shall be evaluated but otherwise ignored.
[CX]
Conversions can be applied to the nth argument after the format in the argument list, rather than to the next unused
argument. In this case, the conversion specifier character % (see below) is replaced by the sequence
"%n$", where n is a decimal integer in the range [1,{NL_ARGMAX}]. This feature provides for the
definition of format strings that select arguments in an order appropriate to specific languages. In format strings containing the
"%n$" form of conversion specifications, it is unspecified whether numbered arguments in the argument list
can be referenced from the format string more than once.
The format can contain either form of a conversion specification—that is, % or "%n$"—but the
two forms cannot be mixed within a single format string. The only exception to this is that %% or %* can be mixed
with the "%n$" form. When numbered argument specifications are used, specifying the Nth argument
requires that all the leading arguments, from the first to the (N-1)th, are pointers.
The fscanf() function in all its forms shall allow detection of a language-dependent radix character in the input string.
The radix character is defined in the current locale (category LC_NUMERIC ). In the POSIX locale, or in a locale where the
radix character is not defined, the radix character shall default to a  ('.').
The application shall ensure that the format is a character string, beginning and ending in its initial shift state, if any,
composed of zero or more directives. Each directive is composed of one of the following: one or more white-space bytes; an ordinary
character (neither '%' nor a white-space byte); or a conversion specification. Each conversion specification is introduced
by the character '%' [CX]   or the character sequence "%n$",   after which the following appear in sequence:
An optional assignment-suppressing character '*'.
An optional non-zero decimal integer that specifies the maximum field width.
[CX]  An
optional assignment-allocation character 'm'.
An option length modifier that specifies the size of the receiving object.
A conversion specifier character that specifies the type of conversion to be applied. The valid conversion specifiers are
described below.
The fscanf() functions shall execute each directive of the format in turn. When all directives have been executed, or if
a directive fails (as detailed below), the function shall return. Failures are described as input failures (due to the
unavailability of input bytes) or matching failures (due to inappropriate input).
A directive composed of one or more white-space bytes shall be executed by reading input up to the first non-white-space byte,
which shall remain unread, or until no more bytes can be read. The directive shall never fail.
A directive that is an ordinary character shall be executed as follows: the next byte shall be read from the input and compared
with the byte that comprises the directive; if the comparison shows that they are not equivalent, the directive shall fail, and the
differing and subsequent bytes shall remain unread. Similarly, if end-of-file, an encoding error, or a read error prevents a
character from being read, the directive shall fail.
A directive that is a conversion specification defines a set of matching input sequences, as described below for each conversion
character. A conversion specification shall be executed in the following steps.
Input white-space bytes shall be skipped, unless the conversion specification includes a [, c, C, or
n conversion specifier.
An item shall be read from the input, unless the conversion specification includes an n conversion specifier. An input
item shall be defined as the longest sequence of input bytes (up to any specified maximum field width, which may be measured in
characters or bytes dependent on the conversion specifier) which is an initial subsequence of a matching sequence. The first byte,
if any, after the input item shall remain unread. If the length of the input item is 0, the execution of the conversion
specification shall fail; this condition is a matching failure, unless end-of-file, an encoding error, or a read error prevented
input from the stream, in which case it is an input failure.
Except in the case of a % conversion specifier, the input item (or, in the case of a %n conversion
specification, the count of input bytes) shall be converted to a type appropriate to the conversion character. If the input item is
not a matching sequence, the execution of the conversion specification fails; this condition is a matching failure. Unless
assignment suppression was indicated by a '*', the result of the conversion shall be placed in the object pointed to by
the first argument following the format argument that has not already received a conversion result if the conversion
specification is introduced by %, [CX]   or in the nth argument if introduced by the character
sequence "%n$".  If this object does not
have an appropriate type, or if the result of the conversion cannot be represented in the space provided, the behavior is
undefined.
[CX]  The
c, s, and [ conversion specifiers shall accept an optional assignment-allocation character 'm',
which shall cause a memory buffer to be allocated to hold the conversion results. If the conversion specifier is s or
[, the allocated buffer shall include space for a terminating null character (or wide character). In such a case, the
argument corresponding to the conversion specifier should be a reference to a pointer variable that will receive a pointer to the
allocated buffer. The system shall allocate a buffer as if malloc() had been called.
The application shall be responsible for freeing the memory after usage. If there is insufficient memory to allocate a buffer, the
function shall set errno to [ENOMEM] and a conversion error shall result. If the function returns EOF, any memory
successfully allocated for parameters using assignment-allocation character 'm' by this call shall be freed before the
function returns.
The length modifiers and their meanings are:
hh
Specifies that a following d, i, o, u, x, X, or n conversion
specifier applies to an argument with type pointer to signed char or unsigned char.
h
Specifies that a following d, i, o, u, x, X, or n conversion
specifier applies to an argument with type pointer to short or unsigned short.
l (ell)
Specifies that a following d, i, o, u, x, X, or n conversion
specifier applies to an argument with type pointer to long or unsigned long; that a following a, A,
e, E, f, F, g, or G conversion specifier applies to an argument with type
pointer to double; or that a following c, s, or [ conversion specifier applies to an argument
with type pointer to wchar_t. [CX]   If the 'm' assignment-allocation character is specified, the conversion applies to
an argument with the type pointer to a pointer to wchar_t.
ll (ell-ell)
Specifies that a following d, i, o, u, x, X, or n conversion
specifier applies to an argument with type pointer to long long or unsigned long long.
j
Specifies that a following d, i, o, u, x, X, or n conversion
specifier applies to an argument with type pointer to intmax_t or uintmax_t.
z
Specifies that a following d, i, o, u, x, X, or n conversion
specifier applies to an argument with type pointer to size_t or the corresponding signed integer type.
t
Specifies that a following d, i, o, u, x, X, or n conversion
specifier applies to an argument with type pointer to ptrdiff_t or the corresponding unsigned type.
L
Specifies that a following a, A, e, E, f, F, g, or G
conversion specifier applies to an argument with type pointer to long double.
If a length modifier appears with any conversion specifier other than as specified above, the behavior is undefined.
The following conversion specifiers are valid:
d
Matches an optionally signed decimal integer, whose format is the same as expected for the subject sequence of strtol() with the value 10 for the base argument. In the absence of a size modifier,
the application shall ensure that the corresponding argument is a pointer to int.
i
Matches an optionally signed integer, whose format is the same as expected for the subject sequence of strtol() with 0 for the base argument. In the absence of a size modifier, the
application shall ensure that the corresponding argument is a pointer to int.
o
Matches an optionally signed octal integer, whose format is the same as expected for the subject sequence of strtoul() with the value 8 for the base argument. In the absence of a size modifier,
the application shall ensure that the corresponding argument is a pointer to unsigned.
u
Matches an optionally signed decimal integer, whose format is the same as expected for the subject sequence of strtoul() with the value 10 for the base argument. In the absence of a size modifier,
the application shall ensure that the corresponding argument is a pointer to unsigned.
x
Matches an optionally signed hexadecimal integer, whose format is the same as expected for the subject sequence of strtoul() with the value 16 for the base argument. In the absence of a size modifier,
the application shall ensure that the corresponding argument is a pointer to unsigned.
a, e, f, g
Matches an optionally signed floating-point number, infinity, or NaN, whose format is the same as expected for the subject sequence
of strtod(). In the absence of a size modifier, the application shall ensure that the
corresponding argument is a pointer to float.
If the fprintf() family of functions generates character string representations
for infinity and NaN (a symbolic entity encoded in floating-point format) to support IEEE Std 754-1985, the
fscanf() family of functions shall recognize them as input.
s
Matches a sequence of bytes that are not white-space bytes. If the 'm' assignment-allocation character is not
specified, the application shall ensure that the corresponding argument is a pointer to the initial byte of an array of
char, signed char, or unsigned char large enough to accept the sequence and a terminating null character code,
which shall be added automatically. [CX]   Otherwise, the application shall ensure that the corresponding argument is a pointer to a
pointer to a char.
If an l (ell) qualifier is present, the input is a sequence of characters that begins in the initial shift state. Each
character shall be converted to a wide character as if by a call to the mbrtowc()
function, with the conversion state described by an mbstate_t object initialized to zero before the first character is
converted. If the 'm' assignment-allocation character is not specified, the application shall ensure that the
corresponding argument is a pointer to an array of wchar_t large enough to accept the sequence and the terminating null wide
character, which shall be added automatically. [CX]   Otherwise, the application shall ensure that the corresponding
argument is a pointer to a pointer to a wchar_t.
[
Matches a non-empty sequence of bytes from a set of expected bytes (the scanset). The normal skip over white-space bytes
shall be suppressed in this case. If the 'm' assignment-allocation character is not specified, the application shall
ensure that the corresponding argument is a pointer to the initial byte of an array of char, signed char, or
unsigned char large enough to accept the sequence and a terminating null byte, which shall be added automatically.
[CX]
Otherwise, the application shall ensure that the corresponding argument is a pointer to a pointer to a char.
If an l (ell) qualifier is present, the input is a sequence of characters that begins in the initial shift state. Each
character in the sequence shall be converted to a wide character as if by a call to the mbrtowc() function, with the conversion state described by an mbstate_t object
initialized to zero before the first character is converted. If the 'm' assignment-allocation character is not specified,
the application shall ensure that the corresponding argument is a pointer to an array of wchar_t large enough to accept the
sequence and the terminating null wide character, which shall be added automatically.
[CX]
Otherwise, the application shall ensure that the corresponding argument is a pointer to a pointer to a wchar_t.
The conversion specification includes all subsequent bytes in the format string up to and including the matching
(']'). The bytes between the square brackets (the scanlist) comprise the scanset,
unless the byte after the  is a  ('^'), in which case the scanset contains
all bytes that do not appear in the scanlist between the  and the . If the conversion
specification begins with "[]" or "[^]", the  is included in the scanlist and the
next  is the matching  that ends the conversion specification; otherwise,
the first  is the one that ends the conversion specification. If a '-' is in the scanlist and
is not the first character, nor the second where the first character is a '^', nor the last character, the behavior is
implementation-defined.
c
Matches a sequence of bytes of the number specified by the field width (1 if no field width is present in the conversion
specification). No null byte is added. The normal skip over white-space bytes shall be suppressed in this case. If the 'm'
assignment-allocation character is not specified, the application shall ensure that the corresponding argument is a pointer to the
initial byte of an array of char, signed char, or unsigned char large enough to accept the sequence.
[CX]
Otherwise, the application shall ensure that the corresponding argument is a pointer to a pointer to a char.
If an l (ell) qualifier is present, the input shall be a sequence of characters that begins in the initial shift state.
Each character in the sequence is converted to a wide character as if by a call to the mbrtowc() function, with the conversion state described by an mbstate_t object
initialized to zero before the first character is converted. No null wide character is added. If the 'm'
assignment-allocation character is not specified, the application shall ensure that the corresponding argument is a pointer to an
array of wchar_t large enough to accept the resulting sequence of wide characters. [CX]   Otherwise, the
application shall ensure that the corresponding argument is a pointer to a pointer to a wchar_t.
p
Matches an implementation-defined set of sequences, which shall be the same as the set of sequences that is produced by the
%p conversion specification of the corresponding fprintf() functions. The
application shall ensure that the corresponding argument is a pointer to a pointer to void. The interpretation of the input
item is implementation-defined. If the input item is a value converted earlier during the same program execution, the pointer that
results shall compare equal to that value; otherwise, the behavior of the %p conversion specification is undefined.
n
No input is consumed. The application shall ensure that the corresponding argument is a pointer to the integer into which shall
be written the number of bytes read from the input so far by this call to the fscanf() functions. Execution of a %n
conversion specification shall not increment the assignment count returned at the completion of execution of the function. No
argument shall be converted, but one shall be consumed. If the conversion specification includes an assignment-suppressing
character or a field width, the behavior is undefined.
C
[XSI]
Equivalent to lc.
S
[XSI]
Equivalent to ls.
%
Matches a single '%' character; no conversion or assignment occurs. The complete conversion specification shall be
%%.
If a conversion specification is invalid, the behavior is undefined.
The conversion specifiers A, E, F, G, and X are also valid and shall be equivalent
to a, e, f, g, and x, respectively.
If end-of-file is encountered during input, conversion shall be terminated. If end-of-file occurs before any bytes matching the
current conversion specification (except for %n) have been read (other than leading white-space bytes, where permitted),
execution of the current conversion specification shall terminate with an input failure. Otherwise, unless execution of the current
conversion specification is terminated with a matching failure, execution of the following conversion specification (if any) shall
be terminated with an input failure.
Reaching the end of the string in sscanf() shall be equivalent to encountering end-of-file for fscanf().
If conversion terminates on a conflicting input, the offending input is left unread in the input. Any trailing white-space bytes
(including  characters) shall be left unread unless matched by a conversion specification. The success of literal
matches and suppressed assignments is only directly determinable via the %n conversion specification.
[CX]  The
fscanf() and scanf() functions may mark the last data access timestamp of the file associated with stream for
update. The last data access timestamp shall be marked for update by the first successful execution of fgetc(), fgets(), fread(), getc(), getchar(), getdelim(), getline(), fscanf(), or scanf() using stream that returns data not
supplied by a prior call to ungetc().
RETURN VALUE
Upon successful completion, these functions shall return the number of successfully matched and assigned input items; this
number can be zero in the event of an early matching failure. If the input ends before the first conversion (if any) has completed,
and without a matching failure having occurred, EOF shall be returned. If an error occurs before the first conversion (if any) has
completed, and without a matching failure having occurred, EOF shall be returned [CX]   and
errno shall be set to indicate the error.   If an error
occurs, the error indicator for the stream shall be set.
ERRORS
For the conditions under which the fscanf() functions fail and may fail, refer to fgetc() or fgetwc().
In addition, the fscanf() function shall fail if:
[EILSEQ]
[CX]
Input byte sequence does not form a valid character.
[ENOMEM]
Insufficient storage space is available.
In addition, the fscanf() function may fail if:
[EINVAL]
[CX]
There are insufficient arguments.
The following sections are informative.
EXAMPLES
The call:
int i, n; float x; char name[50];
n = scanf("%d%f%s", &i, &x, name);
with the input line:
25 54.32E-1 Hamster
assigns to n the value 3, to i the value 25, to x the value 5.432, and name contains the string
"Hamster".
The call:
int i; float x; char name[50];
(void) scanf("%2d%f%*d %[0123456789]", &i, &x, name);
with input:
56789 0123 56a72
assigns 56 to i, 789.0 to x, skips 0123, and places the string "56\0" in name. The next call to
getchar() shall return the character 'a'.
Reading Data into an Array
The following call uses fscanf() to read three floating-point numbers from standard input into the input
array.
float input[3]; fscanf (stdin, "%f %f %f", input, input+1, input+2);
APPLICATION USAGE
If the application calling fscanf() has any objects of type wint_t or wchar_t, it must also include the
header to have these objects defined.
For functions that allocate memory as if by malloc(), the application should
release such memory when it is no longer required by a call to free(). For
fscanf(), this is memory allocated via use of the 'm' assignment-allocation character.
RATIONALE
The set of characters allowed in a scanset is limited to single-byte characters. In other similar places, multi-byte characters
have been permitted, but for alignment with the ISO C standard, it has not been done here. Applications needing this could use
the corresponding wide-character functions to achieve the desired results.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, fprintf(), getc(), setlocale(), strtod(), strtol(), strtoul(), wcrtomb()
XBD 7. Locale, , ,
,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
Aligned with ISO/IEC 9899:1990/Amendment 1:1995 (E). Specifically, the l (ell) qualifier is now defined for the
c, s, and [ conversion specifiers.
The DESCRIPTION is updated to indicate that if infinity and NaN can be generated by the fprintf() family of functions, then they are recognized by the fscanf() family.
Issue 6
The Open Group Corrigenda U021/7 and U028/10 are applied. These correct several occurrences of "characters" in the text which
have been replaced with the term "bytes".
The normative text is updated to avoid use of the term "must" for application requirements.
The following changes are made for alignment with the ISO/IEC 9899:1999 standard:
The prototypes for fscanf(), scanf(), and sscanf() are updated.
The DESCRIPTION is updated.
The hh, ll, j, t, and z length modifiers are added.
The a, A, and F conversion characters are added.
The DESCRIPTION is updated to use the terms "conversion specifier" and "conversion specification" consistently.
Issue 7
Austin Group Interpretation 1003.1-2001 #170 is applied.
SD5-XSH-ERN-9 is applied, correcting fscanf() to scanf() in the DESCRIPTION.
SD5-XSH-ERN-132 is applied, adding the assignment-allocation character 'm'.
Functionality relating to the %n$ form of conversion specification is moved from the XSI option to the Base.
Changes are made related to support for finegrained timestamps.
The APPLICATION USAGE section is updated to clarify that memory is allocated as if by malloc().
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0185 [302], XSH/TC1-2008/0186 [90], and XSH/TC1-2008/0187 [14] are applied.
XSH/TC1-2008/0186 [90] changes the second sentence in the RETURN VALUE section to align with expected wording changes in the next
revision of the ISO C standard.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0135 [936] is applied.
Issue 8
Austin Group Defect 1163 is applied, clarifying the handling of white space in the format string.
Austin Group Defect 1173 is applied, clarifying the description of the assignment-allocation character 'm'.
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
Austin Group Defect 1375 is applied, changing "terminating null character" to "terminating null character (or wide
character)".
Austin Group Defect 1562 is applied, clarifying that it is the application's responsibility to ensure that the format is a
character string, beginning and ending in its initial shift state, if any.
Austin Group Defect 1624 is applied, changing the RETURN VALUE section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/scalblnf.html =====
scalbln
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
scalbln, scalblnf, scalblnl, scalbn, scalbnf, scalbnl — compute exponent using FLT_RADIX
SYNOPSIS
#include
double scalbln(double x, long n);
float scalblnf(float x, long n);
long double scalblnl(long double x, long n);
double scalbn(double x, int n);
float scalbnf(float x, int n);
long double scalbnl(long double x, int n);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute x * FLT_RADIXn efficiently, not normally by
computing FLT_RADIXn explicitly.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return x * FLT_RADIXn.
[MX]  If
the calculation does not overflow or underflow, the returned value shall be exact and shall be independent of the current rounding
direction mode.
If the result would cause overflow, a range error shall occur and these functions shall return ±HUGE_VAL, ±HUGE_VALF, and
±HUGE_VALL (according to the sign of x) as appropriate for the return type of the function.
If the correct value would cause underflow, [MXX]   and is not representable,   a range error may occur, and scalbln(), scalblnf(), scalblnl(),
scalbn(), scalbnf(), and scalbnl() shall return [MXX]
0.0, or   (if IEC 60559 Floating-Point is not supported) an implementation-defined value no greater in
magnitude than DBL_MIN, FLT_MIN, LDBL_MIN, DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0 or ±Inf, x shall be returned.
If n is 0, x shall be returned.
[MXX]
If the correct value would cause underflow, and is representable, a range error may occur and the correct value shall be returned.
ERRORS
These functions shall fail if:
Range Error
The result overflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall be
raised.
These functions may fail if:
Range Error
The result underflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
These functions are named so as to avoid conflicting with the historical definition of the scalb() function from the
Single UNIX Specification. The difference is that the scalb() function has a second argument of double instead of
int. The scalb() function is not part of the ISO C standard. The three functions whose second type is
long are provided because the factor required to scale from the smallest positive floating-point value to the largest finite
one, on many implementations, is too large to represent in the minimum-width int format.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0521 [68] and XSH/TC1-2008/0522 [68] are applied.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/daylight.html =====
tzset
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
daylight, timezone, tzname, tzset — set timezone conversion information
SYNOPSIS
#include
[XSI]  extern int daylight;
extern long timezone;
[CX]  extern char *tzname[2];
void tzset(void);
DESCRIPTION
The tzset() function shall use the value of the environment variable TZ to set time conversion information used by
ctime(), localtime(), mktime(), and strftime(). If TZ is
absent from the environment, implementation-defined default timezone information shall be used.
The tzset() function shall set the external variable tzname as follows:
tzname[0] = "std";
tzname[1] = "dst";
where std and dst are as described in XBD 8. Environment
Variables.
[XSI]
The tzset() function also shall set the external variable daylight to 0 if Daylight Saving Time conversions should
never be applied for the timezone in use; otherwise, non-zero. The external variable timezone shall be set to the
difference, in seconds, between Coordinated Universal Time (UTC) and local standard time.
If a thread accesses tzname, [XSI]  daylight, or timezone   directly while another thread is in a call to tzset(), or to any function that is
required or allowed to set timezone information as if by calling tzset(), the behavior is undefined.
RETURN VALUE
The tzset() function shall not return a value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
Example TZ variables and their timezone differences are given in the table below:
TZ
timezone
EST5EDT
5*60*60
GMT0
0*60*60
JST-9
-9*60*60
MET-1MEST
-1*60*60
MST7MDT
7*60*60
PST8PDT
8*60*60
APPLICATION USAGE
Since the ctime(), localtime(),
mktime(), strftime(), and strftime_l() functions are required to set timezone information as if by calling
tzset(), there is no need for an explicit tzset() call before using these functions. However, portable applications
should call tzset() explicitly before using localtime_r() because setting
timezone information is optional for that function.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
ctime(), localtime(), mktime(), strftime()
XBD 8. Environment Variables,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The example is corrected.
Issue 7
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0377 [880] is applied.
Issue 8
Austin Group Defect 1253 is applied, changing "Daylight Savings" to "Daylight Saving".
Austin Group Defect 1410 is applied, removing the ctime_r() function.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_condattr_getpshared.html =====
pthread_condattr_getpshared
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_condattr_getpshared, pthread_condattr_setpshared — get and set the process-shared condition variable
attributes
SYNOPSIS
[TSH]  #include
int pthread_condattr_getpshared(const pthread_condattr_t *restrict attr,
int *restrict pshared);
int pthread_condattr_setpshared(pthread_condattr_t *attr,
int pshared);
DESCRIPTION
The pthread_condattr_getpshared() function shall obtain the value of the process-shared attribute from the
attributes object referenced by attr.
The pthread_condattr_setpshared() function shall set the process-shared attribute in an initialized attributes
object referenced by attr.
The process-shared attribute is set to PTHREAD_PROCESS_SHARED to permit a condition variable to be operated upon by any
thread that has access to the memory where the condition variable is allocated, even if the condition variable is allocated in
memory that is shared by multiple processes. See 2.9.9 Synchronization Object
Copies and Alternative Mappings for further requirements. The default value of the attribute is
PTHREAD_PROCESS_PRIVATE.
The behavior is undefined if the value specified by the attr argument to pthread_condattr_getpshared() or
pthread_condattr_setpshared() does not refer to an initialized condition variable attributes object.
RETURN VALUE
If successful, the pthread_condattr_setpshared() function shall return zero; otherwise, an error number shall be returned
to indicate the error.
If successful, the pthread_condattr_getpshared() function shall return zero and store the value of the
process-shared attribute of attr into the object referenced by the pshared parameter. Otherwise, an error
number shall be returned to indicate the error.
ERRORS
The pthread_condattr_setpshared() function may fail if:
[EINVAL]
The new value specified for the attribute is outside the range of legal values for that attribute.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
If an implementation detects that the value specified by the attr argument to pthread_condattr_getpshared() or
pthread_condattr_setpshared() does not refer to an initialized condition variable attributes object, it is recommended that
the function should fail and report an [EINVAL] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_create(), pthread_cond_destroy(), pthread_condattr_destroy(), pthread_mutex_destroy()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
The pthread_condattr_getpshared() and pthread_condattr_setpshared() functions are marked as part of the Threads
and Thread Process-Shared Synchronization options.
The restrict keyword is added to the pthread_condattr_getpshared() prototype for alignment with the
ISO/IEC 9899:1999 standard.
Issue 7
The pthread_condattr_getpshared() and pthread_condattr_setpshared() functions are marked only as part of the
Thread Process-Shared Synchronization option as the Threads option is now part of the Base.
The [EINVAL] error for an uninitialized condition variable attributes object is removed; this condition results in undefined
behavior.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0272 [972] and XSH/TC2-2008/0273 [757] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sem_wait.html =====
sem_trywait
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sem_trywait, sem_wait — lock a semaphore
SYNOPSIS
#include
int sem_trywait(sem_t *sem);
int sem_wait(sem_t *sem);
DESCRIPTION
The sem_trywait() function shall lock the semaphore referenced by sem only if the semaphore is currently not
locked; that is, if the semaphore value is currently positive. Otherwise, it shall not lock the semaphore.
The sem_wait() function shall lock the semaphore referenced by sem by performing a semaphore lock operation on
that semaphore. If the semaphore value is currently zero, then the calling thread shall not return from the call to
sem_wait() until it either locks the semaphore or the call is interrupted by a signal.
Upon successful return, the state of the semaphore shall be locked and shall remain locked until the sem_post() function is executed and returns successfully.
The sem_wait() function is interruptible by the delivery of a signal.
RETURN VALUE
The sem_trywait() and sem_wait() functions shall return zero if the calling process successfully performed the
semaphore lock operation on the semaphore designated by sem. If the call was unsuccessful, the state of the semaphore shall
be unchanged, and the function shall return a value of -1 and set errno to indicate the error.
ERRORS
The sem_trywait() function shall fail if:
[EAGAIN]
The semaphore was already locked, so it cannot be immediately locked by the sem_trywait() operation.
The sem_trywait() and sem_wait() functions may fail if:
[EDEADLK]
A deadlock condition was detected.
[EINTR]
A signal interrupted this function.
[EINVAL]
The sem argument does not refer to a valid semaphore.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Applications using these functions may be subject to priority inversion, as discussed in XBD 3.275 Priority Inversion.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
semctl(), semget(), semop(), sem_clockwait(), sem_post()
XBD 3.275 Priority Inversion, 4.15.2 Memory Synchronization,
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Issue 6
The sem_trywait() and sem_wait() functions are marked as part of the Semaphores option.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Semaphores
option.
The sem_timedwait() function is added to the SEE ALSO section for alignment
with IEEE Std 1003.1d-1999.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/121 is applied, updating the ERRORS section so that the [EINVAL]
error becomes optional.
Issue 7
SD5-XSH-ERN-54 is applied, removing the sem_wait() function from the "shall fail" error cases.
The sem_trywait() and sem_wait() functions are moved from the Semaphores option to the Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0530 [37] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wcslcpy.html =====
wcslcat
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wcslcat, wcslcpy — size-bounded wide string concatenation and copying
SYNOPSIS
[CX]  #include
size_t wcslcat(wchar_t *restrict dst, const wchar_t *restrict src,
size_t dstsize);
size_t wcslcpy(wchar_t *restrict dst, const wchar_t *restrict src,
size_t dstsize);
DESCRIPTION
The wcslcpy() and wcslcat() functions copy and concatenate wide strings, stopping when either a terminating null
wide-character code in the source wide string is encountered or the specified full size (in wide-character codes) of the
destination buffer is reached. They null terminate the result if there is room. The application should ensure that room for the
terminating null wide-character code is included in dstsize.
The wcslcpy() function shall copy not more than dstsize - 1 wide-character codes from the wide string pointed to
by src to the array pointed to by dst; a terminating null wide-character code in src and wide-character codes
that follow it shall not be copied. A terminating null wide-character code shall be appended to the result, unless dstsize
is 0. If copying takes place between objects that overlap, the behavior is undefined.
The wcslcat() function shall append not more than dstsize - wcslen(dst) - 1 wide-character codes
from the wide string pointed to by src to the end of the wide string pointed to by dst; a terminating null
wide-character code in src and wide-character codes that follow it shall not be appended. The initial wide-character code of
src shall overwrite the null wide-character code at the end of dst. A terminating null wide-character code shall be
appended to the result, unless its location would be at or beyond dst + dstsize. If copying takes place between
objects that overlap, the behavior is undefined.
The wcslcpy() and wcslcat() functions shall not change the setting of errno on valid input.
RETURN VALUE
Upon successful completion, the wcslcpy() function shall return the length of the wide string pointed to by src;
that is, the number of wide-character codes in the wide string, not including the terminating null wide-character code.
Upon successful completion, the wcslcat() function shall return the initial length of the wide string pointed to by
dst plus the length of the wide string pointed to by src.
No return values are reserved to indicate an error.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The return value of the wcslcpy() and wcslcat() functions follows the same convention as snprintf(); that is, they return the total length (in wide-character codes) of the wide
string they tried to create. If the return value is greater than or equal to dstsize, the output wide string has been
truncated.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
fprintf(), strlcat(), wcslen(), wcsncat(), wcsncpy()
XBD
CHANGE HISTORY
First released in Issue 8.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/putenv.html =====
putenv
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
putenv — change or add a value to an environment
SYNOPSIS
[XSI]  #include
int putenv(char *string);
DESCRIPTION
The putenv() function shall use the string argument to set, or optionally unset, an environment variable
value:
If the string argument points to a string of the form "name=value", where name is a valid name, the
putenv() function shall make the value of the environment variable with that name equal to value by altering an
existing variable or creating a new one. In either case, the string pointed to by string shall become part of the
environment, so altering the string shall change the environment.
If the string argument points to a string containing a valid name, the putenv() function shall either remove the
environment variable with that name (if it exists) from the environment or fail with errno set to [EINVAL].
Otherwise, the behavior is unspecified.
The putenv() function need not be thread-safe.
RETURN VALUE
Upon successful completion, putenv() shall return 0; otherwise, it shall return a non-zero value and set errno to
indicate the error.
ERRORS
The putenv() function may fail if:
[EINVAL]
The string argument points to a string that is not of the form "name=value", where name is a valid
name.
[ENOMEM]
Insufficient memory was available.
The following sections are informative.
EXAMPLES
Changing the Value of an Environment Variable
The following example changes the value of the HOME environment variable to the value /usr/home.
#include
...
static char *var = "HOME=/usr/home";
int ret;
ret = putenv(var);
APPLICATION USAGE
The putenv() function manipulates the environment pointed to by environ, and can be used in conjunction with
getenv().
See exec() for restrictions on changing the environment in multi-threaded
applications.
This routine may use malloc() to enlarge the environment.
A potential error is to call putenv() with an automatic variable as the argument, then return from the calling function
while string is still part of the environment.
Although the space used by string is no longer used once a new string which defines name is passed to
putenv(), if any thread in the application has used getenv() to retrieve a
pointer to this variable, it should not be freed by calling free(). If the changed
environment variable is one known by the system (such as the locale environment variables) the application should never free the
buffer used by earlier calls to putenv() for the same variable.
The setenv() function is preferred over this function. One reason is that
putenv() is optional and therefore less portable. Another is that using putenv() can slow down environment searches,
as explained in the RATIONALE section for getenv().
RATIONALE
Refer to the RATIONALE section in setenv().
FUTURE DIRECTIONS
None.
SEE ALSO
exec, free(), getenv(), malloc(), setenv()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The type of the argument to this function is changed from const char * to char *. This was indicated as a FUTURE
DIRECTION in previous issues.
A note indicating that this function need not be reentrant is added to the DESCRIPTION.
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/48 is applied, clarifying wording in the DESCRIPTION and adding
a new paragraph into APPLICATION USAGE referring readers to exec.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0472 [167], XSH/TC1-2008/0473 [167], XSH/TC1-2008/0474 [273,438], and
XSH/TC1-2008/0475 [273] are applied.
Issue 8
Austin Group Defect 1598 is applied, specifying the allowed behaviors when the string argument points to a string
containing a valid name.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/setregid.html =====
setregid
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
setregid — set real and effective group IDs
SYNOPSIS
[XSI]  #include
int setregid(gid_t rgid, gid_t egid);
DESCRIPTION
The setregid() function shall set the real and effective group IDs of the calling process.
If rgid is -1, the real group ID shall not be changed; if egid is -1, the effective group ID shall not be
changed.
The real and effective group IDs may be set to different values in the same call.
Only a process with appropriate privileges can set the real group ID and the effective group ID to any valid value.
A non-privileged process can set either the real group ID to the saved set-group-ID from one of the exec family of functions, or the effective group ID to the saved set-group-ID or the real group
ID.
If the real group ID is being set (rgid is not -1), or the effective group ID is being set to a value not equal to the
real group ID, then the saved set-group-ID of the current process shall be set equal to the new effective group ID.
Any supplementary group IDs of the calling process remain unchanged.
RETURN VALUE
Upon successful completion, 0 shall be returned. Otherwise, -1 shall be returned and errno set to indicate the error, and
neither of the group IDs are changed.
ERRORS
The setregid() function shall fail if:
[EINVAL]
The value of the rgid or egid argument is invalid or out-of-range.
[EPERM]
The process does not have appropriate privileges and a change other than changing the real group ID to the saved set-group-ID,
or changing the effective group ID to the real group ID or the saved set-group-ID, was requested.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
If a non-privileged set-group-ID process sets its effective group ID to its real group ID, it can only set its effective group
ID back to the previous value if rgid was -1 in the setregid() call, since the saved-group-ID is not changed in that
case. If rgid was equal to the real group ID in the setregid() call, then the saved set-group-ID will also have been
changed to the real user ID.
RATIONALE
Earlier versions of this standard did not specify whether the saved set-group-ID was affected by setregid() calls. This
version specifies common existing practice that constitutes an important security feature. The ability to set both the effective
group ID and saved set-group-ID to be the same as the real group ID means that any security weakness in code that is executed after
that point cannot result in malicious code being executed with the previous effective group ID. Privileged applications could
already do this using just setgid(), but for non-privileged applications the only
standard method available is to use this feature of setregid().
FUTURE DIRECTIONS
None.
SEE ALSO
exec, getegid(), geteuid(), getgid(), getresgid(), getresuid(), getuid(), setegid(), seteuid(), setgid(), setresgid(), setresuid(), setreuid(), setuid()
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
The DESCRIPTION is updated to indicate that the saved set-group-ID can be set by any of the exec family of functions, not just execve().
Issue 7
SD5-XSH-ERN-177 is applied, adding the ability to set both the effective group ID and saved set-group-ID to be the same as the
real group ID.
Issue 8
Austin Group Defect 1344 is applied, adding getresgid(), getresuid(), setresgid(), and setresuid() to SEE ALSO.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/nanosleep.html =====
nanosleep
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
nanosleep — high resolution sleep
SYNOPSIS
[CX]  #include
int nanosleep(const struct timespec *rqtp, struct timespec *rmtp);
DESCRIPTION
The nanosleep() function shall cause the current thread to be suspended from execution until either the time interval
specified by the rqtp argument has elapsed or a signal is delivered to the calling thread, and its action is to invoke a
signal-catching function or to terminate the process. The suspension time may be longer than requested because the argument value
is rounded up to an integer multiple of the sleep resolution or because of the scheduling of other activity by the system. But,
except for the case of being interrupted by a signal, the suspension time shall not be less than the time specified by rqtp,
as measured by the system clock CLOCK_REALTIME.
The use of the nanosleep() function has no effect on the action or blockage of any signal.
RETURN VALUE
If the nanosleep() function returns because the requested time has elapsed, its return value shall be zero.
If the nanosleep() function returns because it has been interrupted by a signal, it shall return a value of -1 and set
errno to indicate the interruption. If the rmtp argument is non-NULL, the timespec structure referenced by it
is updated to contain the amount of time remaining in the interval (the requested time minus the time actually slept). The
rqtp and rmtp arguments can point to the same object. If the rmtp argument is NULL, the remaining time is not
returned.
If nanosleep() fails, it shall return a value of -1 and set errno to indicate the error.
ERRORS
The nanosleep() function shall fail if:
[EINTR]
The nanosleep() function was interrupted by a signal.
[EINVAL]
The rqtp argument specified a nanosecond value less than zero or greater than or equal to 1000 million.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
It is common to suspend execution of a thread for an interval in order to poll the status of a non-interrupting function. A
large number of actual needs can be met with a simple extension to sleep() that
provides finer resolution.
In the POSIX.1-1990 standard and SVR4, it is possible to implement such a routine, but the frequency of wakeup is limited by the
resolution of the alarm() and sleep()
functions. In 4.3 BSD, it is possible to write such a routine using no static storage and reserving no system facilities. Although
it is possible to write a function with similar functionality to sleep() using the
remainder of the timer_*() functions, such a function requires the use of signals and the reservation of some signal number.
This volume of POSIX.1-2024 requires that nanosleep() be non-intrusive of the signals function.
The nanosleep() function shall return a value of 0 on success and -1 on failure or if interrupted. This latter case is
different from sleep(). This was done because the remaining time is returned via an
argument structure pointer, rmtp, instead of as the return value.
FUTURE DIRECTIONS
None.
SEE ALSO
clock_nanosleep(), sleep()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Issue 6
The nanosleep() function is marked as part of the Timers option.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Timers
option.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/37 is applied, updating the SEE ALSO section to include the
clock_nanosleep() function.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/63 is applied, correcting text in the RATIONALE section.
Issue 7
SD5-XBD-ERN-33 is applied.
The nanosleep() function is moved from the Timers option to the Base.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0231 [909] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/isspace_l.html =====
isspace
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
isspace, isspace_l — test for a white-space character
SYNOPSIS
#include
int isspace(int c);
[CX]  int isspace_l(int c, locale_t locale);
DESCRIPTION
For isspace(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The isspace() [CX]   and isspace_l()
functions shall test whether c is a character of class space in the current locale, [CX]   or in the
locale represented by locale,  respectively; see XBD 7. Locale.
The c argument is an int, the value of which the application shall ensure is a character representable as an
unsigned char or equal to the value of the macro EOF. If the argument has any other value, the behavior is undefined.
[CX]  The
behavior is undefined if the locale argument to isspace_l() is the special locale object LC_GLOBAL_LOCALE or is not a
valid locale object handle.
RETURN VALUE
The isspace() [CX]   and isspace_l()
functions shall return non-zero if c is a white-space character; otherwise, they shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
To ensure applications portability, especially across natural languages, only these functions and the functions in the reference
pages listed in the SEE ALSO section should be used for character classification.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
isalnum(), isalpha(), iscntrl(), isdigit(), isgraph(), islower(), isprint(), ispunct(), isupper(), isxdigit(), setlocale(), uselocale()
XBD 7. Locale, ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
The isspace_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0303 [302], XSH/TC1-2008/0304 [283], and XSH/TC1-2008/0305 [283] are
applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wctrans.html =====
wctrans
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wctrans, wctrans_l — define character mapping
SYNOPSIS
#include
wctrans_t wctrans(const char *charclass);
[CX]  wctrans_t wctrans_l(const char *charclass, locale_t locale);
DESCRIPTION
For wctrans(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The wctrans() [CX]   and wctrans_l()
functions are defined for valid character mapping names identified in the current locale. The charclass is a string
identifying a generic character mapping name for which codeset-specific information is required. The following character mapping
names are defined in all locales: tolower and toupper.
These functions shall return a value of type wctrans_t, which can be used as the second argument to subsequent calls of
towctrans() [CX]   and towctrans_l().
The wctrans() [CX]   and wctrans_l()
functions shall determine values of wctrans_t according to the rules of the coded character set defined by character
mapping information in the current locale [CX]   or in the locale represented by locale,   respectively (category LC_CTYPE ).
The values returned by wctrans() shall be valid until a call to setlocale() that modifies the category LC_CTYPE .
[CX]  The
values returned by wctrans_l() shall be valid only in calls to towctrans_l() with a locale represented by locale with the same LC_CTYPE
category value.
The behavior is undefined if the locale argument to wctrans_l() is the special locale object LC_GLOBAL_LOCALE or
is not a valid locale object handle.
RETURN VALUE
The wctrans() [CX]   and wctrans_l()
functions shall return 0 and may set errno to indicate the error if the given character mapping name is not valid for
the current locale (category LC_CTYPE ); otherwise, they shall return a non-zero object of type wctrans_t that can be
used in calls to towctrans() [CX]   and towctrans_l().
ERRORS
These functions may fail if:
[EINVAL]
[CX]
The character mapping name pointed to by charclass is not valid in the current locale.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
towctrans()
XBD
CHANGE HISTORY
First released in Issue 5. Derived from ISO/IEC 9899:1990/Amendment 1:1995 (E).
Issue 7
The wctrans_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0732 [302], XSH/TC1-2008/0733 [289], XSH/TC1-2008/0734 [283], and
XSH/TC1-2008/0735 [283] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getlocalename_l.html =====
getlocalename_l
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getlocalename_l — get a locale name from a locale object
SYNOPSIS
[CX]  #include
const char *getlocalename_l(int category, locale_t locobj);
DESCRIPTION
If category is not LC_ALL, the getlocalename_l() function shall return the locale name for the given locale
category of the locale object locobj, or of the global locale if locobj is the special locale object
LC_GLOBAL_LOCALE.
If category is LC_ALL, the getlocalename_l() function shall return a string that encodes the locale settings for
all locale categories of the locale object locobj, or of the global locale if locobj is the special locale object
LC_GLOBAL_LOCALE, in the same form as is returned by setlocale(). The string
returned is such that a subsequent call to setlocale(), from the same process,
with a pointer to that string as locale and the LC_ALL category shall set the global locale to the same locale for
each category as was present in the queried object.
If the value of the category argument is neither LC_ALL nor a supported locale category value (see setlocale()), getlocalename_l() shall fail.
The behavior is undefined if the locobj argument is neither the special locale object LC_GLOBAL_LOCALE nor a valid locale
object handle.
RETURN VALUE
Upon successful completion, getlocalename_l() shall return a pointer to a string; otherwise, a null pointer shall be
returned.
If locobj is LC_GLOBAL_LOCALE, the returned string pointer might be invalidated or the string content might be
overwritten by a subsequent call in the same thread to getlocalename_l() with LC_GLOBAL_LOCALE; the returned string pointer
might also be invalidated if the calling thread is terminated. Otherwise, the returned string pointer and content shall remain
valid until the locale object locobj is used in a call to freelocale() or
as the base argument in a successful call to newlocale().
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
Determining the locale name for a category of the current locale
The following example shows how to obtain the locale name for the LC_NUMERIC category of the current thread-local locale, or of
the global locale if no thread-local locale is in use.
#include
...
const char *name;
locale_t loc = uselocale(NULL);
name = getlocalename_l(LC_NUMERIC, loc);
APPLICATION USAGE
In addition to the caveats regarding validity of the returned string pointer in RETURN VALUE, the content of the string returned
when category is LC_ALL is only required to be valid for the life of the process, so is not intended for storage or sharing
between processes. As the internal format of the string is implementation-specific, there is nothing preventing a subsequent run of
an application from being presented a different format, for example if the implementation is updated.
RATIONALE
Historical versions of getlocalename_l() did not handle the special locale object LC_GLOBAL_LOCALE, requiring that
applications used setlocale(category, NULL) to query the global locale if uselocale(NULL) returned
LC_GLOBAL_LOCALE. However, since setlocale() is not required to be thread-safe
(even when the only concurrent calls are ones that query the locale), this method was problematic for multi-threaded processes.
This standard requires that getlocalename_l(category, LC_GLOBAL_LOCALE) queries the global locale in a thread-safe
manner, for example by returning a pointer to a thread-local internal buffer instead of a process-wide internal buffer.
FUTURE DIRECTIONS
None.
SEE ALSO
freelocale(), newlocale()
, setlocale(), uselocale()
XBD 7. Locale,
CHANGE HISTORY
First released in Issue 8.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/expf.html =====
exp
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
exp, expf, expl — exponential function
SYNOPSIS
#include
double exp(double x);
float expf(float x);
long double expl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the base-e exponential of x.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the exponential value of x.
If the correct value would cause overflow, a range error shall occur and exp(), expf(), and expl() shall
return the value of the macro HUGE_VAL, HUGE_VALF, and HUGE_VALL, respectively.
If the correct value would cause underflow, [MXX]   and is not representable,  a range error may occur, and exp(), expf(), and expl() shall return [MXX]   0.0, or
(if the IEC 60559 Floating-Point option is not supported) an
implementation-defined value no greater in magnitude than DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0, 1 shall be returned.
If x is -Inf, +0 shall be returned.
If x is +Inf, x shall be returned.
[MXX]
If the correct value would cause underflow, and is representable, a range error may occur and the correct value shall be returned.
ERRORS
These functions shall fail if:
Range Error
The result overflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall be
raised.
These functions may fail if:
Range Error
The result underflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
Computing the Density of the Standard Normal Distribution
This function shows an implementation for the density of the standard normal distribution using exp(). This example uses
the constant M_PI which is part of the XSI option.
#include
double
normal_density (double x)
{
return exp(-x*x/2) / sqrt (2*M_PI);
}
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), isnan(), log()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The expf() and expl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/26 is applied, adding the example to the EXAMPLES section.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0106 [68] and XSH/TC1-2008/0107 [68] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0101 [630] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/signbit.html =====
signbit
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
signbit — test sign
SYNOPSIS
#include
int signbit(real-floating x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The signbit() macro shall determine whether the sign of its argument value is negative. NaNs, zeros, and infinities have
a sign bit.
RETURN VALUE
The signbit() macro shall return a non-zero value if and only if the sign of its argument value is negative.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
fpclassify(), isfinite(),
isinf(), isnan(), isnormal()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/va_arg.html =====
va_arg
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
va_arg, va_copy, va_end, va_start — handle variable argument list
SYNOPSIS
#include
type va_arg(va_list ap, type);
void va_copy(va_list dest, va_list src);
void va_end(va_list ap);
void va_start(va_list ap, argN);
DESCRIPTION
Refer to XBD
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/hypotf.html =====
hypot
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
hypot, hypotf, hypotl — Euclidean distance function
SYNOPSIS
#include
double hypot(double x, double y);
float hypotf(float x, float y);
long double hypotl(long double x, long double y);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the value of the square root of
x2+y2 without undue overflow or underflow.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the length of the hypotenuse of a right-angled triangle with sides of
length x and y.
If the correct value would cause overflow, a range error shall occur and hypot(), hypotf(), and hypotl()
shall return the value of the macro HUGE_VAL, HUGE_VALF, and HUGE_VALL, respectively.
[MX]  If
x or y is ±Inf, +Inf shall be returned (even if one of x or y is NaN).
If x or y is NaN, and the other is not ±Inf, a NaN shall be returned.
[MXX]
If both arguments are subnormal and the correct result is subnormal, a range error may occur and the correct result shall be
returned.
ERRORS
These functions shall fail if:
Range Error
The result overflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall be
raised.
These functions may fail if:
Range Error
[MX]
The result underflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
See the EXAMPLES section in atan2().
APPLICATION USAGE
hypot(x,y), hypot(y,x), and hypot(x, -y) are equivalent.
hypot(x, ±0) is equivalent to fabs(x).
Underflow only happens when both x and y are subnormal and the (inexact) result is also subnormal.
These functions take precautions against overflow during intermediate steps of the computation.
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
atan2(), feclearexcept(),
fetestexcept(), isnan(),
sqrt()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The hypot() function is no longer marked as an extension.
The hypotf() and hypotl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/49 is applied, updating the EXAMPLES section.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0273 [68] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fcntl.html =====
fcntl
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fcntl — file control
SYNOPSIS
#include
int fcntl(int fildes, int cmd, ...);
DESCRIPTION
The fcntl() function shall perform the operations described below on open files. The fildes argument is a file
descriptor.
The available values for cmd are defined in  and are as
follows:
F_DUPFD
Return a new file descriptor which shall be allocated as described in 2.6
File Descriptor Allocation, except that it shall be the lowest numbered available file descriptor greater than or equal to
the third argument, arg, taken as an integer of type int. The new file descriptor shall refer to the same open file
description as the original file descriptor, and shall share any locks. The FD_CLOEXEC and FD_CLOFORK flags associated with the new
file descriptor shall be cleared.
F_DUPFD_CLOEXEC
Like F_DUPFD, but the FD_CLOEXEC flag associated with the new file descriptor shall be set.
F_DUPFD_CLOFORK
Like F_DUPFD, but the FD_CLOFORK flag associated with the new file descriptor shall be set.
F_GETFD
Get the file descriptor flags defined in  that are associated with
the file descriptor fildes. File descriptor flags are associated with a single file descriptor and do not affect other file
descriptors that refer to the same file.
F_SETFD
Set the file descriptor flags defined in , that are associated
with fildes, to the third argument, arg, taken as type int. If the FD_CLOEXEC flag in the third argument is
set, the file descriptor shall be closed upon successful execution of an exec family
function [SPN]  and in the new process image created by posix_spawn() or posix_spawnp();
otherwise, the file descriptor shall remain open. If the FD_CLOFORK flag in the third argument is set, the file descriptor shall
not be inherited by any child process created from a process that has the file descriptor open; otherwise, the file descriptor
shall be inherited.
F_GETFL
Get the file status flags and file access modes, defined in , for
the file description associated with fildes. The file access modes can be extracted from the return value using the mask
O_ACCMODE, which is defined in . File status flags and file access
modes are associated with the file description and do not affect other file descriptors that refer to the same file with different
open file descriptions. The flags returned may include non-standard file status flags which the application did not set, provided
that these additional flags do not alter the behavior of a conforming application.
F_SETFL
Set the file status flags, defined in , for the file description
associated with fildes from the corresponding bits in the third argument, arg, taken as type int. Bits
corresponding to the file access mode and the file creation flags, as defined in , that are set in arg shall be ignored. If any bits in arg other
than those mentioned here are changed by the application, the result is unspecified. If fildes does not support non-blocking
operations, it is unspecified whether the O_NONBLOCK flag will be ignored.
F_GETOWN
If fildes refers to a socket, get the process ID or process group ID specified to receive SIGURG signals when
out-of-band data is available. Positive values shall indicate a process ID; negative values, other than -1, shall indicate a
process group ID; the value zero shall indicate that no SIGURG signals are to be sent. If fildes does not refer to a socket,
the results are unspecified.
F_SETOWN
If fildes refers to a socket, atomically set the process ID or process group ID specified to receive SIGURG signals when
out-of-band data is available, using the value of the third argument, arg, taken as type int. Positive values shall
indicate a process ID; negative values, other than -1, shall indicate a process group ID; the value zero shall indicate that no
SIGURG signals are to be sent. If fildes does not refer to a socket, the results are unspecified.
F_GETOWN_EX
If fildes refers to a socket, get the process ID or process group ID specified to receive SIGURG signals when
out-of-band data is available, by setting the type and pid members of the f_owner_ex structure pointed to by
the third argument, arg. The value of type shall be F_OWNER_PID or F_OWNER_PGRP to indicate that pid contains
a process ID or a process group ID, respectively. The value of pid shall be zero if no SIGURG signals are to be sent. If
fildes does not refer to a socket, the results are unspecified.
F_SETOWN_EX
If fildes refers to a socket, set the process ID or process group ID specified to receive SIGURG signals when
out-of-band data is available, using the value of the third argument, arg, taken as type pointer to struct
f_owner_ex. The type and pid members of this structure shall be used as follows:
A pid value of zero shall indicate that no SIGURG signals are to be sent.
A type value of F_OWNER_PID and a positive pid value shall indicate that SIGURG signals are to be sent to the
process ID specified in pid.
A type value of F_OWNER_PGRP and a positive pid value shall indicate that SIGURG signals are to be sent to the
process group ID specified in pid.
If fildes does not refer to a socket, the results are unspecified.
For F_SETOWN and F_SETOWN_EX, each time a SIGURG signal is sent to the specified process or process group, permission checks
equivalent to those performed by kill() shall be performed, as if kill() were called by a process with the same real user ID, effective user ID, and privileges
that the process calling fcntl() has at the time of the call; if the kill() call
would fail, no signal shall be sent. These permission checks may also be performed by the fcntl() call. If the process
specified by arg later terminates, or the process group specified by arg later becomes empty, while still being
specified to receive SIGURG signals when out-of-band data is available from fildes, then no signals shall be sent to any
subsequently created process that has the same process ID or process group ID, regardless of permission; it is unspecified whether
this is achieved by the equivalent of a fcntl(fildes, F_SETOWN, 0) call at the time the process terminates or is
waited for or the process group becomes empty, or by other means.
The following values for cmd are available for advisory record locking. Record locking shall be supported for regular
files, and may be supported for other files.
F_GETLK
Get any lock which blocks the process-owned file lock description pointed to by the third argument, arg, taken as a
pointer to type struct flock, defined in . The information
retrieved shall overwrite the information passed to fcntl() in the structure flock. If no lock is found that would
prevent this lock from being created, then the structure shall be left unchanged except for the lock type in l_type which
shall be set to F_UNLCK.
F_SETLK
Set or clear a process-owned file lock according to the lock description pointed to by the third argument, arg, taken as
a pointer to type struct flock, defined in . F_SETLK can
establish shared (or read) locks (F_RDLCK) or exclusive (or write) locks (F_WRLCK), as well as remove either type of lock
(F_UNLCK). F_RDLCK, F_WRLCK, and F_UNLCK are defined in . If a shared
or exclusive lock cannot be set, fcntl() shall return immediately with a return value of -1.
F_SETLKW
This command shall be equivalent to F_SETLK except that if a shared or exclusive lock is blocked by other locks, the thread
shall wait until the request can be satisfied. If a signal that is to be caught is received while fcntl() is waiting for a
region, fcntl() shall be interrupted. Upon return from the signal handler, fcntl() shall return -1 with errno
set to [EINTR], and the lock operation shall not be done.
F_OFD_GETLK
Get any lock which blocks the OFD-owned file lock description pointed to by the third argument, arg, taken as a pointer
to type struct flock, defined in ; the application shall ensure
that the l_pid member of the structure pointed to by arg is set to 0 on input. The information retrieved shall
overwrite the information passed to fcntl() in the structure flock. If no lock is found that would prevent this lock
from being created, then the structure shall be left unchanged except for the lock type in l_type which shall be set to
F_UNLCK.
F_OFD_SETLK
Set or clear an OFD-owned file lock according to the lock description pointed to by the third argument, arg, taken as a
pointer to type struct flock, defined in ; the application
shall ensure that the l_pid member of the structure pointed to by arg is set to 0 on input. F_OFD_SETLK can establish
shared (or read) locks (F_RDLCK) or exclusive (or write) locks (F_WRLCK), as well as remove either type of lock (F_UNLCK). F_RDLCK,
F_WRLCK, and F_UNLCK are defined in . If a shared or exclusive lock
cannot be set, fcntl() shall return immediately with a return value of -1.
F_OFD_SETLKW
This command shall be equivalent to F_OFD_SETLK except that if a shared or exclusive lock is blocked by other locks, the thread
shall wait until the request can be satisfied. If a signal that is to be caught is received while fcntl() is waiting for a
region, fcntl() shall be interrupted. Upon return from the signal handler, fcntl() shall return -1 with errno
set to [EINTR], and the lock operation shall not be done.
Additional implementation-defined values for cmd may be defined in . Their names shall start with F_.
When a shared lock is set on a segment of a file, other processes can set shared process-owned locks, and other open file
descriptions can be used to set shared OFD-owned locks, on that segment or a portion of it. A shared process-owned lock shall
prevent any other process from setting an exclusive process-owned lock, and shall prevent any exclusive OFD-owned lock from being
set, on any portion of the protected area. A shared OFD-owned lock shall prevent any other open file description from being used to
set an exclusive OFD-owned lock, and shall prevent any exclusive process-owned lock from being set, on any portion of the protected
area. A request for a shared lock shall fail if the file descriptor is not open for reading.
An exclusive process-owned lock shall prevent any other process from setting a shared or exclusive process-owned lock, and shall
prevent any shared or exclusive OFD-owned lock from being set, on any portion of the protected area. An exclusive OFD-owned lock
shall prevent any other open file description from being used to set a shared or exclusive OFD-owned lock, and shall prevent any
shared or exclusive process-owned lock from being set, on any portion of the protected area. A request for an exclusive lock shall
fail if the file descriptor is not open for writing.
The structure flock describes the type (l_type), starting offset (l_whence), relative offset
(l_start), size (l_len), and process ID (l_pid) of the segment of the file to be affected.
The value of l_whence is SEEK_SET, SEEK_CUR, or SEEK_END, to indicate that the relative offset l_start bytes shall
be measured from the start of the file, current position, or end of the file, respectively. The value of l_len is the number
of consecutive bytes to be locked. The value of l_len may be negative (where the definition of off_t permits negative
values of l_len). On input, the l_pid field shall be ignored for F_GETLK, F_SETLK and F_SETLKW; the application shall
ensure that it is set to zero for F_OFD_GETLK, F_OFD_SETLK and F_OFD_SETLKW. It is set by F_GETLK and F_OFD_GETLK when identifying
a blocking lock. After a successful F_GETLK or F_OFD_GETLK request, when a blocking lock is found, the values returned in the
flock structure shall be as follows:
l_type
Type of blocking lock found.
l_whence
SEEK_SET.
l_start
Start of the blocking lock.
l_len
Length of the blocking lock.
l_pid
Process ID of the process that holds the blocking lock if the blocking lock is a process-owned file lock, or (pid_t)-1
if the blocking lock is an OFD-owned file lock.
If the command is F_SETLKW or F_OFD_SETLKW and the thread needs to wait for a blocking lock to be released, then the range of
bytes to be locked shall be determined before the fcntl() function blocks. If the file size or file descriptor seek offset
change while fcntl() is blocked, this shall not affect the range of bytes locked.
If l_len is positive, the area affected shall start at l_start and end at l_start+l_len-1. If
l_len is negative, the area affected shall start at l_start+l_len and end at l_start-1. Locks may start
and extend beyond the current end of a file, but shall not extend before the beginning of the file. A lock shall be set to extend
to the largest possible value of the file offset for that file by setting l_len to 0. If such a lock also has l_start
set to 0 and l_whence is set to SEEK_SET, the whole file shall be locked.
Each byte in the file can be locked either with one or more shared locks (F_RDLCK) or with one exclusive lock (F_WRLCK).
Before a successful return from an F_SETLK or an F_SETLKW request when the calling process has previously existing process-owned
locks on bytes in the region specified by the request, the previous shared or exclusive lock for each byte in the specified region
shall be replaced by the new shared or exclusive lock. An F_SETLK or an F_SETLKW request (respectively) shall fail or block when
another process has existing process-owned locks, or any open file description (including the one associated with fildes)
has existing OFD-owned locks, on bytes in the specified region and any of those locks conflicts with the requested lock.
Before a successful return from an F_OFD_SETLK or an F_OFD_SETLKW request when the open file description associated with fildes
has previously existing OFD-owned locks on bytes in the region specified by the request, the previous shared or exclusive lock for
each byte in the specified region shall be replaced by the new shared or exclusive lock. An F_OFD_SETLK or an F_OFD_SETLKW request
(respectively) shall fail or block when another open file description has existing OFD-owned locks, or any process (including the
calling process) has existing process-owned locks, on bytes in the specified region and any of those locks conflicts with the
requested lock.
All process-owned locks associated with a file for a given process shall be removed when any file descriptor for that file is
closed by that process (even if via a different open file description) or the process holding that file descriptor terminates.
Process-owned locks shall not be inherited by a child process.
All OFD-owned locks associated with a given open file description shall be removed when all file descriptors associated with
that open file description have been closed (either directly or as a side-effect of, for example, process termination or
FD_CLOEXEC). OFD-owned locks shall be shared across all file descriptors that are associated with the owning open file description,
regardless of which process holds the file descriptor.
A potential for deadlock occurs if a process or thread controlling a locked region is put to sleep by attempting to lock a
region that has an existing conflicting lock. If the system detects that sleeping until a locked region is unlocked would cause a
deadlock, fcntl() shall fail with an [EDEADLK] error. Deadlock detection may differ between process-owned locks and
OFD-owned locks.
[XSI]
The interaction between fcntl() and lockf() locks is unspecified.
An unlock (F_UNLCK) request in which l_len is non-zero and the offset of the last byte of the requested segment is the
maximum value for an object of type off_t, when the process (for F_SETLK and F_SETLKW) or open file description (for
F_OFD_SETLK and F_OFD_SETLKW) has an existing lock in which l_len is 0 and which includes the last byte of the requested
segment, shall be treated as a request to unlock from the start of the requested segment with an l_len equal to 0.
Otherwise, an unlock (F_UNLCK) request shall attempt to unlock only the requested segment.
[SHM]
When the file descriptor fildes refers to a shared memory object, the behavior of fcntl() shall be the same as for a
regular file except the effect of the following values for the argument cmd is unspecified: F_SETFL, F_GETLK, F_SETLK,
F_SETLKW, F_OFD_GETLK, F_OFD_SETLK, and F_OFD_SETLKW.
[TYM]
If fildes refers to a typed memory object, the result of the fcntl() function is unspecified.
RETURN VALUE
Upon successful completion, the value returned shall depend on cmd as follows:
F_DUPFD
A new file descriptor.
F_DUPFD_CLOEXEC
A new file descriptor.
F_DUPFD_CLOFORK
A new file descriptor.
F_GETFD
Value of flags defined in . The return value shall not be
negative.
F_SETFD
Value other than -1.
F_GETFL
Value of file status flags and access modes. The return value shall not be negative.
F_SETFL
Value other than -1.
F_GETLK
Value other than -1.
F_SETLK
Value other than -1.
F_SETLKW
Value other than -1.
F_OFD_GETLK
Value other than -1.
F_OFD_SETLK
Value other than -1.
F_OFD_SETLKW
Value other than -1.
F_GETOWN
Value of the socket owner process or process group; this shall not be -1.
F_SETOWN
Value other than -1.
F_GETOWN_EX
Value other than -1.
F_SETOWN_EX
Value other than -1.
Otherwise, -1 shall be returned and errno set to indicate the error.
ERRORS
The fcntl() function shall fail if:
[EACCES] or [EAGAIN]
The cmd argument is F_SETLK, the type of lock (l_type) is a shared (F_RDLCK) or exclusive (F_WRLCK) lock, and the
requested lock cannot be set because it is blocked by an existing lock on the file.
[EAGAIN]
The cmd argument is F_OFD_SETLK, the type of lock (l_type) is a shared (F_RDLCK) or exclusive (F_WRLCK) lock, and
the requested lock cannot be set because it is blocked by an existing lock on the file.
[EBADF]
The fildes argument is not a valid open file descriptor; or the argument cmd is F_SETLK, F_SETLKW, F_OFD_SETLK,
or F_OFD_SETLKW, the type of lock, l_type, is a shared lock (F_RDLCK), and fildes is not a valid file descriptor open
for reading, or the type of lock, l_type, is an exclusive lock (F_WRLCK), and fildes is not a valid file descriptor
open for writing.
[EINTR]
The cmd argument is F_SETLKW or F_OFD_SETLKW and the function was interrupted by a signal.
[EINVAL]
The cmd argument is invalid; or the cmd argument is F_DUPFD, F_DUPFD_CLOEXEC, or F_DUPFD_CLOFORK and arg
is negative or is greater than or equal to {OPEN_MAX}; or the cmd argument is F_SETOWN_EX and the type member of the
f_owner_ex structure pointed to by arg is invalid, or the pid member is negative and the type member is
F_OWNER_PID or F_OWNER_PGRP; or the cmd argument is F_GETLK, F_SETLK, F_SETLKW, F_OFD_GETLK, F_OFD_SETLK, or F_OFD_SETLKW
and the data pointed to by arg is not valid, or fildes refers to a file that does not support locking.
[EMFILE]
The argument cmd is F_DUPFD, F_DUPFD_CLOEXEC, or F_DUPFD_CLOFORK and all file descriptors available to the process are
currently open, or no file descriptors greater than or equal to arg are available.
[ENOLCK]
The argument cmd is F_SETLK, F_SETLKW, F_OFD_SETLK, or F_OFD_SETLKW and satisfying the lock or unlock request would
result in the number of locked regions in the system exceeding a system-imposed limit.
[EOVERFLOW]
One of the values to be returned cannot be represented correctly.
[EOVERFLOW]
The cmd argument is F_GETLK, F_SETLK, F_SETLKW, F_OFD_GETLK, F_OFD_SETLK, or F_OFD_SETLKW and the smallest or, if
l_len is non-zero, the largest offset of any byte in the requested segment cannot be represented correctly in an object of
type off_t.
[ESRCH]
The cmd argument is F_SETOWN or F_SETOWN_EX and no process or process group can be found corresponding to that specified
by arg.
The fcntl() function may fail if:
[EDEADLK]
The cmd argument is F_SETLKW or F_OFD_SETLKW, the type of lock (l_type) is a shared (F_RDLCK) or exclusive
(F_WRLCK) lock, the requested lock is blocked by an existing lock on the file, and the system determines that waiting for that lock
to be released would cause a deadlock.
[EINVAL]
The cmd argument is F_SETOWN and the value of arg is positive and is not valid as a process ID or the value of
arg is negative and its absolute value is not valid as a process group ID; or the cmd argument is F_SETOWN_EX, the
value of the type member of the f_owner_ex structure pointed to by arg is F_OWNER_PID, and the value of the
pid member is not valid as a process ID; or the cmd argument is F_SETOWN_EX, the value of the type member of
the f_owner_ex structure pointed to by arg is F_OWNER_PGRP, and the value of the pid member is not valid as a
process group ID.
[EPERM]
The cmd argument is F_SETOWN or F_SETOWN_EX and the calling process does not have permission to send a SIGURG signal to
any process specified by arg.
The following sections are informative.
EXAMPLES
Locking and Unlocking a File
The following example demonstrates how to place a lock on bytes 100 to 109 of a file and then later remove it. F_SETLK is used
to perform a non-blocking lock request so that the process does not have to wait if an incompatible lock is held by another
process; instead the process can take some other action.
#include
#include
#include
#include
#include
int
main(int argc, char *argv[])
{
int fd;
struct flock fl;
fd = open("testfile", O_RDWR);
if (fd == -1)
/* Handle error */;
/* Make a non-blocking request to place a write lock
on bytes 100-109 of testfile */
fl.l_type = F_WRLCK;
fl.l_whence = SEEK_SET;
fl.l_start = 100;
fl.l_len = 10;
if (fcntl(fd, F_SETLK, &fl) == -1) {
if (errno == EACCES || errno == EAGAIN) {
printf("Already locked by another process\n");
/* We cannot get the lock at the moment */
} else {
/* Handle unexpected error */;
}
} else { /* Lock was granted... */
/* Perform I/O on bytes 100 to 109 of file */
/* Unlock the locked bytes */
fl.l_type = F_UNLCK;
fl.l_whence = SEEK_SET;
fl.l_start = 100;
fl.l_len = 10;
if (fcntl(fd, F_SETLK, &fl) == -1)
/* Handle error */;
}
exit(EXIT_SUCCESS);
} /* main */
Setting the Close-on-Exec Flag
The following example demonstrates how to set the close-on-exec flag for the file descriptor fd.
#include
#include
...
int flags;
flags = fcntl(fd, F_GETFD);
if (flags == -1)
/* Handle error */;
flags |= FD_CLOEXEC;
if (fcntl(fd, F_SETFD, flags) == -1)
/* Handle error */;"
APPLICATION USAGE
The arg values to F_GETFD, F_SETFD, F_GETFL, and F_SETFL all represent flag values to allow for future growth.
Applications using these functions should do a read-modify-write operation on them, rather than assuming that only the values
defined by this volume of POSIX.1-2024 are valid. It is a common error to forget this, particularly in the case of F_SETFD. Some
implementations set additional file status flags to advise the application of default behavior, even though the application did not
request these flags.
In order to set both FD_CLOEXEC and FD_CLOFORK when duplicating a file descriptor, applications should use F_DUPFD_CLOFORK to
obtain the new file descriptor with FD_CLOFORK already set, and then use F_SETFD to set the FD_CLOEXEC flag on the new descriptor.
(The alternative of first using F_DUPFD_CLOEXEC and then setting FD_CLOFORK with F_SETFD has a timing window where another thread
could create a child process which inherits the new descriptor because FD_CLOFORK has not yet been set.)
The FD_CLOFORK flag takes effect for all child processes, not just those created using fork() or _Fork().
On implementations where process IDs can be greater than {INT_MAX}, F_SETOWN cannot be used with process IDs greater than
{INT_MAX} or process group IDs greater than {INT_MAX}+1 because the value is passed to fcntl() in an argument of type
int. In this situation, F_SETOWN_EX should be used instead.
Similarly, if a process ID greater than {INT_MAX} or a process group ID greater than {INT_MAX}+1 has been set to receive SIGURG
signals (using F_SETOWN_EX), F_GETOWN cannot be used to obtain the value because fcntl() returns the value as type
int and will thus give an [EOVERFLOW] error for such values. F_GETOWN_EX should be used instead.
Note that the convention of negating a process group ID is only used with F_SETOWN and F_GETOWN; the pid member of the
f_owner_ex structure used with F_SETOWN_EX and F_GETOWN_EX is not negated when it specifies a process group ID.
On systems which do not perform permission checks at the time of an fcntl() call with F_SETOWN or F_SETOWN_EX, if the
permission checks performed at the time the signal is sent disallow sending the signal to any process, the process that called
fcntl() has no way of discovering that this has happened. A call to kill() with
signal 0 can be used as a prior check of permissions, although this is no guarantee that permission will be granted at the time a
signal is sent, since the target process(es) could change user IDs or privileges in the meantime.
Record-locking should not be used in combination with buffered standard I/O streams (see 2.5 Standard I/O Streams). Instead, non-buffered I/O should be used. Unexpected
results may occur in processes that do buffering in the user address space. The process may later read/write data which is/was
locked. Functions that operate on standard I/O streams are the most common source of such buffering.
RATIONALE
The ellipsis in the SYNOPSIS is the syntax specified by the ISO C standard for a variable number of arguments. It is used
because System V uses pointers for the implementation of file locking functions.
This volume of POSIX.1-2024 permits concurrent read and write access to file data using the fcntl() function; this is a
change from the 1984 /usr/group standard and early proposals. Without concurrency controls, this feature may not be fully utilized
without occasional loss of data.
Data losses occur in several ways. One case occurs when several processes try to update the same record, without sequencing
controls; several updates may occur in parallel and the last writer "wins". Another case is a bit-tree or other internal
list-based database that is undergoing reorganization. Without exclusive use to the tree segment by the updating process, other
reading processes chance getting lost in the database when the index blocks are split, condensed, inserted, or deleted. While
fcntl() is useful for many applications, it is not intended to be overly general and does not handle the bit-tree example
well.
This facility is only required for regular files because it is not appropriate for many devices such as terminals and network
connections.
Since fcntl() works with "any file descriptor associated with that file, however it is obtained", the file descriptor
may have been inherited through a fork() or exec operation and thus may affect a file that another process also has open.
The use of the open file description to identify what to lock requires extra calls and presents problems if several processes
are sharing an open file description, but there are too many implementations of the existing mechanism for this volume of
POSIX.1-2024 to use different specifications.
Another consequence of this model is that closing any file descriptor for a given file (whether or not it is the same open file
description that created the lock) causes the locks on that file to be relinquished for that process. Equivalently, any close for
any file/process pair relinquishes the locks owned on that file for that process. But note that while an open file description may
be shared through fork(), locks are not inherited through fork(). Yet locks may be inherited through one of the exec functions.
The identification of a machine in a network environment is outside the scope of this volume of POSIX.1-2024. Thus, an
l_sysid member, such as found in System V, is not included in the locking structure.
Changing of lock types can result in a previously locked region being split into smaller regions.
Mandatory locking was a major feature of the 1984 /usr/group standard.
For advisory file record locking to be effective, all processes that have access to a file must cooperate and use the advisory
mechanism before doing I/O on the file. Enforcement-mode record locking is important when it cannot be assumed that all processes
are cooperating. For example, if one user uses an editor to update a file at the same time that a second user executes another
process that updates the same file and if only one of the two processes is using advisory locking, the processes are not
cooperating. Enforcement-mode record locking would protect against accidental collisions.
Secondly, advisory record locking requires a process using locking to bracket each I/O operation with lock (or test) and unlock
operations. With enforcement-mode file and record locking, a process can lock the file once and unlock when all I/O operations have
been completed. Enforcement-mode record locking provides a base that can be enhanced; for example, with sharable locks. That is,
the mechanism could be enhanced to allow a process to lock a file so other processes could read it, but none of them could write
it.
Mandatory locks were omitted for several reasons:
Mandatory lock setting was done by multiplexing the set-group-ID bit in most implementations; this was confusing, at best.
The relationship to file truncation as supported in 4.2 BSD was not well specified.
Any publicly readable file could be locked by anyone. Many historical implementations keep the password database in a publicly
readable file. A malicious user could thus prohibit logins. Another possibility would be to hold open a long-distance telephone
line.
Some demand-paged historical implementations offer memory mapped files, and enforcement cannot be done on that type of file.
Since sleeping on a region is interrupted with any signal, alarm() may be used to
provide a timeout facility in applications requiring it. This is useful in deadlock detection. Since implementation of full
deadlock detection is not always feasible, the [EDEADLK] error was made optional.
The F_SETOWN_EX and F_GETOWN_EX values for cmd and the associated f_owner_ex structure were adopted from the GNU C
library. In addition to the values F_OWNER_PID and F_OWNER_PGRP for the type member, this also has F_OWNER_TID to specify
that the pid member contains a thread ID. However, this relies on thread IDs being representable in a pid_t and so
was not included in POSIX.1-2024. The aim of adding F_SETOWN_EX and F_GETOWN_EX was to address the inability of F_SETOWN and
F_GETOWN to handle process IDs greater than {INT_MAX} and process group IDs greater than {INT_MAX}+1, and this need is satisfied
without including F_OWNER_TID.
FUTURE DIRECTIONS
None.
SEE ALSO
alarm(), close(), exec, kill(), open(), sigaction()
XBD ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Realtime Extension and the POSIX Threads Extension.
Large File Summit extensions are added.
Issue 6
In the SYNOPSIS, the optional include of the  header is
removed.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The requirement to include  has been removed. Although
was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.
In the DESCRIPTION, sentences describing behavior when l_len is negative are now mandated, and the description of unlock
(F_UNLOCK) when l_len is non-negative is mandated.
In the ERRORS section, the [EINVAL] error condition has the case mandated when the cmd is invalid, and two [EOVERFLOW]
error conditions are added.
The F_GETOWN and F_SETOWN values are added for sockets.
The following changes were made to align with the IEEE P1003.1a draft standard:
Clarification is added that the extent of the bytes locked is determined prior to the blocking action.
The DESCRIPTION is updated for alignment with IEEE Std 1003.1j-2000 by specifying that fcntl() results are
unspecified for typed memory objects.
The normative text is updated to avoid use of the term "must" for application requirements.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/29 is applied, adding the example to the EXAMPLES section.
Issue 7
Austin Group Interpretation 1003.1-2001 #150 is applied, clarifying the file status flags returned when cmd is
F_GETFL.
Austin Group Interpretation 1003.1-2001 #171 is applied, adding support to set the FD_CLOEXEC flag atomically at open(), and adding the F_DUPFD_CLOEXEC flag.
The optional  header is removed from this function, since
now defines SEEK_SET, SEEK_CUR, and SEEK_END as part of the Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0116 [141] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0105 [835], XSH/TC2-2008/0106 [677], XSH/TC2-2008/0107 [484],
XSH/TC2-2008/0108 [675], and XSH/TC2-2008/0109 [675,677] are applied.
Issue 8
Austin Group Defect 695 is applied, adding an atomicity requirement to the F_SETOWN operation.
Austin Group Defects 768 and 1671 are applied, adding OFD-owned file locks.
Austin Group Defect 1203 is applied, changing some wording in the RETURN VALUE section to use "shall".
Austin Group Defects 1274 and 1670 are applied, adding F_GETOWN_EX and F_SETOWN_EX.
Austin Group Defect 1318 is applied, adding FD_CLOFORK and F_DUPFD_CLOFORK.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getrusage.html =====
getrusage
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getrusage — get information about resource utilization
SYNOPSIS
[XSI]  #include
int getrusage(int who, struct rusage *r_usage);
DESCRIPTION
The getrusage() function shall provide measures of the resources used by the current process or its terminated and
waited-for child processes. If the value of the who argument is RUSAGE_SELF, information shall be returned about resources
used by the current process. If the value of the who argument is RUSAGE_CHILDREN, information shall be returned about
resources used by the children of the current process that have terminated and been waited-for and their children that have
terminated and been waited-for, recursively. If the child is never waited for (for example, if the parent has SA_NOCLDWAIT set or
sets SIGCHLD to SIG_IGN), the resource information for the child process is discarded and not included in the resource information
provided by getrusage().
The r_usage argument is a pointer to an object of type struct rusage in which the returned information is
stored.
RETURN VALUE
Upon successful completion, getrusage() shall return 0; otherwise, -1 shall be returned and errno set to indicate
the error.
ERRORS
The getrusage() function shall fail if:
[EINVAL]
The value of the who argument is not valid.
The following sections are informative.
EXAMPLES
Using getrusage()
The following example returns information about the resources used by the current process.
#include
...
int who = RUSAGE_SELF;
struct rusage usage;
int ret;
ret = getrusage(who, &usage);
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
exit(), sigaction(),
time(), times(),
wait()
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 8
Austin Group Defect 1336 is applied, clarifying the requirements when the who argument is RUSAGE_CHILDREN.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/iswdigit.html =====
iswdigit
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
iswdigit, iswdigit_l — test for a decimal digit wide-character code
SYNOPSIS
#include
int iswdigit(wint_t wc);
[CX]  int iswdigit_l(wint_t wc, locale_t locale);
DESCRIPTION
For iswdigit(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The iswdigit() [CX]   and iswdigit_l()
functions shall test whether wc is a wide-character code representing a character of class digit in the current
locale, [CX]   or in the locale represented by locale,
respectively; see XBD 7. Locale.
The wc argument is a wint_t, the value of which the application shall ensure is a wide-character code
corresponding to a valid character in the locale used by the function, or equal to the value of the macro WEOF. If the argument has
any other value, the behavior is undefined.
[CX]  The
behavior is undefined if the locale argument to iswdigit_l() is the special locale object LC_GLOBAL_LOCALE or is not
a valid locale object handle.
RETURN VALUE
The iswdigit() [CX]   and iswdigit_l()
functions shall return non-zero if wc is a decimal digit wide-character code; otherwise, they shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
To ensure applications portability, especially across natural languages, only these functions and the functions in the reference
pages listed in the SEE ALSO section should be used for character classification.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
iswalnum(), iswalpha(),
iswcntrl(), iswctype(),
iswgraph(), iswlower(),
iswprint(), iswpunct(),
iswspace(), iswupper(),
iswxdigit(), setlocale(),
uselocale()
XBD 7. Locale, ,
CHANGE HISTORY
First released in Issue 4.
Issue 5
The following change has been made in this version for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E):
The SYNOPSIS has been changed to indicate that this function and associated data types are now made visible by inclusion of the
header rather than .
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
The iswdigit_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0323 [302], XSH/TC1-2008/0324 [283], and XSH/TC1-2008/0325 [283] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0186 [685] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_setcancelstate.html =====
pthread_setcancelstate
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_setcancelstate, pthread_setcanceltype, pthread_testcancel — set cancelability state
SYNOPSIS
#include
int pthread_setcancelstate(int state, int *oldstate);
int pthread_setcanceltype(int type, int *oldtype);
void pthread_testcancel(void);
DESCRIPTION
The pthread_setcancelstate() function shall atomically both set the calling thread's cancelability state to the indicated
state and return the previous cancelability state at the location referenced by oldstate. Legal values for
state are PTHREAD_CANCEL_ENABLE and PTHREAD_CANCEL_DISABLE.
The pthread_setcanceltype() function shall atomically both set the calling thread's cancelability type to the indicated
type and return the previous cancelability type at the location referenced by oldtype. Legal values for type
are PTHREAD_CANCEL_DEFERRED and PTHREAD_CANCEL_ASYNCHRONOUS.
The cancelability state and type of any newly created threads, including the thread in which main() was first invoked,
shall be PTHREAD_CANCEL_ENABLE and PTHREAD_CANCEL_DEFERRED respectively.
The pthread_testcancel() function shall create a cancellation point in the calling thread. The
pthread_testcancel() function shall have no effect if cancelability is disabled.
The pthread_setcancelstate() function shall be async-signal-safe.
RETURN VALUE
If successful, the pthread_setcancelstate() and pthread_setcanceltype() functions shall return zero; otherwise, an
error number shall be returned to indicate the error.
ERRORS
The pthread_setcancelstate() function may fail if:
[EINVAL]
The specified state is not PTHREAD_CANCEL_ENABLE or PTHREAD_CANCEL_DISABLE.
The pthread_setcanceltype() function may fail if:
[EINVAL]
The specified type is not PTHREAD_CANCEL_DEFERRED or PTHREAD_CANCEL_ASYNCHRONOUS.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
In order to write a signal handler for an asynchronous signal which can run safely in a cancellable thread,
pthread_setcancelstate() must be used to disable cancellation for the duration of any calls that the signal handler makes
which are cancellation points. However, earlier versions of the standard did not permit strictly conforming applications to call
pthread_setcancelstate() from a signal handler since it was not required to be async-signal-safe. On non-conforming
implementations where pthread_setcancelstate() is not async-signal-safe, alternatives are to ensure either that the
corresponding signals are blocked during execution of functions that are not async-cancel-safe or that cancellation is disabled
during times when those signals could be delivered.
RATIONALE
The pthread_setcancelstate() and pthread_setcanceltype() functions control the points at which a thread may be
asynchronously canceled. For cancellation control to be usable in modular fashion, some rules need to be followed.
An object can be considered to be a generalization of a procedure. It is a set of procedures and global variables written as a
unit and called by clients not known by the object. Objects may depend on other objects.
First, cancelability should only be disabled on entry to an object, never explicitly enabled. On exit from an object, the
cancelability state should always be restored to its value on entry to the object.
This follows from a modularity argument: if the client of an object (or the client of an object that uses that object) has
disabled cancelability, it is because the client does not want to be concerned about cleaning up if the thread is canceled while
executing some sequence of actions. If an object is called in such a state and it enables cancelability and a cancellation request
is pending for that thread, then the thread is canceled, contrary to the wish of the client that disabled.
Second, the cancelability type may be explicitly set to either deferred or asynchronous upon entry to an object.
But as with the cancelability state, on exit from an object the cancelability type should always be restored to its value on entry
to the object.
Finally, only functions that are cancel-safe may be called from a thread that is asynchronously cancelable.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_cancel()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
The pthread_setcancelstate(), pthread_setcanceltype(), and pthread_testcancel() functions are marked as
part of the Threads option.
Issue 7
The pthread_setcancelstate(), pthread_setcanceltype(), and pthread_testcancel() functions are moved from
the Threads option to the Base.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0294 [622] and XSH/TC2-2008/0295 [615] are applied.
Issue 8
Austin Group Defect 841 is applied, requiring pthread_setcancelstate() to be async-signal-safe.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/strcspn.html =====
strcspn
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
strcspn — get the length of a complementary substring
SYNOPSIS
#include
size_t strcspn(const char *s1, const char *s2);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The strcspn() function shall compute the length (in bytes) of the maximum initial segment of the string pointed to by
s1 which consists entirely of bytes not from the string pointed to by s2.
[CX]  The
strcspn() function shall not change the setting of errno on valid input.
RETURN VALUE
The strcspn() function shall return the length of the computed segment of the string pointed to by s1; no return
value is reserved to indicate an error.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
strspn()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The RETURN VALUE section is updated to indicate that strcspn() returns the length of s1, and not s1 itself
as was previously stated.
Issue 6
The Open Group Corrigendum U030/1 is applied. The text of the RETURN VALUE section is updated to indicate that the computed
segment length is returned, not the s1 length.
Issue 8
Austin Group Defect 448 is applied, adding a requirement that strcspn() does not change the setting of errno on
valid input.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fdimf.html =====
fdim
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fdim, fdimf, fdiml — compute positive difference between two floating-point numbers
SYNOPSIS
#include
double fdim(double x, double y);
float fdimf(float x, float y);
long double fdiml(long double x, long double y);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall determine the positive difference between their arguments. If x is greater than y,
x-y is returned. If x is less than or equal to y, +0 is returned.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the positive difference value.
If x-y is positive and overflows, a range error shall occur and fdim(), fdimf(), and fdiml()
shall return the value of the macro HUGE_VAL, HUGE_VALF, and HUGE_VALL, respectively.
If the correct value would cause underflow, a range error may occur, and fdim(), fdimf(), and fdiml() shall
return [MXX]   the correct value, or   (if the IEC 60559
Floating-Point option is not supported) an implementation-defined value no greater in magnitude than DBL_MIN, FLT_MIN, and
LDBL_MIN, respectively.
[MX]  If
x or y is NaN, a NaN shall be returned.
ERRORS
The fdim() function shall fail if:
Range Error
The result overflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall be
raised.
The fdim() function may fail if:
Range Error
The result underflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), fmax(), fmin()
4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0119 [68,428] and XSH/TC1-2008/0120 [68,428] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/putc.html =====
putc
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
putc — put a byte on a stream
SYNOPSIS
#include
int putc(int c, FILE *stream);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The putc() function shall be equivalent to fputc(), except that if it is
implemented as a macro it may evaluate stream more than once, so the argument should never be an expression with
side-effects.
RETURN VALUE
Refer to fputc().
ERRORS
Refer to fputc().
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Since it may be implemented as a macro, putc() may treat a stream argument with side-effects incorrectly. In
particular, putc(c,*f++) does not necessarily work correctly. Therefore, use of this function is not
recommended in such situations; fputc() should be used instead.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, fputc()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0470 [14] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/remquol.html =====
remquo
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
remquo, remquof, remquol — remainder functions
SYNOPSIS
#include
double remquo(double x, double y, int *quo);
float remquof(float x, float y, int *quo);
long double remquol(long double x, long double y, int *quo);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The remquo(), remquof(), and remquol() functions shall compute the same remainder as the remainder(), remainderf(), and remainderl() functions, respectively. In the object pointed to by quo, they store
a value whose sign is the sign of x/y and whose magnitude is congruent modulo 2n to
the magnitude of the integral quotient of x/y, where n is an implementation-defined integer greater than or
equal to 3. If y is zero, the value stored in the object pointed to by quo is unspecified.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
These functions shall return x REM y.
[MX]
When subnormal results are supported, the returned value shall be exact.
If NaN is supported and a NaN is returned, the value stored in the object pointed to by quo is unspecified.
On systems that do not support the IEC 60559 Floating-Point option, if y is zero, it is implementation-defined whether a
domain error occurs or zero is returned.
[MX]  If
x or y is NaN, a NaN shall be returned.
If x is ±Inf or y is zero and the other argument is non-NaN, a domain error shall occur, and a NaN shall be
returned.
ERRORS
These functions shall fail if:
Domain Error
[MX]
The x argument is ±Inf, or the y argument is ±0 and the other argument is non-NaN.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
These functions may fail if:
Domain Error
The y argument is zero.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
These functions are intended for implementing argument reductions which can exploit a few low-order bits of the quotient. Note
that x may be so large in magnitude relative to y that an exact representation of the quotient is not practical.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), remainder()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
ISO/IEC 9899:1999 standard, Technical Corrigendum 2 #56 (SD5-XSH-ERN-83) is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0507 [320] is applied.
Issue 8
Austin Group Defect 713 is applied, clarifying the behavior when a NaN is returned.
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/cosl.html =====
cos
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
cos, cosf, cosl — cosine function
SYNOPSIS
#include
double cos(double x);
float cosf(float x);
long double cosl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the cosine of their argument x, measured in radians.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the cosine of x.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0, the value 1.0 shall be returned.
If x is ±Inf, a domain error shall occur, and a NaN shall be returned.
ERRORS
These functions shall fail if:
Domain Error
[MX]
The x argument is ±Inf.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
Taking the Cosine of a 45-Degree Angle
#include
...
double radians = 45 * M_PI / 180;
double result;
...
result = cos(radians);
APPLICATION USAGE
These functions may lose accuracy when their argument is near an odd multiple of ℼ/2 or is far from 0.
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
acos(), feclearexcept(),
fetestexcept(), isnan(),
sin(), tan()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The cosf() and cosl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0063 [320] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/isalpha.html =====
isalpha
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
isalpha, isalpha_l — test for an alphabetic character
SYNOPSIS
#include
int isalpha(int c);
[CX]  int isalpha_l(int c, locale_t locale);
DESCRIPTION
For isalpha(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The isalpha() [CX]   and isalpha_l()
functions shall test whether c is a character of class alpha in the current locale, [CX]   or in the
locale represented by locale,  respectively; see XBD 7. Locale.
The c argument is an int, the value of which the application shall ensure is representable as an unsigned
char or equal to the value of the macro EOF. If the argument has any other value, the behavior is undefined.
[CX]  The
behavior is undefined if the locale argument to isalpha_l() is the special locale object LC_GLOBAL_LOCALE or is not a
valid locale object handle.
RETURN VALUE
The isalpha() [CX]   and isalpha_l()
functions shall return non-zero if c is an alphabetic character; otherwise, they shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
To ensure applications portability, especially across natural languages, only these functions and the functions in the reference
pages listed in the SEE ALSO section should be used for character classification.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
isalnum(), isblank(), iscntrl(), isdigit(), isgraph(), islower(), isprint(), ispunct(), isspace(), isupper(), isxdigit(), setlocale(), uselocale()
XBD 7. Locale, , ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
The isalpha_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0277 [302], XSH/TC1-2008/0278 [283], and XSH/TC1-2008/0279 [283] are
applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/hcreate.html =====
hcreate
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
hcreate, hdestroy, hsearch — manage hash search table
SYNOPSIS
[XSI]  #include
int hcreate(size_t nel);
void hdestroy(void);
ENTRY *hsearch(ENTRY item, ACTION action);
DESCRIPTION
The hcreate(), hdestroy(), and hsearch() functions shall manage hash search tables.
The hcreate() function shall allocate sufficient space for the table, and the application shall ensure it is called
before hsearch() is used. The nel argument is an estimate of the maximum number of entries that the table shall
contain. This number may be adjusted upward by the algorithm in order to obtain certain mathematically favorable circumstances.
The hdestroy() function shall dispose of the search table, and may be followed by another call to hcreate(). After
the call to hdestroy(), the data can no longer be considered accessible.
The hsearch() function is a hash-table search routine. It shall return a pointer into a hash table indicating the
location at which an entry can be found. The item argument is a structure of type ENTRY (defined in the  header) containing two pointers: item.key points to the comparison
key (a char *), and item.data (a void *) points to any other data to be associated with that key. The
comparison function used by hsearch() is strcmp(). The action argument
is a member of an enumeration type ACTION indicating the disposition of the entry if it cannot be found in the table. ENTER
indicates that the item should be inserted in the table at an appropriate point. FIND indicates that no entry should be made.
Unsuccessful resolution is indicated by the return of a null pointer.
These functions need not be thread-safe.
RETURN VALUE
The hcreate() function shall return 0 if it cannot allocate sufficient space for the table; otherwise, it shall return
non-zero.
The hdestroy() function shall not return a value.
The hsearch() function shall return a null pointer if either the action is FIND and the item could not be found or the
action is ENTER and the table is full.
ERRORS
The hcreate() and hsearch() functions may fail if:
[ENOMEM]
Insufficient storage space is available.
The following sections are informative.
EXAMPLES
The following example reads in strings followed by two numbers and stores them in a hash table, discarding duplicates. It then
reads in strings and finds the matching entry in the hash table and prints it out.
#include
#include
#include
struct info {        /* This is the info stored in the table */
int age, room;   /* other than the key. */
};
#define NUM_EMPL    5000    /* # of elements in search table. */
int main(void)
{
char string_space[NUM_EMPL*20];   /* Space to store strings. */
struct info info_space[NUM_EMPL]; /* Space to store employee info. */
char *str_ptr = string_space;     /* Next space in string_space. */
struct info *info_ptr = info_space;
/* Next space in info_space. */
ENTRY item;
ENTRY *found_item; /* Name to look for in table. */
char name_to_find[30];
int i = 0;
/* Create table; no error checking is performed. */
(void) hcreate(NUM_EMPL);
while (scanf("%s%d%d", str_ptr, &info_ptr->age,
&info_ptr->room) != EOF && i++ key,
((struct info *)found_item->data)->age,
((struct info *)found_item->data)->room);
} else
(void)printf("no such employee %s\n", name_to_find);
}
return 0;
}
APPLICATION USAGE
The hcreate() and hsearch() functions may use malloc() to allocate
space.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
bsearch(), lsearch(), malloc(), strcmp(), tdelete()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
A note indicating that this function need not be reentrant is added to the DESCRIPTION.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/seed48.html =====
drand48
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
drand48, erand48, jrand48, lcong48, lrand48, mrand48, nrand48, seed48, srand48 — generate uniformly distributed
pseudo-random numbers
SYNOPSIS
[XSI]  #include
double drand48(void);
double erand48(unsigned short xsubi[3]);
long jrand48(unsigned short xsubi[3]);
void lcong48(unsigned short param[7]);
long lrand48(void);
long mrand48(void);
long nrand48(unsigned short xsubi[3]);
unsigned short *seed48(unsigned short seed16v[3]);
void srand48(long seedval);
DESCRIPTION
This family of functions shall generate pseudo-random numbers using a linear congruential algorithm and 48-bit integer
arithmetic.
The drand48() and erand48() functions shall return non-negative, double-precision, floating-point values,
uniformly distributed over the interval [0.0,1.0).
The lrand48() and nrand48() functions shall return non-negative, long integers, uniformly distributed over the
interval [0,231).
The mrand48() and jrand48() functions shall return signed long integers uniformly distributed over the interval
[-231,231).
The srand48(), seed48(), and lcong48() functions are initialization entry points, one of which should be
invoked before either drand48(), lrand48(), or mrand48() is called. (Although it is not recommended practice,
constant default initializer values shall be supplied automatically if drand48(), lrand48(), or mrand48() is
called without a prior call to an initialization entry point.) The erand48(), nrand48(), and jrand48()
functions do not require an initialization entry point to be called first.
All the routines work by generating a sequence of 48-bit integer values,
\(X_{i}\),
according to the linear congruential formula:
\(X_{n+1}=\left(a X_n+c\right)_{\bmod m} \quad n \geq 0\)
The parameter m=248; hence 48-bit integer arithmetic is performed. Unless lcong48() is invoked, the multiplier
value a and the addend value c are given by:
\(
\begin{aligned}
& a= \text { 5DEECE66D }_{16}=273673163155_8 \\
& c=\mathrm{B}_{16}=13_8
\end{aligned}
\)
The value returned by any of the drand48(), erand48(), jrand48(), lrand48(), mrand48(), or
nrand48() functions is computed by first generating the next 48-bit \(X_{i}\) in the sequence. \(X_{i}\) is then converted
to the return value as follows:
For drand48() and erand48() the value shall be 2-48 times \(X_{i}\).
For jrand48() and mrand48() the value shall be the largest integer not greater than 2-16 times \(X_{i}\).
For lrand48() and nrand48() the value shall be the largest integer not greater than 2-17 times \(X_{i}\).
The drand48(), lrand48(), and mrand48() functions store the last 48-bit \(X_{i}\) generated in an internal
buffer; that is why the application shall ensure that these are initialized prior to being invoked. The erand48(),
nrand48(), and jrand48() functions require the calling program to provide storage for the successive \(X_{i}\) values
in the array specified as an argument when the functions are invoked. That is why these routines do not have to be initialized; the
calling program merely has to place the desired initial value of \(X_{i}\) into the array and pass it as an argument. By using
different arguments, erand48(), nrand48(), and jrand48() allow separate modules of a large program to generate
several independent streams of pseudo-random numbers; that is, the sequence of numbers in each stream shall not
depend upon how many times the routines are called to generate numbers for the other streams.
The initializer function srand48() sets the high-order 32 bits of \(X_{i}\) to the low-order 32 bits contained in its
argument. The low-order 16 bits of \(X_{i}\) are set to the arbitrary value 330E16.
The initializer function seed48() sets the value of \(X_{i}\) to the 48-bit value specified in the argument array. The
low-order 16 bits of \(X_{i}\) are set to the low-order 16 bits of seed16v[0]. The mid-order 16 bits of \(X_{i}\) are
set to the low-order 16 bits of seed16v[1]. The high-order 16 bits of \(X_{i}\) are set to the low-order 16 bits of
seed16v[2]. In addition, the previous value of \(X_{i}\) is copied into a 48-bit internal buffer, used only by
seed48(), and a pointer to this buffer is the value returned by seed48(). This returned pointer, which can just be
ignored if not needed, is useful if a program is to be restarted from a given point at some future time—use the pointer to get at
and store the last \(X_{i}\) value, and then use this value to reinitialize via seed48() when the program is restarted.
The initializer function lcong48() allows the user to specify the initial \(X_{i}\), the multiplier value a, and the
addend value c. Argument array elements param[0-2] specify \(X_{i}\), param[3-5] specify the
multiplier a, and param[6] specifies the 16-bit addend c. After lcong48() is called, a subsequent call to
either srand48() or seed48() shall restore the standard multiplier and addend values, a and c,
specified above.
The drand48(), lrand48(), and mrand48() functions need not be thread-safe.
RETURN VALUE
As described in the DESCRIPTION above.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
The following program tests that the required pseudo-random number generator is used by these functions.
#include
#include
int main() {
{
unsigned short xsubi[3] = {37174, 64810, 11603};
double d = erand48(xsubi);
assert(d >= 0.896);
assert(d = 0.337);
assert(d = 0.647);
assert(d = 0.500);
assert(d = 0.506);
assert(d
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
A note indicating that the drand48(), lrand48(), and mrand48() functions need not be reentrant is added to
the DESCRIPTION.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0083 [743] is applied.
Issue 8
Austin Group Defect 1107 is applied, clarifying how the return value is calculated from  \(X_{i}\) for each function.
Austin Group Defect 1134 is applied, adding getentropy().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/CMPLXL.html =====
CMPLX
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
CMPLX, CMPLXF, CMPLXL — make a complex value
SYNOPSIS
#include
double complex CMPLX(double x, double y);
float complex CMPLXF(float x, float y);
long double complex CMPLXL(long double x, long double y);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The CMPLX macros shall expand to an expression of the specified complex type, with the real part having the (converted) value of
x and the imaginary part having the (converted) value of y. The resulting expression shall be suitable for use as an
initializer for an object with static or thread storage duration, provided both arguments are likewise suitable.
RETURN VALUE
The CMPLX macros return the complex value x + i y (where i is the imaginary unit).
These macros shall behave as if the implementation supported imaginary types and the definitions were:
#define CMPLX(x, y)  ((double complex)((double)(x) + \
_Imaginary_I * (double)(y)))
#define CMPLXF(x, y) ((float complex)((float)(x) + \
_Imaginary_I * (float)(y)))
#define CMPLXL(x, y) ((long double complex)((long double)(x) + \
_Imaginary_I * (long double)(y)))
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fscanf.html =====
fscanf
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fscanf, scanf, sscanf — convert formatted input
SYNOPSIS
#include
int fscanf(FILE *restrict stream, const char *restrict format, ...);
int scanf(const char *restrict format, ...);
int sscanf(const char *restrict s, const char *restrict format, ...);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The fscanf() function shall read from the named input stream. The scanf() function shall read from the
standard input stream stdin. The sscanf() function shall read from the string s. Each function reads bytes,
interprets them according to a format, and stores the results in its arguments. Each expects, as arguments, a control string
format described below, and a set of pointer arguments indicating where the converted input should be stored. The
result is undefined if there are insufficient arguments for the format. If the format is exhausted while arguments remain, the
excess arguments shall be evaluated but otherwise ignored.
[CX]
Conversions can be applied to the nth argument after the format in the argument list, rather than to the next unused
argument. In this case, the conversion specifier character % (see below) is replaced by the sequence
"%n$", where n is a decimal integer in the range [1,{NL_ARGMAX}]. This feature provides for the
definition of format strings that select arguments in an order appropriate to specific languages. In format strings containing the
"%n$" form of conversion specifications, it is unspecified whether numbered arguments in the argument list
can be referenced from the format string more than once.
The format can contain either form of a conversion specification—that is, % or "%n$"—but the
two forms cannot be mixed within a single format string. The only exception to this is that %% or %* can be mixed
with the "%n$" form. When numbered argument specifications are used, specifying the Nth argument
requires that all the leading arguments, from the first to the (N-1)th, are pointers.
The fscanf() function in all its forms shall allow detection of a language-dependent radix character in the input string.
The radix character is defined in the current locale (category LC_NUMERIC ). In the POSIX locale, or in a locale where the
radix character is not defined, the radix character shall default to a  ('.').
The application shall ensure that the format is a character string, beginning and ending in its initial shift state, if any,
composed of zero or more directives. Each directive is composed of one of the following: one or more white-space bytes; an ordinary
character (neither '%' nor a white-space byte); or a conversion specification. Each conversion specification is introduced
by the character '%' [CX]   or the character sequence "%n$",   after which the following appear in sequence:
An optional assignment-suppressing character '*'.
An optional non-zero decimal integer that specifies the maximum field width.
[CX]  An
optional assignment-allocation character 'm'.
An option length modifier that specifies the size of the receiving object.
A conversion specifier character that specifies the type of conversion to be applied. The valid conversion specifiers are
described below.
The fscanf() functions shall execute each directive of the format in turn. When all directives have been executed, or if
a directive fails (as detailed below), the function shall return. Failures are described as input failures (due to the
unavailability of input bytes) or matching failures (due to inappropriate input).
A directive composed of one or more white-space bytes shall be executed by reading input up to the first non-white-space byte,
which shall remain unread, or until no more bytes can be read. The directive shall never fail.
A directive that is an ordinary character shall be executed as follows: the next byte shall be read from the input and compared
with the byte that comprises the directive; if the comparison shows that they are not equivalent, the directive shall fail, and the
differing and subsequent bytes shall remain unread. Similarly, if end-of-file, an encoding error, or a read error prevents a
character from being read, the directive shall fail.
A directive that is a conversion specification defines a set of matching input sequences, as described below for each conversion
character. A conversion specification shall be executed in the following steps.
Input white-space bytes shall be skipped, unless the conversion specification includes a [, c, C, or
n conversion specifier.
An item shall be read from the input, unless the conversion specification includes an n conversion specifier. An input
item shall be defined as the longest sequence of input bytes (up to any specified maximum field width, which may be measured in
characters or bytes dependent on the conversion specifier) which is an initial subsequence of a matching sequence. The first byte,
if any, after the input item shall remain unread. If the length of the input item is 0, the execution of the conversion
specification shall fail; this condition is a matching failure, unless end-of-file, an encoding error, or a read error prevented
input from the stream, in which case it is an input failure.
Except in the case of a % conversion specifier, the input item (or, in the case of a %n conversion
specification, the count of input bytes) shall be converted to a type appropriate to the conversion character. If the input item is
not a matching sequence, the execution of the conversion specification fails; this condition is a matching failure. Unless
assignment suppression was indicated by a '*', the result of the conversion shall be placed in the object pointed to by
the first argument following the format argument that has not already received a conversion result if the conversion
specification is introduced by %, [CX]   or in the nth argument if introduced by the character
sequence "%n$".  If this object does not
have an appropriate type, or if the result of the conversion cannot be represented in the space provided, the behavior is
undefined.
[CX]  The
c, s, and [ conversion specifiers shall accept an optional assignment-allocation character 'm',
which shall cause a memory buffer to be allocated to hold the conversion results. If the conversion specifier is s or
[, the allocated buffer shall include space for a terminating null character (or wide character). In such a case, the
argument corresponding to the conversion specifier should be a reference to a pointer variable that will receive a pointer to the
allocated buffer. The system shall allocate a buffer as if malloc() had been called.
The application shall be responsible for freeing the memory after usage. If there is insufficient memory to allocate a buffer, the
function shall set errno to [ENOMEM] and a conversion error shall result. If the function returns EOF, any memory
successfully allocated for parameters using assignment-allocation character 'm' by this call shall be freed before the
function returns.
The length modifiers and their meanings are:
hh
Specifies that a following d, i, o, u, x, X, or n conversion
specifier applies to an argument with type pointer to signed char or unsigned char.
h
Specifies that a following d, i, o, u, x, X, or n conversion
specifier applies to an argument with type pointer to short or unsigned short.
l (ell)
Specifies that a following d, i, o, u, x, X, or n conversion
specifier applies to an argument with type pointer to long or unsigned long; that a following a, A,
e, E, f, F, g, or G conversion specifier applies to an argument with type
pointer to double; or that a following c, s, or [ conversion specifier applies to an argument
with type pointer to wchar_t. [CX]   If the 'm' assignment-allocation character is specified, the conversion applies to
an argument with the type pointer to a pointer to wchar_t.
ll (ell-ell)
Specifies that a following d, i, o, u, x, X, or n conversion
specifier applies to an argument with type pointer to long long or unsigned long long.
j
Specifies that a following d, i, o, u, x, X, or n conversion
specifier applies to an argument with type pointer to intmax_t or uintmax_t.
z
Specifies that a following d, i, o, u, x, X, or n conversion
specifier applies to an argument with type pointer to size_t or the corresponding signed integer type.
t
Specifies that a following d, i, o, u, x, X, or n conversion
specifier applies to an argument with type pointer to ptrdiff_t or the corresponding unsigned type.
L
Specifies that a following a, A, e, E, f, F, g, or G
conversion specifier applies to an argument with type pointer to long double.
If a length modifier appears with any conversion specifier other than as specified above, the behavior is undefined.
The following conversion specifiers are valid:
d
Matches an optionally signed decimal integer, whose format is the same as expected for the subject sequence of strtol() with the value 10 for the base argument. In the absence of a size modifier,
the application shall ensure that the corresponding argument is a pointer to int.
i
Matches an optionally signed integer, whose format is the same as expected for the subject sequence of strtol() with 0 for the base argument. In the absence of a size modifier, the
application shall ensure that the corresponding argument is a pointer to int.
o
Matches an optionally signed octal integer, whose format is the same as expected for the subject sequence of strtoul() with the value 8 for the base argument. In the absence of a size modifier,
the application shall ensure that the corresponding argument is a pointer to unsigned.
u
Matches an optionally signed decimal integer, whose format is the same as expected for the subject sequence of strtoul() with the value 10 for the base argument. In the absence of a size modifier,
the application shall ensure that the corresponding argument is a pointer to unsigned.
x
Matches an optionally signed hexadecimal integer, whose format is the same as expected for the subject sequence of strtoul() with the value 16 for the base argument. In the absence of a size modifier,
the application shall ensure that the corresponding argument is a pointer to unsigned.
a, e, f, g
Matches an optionally signed floating-point number, infinity, or NaN, whose format is the same as expected for the subject sequence
of strtod(). In the absence of a size modifier, the application shall ensure that the
corresponding argument is a pointer to float.
If the fprintf() family of functions generates character string representations
for infinity and NaN (a symbolic entity encoded in floating-point format) to support IEEE Std 754-1985, the
fscanf() family of functions shall recognize them as input.
s
Matches a sequence of bytes that are not white-space bytes. If the 'm' assignment-allocation character is not
specified, the application shall ensure that the corresponding argument is a pointer to the initial byte of an array of
char, signed char, or unsigned char large enough to accept the sequence and a terminating null character code,
which shall be added automatically. [CX]   Otherwise, the application shall ensure that the corresponding argument is a pointer to a
pointer to a char.
If an l (ell) qualifier is present, the input is a sequence of characters that begins in the initial shift state. Each
character shall be converted to a wide character as if by a call to the mbrtowc()
function, with the conversion state described by an mbstate_t object initialized to zero before the first character is
converted. If the 'm' assignment-allocation character is not specified, the application shall ensure that the
corresponding argument is a pointer to an array of wchar_t large enough to accept the sequence and the terminating null wide
character, which shall be added automatically. [CX]   Otherwise, the application shall ensure that the corresponding
argument is a pointer to a pointer to a wchar_t.
[
Matches a non-empty sequence of bytes from a set of expected bytes (the scanset). The normal skip over white-space bytes
shall be suppressed in this case. If the 'm' assignment-allocation character is not specified, the application shall
ensure that the corresponding argument is a pointer to the initial byte of an array of char, signed char, or
unsigned char large enough to accept the sequence and a terminating null byte, which shall be added automatically.
[CX]
Otherwise, the application shall ensure that the corresponding argument is a pointer to a pointer to a char.
If an l (ell) qualifier is present, the input is a sequence of characters that begins in the initial shift state. Each
character in the sequence shall be converted to a wide character as if by a call to the mbrtowc() function, with the conversion state described by an mbstate_t object
initialized to zero before the first character is converted. If the 'm' assignment-allocation character is not specified,
the application shall ensure that the corresponding argument is a pointer to an array of wchar_t large enough to accept the
sequence and the terminating null wide character, which shall be added automatically.
[CX]
Otherwise, the application shall ensure that the corresponding argument is a pointer to a pointer to a wchar_t.
The conversion specification includes all subsequent bytes in the format string up to and including the matching
(']'). The bytes between the square brackets (the scanlist) comprise the scanset,
unless the byte after the  is a  ('^'), in which case the scanset contains
all bytes that do not appear in the scanlist between the  and the . If the conversion
specification begins with "[]" or "[^]", the  is included in the scanlist and the
next  is the matching  that ends the conversion specification; otherwise,
the first  is the one that ends the conversion specification. If a '-' is in the scanlist and
is not the first character, nor the second where the first character is a '^', nor the last character, the behavior is
implementation-defined.
c
Matches a sequence of bytes of the number specified by the field width (1 if no field width is present in the conversion
specification). No null byte is added. The normal skip over white-space bytes shall be suppressed in this case. If the 'm'
assignment-allocation character is not specified, the application shall ensure that the corresponding argument is a pointer to the
initial byte of an array of char, signed char, or unsigned char large enough to accept the sequence.
[CX]
Otherwise, the application shall ensure that the corresponding argument is a pointer to a pointer to a char.
If an l (ell) qualifier is present, the input shall be a sequence of characters that begins in the initial shift state.
Each character in the sequence is converted to a wide character as if by a call to the mbrtowc() function, with the conversion state described by an mbstate_t object
initialized to zero before the first character is converted. No null wide character is added. If the 'm'
assignment-allocation character is not specified, the application shall ensure that the corresponding argument is a pointer to an
array of wchar_t large enough to accept the resulting sequence of wide characters. [CX]   Otherwise, the
application shall ensure that the corresponding argument is a pointer to a pointer to a wchar_t.
p
Matches an implementation-defined set of sequences, which shall be the same as the set of sequences that is produced by the
%p conversion specification of the corresponding fprintf() functions. The
application shall ensure that the corresponding argument is a pointer to a pointer to void. The interpretation of the input
item is implementation-defined. If the input item is a value converted earlier during the same program execution, the pointer that
results shall compare equal to that value; otherwise, the behavior of the %p conversion specification is undefined.
n
No input is consumed. The application shall ensure that the corresponding argument is a pointer to the integer into which shall
be written the number of bytes read from the input so far by this call to the fscanf() functions. Execution of a %n
conversion specification shall not increment the assignment count returned at the completion of execution of the function. No
argument shall be converted, but one shall be consumed. If the conversion specification includes an assignment-suppressing
character or a field width, the behavior is undefined.
C
[XSI]
Equivalent to lc.
S
[XSI]
Equivalent to ls.
%
Matches a single '%' character; no conversion or assignment occurs. The complete conversion specification shall be
%%.
If a conversion specification is invalid, the behavior is undefined.
The conversion specifiers A, E, F, G, and X are also valid and shall be equivalent
to a, e, f, g, and x, respectively.
If end-of-file is encountered during input, conversion shall be terminated. If end-of-file occurs before any bytes matching the
current conversion specification (except for %n) have been read (other than leading white-space bytes, where permitted),
execution of the current conversion specification shall terminate with an input failure. Otherwise, unless execution of the current
conversion specification is terminated with a matching failure, execution of the following conversion specification (if any) shall
be terminated with an input failure.
Reaching the end of the string in sscanf() shall be equivalent to encountering end-of-file for fscanf().
If conversion terminates on a conflicting input, the offending input is left unread in the input. Any trailing white-space bytes
(including  characters) shall be left unread unless matched by a conversion specification. The success of literal
matches and suppressed assignments is only directly determinable via the %n conversion specification.
[CX]  The
fscanf() and scanf() functions may mark the last data access timestamp of the file associated with stream for
update. The last data access timestamp shall be marked for update by the first successful execution of fgetc(), fgets(), fread(), getc(), getchar(), getdelim(), getline(), fscanf(), or scanf() using stream that returns data not
supplied by a prior call to ungetc().
RETURN VALUE
Upon successful completion, these functions shall return the number of successfully matched and assigned input items; this
number can be zero in the event of an early matching failure. If the input ends before the first conversion (if any) has completed,
and without a matching failure having occurred, EOF shall be returned. If an error occurs before the first conversion (if any) has
completed, and without a matching failure having occurred, EOF shall be returned [CX]   and
errno shall be set to indicate the error.   If an error
occurs, the error indicator for the stream shall be set.
ERRORS
For the conditions under which the fscanf() functions fail and may fail, refer to fgetc() or fgetwc().
In addition, the fscanf() function shall fail if:
[EILSEQ]
[CX]
Input byte sequence does not form a valid character.
[ENOMEM]
Insufficient storage space is available.
In addition, the fscanf() function may fail if:
[EINVAL]
[CX]
There are insufficient arguments.
The following sections are informative.
EXAMPLES
The call:
int i, n; float x; char name[50];
n = scanf("%d%f%s", &i, &x, name);
with the input line:
25 54.32E-1 Hamster
assigns to n the value 3, to i the value 25, to x the value 5.432, and name contains the string
"Hamster".
The call:
int i; float x; char name[50];
(void) scanf("%2d%f%*d %[0123456789]", &i, &x, name);
with input:
56789 0123 56a72
assigns 56 to i, 789.0 to x, skips 0123, and places the string "56\0" in name. The next call to
getchar() shall return the character 'a'.
Reading Data into an Array
The following call uses fscanf() to read three floating-point numbers from standard input into the input
array.
float input[3]; fscanf (stdin, "%f %f %f", input, input+1, input+2);
APPLICATION USAGE
If the application calling fscanf() has any objects of type wint_t or wchar_t, it must also include the
header to have these objects defined.
For functions that allocate memory as if by malloc(), the application should
release such memory when it is no longer required by a call to free(). For
fscanf(), this is memory allocated via use of the 'm' assignment-allocation character.
RATIONALE
The set of characters allowed in a scanset is limited to single-byte characters. In other similar places, multi-byte characters
have been permitted, but for alignment with the ISO C standard, it has not been done here. Applications needing this could use
the corresponding wide-character functions to achieve the desired results.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, fprintf(), getc(), setlocale(), strtod(), strtol(), strtoul(), wcrtomb()
XBD 7. Locale, , ,
,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
Aligned with ISO/IEC 9899:1990/Amendment 1:1995 (E). Specifically, the l (ell) qualifier is now defined for the
c, s, and [ conversion specifiers.
The DESCRIPTION is updated to indicate that if infinity and NaN can be generated by the fprintf() family of functions, then they are recognized by the fscanf() family.
Issue 6
The Open Group Corrigenda U021/7 and U028/10 are applied. These correct several occurrences of "characters" in the text which
have been replaced with the term "bytes".
The normative text is updated to avoid use of the term "must" for application requirements.
The following changes are made for alignment with the ISO/IEC 9899:1999 standard:
The prototypes for fscanf(), scanf(), and sscanf() are updated.
The DESCRIPTION is updated.
The hh, ll, j, t, and z length modifiers are added.
The a, A, and F conversion characters are added.
The DESCRIPTION is updated to use the terms "conversion specifier" and "conversion specification" consistently.
Issue 7
Austin Group Interpretation 1003.1-2001 #170 is applied.
SD5-XSH-ERN-9 is applied, correcting fscanf() to scanf() in the DESCRIPTION.
SD5-XSH-ERN-132 is applied, adding the assignment-allocation character 'm'.
Functionality relating to the %n$ form of conversion specification is moved from the XSI option to the Base.
Changes are made related to support for finegrained timestamps.
The APPLICATION USAGE section is updated to clarify that memory is allocated as if by malloc().
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0185 [302], XSH/TC1-2008/0186 [90], and XSH/TC1-2008/0187 [14] are applied.
XSH/TC1-2008/0186 [90] changes the second sentence in the RETURN VALUE section to align with expected wording changes in the next
revision of the ISO C standard.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0135 [936] is applied.
Issue 8
Austin Group Defect 1163 is applied, clarifying the handling of white space in the format string.
Austin Group Defect 1173 is applied, clarifying the description of the assignment-allocation character 'm'.
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
Austin Group Defect 1375 is applied, changing "terminating null character" to "terminating null character (or wide
character)".
Austin Group Defect 1562 is applied, clarifying that it is the application's responsibility to ensure that the format is a
character string, beginning and ending in its initial shift state, if any.
Austin Group Defect 1624 is applied, changing the RETURN VALUE section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/log10l.html =====
log10
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
log10, log10f, log10l — base 10 logarithm function
SYNOPSIS
#include
double log10(double x);
float log10f(float x);
long double log10l(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the base 10 logarithm of their argument x, log10(x).
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the base 10 logarithm of x.
If x is ±0, a pole error shall occur and log10(), log10f(), and log10l() shall return -HUGE_VAL,
-HUGE_VALF, and -HUGE_VALL, respectively.
For finite values of x that are less than 0, [MX]   or if x is -Inf,  a domain error shall occur, and [MX]   either a NaN (if supported), or   an implementation-defined value shall be returned.
[MX]  If
x is NaN, a NaN shall be returned.
If x is 1, +0 shall be returned.
If x is +Inf, +Inf shall be returned.
ERRORS
These functions shall fail if:
Domain Error
The finite value of x is negative, [MX]   or x is -Inf.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
Pole Error
The value of x is zero.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the divide-by-zero floating-point exception shall
be raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), isnan(), log(), pow()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
The log10f() and log10l() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/mq_setattr.html =====
mq_setattr
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
mq_setattr — set message queue attributes (REALTIME)
SYNOPSIS
[MSG]  #include
int mq_setattr(mqd_t mqdes, const struct mq_attr *restrict mqstat,
struct mq_attr *restrict omqstat);
DESCRIPTION
The mq_setattr() function shall set attributes associated with the open message queue description referenced by the
message queue descriptor specified by mqdes.
The message queue attributes corresponding to the following members defined in the mq_attr structure shall be set to the
specified values upon successful completion of mq_setattr():
mq_flags
The value of this member is the bitwise-logical OR of zero or more of O_NONBLOCK and any implementation-defined flags.
The values of the mq_maxmsg, mq_msgsize, and mq_curmsgs members of the mq_attr structure shall be
ignored by mq_setattr().
If omqstat is non-NULL, the mq_setattr() function shall store, in the location referenced by omqstat, the
previous message queue attributes and the current queue status. These values shall be the same as would be returned by a call to
mq_getattr() at that point.
RETURN VALUE
Upon successful completion, the function shall return a value of zero and the attributes of the message queue shall have been
changed as specified.
Otherwise, the message queue attributes shall be unchanged, and the function shall return a value of -1 and set errno to
indicate the error.
ERRORS
The mq_setattr() function shall fail if:
[EBADF]
The mqdes argument is not a valid message queue descriptor.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
mq_open(), mq_send(), msgctl(), msgget(), msgrcv(), msgsnd()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Issue 6
The mq_setattr() function is marked as part of the Message Passing option.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Message
Passing option.
The mq_timedsend() function is added to the SEE ALSO section for alignment
with IEEE Std 1003.1d-1999.
The restrict keyword is added to the mq_setattr() prototype for alignment with the ISO/IEC 9899:1999
standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/llroundl.html =====
llround
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
llround, llroundf, llroundl — round to nearest integer value
SYNOPSIS
#include
long long llround(double x);
long long llroundf(float x);
long long llroundl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall round their argument to the nearest integer value, rounding halfway cases away from zero, regardless of
the current rounding direction.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the rounded integer value.
[MX]  If
x is NaN, a domain error shall occur, and an unspecified value is returned.
If x is +Inf, a domain error shall occur and an unspecified value is returned.
If x is -Inf, a domain error shall occur and an unspecified value is returned.
If the correct value is positive and too large to represent as a long long, an unspecified value shall be returned.
[MX]
On systems that support the IEC 60559 Floating-Point option, a domain error shall occur;   otherwise, a [CX]   domain  error may occur.
If the correct value is negative and too large to represent as a long long, an unspecified value shall be returned.
[MX]
On systems that support the IEC 60559 Floating-Point option, a domain error shall occur;   otherwise, a [CX]   domain  error may occur.
ERRORS
These functions shall fail if:
Domain Error
[MX]
The x argument is NaN or ±Inf, or the correct value is not representable as an integer.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
These functions may fail if:
Domain Error
The correct value is not representable as an integer.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
These functions differ from the llrint() functions in that the default rounding
direction for the llround() functions round halfway cases away from zero and need not raise the inexact floating-point
exception for non-integer arguments that round to within the range of the return type.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), lround()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
ISO/IEC 9899:1999 standard, Technical Corrigendum 2 #54 (SD5-XSH-ERN-75) is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/shm_unlink.html =====
shm_unlink
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
shm_unlink — remove a shared memory object (REALTIME)
SYNOPSIS
[SHM]  #include
int shm_unlink(const char *name);
DESCRIPTION
The shm_unlink() function shall remove the name of the shared memory object named by the string pointed to by
name.
If one or more references to the shared memory object exist when the object is unlinked, the name shall be removed before
shm_unlink() returns, but the removal of the memory object contents shall be postponed until all open and map references to
the shared memory object have been removed.
Even if the object continues to exist after the last shm_unlink(), reuse of the name shall subsequently cause shm_open() to behave as if no shared memory object of this name exists (that is, shm_open() shall fail if O_CREAT is not set, or shall create a new shared memory object if
O_CREAT is set).
RETURN VALUE
Upon successful completion, a value of zero shall be returned. Otherwise, a value of -1 shall be returned and errno set
to indicate the error. If -1 is returned, the named shared memory object shall not be changed by this function call.
ERRORS
The shm_unlink() function shall fail if:
[EACCES]
Permission is denied to unlink the named shared memory object.
[ENOENT]
The named shared memory object does not exist.
The shm_unlink() function may fail if:
[ENAMETOOLONG]
The length of the name argument exceeds {_POSIX_PATH_MAX} on systems that do not support the XSI option [XSI]   or exceeds
{_XOPEN_PATH_MAX} on XSI systems,   or has a pathname component
that is longer than {_POSIX_NAME_MAX} on systems that do not support the XSI option [XSI]   or longer
than {_XOPEN_NAME_MAX} on XSI systems.   A call to
shm_unlink() with a name argument that contains the same shared memory object name as was previously used in a
successful shm_open() call shall not give an [ENAMETOOLONG] error.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Names of memory objects that were allocated with open() are deleted with unlink() in the usual fashion. Names of memory objects that were allocated with shm_open() are deleted with shm_unlink(). Note that the actual memory object is not
destroyed until the last close and unmap on it have occurred if it was already in use.
RATIONALE
None.
FUTURE DIRECTIONS
A future version might require the shm_open() and shm_unlink() functions
to have semantics similar to normal file system operations.
SEE ALSO
close(), mmap(), munmap(), shmat(), shmctl(), shmdt(), shm_open()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Issue 6
The shm_unlink() function is marked as part of the Shared Memory Objects option.
In the DESCRIPTION, text is added to clarify that reusing the same name after a shm_unlink() will not attach to the old
shared memory object.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Shared
Memory Objects option.
Issue 7
Austin Group Interpretation 1003.1-2001 #077 is applied, changing [ENAMETOOLONG] from a "shall fail" to a "may fail"
error.
Austin Group Interpretation 1003.1-2001 #141 is applied, adding FUTURE DIRECTIONS.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/geteuid.html =====
geteuid
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
geteuid — get the effective user ID
SYNOPSIS
#include
uid_t geteuid(void);
DESCRIPTION
The geteuid() function shall return the effective user ID of the calling process. The geteuid() function shall not
modify errno.
RETURN VALUE
The geteuid() function shall always be successful and no return value is reserved to indicate an error.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
In a conforming environment, geteuid() will always succeed. It is possible for implementations to provide an extension
where a process in a non-conforming environment will not be associated with a user or group ID. It is recommended that such
implementations return (uid_t)-1 and set errno to indicate such an environment; doing so does not violate this
standard, since such an environment is already an extension.
FUTURE DIRECTIONS
None.
SEE ALSO
getegid(), getgid(), getresgid(), getresuid(), getuid(), setegid(), seteuid(), setgid(), setregid(), setresgid(), setresuid(), setreuid(), setuid()
XBD ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
In the SYNOPSIS, the optional include of the  header is
removed.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The requirement to include  has been removed. Although
was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.
Issue 7
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0158 [511] is applied.
Issue 8
Austin Group Defect 1344 is applied, adding getresgid(), getresuid(), setresgid(), and setresuid() to SEE ALSO.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getc.html =====
getc
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getc — get a byte from a stream
SYNOPSIS
#include
int getc(FILE *stream);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The getc() function shall be equivalent to fgetc(), except that if it is
implemented as a macro it may evaluate stream more than once, so the argument should never be an expression with
side-effects.
RETURN VALUE
Refer to fgetc().
ERRORS
Refer to fgetc().
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
If the integer value returned by getc() is stored into a variable of type char and then compared against the
integer constant EOF, the comparison may never succeed, because sign-extension of a variable of type char on widening to
integer is implementation-defined.
Since it may be implemented as a macro, getc() may treat incorrectly a stream argument with side-effects. In
particular, getc(*f++) does not necessarily work as expected. Therefore, use of this function should be preceded by
"#undef getc" in such situations; fgetc() could also be used.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, fgetc()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0231 [14] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/mblen.html =====
mblen
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
mblen — get number of bytes in a character
SYNOPSIS
#include
int mblen(const char *s, size_t n);
DESCRIPTION
[CX]  Except for requirements relating to data races, the functionality described on this reference page is aligned with the
ISO C standard. Any other conflict between the requirements described here and the ISO C standard is unintentional. This
volume of POSIX.1-2024 defers to the ISO C standard for all mblen() functionality except in relation to data races.
If s is not a null pointer, mblen() shall determine the number of bytes constituting the character pointed to by
s. Except that the shift state of mbtowc() is not affected, it shall be
equivalent to:
mbtowc((wchar_t *)0, (const char *)0, 0);
mbtowc((wchar_t *)0, s, n);
The implementation shall behave as if no function defined in this volume of POSIX.1-2024 calls mblen().
The behavior of this function is affected by the LC_CTYPE category of the current locale. For a state-dependent encoding,
this function shall be placed into its initial state at program startup and can be returned to that state by a call for which its
character pointer argument, s, is a null pointer. Subsequent calls with s as other than a null pointer shall cause
the internal state of the function to be altered as necessary. A call with s as a null pointer shall cause this function to
return a non-zero value if encodings have state dependency, and 0 otherwise. If the implementation employs special bytes to change
the shift state, these bytes shall not produce separate wide-character codes, but shall be grouped with an adjacent character.
Changing the LC_CTYPE category causes the shift state of this function to be unspecified.
The mblen() function [CX]   need not be thread-safe; however, it   shall avoid data races with all other functions.
RETURN VALUE
If s is a null pointer, mblen() shall return a non-zero or 0 value, if character encodings, respectively, do or do
not have state-dependent encodings. If s is not a null pointer, mblen() shall either return 0 (if s points to
the null byte), or return the number of bytes that constitute the character (if the next n or fewer bytes form a valid
character), or return -1 (if they do not form a valid character) [CX]   and may set errno to indicate the error.  In no case shall the value returned be greater than n or the value of
the {MB_CUR_MAX} macro.
ERRORS
The mblen() function may fail if:
[EILSEQ]
[CX]  An
invalid character sequence is detected. In the POSIX locale an [EILSEQ] error cannot occur since all byte values are valid
characters.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
When the ISO C standard introduced threads in C11, it required mblen() to avoid data races (with itself as well as
with other functions), whereas POSIX.1-2008 did not require it to be thread-safe, and in many implementations it did not avoid data
races with itself and still does not. The ISO C committee intend to change the requirements in a future version of the ISO C
standard, but since POSIX.1 currently refers to C17 it is necessary for it not to defer to the ISO C standard regarding data
races in order to continue to allow this function not to avoid data races with itself.
FUTURE DIRECTIONS
It is expected that a change in a future version of the ISO C standard will allow a future version of this standard to
remove the data race exception from the statement that it defers to the ISO C standard.
SEE ALSO
mbtowc(), mbstowcs(), wctomb(), wcstombs()
XBD
CHANGE HISTORY
First released in Issue 4. Aligned with the ISO C standard.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0367 [109] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0204 [663,674] is applied.
Issue 8
Austin Group Defects 708 and 1302 are applied, aligning this function with the ISO/IEC 9899:2018 standard, except in
relation to data races.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/l64a.html =====
a64l
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
a64l, l64a — convert between a 32-bit integer and a radix-64 ASCII string
SYNOPSIS
[XSI]  #include
long a64l(const char *s);
char *l64a(long value);
DESCRIPTION
These functions maintain numbers stored in radix-64 ASCII characters. This is a notation by which 32-bit integers can be
represented by up to six characters; each character represents a digit in radix-64 notation. If the type long contains more
than 32 bits, only the low-order 32 bits shall be used for these operations.
The characters used to represent digits are '.' (dot) for 0, '/' for 1, '0' through '9' for
[2,11], 'A' through 'Z' for [12,37], and 'a' through 'z' for [38,63].
The a64l() function shall take a pointer to a radix-64 representation, in which the first digit is the least significant,
and return the corresponding long value. If the string pointed to by s contains more than six characters,
a64l() shall use the first six. If the first six characters of the string contain a null terminator, a64l() shall use
only characters preceding the null terminator. The a64l() function shall scan the character string from left to right with
the least significant digit on the left, decoding each character as a 6-bit radix-64 number. If the type long contains more
than 32 bits, the resulting value is sign-extended. The behavior of a64l() is unspecified if s is a null pointer or
the string pointed to by s was not generated by a previous call to l64a().
The l64a() function shall take a long argument and return a pointer to the corresponding radix-64 representation.
The behavior of l64a() is unspecified if value is negative.
The value returned by l64a() may be a pointer into a static buffer. Subsequent calls to l64a() may overwrite the
buffer.
The l64a() function need not be thread-safe.
RETURN VALUE
Upon successful completion, a64l() shall return the long value resulting from conversion of the input string. If a
string pointed to by s is an empty string, a64l() shall return 0L.
The l64a() function shall return a pointer to the radix-64 representation. If value is 0L, l64a() shall
return a pointer to an empty string.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
If the type long contains more than 32 bits, the result of a64l(l64a(x)) is x in the
low-order 32 bits.
RATIONALE
This is not the same encoding as used by either encoding variant of the uuencode
utility.
FUTURE DIRECTIONS
None.
SEE ALSO
strtoul()
XBD
XCU uuencode
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Normative text previously in the APPLICATION USAGE section is moved to the DESCRIPTION.
A note indicating that the l64a() function need not be reentrant is added to the DESCRIPTION.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/execl.html =====
exec
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
environ, execl, execle, execlp, execv, execve, execvp, fexecve — execute a file
SYNOPSIS
#include
extern char **environ;
int execl(const char *path, const char *arg0, ... /*, (char *)0 */);
int execle(const char *path, const char *arg0, ... /*,
(char *)0, char *const envp[]*/);
int execlp(const char *file, const char *arg0, ... /*, (char *)0 */);
int execv(const char *path, char *const argv[]);
int execve(const char *path, char *const argv[], char *const envp[]);
int execvp(const char *file, char *const argv[]);
int fexecve(int fd, char *const argv[], char *const envp[]);
DESCRIPTION
The exec family of functions shall replace the current process image with a new process image. The new image shall be
constructed from a regular, executable file called the new process image file. There shall be no return from a successful
exec, because the calling process image is overlaid by the new process image.
The fexecve() function shall be equivalent to the execve() function except that the file to be executed is
determined by the file descriptor fd instead of a pathname. The file offset of fd is ignored.
When a C-language program is executed as a result of a call to one of the exec family of functions, it shall be entered
as a C-language function call as follows:
int main (int argc, char *argv[]);
where argc is the argument count and argv is an array of character pointers to the arguments themselves. In
addition, the following variable, which needs to be declared by the user if it is to be used directly:
extern char **environ;
is initialized as a pointer to an array of character pointers to the environment strings. The argv and environ
arrays are each terminated by a null pointer. The null pointer terminating the argv array is not counted in argc.
Applications can change the entire environment in a single operation by assigning the environ variable to point to an
array of character pointers to the new environment strings. After assigning a new value to environ, applications should not
rely on the new environment strings remaining part of the environment, as a call to getenv(), secure_getenv(),
[XSI]
putenv(),  setenv(), unsetenv(), or any function that is
dependent on an environment variable may, on noticing that environ has changed, copy the environment strings to a new array
and assign environ to point to it.
Any application that directly modifies the pointers to which the environ variable points has undefined behavior.
Conforming multi-threaded applications shall not use the environ variable to access or modify any environment variable
while any other thread is concurrently modifying any environment variable. A call to any function dependent on any environment
variable shall be considered a use of the environ variable to access that environment variable.
The arguments specified by a program with one of the exec functions shall be passed on to the new process image in the
corresponding main() arguments.
For the execl(), execle(), execv(), and execve() functions, the argument path points to a
pathname that identifies the new process image file.
For the execlp() and execvp() functions, the argument file is used to construct a pathname that identifies
the new process image file. If the file argument contains a  character, the file argument shall be used
as the pathname for this file. Otherwise, the path prefix for this file is obtained by a search of the directories passed as the
environment variable PATH (see XBD 8. Environment Variables). If
this environment variable is not present, the results of the search are implementation-defined.
There are two distinct ways in which the contents of the process image file may cause the execution to fail, distinguished by
the setting of errno to either [ENOEXEC] or [EINVAL] (see the ERRORS section). In the cases where the other members of the
exec family of functions would fail and set errno to [ENOEXEC], the execlp() and execvp() functions
shall execute a command interpreter and the environment of the executed command shall be as if the process invoked the sh utility using execl() as follows:
execl(, , file, , (char *)0);
where  is an unspecified pathname for the sh utility,
is an unspecified string, file is the process image file, and where  is zero or more
parameters corresponding to any initial non-null arguments passed after arg0 for execlp() or to any initial non-null
members of argv starting at argv[1] for execvp().
The arguments represented by arg0,... are pointers to null-terminated character strings. These strings shall constitute
the argument list available to the new process image. The list is terminated by a null pointer. The argument arg0 should
point to a filename string that is associated with the process being started by one of the exec functions.
The argument argv is an array of character pointers to null-terminated strings. The application shall ensure that the
last member of this array is a null pointer. These strings shall constitute the argument list available to the new process image.
The value in argv[0] should point to a filename string that is associated with the process being started by one of the
exec functions.
The argument envp is an array of character pointers to null-terminated strings. These strings shall constitute the
environment for the new process image. The envp array is terminated by a null pointer.
For those forms not containing an envp pointer (execl(), execv(),
execlp(), and execvp()), the environment for the new process image shall be taken from the external variable
environ in the calling process.
The number of bytes available for the new process' combined argument and environment lists is {ARG_MAX}. It is
implementation-defined whether null terminators, pointers, and/or any alignment bytes are included in this total.
File descriptors open in the calling process image shall remain open in the new process image, except for those whose
close-on-exec flag FD_CLOEXEC is set. For those file descriptors that remain open, all attributes of the open file
description shall remain unchanged and the FD_CLOFORK file descriptor flag, if set, shall remain set. For any file descriptor that
is closed for this reason, process-owned file locks that the calling process owns on the file associated with the file descriptor
shall be unlocked as a result of the close, as described in close(). File locks that
are not unlocked by closing of file descriptors remain unchanged.
If file descriptor 0, 1, or 2 would otherwise be closed after a successful call to one of the exec family of functions,
implementations may open an unspecified file for the file descriptor in the new process image. If a standard utility or a
conforming application is executed with file descriptor 0 not open for reading or with file descriptor 1 or 2 not open for writing,
the environment in which the utility or application is executed shall be deemed non-conforming, and consequently the utility or
application might not behave as described in this standard.
Directory streams open in the calling process image shall be closed in the new process image.
The state of the floating-point environment in the initial thread of the new process image shall be set to the default.
The state of conversion descriptors and message catalog descriptors in the new process image is undefined.
For the new process image, the equivalent of:
setlocale(LC_ALL, "C")
shall be executed at start-up.
Signals set to the default action (SIG_DFL) in the calling process image shall be set to the default action in the new process
image. Except for SIGCHLD, signals set to be ignored (SIG_IGN) by the calling process image shall be set to be ignored by the new
process image. Signals set to be caught by the calling process image shall be set to the default action in the new process image
(see ).
If the SIGCHLD signal is set to be ignored by the calling process image, it is unspecified whether the SIGCHLD signal is set to
be ignored or to the default action in the new process image.
[XSI]
After a successful call to any of the exec functions, alternate signal stacks are not preserved and the SA_ONSTACK flag
shall be cleared for all signals.
After a successful call to any of the exec functions, any functions previously registered by the atexit(), at_quick_exit(), or pthread_atfork() functions are no longer registered.
[XSI]
If the ST_NOSUID bit is set for the file system containing the new process image file, then the effective user ID, effective group
ID, saved set-user-ID, and saved set-group-ID are unchanged in the new process image. Otherwise,  if the set-user-ID mode bit of the new process image file is set, the effective user ID of the new
process image shall be set to the user ID of the new process image file. Similarly, if the set-group-ID mode bit of the new process
image file is set, the effective group ID of the new process image shall be set to the group ID of the new process image file. The
real user ID, real group ID, and supplementary group IDs of the new process image shall remain the same as those of the calling
process image. The effective user ID and effective group ID of the new process image shall be saved (as the saved set-user-ID and
the saved set-group-ID) for use by setuid().
[XSI]
Any shared memory segments attached to the calling process image shall not be attached to the new process image.
Any named semaphores open in the calling process shall be closed as if by appropriate calls to sem_close(). Any unnamed semaphores open in the calling process shall be destroyed as if
by calls to sem_destroy().
[TYM]
Any blocks of typed memory that were mapped in the calling process are unmapped, as if munmap() was implicitly called to unmap them.
[ML]
Memory locks established by the calling process via calls to mlockall() or mlock() shall be removed. If locked pages in the address space of the calling process are also
mapped into the address spaces of other processes and are locked by those processes, the locks established by the other processes
shall be unaffected by the call by this process to the exec function. If the exec function fails, the effect on
memory locks is unspecified.
Memory mappings created in the process are unmapped before the address space is rebuilt for the new process image.
When the calling process image does not use the SCHED_FIFO, SCHED_RR, [SS]
or SCHED_SPORADIC   scheduling policies, the scheduling policy and parameters of the new process image and the initial
thread in that new process image are implementation-defined.
[PS]
When the calling process image uses the SCHED_FIFO, SCHED_RR, or SCHED_SPORADIC scheduling policies, the process policy and
scheduling parameter settings shall not be changed by a call to an exec function.  [TPS]   The initial thread in the new process image shall inherit the process scheduling policy and
parameters. It shall have the default system contention scope, but shall inherit its allocation domain from the calling process
image.
Per-process timers created by the calling process shall be deleted before replacing the current process image with the new
process image.
[MSG]
All open message queue descriptors in the calling process shall be closed, as described in mq_close().
Any outstanding asynchronous I/O operations may be canceled. Those asynchronous I/O operations that are not canceled shall
complete as if the exec function had not yet occurred, but any associated signal notifications shall be suppressed. It is
unspecified whether the exec function itself blocks awaiting such I/O completion. In no event, however, shall the new
process image created by the exec function be affected by the presence of outstanding asynchronous I/O operations at the
time the exec function is called. Whether any I/O is canceled, and which I/O may be canceled upon exec, is
implementation-defined.
[CPT]
The new process image shall inherit the CPU-time clock of the calling process image. This inheritance means that the process
CPU-time clock of the process being exec-ed shall not be reinitialized or altered as a result of the exec function
other than to reflect the time spent by the process executing the exec function itself.
[TCT]
The initial value of the CPU-time clock of the initial thread of the new process image shall be set to zero.
The thread ID of the initial thread in the new process image is unspecified.
The size and location of the stack on which the initial thread in the new process image runs is unspecified.
The initial thread in the new process image shall have its cancellation type set to PTHREAD_CANCEL_DEFERRED and its cancellation
state set to PTHREAD_CANCEL_ENABLED.
The initial thread in the new process image shall have all thread-specific data values set to NULL and all thread-specific data
keys shall be removed by the call to exec without running destructors.
The initial thread in the new process image shall be joinable, as if created with the detachstate attribute set to
PTHREAD_CREATE_JOINABLE.
The new process shall inherit at least the following attributes from the calling process image:
[XSI]
Nice value (see nice())
[XSI]
semadj values (see semop())
Process ID
Parent process ID
Process group ID
Session membership
Real user ID
Real group ID
Supplementary group IDs
Time left until an alarm clock signal (see alarm())
Current working directory
Root directory
File mode creation mask (see umask())
File size limit (see getrlimit() and setrlimit())
Process signal mask (see pthread_sigmask())
Pending signal (see sigpending())
tms_utime, tms_stime, tms_cutime, and tms_cstime (see times())
Resource limits
Controlling terminal
The initial thread of the new process shall inherit at least the following attributes from the calling thread:
Signal mask (see sigprocmask() and pthread_sigmask())
Pending signals (see sigpending())
All other process attributes defined in this volume of POSIX.1-2024 shall be inherited in the new process image from the old
process image. All other thread attributes defined in this volume of POSIX.1-2024 shall be inherited in the initial thread in the
new process image from the calling thread in the old process image. The inheritance of process or thread attributes not defined by
this volume of POSIX.1-2024 is implementation-defined.
A call to any exec function from a process with more than one thread shall result in all threads being terminated and the
new executable image being loaded and executed. No destructor functions or cleanup handlers shall be called.
Upon successful completion, the exec functions shall mark for update the last data access timestamp of the file. If an
exec function failed but was able to locate the process image file, whether the last data access timestamp is marked for
update is unspecified. Should the exec function succeed, the process image file shall be considered to have been opened with
open(). The corresponding close() shall be
considered to occur at a time after this open, but before process termination or successful completion of a subsequent call to one
of the exec functions, posix_spawn(), or posix_spawnp(). The argv[] and envp[] arrays of pointers and the strings
to which those arrays point shall not be modified by a call to one of the exec functions, except as a consequence of
replacing the process image.
The saved resource limits in the new process image are set to be a copy of the process' corresponding hard and soft limits.
RETURN VALUE
If one of the exec functions returns to the calling process image, an error has occurred; the return value shall be -1,
and errno shall be set to indicate the error.
ERRORS
The exec functions shall fail if:
[E2BIG]
The number of bytes used by the new process image's argument list and environment list is greater than the system-imposed limit
of {ARG_MAX} bytes.
[EACCES]
The new process image file is not a regular file and the implementation does not support execution of files of its type.
[EINVAL]
The new process image file has appropriate privileges and has a recognized executable binary format, but the system does not
support execution of a file with this format.
The exec functions, except for fexecve(), shall fail if:
[EACCES]
Search permission is denied for a directory listed in the new process image file's path prefix, or the new process image file
denies execution permission.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the path or file argument.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOENT]
A component of path or file does not name an existing file or path or file is an empty string.
[ENOTDIR]
A component of the new process image file's path prefix names an existing file that is neither a directory nor a symbolic link
to a directory, or the new process image file's pathname contains at least one non- character and ends with one or
more trailing  characters and the last pathname component names an existing file that is neither a directory nor a
symbolic link to a directory.
The exec functions, except for execlp() and execvp(), shall fail if:
[ENOEXEC]
The new process image file has the appropriate access permission but has an unrecognized format.
The fexecve() function shall fail if:
[EBADF]
The fd argument is not a valid file descriptor open for executing.
The exec functions may fail if:
[ENOMEM]
The new process image requires more memory than is allowed by the hardware or system-imposed memory management
constraints.
The exec functions, except for fexecve(), may fail if:
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the path or file argument.
[ENAMETOOLONG]
The length of the path argument or the length of the pathname constructed from the file argument exceeds {PATH_MAX},
or pathname resolution of a symbolic link produced an intermediate result with a length that exceeds {PATH_MAX}.
[ETXTBSY]
The new process image file is a pure procedure (shared text) file that is currently open for writing by some process.
The following sections are informative.
EXAMPLES
Using execl()
The following example executes the ls command, specifying the pathname of the
executable (/bin/ls) and using arguments supplied directly to the command to produce single-column output.
#include
int ret;
...
ret = execl ("/bin/ls", "ls", "-1", (char *)0);
Using execle()
The following example is similar to Using execl(). In addition, it specifies the environment
for the new process image using the env argument.
#include
int ret;
char *env[] = { "HOME=/usr/home", "LOGNAME=home", (char *)0 };
...
ret = execle ("/bin/ls", "ls", "-l", (char *)0, env);
Using execlp()
The following example searches for the location of the ls command among the
directories specified by the PATH environment variable.
#include
int ret;
...
ret = execlp ("ls", "ls", "-l", (char *)0);
Using execv()
The following example passes arguments to the ls command in the cmd array.
#include
int ret;
char *cmd[] = { "ls", "-l", (char *)0 };
...
ret = execv ("/bin/ls", cmd);
Using execve()
The following example passes arguments to the ls command in the cmd array, and
specifies the environment for the new process image using the env argument.
#include
int ret;
char *cmd[] = { "ls", "-l", (char *)0 };
char *env[] = { "HOME=/usr/home", "LOGNAME=home", (char *)0 };
...
ret = execve ("/bin/ls", cmd, env);
Using execvp()
The following example searches for the location of the ls command among the
directories specified by the PATH environment variable, and passes arguments to the ls command in the cmd array.
#include
int ret;
char *cmd[] = { "ls", "-l", (char *)0 };
...
ret = execvp ("ls", cmd);
APPLICATION USAGE
As the state of conversion descriptors and message catalog descriptors in the new process image is undefined, conforming
applications should not rely on their use and should close them prior to calling one of the exec functions.
Applications that require other than the default POSIX locale as the global locale in the new process image should call setlocale() with the appropriate parameters.
When assigning a new value to the environ variable, applications should ensure that the environment to which it will
point contains at least the following:
Any implementation-defined variables required by the implementation to provide a conforming environment. See the _CS_V8_ENV
entry in  and confstr() for details.
A value for PATH which finds conforming versions of all standard utilities before any other versions.
The same constraint applies to the envp array passed to execle() or execve(), in order to ensure that the
new process image is invoked in a conforming environment.
Applications should not execute programs with file descriptor 0 not open for reading or with file descriptor 1 or 2 not open for
writing, as this might cause the executed program to misbehave. In order not to pass on these file descriptors to an executed
program, applications should not just close them but should reopen them on, for example, /dev/null. Some implementations may
reopen them automatically, but applications should not rely on this being done.
If an application wants to perform an integrity test of the file being executed before executing it, the file will need to be
opened with read permission to perform the integrity test.
Since execute permission is checked by fexecve(), the file description fd need not have been opened with the
O_EXEC flag. However, if the file to be executed denies read and write permission for the process preparing to do the exec,
the only way to provide the fd to fexecve() will be to use the O_EXEC flag when opening fd. In this case, the
application will not be able to perform an integrity test since it will not be able to read the contents of the file.
Note that when a file descriptor is opened with O_RDONLY, O_RDWR, or O_WRONLY mode, the file descriptor can be used to read,
read and write, or write the file, respectively, even if the mode of the file changes after the file was opened. Using the O_EXEC
open mode is different; fexecve() will ignore the mode that was used when the file descriptor was opened and the exec
will fail if the mode of the file associated with fd does not grant execute permission to the calling process at the time
fexecve() is called.
RATIONALE
Early proposals required that the value of argc passed to main() be "one or greater". This was driven by the
same requirement in drafts of the ISO C standard. In fact, historical implementations have passed a value of zero when no
arguments are supplied to the caller of the exec functions. This requirement was removed from the ISO C standard and
subsequently removed from this volume of POSIX.1-2024 as well. The wording, in particular the use of the word should,
requires a Strictly Conforming POSIX Application to pass at least one argument to the exec function, thus guaranteeing that
argc be one or greater when invoked by such an application. In fact, this is good practice, since many existing applications
reference argv[0] without first checking the value of argc.
The requirement on a Strictly Conforming POSIX Application also states that the value passed as the first argument be a filename
string associated with the process being started. Although some existing applications pass a pathname rather than a filename string
in some circumstances, a filename string is more generally useful, since the common usage of argv[0] is in printing
diagnostics. In some cases the filename passed is not the actual filename of the file; for example, many implementations of the
login utility use a convention of prefixing a  ('-') to the actual filename, which indicates to
the command interpreter being invoked that it is a "login shell".
Also, note that the test and [ utilities require specific strings for the
argv[0] argument to have deterministic behavior across all implementations.
Historically, there have been two ways that implementations can exec shell scripts.
One common historical implementation is that the execl(), execv(), execle(), and execve() functions
return an [ENOEXEC] error for any file not recognizable as executable, including a shell script. When the execlp() and
execvp() functions encounter such a file, they assume the file to be a shell script and invoke a known command interpreter
to interpret such files. This is now required by POSIX.1-2024. These implementations of execvp() and execlp() only
give the [ENOEXEC] error in the rare case of a problem with the command interpreter's executable file. Because of these
implementations, the [ENOEXEC] error is not mentioned for execlp() or execvp(), although implementations can still
give it.
Another way that some historical implementations handle shell scripts is by recognizing the first two bytes of the file as the
character string "#!" and using the remainder of the first line of the file as the name of the command interpreter to
execute.
One potential source of confusion noted by the standard developers is over how the contents of a process image file affect the
behavior of the exec family of functions. The following is a description of the actions taken:
If the process image file is a valid executable (in a format that is executable and valid and having appropriate privileges) for
this system, then the system executes the file.
If the process image file has appropriate privileges and is in a format that is executable but not valid for this system (such
as a recognized binary for another architecture), then this is an error and errno is set to [EINVAL] (see later RATIONALE on
[EINVAL]).
If the process image file has appropriate privileges but is not otherwise recognized:
If this is a call to execlp() or execvp(), then they invoke a command interpreter assuming that the process image
file is a shell script.
If this is not a call to execlp() or execvp(), then an error occurs and errno is set to [ENOEXEC].
Applications that do not require to access their arguments may use the form:
main(void)
as specified in the ISO C standard. However, the implementation will always provide the two arguments argc and
argv, even if they are not used.
Some implementations provide a third argument to main() called envp. This is defined as a pointer to the
environment. The ISO C standard specifies invoking main() with two arguments, so implementations are required to
support applications written this way. Since this volume of POSIX.1-2024 defines the global variable environ, which is also
provided by historical implementations and can be used anywhere that envp could be used, there is no functional need for the
envp argument. Applications should use the getenv() function rather than
accessing the environment directly via either envp or environ. Implementations are required to support the
two-argument calling sequence, but this does not prohibit an implementation from supporting envp as an optional third
argument.
This volume of POSIX.1-2024 specifies that signals set to SIG_IGN remain set to SIG_IGN, and that the new process image inherits
the signal mask of the thread that called exec in the old process image. This is consistent with historical implementations,
and it permits some useful functionality, such as the nohup command. However, it
should be noted that many existing applications wrongly assume that they start with certain signals set to the default action
and/or unblocked. In particular, applications written with a simpler signal model that does not include blocking of signals, such
as the one in the ISO C standard, may not behave properly if invoked with some signals blocked. Therefore, it is best not to
block or ignore signals across execs without explicit reason to do so, and especially not to block signals across
execs of arbitrary (not closely cooperating) programs.
The exec functions always save the value of the effective user ID and effective group ID of the process at the completion
of the exec, whether or not the set-user-ID or the set-group-ID bit of the process image file is set.
The statement about argv[] and envp[] being constants is included to make explicit to future writers of language
bindings that these objects are completely constant. Due to a limitation of the ISO C standard, it is not possible to state
that idea in standard C. Specifying two levels of const-qualification for the argv[] and envp[]
parameters for the exec functions may seem to be the natural choice, given that these functions do not modify either the
array of pointers or the characters to which the function points, but this would disallow existing correct code. Instead, only the
array of pointers is noted as constant. The table of assignment compatibility for dst=src derived from the ISO C
standard summarizes the compatibility:
dst:
char *[]
const char *[]
char *const[]
const char *const[]
src:
char *[]
VALID
—
VALID
—
const char *[]
—
VALID
—
VALID
char * const []
—
—
VALID
—
const char *const[]
—
—
—
VALID
Since all existing code has a source type matching the first row, the column that gives the most valid combinations
is the third column. The only other possibility is the fourth column, but using it would require a cast on the argv or
envp arguments. It is unfortunate that the fourth column cannot be used, because the declaration a non-expert would
naturally use would be that in the second row.
The ISO C standard and this volume of POSIX.1-2024 do not conflict on the use of environ, but some
historical implementations of environ may cause a conflict. As long as environ is treated in the same way as an entry
point (for example, fork()), it conforms to both standards. A library can contain
fork(), but if there is a user-provided fork(), that fork() is given precedence and no
problem ensues. The situation is similar for environ: the definition in this volume of POSIX.1-2024 is to be used if there
is no user-provided environ to take precedence. At least three implementations are known to exist that solve this
problem.
[E2BIG]
The limit {ARG_MAX} applies not just to the size of the argument list, but to the sum of that and the size of the environment
list.
[EFAULT]
Some historical systems return [EFAULT] rather than [ENOEXEC] when the new process image file is corrupted. They are
non-conforming.
[EINVAL]
This error condition was added to POSIX.1-2024 to allow an implementation to detect executable files generated for different
architectures, and indicate this situation to the application. Historical implementations of shells, execvp(), and
execlp() that encounter an [ENOEXEC] error will execute a shell on the assumption that the file is a shell script. This will
not produce the desired effect when the file is a valid executable for a different architecture. An implementation may now choose
to avoid this problem by returning [EINVAL] when a valid executable for a different architecture is encountered. Some historical
implementations return [EINVAL] to indicate that the path argument contains a character with the high order bit set. The
standard developers chose to deviate from historical practice for the following reasons:
The new utilization of [EINVAL] will provide some measure of utility to the user community.
Historical use of [EINVAL] is not acceptable in an internationalized operating environment.
[ENAMETOOLONG]
Since the file pathname may be constructed by taking elements in the PATH variable and putting them together with the
filename, the [ENAMETOOLONG] error condition could also be reached this way.
[ETXTBSY]
System V returns this error when the executable file is currently open for writing by some process. This volume of POSIX.1-2024
neither requires nor prohibits this behavior.
Other systems (such as System V) may return [EINTR] from exec. This is not addressed by this volume of
POSIX.1-2024, but implementations may have a window between the call to exec and the time that a signal could cause one of
the exec calls to return with [EINTR].
An explicit statement regarding the floating-point environment (as defined in the  header) was added to make it clear that the floating-point environment is set
to its default when a call to one of the exec functions succeeds. The requirements for inheritance or setting to the default
for other process and thread start-up functions is covered by more generic statements in their descriptions and can be summarized
as follows:
posix_spawn()
Set to default.
fork()
Inherit.
pthread_create()
Inherit.
The purpose of the fexecve() function is to enable executing a file which has been verified to be the
intended file. It is possible to actively check the file by reading from the file descriptor and be sure that the file is not
exchanged for another between the reading and the execution. Alternatively, a function like openat() can be used to open a file which has been found by reading the content of a
directory using readdir().
When execlp() or execvp() fall back to invoking sh because
of an [ENOEXEC] condition, the standard leaves the process name (what becomes argv[0] in the resulting sh process) unspecified. Existing implementations vary on whether they pass a variation of
"sh", or preserve the original arg0. There are existing implementations of sh that behave differently depending on the contents of argv[0], such that blindly passing
the original arg0 on to the fallback execution can fail to invoke a compliant shell environment. Because of the requirements
on how sh handles its command line arguments, the shell script will see $0
containing the pathname of the script being executed, regardless of the value of argv[0].
FUTURE DIRECTIONS
None.
SEE ALSO
alarm(), atexit(), chmod(), close(), confstr(), exit(), fcntl(), fork(), fstatvfs(), getenv(), getrlimit(), mknod(), mmap(), nice(), open(), posix_spawn(), pthread_atfork(), pthread_sigmask(), putenv(),
readdir(), semop(), setlocale(), shmat(), sigaction(), sigaltstack(),
sigpending(), system(),
times(), umask()
XBD 8. Environment Variables,
XCU test
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Realtime Extension and the POSIX Threads Extension.
Large File Summit extensions are added.
Issue 6
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
In the DESCRIPTION, behavior is defined for when the process image file is not a valid executable.
In this version, _POSIX_SAVED_IDS is mandated, thus the effective user ID and effective group ID of the new
process image shall be saved (as the saved set-user-ID and the saved set-group-ID) for use by the setuid() function.
The [ELOOP] mandatory error condition is added.
A second [ENAMETOOLONG] is added as an optional error condition.
The [ETXTBSY] optional error condition is added.
The following changes were made to align with the IEEE P1003.1a draft standard:
The [EINVAL] mandatory error condition is added.
The [ELOOP] optional error condition is added.
The description of CPU-time clock semantics is added for alignment with IEEE Std 1003.1d-1999.
The DESCRIPTION is updated for alignment with IEEE Std 1003.1j-2000 by adding semantics for typed
memory.
The normative text is updated to avoid use of the term "must" for application requirements.
The description of tracing semantics is added for alignment with IEEE Std 1003.1q-2000.
IEEE PASC Interpretation 1003.1 #132 is applied.
The DESCRIPTION is updated to make it explicit that the floating-point environment in the new process image is set
to the default.
The DESCRIPTION and RATIONALE are updated to include clarifications of how the contents of a process image file
affect the behavior of the exec functions.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/15 is applied, adding a new paragraph to the
DESCRIPTION and text to the end of the APPLICATION USAGE section. This change addresses a security concern, where implementations
may want to reopen file descriptors 0, 1, and 2 for programs with the set-user-id or set-group-id file mode bits calling the
exec family of functions.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/24 is applied, applying changes to the DESCRIPTION,
addressing which attributes are inherited by threads, and behavioral requirements for threads attributes.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/25 is applied, updating text in the RATIONALE from
"the process signal mask be unchanged across an exec" to "the new process image inherits the signal mask of the thread
that called exec in the old process image".
Issue 7
Austin Group Interpretation 1003.1-2001 #047 is applied, adding the description of _CS_V7_ENV to the APPLICATION USAGE.
Austin Group Interpretation 1003.1-2001 #143 is applied.
The fexecve() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 2.
Functionality relating to the Asynchronous Input and Output, Memory Mapped Files, Threads, and Timers options is
moved to the Base.
Changes are made related to support for finegrained timestamps.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0095 [386], XSH/TC1-2008/0096 [167], XSH/TC1-2008/0097 [291],
XSH/TC1-2008/0098 [173], XSH/TC1-2008/0099 [296], XSH/TC1-2008/00100 [324], XSH/TC1-2008/00101 [296], XSH/TC1-2008/00102 [302],
XSH/TC1-2008/00103 [167], XSH/TC1-2008/00104 [173], and XSH/TC1-2008/00105 [291,429] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0097 [584], XSH/TC2-2008/0098 [898], and XSH/TC2-2008/0099
[734] are applied.
Issue 8
Austin Group Defects 51 and 1669 are applied, moving the getrlimit() and
setrlimit() functions from the XSI option to the Base.
Austin Group Defect 368 is applied, adding a requirement for unnamed semaphores to be destroyed.
Austin Group Defect 768 is applied, adding OFD-owned file locks.
Austin Group Defect 922 is applied, adding the secure_getenv()
function.
Austin Group Defect 1284 is applied, changing "checksum test" to "integrity test" in the APPLICATION USAGE
section.
Austin Group Defect 1318 is applied, adding FD_CLOFORK.
Austin Group Defect 1330 is applied, removing obsolescent interfaces and changing "_V7_" to "_V8_".
Austin Group Defect 1435 is applied, adding function lists to the descriptions of the path and file
arguments.
Austin Group Defect 1645 is applied, making it unspecified what string is passed to the shell in argv[0]
when executed by execlp() or execvp().
Austin Group Defect 1646 is applied, adding at_quick_exit() to
the list of registration functions whose registrations are not inherited across exec.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/ptsname_r.html =====
ptsname
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ptsname, ptsname_r — get name of the subsidiary pseudo-terminal device
SYNOPSIS
[XSI]  #include
char *ptsname(int fildes);
int ptsname_r(int fildes, char *name, size_t namesize);
DESCRIPTION
The ptsname() function shall return the name of the subsidiary pseudo-terminal device associated with a manager
pseudo-terminal device. The fildes argument is a file descriptor that refers to the manager device. The ptsname()
function shall return a pointer to a string containing the pathname of the corresponding subsidiary device.
The ptsname() function need not be thread-safe.
The ptsname_r() function shall store the name of the subsidiary pseudo-terminal device corresponding to fildes in
the character array referenced by name. The array is namesize characters long and should have space for the name and
the terminating null character. The maximum length of the terminal name shall be {TTY_NAME_MAX}.
RETURN VALUE
Upon successful completion, ptsname() shall return a pointer to a string which is the name of the pseudo-terminal
subsidiary device. Upon failure, ptsname() shall return a null pointer and may set errno. This could occur if
fildes is an invalid file descriptor or if the subsidiary device name does not exist in the file system.
The application shall not modify the string returned. The returned pointer might be invalidated or the string content might be
overwritten by a subsequent call to ptsname(). The returned pointer and the string content might also be invalidated if the
calling thread is terminated.
If successful, the ptsname_r() function shall return zero. Otherwise, an error number shall be returned to indicate the
error.
ERRORS
The ptsname_r() function shall fail if:
[EBADF]
The fildes argument is not a valid file descriptor.
[EINVAL]
The name argument is a null pointer.
[ERANGE]
The value of namesize is smaller than the length of the string to be returned including the terminating null
character.
The ptsname() function may fail if:
[EBADF]
The fildes argument is not a valid file descriptor.
The ptsname() and ptsname_r() functions may fail if:
[EINVAL] or [ENOTTY]
The file associated with the fildes argument is not a manager pseudo-terminal device.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
The ptsname_r() function is required to make it possible for a multi-threaded program to safely determine the name of a
subsidiary device. Although the name of the device is constrained by {TTY_NAME_MAX}, this value might not be a compile-time
constant, so an application can rely on repeated calls with successively larger buffers until the result is no longer [ERANGE] as
an alternative for properly sizing the buffer.
Historically, some versions of ptsname() did not set errno even when returning a null pointer. However,
ptsname_r() is required to either populate the buffer with a valid name or return an error value.
See also the RATIONALE section for posix_openpt().
FUTURE DIRECTIONS
None.
SEE ALSO
grantpt(), open(), posix_openpt(), ttyname(), unlockpt()
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
A note indicating that this function need not be reentrant is added to the DESCRIPTION.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0468 [75] and XSH/TC1-2008/0469 [96] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0298 [503], XSH/TC2-2008/0299 [656], and XSH/TC2-2008/0300 [503] are
applied.
Issue 8
Austin Group Defect 508 is applied, adding the ptsname_r() function.
Austin Group Defect 1466 is applied, changing the terminology used for pseudo-terminal devices.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/isblank_l.html =====
isblank
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
isblank, isblank_l — test for a blank character
SYNOPSIS
#include
int isblank(int c);
[CX]  int isblank_l(int c, locale_t locale);
DESCRIPTION
For isblank(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The isblank() [CX]   and isblank_l()
functions shall test whether c is a character of class blank in the current locale, [CX]   or in the
locale represented by locale,  respectively; see XBD 7. Locale.
The c argument is a type int, the value of which the application shall ensure is a character representable as an
unsigned char or equal to the value of the macro EOF. If the argument has any other value, the behavior is undefined.
[CX]  The
behavior is undefined if the locale argument to isblank_l() is the special locale object LC_GLOBAL_LOCALE or is not a
valid locale object handle.
RETURN VALUE
The isblank() [CX]   and isblank_l()
functions shall return non-zero if c is a ; otherwise, they shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
To ensure applications portability, especially across natural languages, only these functions and the functions in the reference
pages listed in the SEE ALSO section should be used for character classification.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
isalnum(), isalpha(), iscntrl(), isdigit(), isgraph(), islower(), isprint(), ispunct(), isspace(), isupper(), isxdigit(), setlocale(), uselocale()
XBD 7. Locale, ,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
The isblank_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0280 [302], XSH/TC1-2008/0281 [283], and XSH/TC1-2008/0282 [283] are
applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/nexttoward.html =====
nextafter
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
nextafter, nextafterf, nextafterl, nexttoward, nexttowardf, nexttowardl — next representable floating-point
number
SYNOPSIS
#include
double nextafter(double x, double y);
float nextafterf(float x, float y);
long double nextafterl(long double x, long double y);
double nexttoward(double x, long double y);
float nexttowardf(float x, long double y);
long double nexttowardl(long double x, long double y);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The nextafter(), nextafterf(), and nextafterl() functions shall compute the next representable
floating-point value following x in the direction of y. Thus, if y is less than x, nextafter()
shall return the largest representable floating-point number less than x. The nextafter(), nextafterf(), and
nextafterl() functions shall return y if x equals y.
The nexttoward(), nexttowardf(), and nexttowardl() functions shall be equivalent to the corresponding
nextafter() functions, except that the second parameter shall have type long double and the functions shall return
y converted to the type of the function if x equals y.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the next representable floating-point value following x in the
direction of y.
If x==y, y (of the type x) shall be returned.
[MX]
Even though underflow or overflow can occur, the returned value shall be independent of the current rounding direction mode.
If x is finite and the correct function value would overflow, a range error shall occur and ±HUGE_VAL, ±HUGE_VALF, and
±HUGE_VALL (with the same sign as x) shall be returned as appropriate for the return type of the function.
[MX]  If
x or y is NaN, a NaN shall be returned.
[MX]  If
x!=y and the correct function value is subnormal, zero, or underflows, a range error shall occur, and
[MXX]
the correct function value (if representable) or
[MX]  0.0 shall be returned.
ERRORS
These functions shall fail if:
Range Error
The correct value overflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall be
raised.
Range Error
[MX]
The correct value is subnormal or underflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
When  is included, note that the return type of
nextafter() depends on the generic typing deduced from both arguments, while the return type of nexttoward() depends
only on the generic typing of the first argument.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
The nextafter() function is no longer marked as an extension.
The nextafterf(), nextafterl(), nexttoward(), nexttowardf(), and nexttowardl() functions are
added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0407 [68] and XSH/TC1-2008/0408 [357] are applied.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/remainderf.html =====
remainder
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
remainder, remainderf, remainderl — remainder function
SYNOPSIS
#include
double remainder(double x, double y);
float remainderf(float x, float y);
long double remainderl(long double x, long double y);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall return the floating-point remainder r=x-ny when y is non-zero. The value
n is the integral value nearest the exact value x/y. When |n-x/y|=½, the value n
is chosen to be even.
The behavior of remainder() shall be independent of the rounding mode.
RETURN VALUE
Upon successful completion, these functions shall return the floating-point remainder r=x-ny when y
is non-zero.
[MX]
When subnormal results are supported, the returned value shall be exact.
On systems that do not support the IEC 60559 Floating-Point option, if y is zero, it is implementation-defined whether a
domain error occurs or zero is returned.
[MX]  If
x or y is NaN, a NaN shall be returned.
If x is infinite or y is 0 and the other is non-NaN, a domain error shall occur, and a NaN shall be returned.
ERRORS
These functions shall fail if:
Domain Error
[MX]
The x argument is ±Inf, or the y argument is ±0 and the other argument is non-NaN.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
These functions may fail if:
Domain Error
The y argument is zero.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
abs(), div(), feclearexcept(), fetestexcept()
, ldiv()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
The remainder() function is no longer marked as an extension.
The remainderf() and remainderl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
ISO/IEC 9899:1999 standard, Technical Corrigendum 2 #55 (SD5-XSH-ERN-82) is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0506 [320] is applied.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fstat.html =====
fstat
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fstat — get file status
SYNOPSIS
#include
int fstat(int fildes, struct stat *buf);
DESCRIPTION
The fstat() function shall obtain information about an open file associated with the file descriptor fildes, and
shall write it to the area pointed to by buf.
[SHM]
If fildes references a shared memory object, the implementation shall update in the stat structure pointed to by the
buf argument the st_uid, st_gid, st_size, and st_mode fields, and only the S_IRUSR, S_IWUSR,
S_IRGRP, S_IWGRP, S_IROTH, and S_IWOTH file permission bits need be valid. The implementation may update other fields and flags.
[TYM]
If fildes references a typed memory object, the implementation shall update in the stat structure pointed to by the
buf argument the st_uid, st_gid, st_size, and st_mode fields, and only the S_IRUSR, S_IWUSR,
S_IRGRP, S_IWGRP, S_IROTH, and S_IWOTH file permission bits need be valid. The implementation may update other fields and flags.
The buf argument is a pointer to a stat structure, as defined in , into which information is placed concerning the file.
For all other file types defined in this volume of POSIX.1-2024, the structure members st_mode, st_ino,
st_dev, st_uid, st_gid, st_atim, st_ctim, and st_mtim shall have meaningful values and
the value of the st_nlink member shall be set to the number of links to the file.
An implementation that provides additional or alternative file access control mechanisms may, under implementation-defined
conditions, cause fstat() to fail.
The fstat() function shall update any time-related fields (as described in XBD 4.12 File Times Update), before writing into the stat structure.
RETURN VALUE
Upon successful completion, 0 shall be returned. Otherwise, -1 shall be returned and errno set to indicate the error.
ERRORS
The fstat() function shall fail if:
[EBADF]
The fildes argument is not a valid file descriptor.
[EIO]
An I/O error occurred while reading from the file system.
[EOVERFLOW]
The file size in bytes or the number of blocks allocated to the file or the file serial number cannot be represented correctly
in the structure pointed to by buf.
The fstat() function may fail if:
[EOVERFLOW]
One of the values is too large to store into the structure pointed to by the buf argument.
The following sections are informative.
EXAMPLES
Obtaining File Status Information
The following example shows how to obtain file status information for a file named /home/cnd/mod1. The structure variable
buffer is defined for the stat structure. The /home/cnd/mod1 file is opened with read/write privileges and is
passed to the open file descriptor fildes.
#include
#include
#include
struct stat buffer;
int         status;
...
fildes = open("/home/cnd/mod1", O_RDWR);
status = fstat(fildes, &buffer);
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
fstatat()
XBD 4.12 File Times Update, ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Realtime Extension.
Large File Summit extensions are added.
Issue 6
In the SYNOPSIS, the optional include of the  header is
removed.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The requirement to include  has been removed. Although
was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.
The [EIO] mandatory error condition is added.
The [EOVERFLOW] mandatory error condition is added. This change is to support large files.
The [EOVERFLOW] optional error condition is added.
The DESCRIPTION is updated for alignment with IEEE Std 1003.1j-2000 by specifying that shared memory object semantics
apply to typed memory objects.
Issue 7
XSH-SD5-ERN-161 is applied, updating the DESCRIPTION to clarify to which file types st_nlink applies.
Changes are made related to support for finegrained timestamps.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/strncasecmp.html =====
strcasecmp
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
strcasecmp, strcasecmp_l, strncasecmp, strncasecmp_l — case-insensitive string comparisons
SYNOPSIS
#include
int strcasecmp(const char *s1, const char *s2);
int strcasecmp_l(const char *s1, const char *s2,
locale_t locale);
int strncasecmp(const char *s1, const char *s2, size_t n);
int strncasecmp_l(const char *s1, const char *s2,
size_t n, locale_t locale);
DESCRIPTION
The strcasecmp() and strcasecmp_l() functions shall compare, while ignoring differences in case, the string
pointed to by s1 to the string pointed to by s2. The strncasecmp() and strncasecmp_l() functions shall
compare, while ignoring differences in case, not more than n bytes from the string pointed to by s1 to the string
pointed to by s2.
The strcasecmp() and strncasecmp() functions use the current locale to determine the case of the characters.
The strcasecmp_l() and strncasecmp_l() functions use the locale represented by locale to determine the case
of the characters.
When the LC_CTYPE category of the locale being used is from the POSIX locale, these functions shall behave as if the
strings had been converted to lowercase and then a byte comparison performed, and errno shall not be changed on valid input.
Otherwise, the results are unspecified.
The behavior is undefined if the locale argument to strcasecmp_l() or strncasecmp_l() is the special locale
object LC_GLOBAL_LOCALE or is not a valid locale object handle.
RETURN VALUE
Upon completion, strcasecmp() and strcasecmp_l() shall return an integer greater than, equal to, or less than 0,
if the string pointed to by s1 is, ignoring case, greater than, equal to, or less than the string pointed to by s2,
respectively.
Upon successful completion, strncasecmp() and strncasecmp_l() shall return an integer greater than, equal to, or
less than 0, if the possibly null-terminated array pointed to by s1 is, ignoring case, greater than, equal to, or less than
the possibly null-terminated array pointed to by s2, respectively.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
wcscasecmp()
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 7
The strcasecmp() and strncasecmp() functions are moved from the XSI option to the Base.
The strcasecmp_l() and strncasecmp_l() functions are added from The Open Group Technical Standard, 2006, Extended
API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0589 [302], XSH/TC1-2008/0590 [294], XSH/TC1-2008/0591 [283], and
XSH/TC1-2008/0592 [283] are applied.
Issue 8
Austin Group Defect 448 is applied, adding a requirement that errno is not changed on valid input.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fgetws.html =====
fgetws
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fgetws — get a wide-character string from a stream
SYNOPSIS
#include
#include
wchar_t *fgetws(wchar_t *restrict ws, int n,
FILE *restrict stream);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The fgetws() function shall read characters from the stream, convert these to the corresponding wide-character
codes, place them in the wchar_t array pointed to by ws, until n-1 characters are read, or a
is read, converted, and transferred to ws, or an end-of-file condition is encountered. The wide-character string, ws,
shall then be terminated with a null wide-character code.
If an error occurs, the resulting value of the file position indicator for the stream is unspecified.
[CX]  The
fgetws() function may mark the last data access timestamp of the file associated with stream for update. The last
data access timestamp shall be marked for update by the first successful execution of fgetwc(), fgetws(), fwscanf(), getwc(), getwchar(), vfwscanf(), vwscanf(), or wscanf() using stream that returns data not supplied by a prior call to ungetwc().
RETURN VALUE
Upon successful completion, fgetws() shall return ws. If the end-of-file indicator for the stream is set, or if
the stream is at end-of-file, the end-of-file indicator for the stream shall be set and fgetws() shall return a null
pointer. If an error occurs, the error indicator for the stream shall be set, and fgetws() shall return a null pointer
[CX]
and shall set errno to indicate the error.
ERRORS
Refer to fgetwc().
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, fopen(), fread()
XBD ,
CHANGE HISTORY
First released in Issue 4. Derived from the MSE working draft.
Issue 5
The Optional Header (OH) marking is removed from .
Issue 6
Extensions beyond the ISO C standard are marked.
The prototype for fgetws() is changed for alignment with the ISO/IEC 9899:1999 standard.
Issue 7
Austin Group Interpretation 1003.1-2001 #051 is applied, clarifying the RETURN VALUE section.
Changes are made related to support for finegrained timestamps.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0139 [14] is applied.
Issue 8
Austin Group Defect 1624 is applied, changing the RETURN VALUE section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sync.html =====
sync
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sync — schedule file system updates
SYNOPSIS
[XSI]  #include
void sync(void);
DESCRIPTION
The sync() function shall cause all information in memory that updates file systems to be scheduled for writing out to
all file systems.
The writing, although scheduled, is not necessarily complete upon return from sync().
RETURN VALUE
The sync() function shall not return a value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
fsync()
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/random.html =====
initstate
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
initstate, random, setstate, srandom — pseudo-random number functions
SYNOPSIS
[XSI]  #include
char *initstate(unsigned seed, char *state, size_t size);
long random(void);
char *setstate(char *state);
void srandom(unsigned seed);
DESCRIPTION
The random() function shall use a non-linear additive feedback random-number generator employing a default state array
size of 31 long integers to return successive pseudo-random numbers in the range from 0 to 231-1.
The period of this random-number generator is approximately 16 x (231-1). The size of the state array
determines the period of the random-number generator. Increasing the state array size shall increase the period.
With 256 bytes of state information, the period of the random-number generator shall be greater than
269.
Like rand(), random() shall produce by default a sequence of numbers that can
be duplicated by calling srandom() with 1 as the seed.
The srandom() function shall initialize the current state array using the value of seed.
The initstate() and setstate() functions handle restarting and changing random-number generators. The
initstate() function allows a state array, pointed to by the state argument, to be initialized for future use. The
size argument, which specifies the size in bytes of the state array, shall be used by initstate() to decide what type
of random-number generator to use; the larger the state array, the more random the numbers. Values for the amount of state
information are 8, 32, 64, 128, and 256 bytes. Other values greater than 8 bytes are rounded down to the nearest one of these
values. If initstate() is called with 8
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
In the DESCRIPTION, the phrase "values smaller than 8" is replaced with "values greater than or equal to 8, or less than
32", "size>>
===== susv5-html/functions/V2_chap01.html =====
Introduction
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
1. Introduction
The System Interfaces volume of POSIX.1-2024 describes the interfaces offered to application programs by POSIX-conformant
systems.
1.1 Relationship to Other Formal Standards
This volume of POSIX.1-2024 is aligned with the following standards, except where stated otherwise:
ISO C (C17)
ISO/IEC 9899:2018, Programming Languages — C.
Parts of the ISO/IEC 9899:2018 standard (hereinafter referred to as the ISO C standard) are referenced to describe
requirements also mandated by this volume of POSIX.1-2024. Some functions and headers included within this volume of POSIX.1-2024
have a version in the ISO C standard; in this case CX markings are added as appropriate to show where the ISO C standard
has been extended (see 1.8.1 Codes). Any conflict between this volume
of POSIX.1-2024 and the ISO C standard is unintentional, except where stated otherwise.
This volume of POSIX.1-2024 also allows, but does not require, mathematics functions to support IEEE Std 754-1985 and
IEEE Std 854-1987.
1.2 Format of Entries
The entries in 3. System Interfaces are based on a common format as
follows. The only sections relating to conformance are the SYNOPSIS, DESCRIPTION, RETURN VALUE, and ERRORS sections.
NAME
This section gives the name or names of the entry and briefly states its purpose.
SYNOPSIS
This section summarizes the use of the entry being described. If it is necessary to include a header to use this function, the
names of such headers are shown, for example:
#include
DESCRIPTION
This section describes the functionality of the function or header.
RETURN VALUE
This section indicates the possible return values, if any.
If the implementation can detect errors, "successful completion" means that no error has been detected during execution of the
function. If the implementation does detect an error, the error is indicated.
For functions where no errors are defined, "successful completion" means that if the implementation checks for errors, no
error has been detected. If the implementation can detect errors, and an error is detected, the indicated return value is returned
and errno may be set.
ERRORS
This section gives the symbolic names of the error values returned by a function or stored into a variable accessed through the
symbol errno if an error occurs.
"No errors are defined" means that error values returned by a function or stored into a variable accessed through the symbol
errno, if any, depend on the implementation.
EXAMPLES
This section is informative.
This section gives examples of usage, where appropriate. In the event of conflict between an example and a normative part of
this volume of POSIX.1-2024, the normative material is to be taken as correct.
APPLICATION USAGE
This section is informative.
This section gives warnings and advice to application developers about the entry. In the event of conflict between warnings and
advice and a normative part of this volume of POSIX.1-2024, the normative material is to be taken as correct.
RATIONALE
This section is informative.
This section contains historical information concerning the contents of this volume of POSIX.1-2024 and why features were
included or discarded by the standard developers.
FUTURE DIRECTIONS
This section is informative.
This section provides comments which should be used as a guide to current thinking; there is not necessarily a commitment to
adopt these future directions.
SEE ALSO
This section is informative.
This section gives references to related information.
CHANGE HISTORY
This section is informative.
This section shows the derivation of the entry and any significant changes that have been made to it.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/iswctype_l.html =====
iswctype
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
iswctype, iswctype_l — test character for a specified class
SYNOPSIS
#include
int iswctype(wint_t wc, wctype_t charclass);
[CX]  int iswctype_l(wint_t wc, wctype_t charclass,
locale_t locale);
DESCRIPTION
For iswctype(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The iswctype() [CX]   and iswctype_l()
functions shall determine whether the wide-character code wc has the character class charclass, returning true
or false. The iswctype() [CX]   and iswctype_l()
functions are defined on WEOF and wide-character codes corresponding to the valid character encodings in the current locale, or
[CX]
in the locale represented by locale,  respectively. If
the wc argument is not in the domain of the function, the result is undefined. If the value of charclass is invalid
(that is, not obtained by a call to wctype() or charclass is invalidated by a
subsequent call to setlocale() that has affected category LC_CTYPE ) the
result is unspecified.
[CX]  The
behavior is undefined if the locale argument to iswctype_l() is the special locale object LC_GLOBAL_LOCALE or is not
a valid locale object handle.
RETURN VALUE
The iswctype() [CX]   and iswctype_l()
functions shall return non-zero (true) if and only if wc has the property described by charclass. If
charclass is (wctype_t)0, the iswctype() [CX]   and iswctype_l()  functions shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
Testing for a Valid Character
#include
...
int yes_or_no;
wint_t wc;
wctype_t valid_class;
...
if ((valid_class=wctype("vowel")) == (wctype_t)0)
/* Invalid character class. */
yes_or_no=iswctype(wc,valid_class);
APPLICATION USAGE
The twelve strings "alnum", "alpha", "blank", "cntrl", "digit", "graph",
"lower", "print", "punct", "space", "upper", and "xdigit" are reserved for
the standard character classes. In the table below, the functions in the left column are equivalent to the functions in the right
column.
iswalnum(wc)            iswctype(wc, wctype("alnum"))
iswalnum_l(wc, locale)  iswctype_l(wc, wctype("alnum"), locale)
iswalpha(wc)            iswctype(wc, wctype("alpha"))
iswalpha_l(wc, locale)  iswctype_l(wc, wctype("alpha"), locale)
iswblank(wc)            iswctype(wc, wctype("blank"))
iswblank_l(wc, locale)  iswctype_l(wc, wctype("blank"), locale)
iswcntrl(wc)            iswctype(wc, wctype("cntrl"))
iswcntrl_l(wc, locale)  iswctype_l(wc, wctype("cntrl"), locale)
iswdigit(wc)            iswctype(wc, wctype("digit"))
iswdigit_l(wc, locale)  iswctype_l(wc, wctype("digit"), locale)
iswgraph(wc)            iswctype(wc, wctype("graph"))
iswgraph_l(wc, locale)  iswctype_l(wc, wctype("graph"), locale)
iswlower(wc)            iswctype(wc, wctype("lower"))
iswlower_l(wc, locale)  iswctype_l(wc, wctype("lower"), locale)
iswprint(wc)            iswctype(wc, wctype("print"))
iswprint_l(wc, locale)  iswctype_l(wc, wctype("print"), locale)
iswpunct(wc)            iswctype(wc, wctype("punct"))
iswpunct_l(wc, locale)  iswctype_l(wc, wctype("punct"), locale)
iswspace(wc)            iswctype(wc, wctype("space"))
iswspace_l(wc, locale)  iswctype_l(wc, wctype("space"), locale)
iswupper(wc)            iswctype(wc, wctype("upper"))
iswupper_l(wc, locale)  iswctype_l(wc, wctype("upper"), locale)
iswxdigit(wc)           iswctype(wc, wctype("xdigit"))
iswxdigit_l(wc, locale) iswctype_l(wc, wctype("xdigit"), locale)
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
iswalnum(), iswalpha(),
iswcntrl(), iswdigit(),
iswgraph(), iswlower(),
iswprint(), iswpunct(),
iswspace(), iswupper(),
iswxdigit(), setlocale(),
uselocale(), wctype()
XBD ,
CHANGE HISTORY
First released as World-wide Portability Interfaces in Issue 4.
Issue 5
The following change has been made in this version for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E):
The SYNOPSIS has been changed to indicate that this function and associated data types are now made visible by inclusion of the
header rather than .
Issue 6
The behavior of charclass = (wctype_t)0 is now described.
An example is added.
A new function, iswblank(), is added to the list in the APPLICATION USAGE.
Issue 7
The iswctype_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0321 [283] and XSH/TC1-2008/0322 [283] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0184 [799] and XSH/TC2-2008/0185 [799] are applied.
Issue 8
Austin Group Defect 1302 is applied, aligning the iswctype() function with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/erand48.html =====
drand48
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
drand48, erand48, jrand48, lcong48, lrand48, mrand48, nrand48, seed48, srand48 — generate uniformly distributed
pseudo-random numbers
SYNOPSIS
[XSI]  #include
double drand48(void);
double erand48(unsigned short xsubi[3]);
long jrand48(unsigned short xsubi[3]);
void lcong48(unsigned short param[7]);
long lrand48(void);
long mrand48(void);
long nrand48(unsigned short xsubi[3]);
unsigned short *seed48(unsigned short seed16v[3]);
void srand48(long seedval);
DESCRIPTION
This family of functions shall generate pseudo-random numbers using a linear congruential algorithm and 48-bit integer
arithmetic.
The drand48() and erand48() functions shall return non-negative, double-precision, floating-point values,
uniformly distributed over the interval [0.0,1.0).
The lrand48() and nrand48() functions shall return non-negative, long integers, uniformly distributed over the
interval [0,231).
The mrand48() and jrand48() functions shall return signed long integers uniformly distributed over the interval
[-231,231).
The srand48(), seed48(), and lcong48() functions are initialization entry points, one of which should be
invoked before either drand48(), lrand48(), or mrand48() is called. (Although it is not recommended practice,
constant default initializer values shall be supplied automatically if drand48(), lrand48(), or mrand48() is
called without a prior call to an initialization entry point.) The erand48(), nrand48(), and jrand48()
functions do not require an initialization entry point to be called first.
All the routines work by generating a sequence of 48-bit integer values,
\(X_{i}\),
according to the linear congruential formula:
\(X_{n+1}=\left(a X_n+c\right)_{\bmod m} \quad n \geq 0\)
The parameter m=248; hence 48-bit integer arithmetic is performed. Unless lcong48() is invoked, the multiplier
value a and the addend value c are given by:
\(
\begin{aligned}
& a= \text { 5DEECE66D }_{16}=273673163155_8 \\
& c=\mathrm{B}_{16}=13_8
\end{aligned}
\)
The value returned by any of the drand48(), erand48(), jrand48(), lrand48(), mrand48(), or
nrand48() functions is computed by first generating the next 48-bit \(X_{i}\) in the sequence. \(X_{i}\) is then converted
to the return value as follows:
For drand48() and erand48() the value shall be 2-48 times \(X_{i}\).
For jrand48() and mrand48() the value shall be the largest integer not greater than 2-16 times \(X_{i}\).
For lrand48() and nrand48() the value shall be the largest integer not greater than 2-17 times \(X_{i}\).
The drand48(), lrand48(), and mrand48() functions store the last 48-bit \(X_{i}\) generated in an internal
buffer; that is why the application shall ensure that these are initialized prior to being invoked. The erand48(),
nrand48(), and jrand48() functions require the calling program to provide storage for the successive \(X_{i}\) values
in the array specified as an argument when the functions are invoked. That is why these routines do not have to be initialized; the
calling program merely has to place the desired initial value of \(X_{i}\) into the array and pass it as an argument. By using
different arguments, erand48(), nrand48(), and jrand48() allow separate modules of a large program to generate
several independent streams of pseudo-random numbers; that is, the sequence of numbers in each stream shall not
depend upon how many times the routines are called to generate numbers for the other streams.
The initializer function srand48() sets the high-order 32 bits of \(X_{i}\) to the low-order 32 bits contained in its
argument. The low-order 16 bits of \(X_{i}\) are set to the arbitrary value 330E16.
The initializer function seed48() sets the value of \(X_{i}\) to the 48-bit value specified in the argument array. The
low-order 16 bits of \(X_{i}\) are set to the low-order 16 bits of seed16v[0]. The mid-order 16 bits of \(X_{i}\) are
set to the low-order 16 bits of seed16v[1]. The high-order 16 bits of \(X_{i}\) are set to the low-order 16 bits of
seed16v[2]. In addition, the previous value of \(X_{i}\) is copied into a 48-bit internal buffer, used only by
seed48(), and a pointer to this buffer is the value returned by seed48(). This returned pointer, which can just be
ignored if not needed, is useful if a program is to be restarted from a given point at some future time—use the pointer to get at
and store the last \(X_{i}\) value, and then use this value to reinitialize via seed48() when the program is restarted.
The initializer function lcong48() allows the user to specify the initial \(X_{i}\), the multiplier value a, and the
addend value c. Argument array elements param[0-2] specify \(X_{i}\), param[3-5] specify the
multiplier a, and param[6] specifies the 16-bit addend c. After lcong48() is called, a subsequent call to
either srand48() or seed48() shall restore the standard multiplier and addend values, a and c,
specified above.
The drand48(), lrand48(), and mrand48() functions need not be thread-safe.
RETURN VALUE
As described in the DESCRIPTION above.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
The following program tests that the required pseudo-random number generator is used by these functions.
#include
#include
int main() {
{
unsigned short xsubi[3] = {37174, 64810, 11603};
double d = erand48(xsubi);
assert(d >= 0.896);
assert(d = 0.337);
assert(d = 0.647);
assert(d = 0.500);
assert(d = 0.506);
assert(d
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
A note indicating that the drand48(), lrand48(), and mrand48() functions need not be reentrant is added to
the DESCRIPTION.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0083 [743] is applied.
Issue 8
Austin Group Defect 1107 is applied, clarifying how the return value is calculated from  \(X_{i}\) for each function.
Austin Group Defect 1134 is applied, adding getentropy().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/free.html =====
free
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
free — free allocated memory
SYNOPSIS
#include
void free(void *ptr);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The free() function shall cause the space pointed to by ptr to be deallocated; that is, made available for further
allocation. If ptr is a null pointer, no action shall occur. Otherwise, if the argument does not match a pointer earlier
returned by aligned_alloc(), calloc(), malloc(),
[ADV]
posix_memalign(),  realloc(),
[CX]
reallocarray(), or a function in POSIX.1-2024 that allocates memory as if by
malloc(),  or if the
space has been deallocated by a call to free(), [CX]  reallocarray(),
or realloc(), the
behavior is undefined.
Any use of a pointer that refers to freed space results in undefined behavior.
[CX]  The
free() function shall not modify errno if ptr is a null pointer or a pointer previously returned as if by
malloc() and not yet deallocated.
For purposes of determining the existence of a data race, free() shall behave as though it accessed only memory locations
accessible through its argument and not other static duration storage. The function may, however, visibly modify the storage that
it deallocates. Calls to aligned_alloc(), calloc(), free(), malloc(),
[ADV]
posix_memalign(),
[CX]
reallocarray(),
and realloc() that allocate or deallocate a particular region of memory shall occur
in a single total order (see XBD 4.15.1 Memory Ordering), and each
such deallocation call shall synchronize with the next allocation (if any) in this order.
RETURN VALUE
The free() function shall not return a value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
There is now no requirement for the implementation to support the inclusion of .
Because the free() function does not modify errno for valid pointers, it is safe to use it in cleanup code without
corrupting earlier errors, such as in this example code:
// buf was obtained by malloc(buflen)
ret = write(fd, buf, buflen);
if (ret
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
Reference to the valloc() function is removed.
Issue 7
The DESCRIPTION is updated to clarify that if the pointer returned is not by a function that allocates memory as if by malloc(), then the behavior is undefined.
Issue 8
Austin Group Defect 385 is applied, adding a requirement that free() does not modify errno when passed a pointer
to an object than can be freed.
Austin Group Defect 1218 is applied, adding reallocarray().
Austin Group Defect 1302 is applied, aligning this function with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/if_freenameindex.html =====
if_freenameindex
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
if_freenameindex — free memory allocated by if_nameindex
SYNOPSIS
#include
void if_freenameindex(struct if_nameindex *ptr);
DESCRIPTION
The if_freenameindex() function shall free the memory allocated by if_nameindex(). The ptr argument shall be a pointer that was returned by
if_nameindex(). After if_freenameindex() has been called, the
application shall not use the array of which ptr is the address. The if_freenameindex() function shall not modify
errno if ptr was previously returned by if_nameindex() and not
yet freed.
RETURN VALUE
None.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
getsockopt(), if_indextoname(), if_nameindex(), if_nametoindex(), setsockopt()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
Issue 8
Austin Group Defect 385 is applied, adding a requirement that if_freenameindex() does not modify errno when passed
a pointer to an if_nameindex structure than can be freed.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sigaddset.html =====
sigaddset
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sigaddset — add a signal to a signal set
SYNOPSIS
[CX]  #include
int sigaddset(sigset_t *set, int signo);
DESCRIPTION
The sigaddset() function adds the individual signal specified by the signo to the signal set pointed to by
set.
Applications shall call either sigemptyset() or sigfillset() at least once for each object of type sigset_t prior to any other use
of that object. If such an object is not initialized in this way, but is nonetheless supplied as an argument to any of pthread_sigmask(), sigaction(),
sigaddset(), sigdelset(), sigismember(), sigpending(), sigprocmask(), sigsuspend(), sigtimedwait(), sigwait(), or sigwaitinfo(), the results are undefined.
RETURN VALUE
Upon successful completion, sigaddset() shall return 0; otherwise, it shall return -1 and set errno to indicate
the error.
ERRORS
The sigaddset() function may fail if:
[EINVAL]
The value of the signo argument is an invalid or unsupported signal number.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.4 Signal Concepts, pthread_sigmask(), sigaction(),
sigdelset(), sigemptyset(),
sigfillset(), sigismember()
, sigpending(), sigsuspend()
XBD
CHANGE HISTORY
First released in Issue 3. Included for alignment with the POSIX.1-1988 standard.
Issue 5
The last paragraph of the DESCRIPTION was included as an APPLICATION USAGE note in previous issues.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
The SYNOPSIS is marked CX since the presence of this function in the  header is an extension over the ISO C standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/tanhf.html =====
tanh
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
tanh, tanhf, tanhl — hyperbolic tangent functions
SYNOPSIS
#include
double tanh(double x);
float tanhf(float x);
long double tanhl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the hyperbolic tangent of their argument x.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the hyperbolic tangent of x.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0, x shall be returned.
If x is ±Inf, ±1 shall be returned.
[MXX]
If x is subnormal, x should be returned.
[MX]  If x is subnormal, a range error may occur and, if x is
not returned, tanh(), tanhf(), and tanhl() shall return an implementation-defined value no greater in
magnitude than DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
ERRORS
These functions may fail if:
Range Error
[MX]
The value of x is subnormal.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
atanh(), feclearexcept(),
fetestexcept(), isnan(),
tan()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The tanhf() and tanhl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0638 [68] is applied.
Issue 8
Austin Group Defect 1382 is applied, rearranging the text describing the behavior when x is subnormal to avoid the need
for two shading changes.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_rwlock_tryrdlock.html =====
pthread_rwlock_rdlock
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_rwlock_rdlock, pthread_rwlock_tryrdlock — lock a read-write lock object for reading
SYNOPSIS
#include
int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);
DESCRIPTION
The pthread_rwlock_rdlock() function shall apply a read lock to the read-write lock referenced by rwlock. The
calling thread acquires the read lock if a writer does not hold the lock and there are no writers blocked on the lock.
[TPS]
If the Thread Execution Scheduling option is supported, and the threads that hold or are blocked on the lock are executing with the
scheduling policies SCHED_FIFO or SCHED_RR, the calling thread shall not acquire the lock if a writer holds the lock or if the
calling thread does not already hold a read lock and writers of higher or equal priority are blocked on the lock; otherwise, the
calling thread shall acquire the lock.
[TPS TSP]  If the Thread Execution Scheduling option is supported, and the threads that hold or are blocked on the lock are
executing with the SCHED_SPORADIC scheduling policy, the calling thread shall not acquire the lock if a writer holds the lock or if
the calling thread does not already hold a read lock and writers of higher or equal priority are blocked on the lock; otherwise,
the calling thread shall acquire the lock.
If the Thread Execution Scheduling option is not supported, it is implementation-defined whether the calling thread acquires the
lock when a writer does not hold the lock and there are writers blocked on the lock. If a writer holds the lock, the calling thread
shall not acquire the read lock.
Whether the Thread Execution Scheduling option is supported or not, if the read lock is not acquired, the calling thread shall
block until it can acquire the lock. The calling thread may deadlock if at the time the call is made it holds a write lock.
A thread may hold multiple concurrent read locks on rwlock (that is, successfully call the pthread_rwlock_rdlock()
function n times). If so, the application shall ensure that the thread performs matching unlocks (that is, it calls the
pthread_rwlock_unlock() function n times).
The maximum number of simultaneous read locks that an implementation guarantees can be applied to a read-write lock shall be
implementation-defined. The pthread_rwlock_rdlock() function may fail if this maximum would be exceeded.
The pthread_rwlock_tryrdlock() function shall apply a read lock as in the pthread_rwlock_rdlock() function, with
the exception that the function shall fail if the equivalent pthread_rwlock_rdlock() call would have blocked the calling
thread. In no case shall the pthread_rwlock_tryrdlock() function ever block; it always either acquires the lock or fails and
returns immediately.
Results are undefined if any of these functions are called with an uninitialized read-write lock.
If a signal is delivered to a thread waiting for a read-write lock for reading, upon return from the signal handler the thread
resumes waiting for the read-write lock for reading as if it was not interrupted.
RETURN VALUE
If successful, the pthread_rwlock_rdlock() function shall return zero; otherwise, an error number shall be returned to
indicate the error.
The pthread_rwlock_tryrdlock() function shall return zero if the lock for reading on the read-write lock object
referenced by rwlock is acquired. Otherwise, an error number shall be returned to indicate the error.
ERRORS
The pthread_rwlock_tryrdlock() function shall fail if:
[EBUSY]
The read-write lock could not be acquired for reading because a writer holds the lock or a writer with the appropriate priority
was blocked on it.
The pthread_rwlock_rdlock() and pthread_rwlock_tryrdlock() functions may fail if:
[EAGAIN]
The read lock could not be acquired because the maximum number of read locks for rwlock has been exceeded.
The pthread_rwlock_rdlock() function may fail if:
[EDEADLK]
A deadlock condition was detected or the current thread already owns the read-write lock for writing.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Applications using these functions may be subject to priority inversion, as discussed in XBD 3.275 Priority Inversion.
RATIONALE
If an implementation detects that the value specified by the rwlock argument to pthread_rwlock_rdlock() or
pthread_rwlock_tryrdlock() does not refer to an initialized read-write lock object, it is recommended that the function
should fail and report an [EINVAL] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_rwlock_clockrdlock(), pthread_rwlock_clockwrlock(), pthread_rwlock_destroy(), pthread_rwlock_trywrlock(), pthread_rwlock_unlock()
XBD 3.275 Priority Inversion, 4.15.2 Memory Synchronization,
CHANGE HISTORY
First released in Issue 5.
Issue 6
The following changes are made for alignment with IEEE Std 1003.1j-2000:
The margin code in the SYNOPSIS is changed to THR to indicate that the functionality is now part of the Threads option
(previously it was part of the Read-Write Locks option in IEEE Std 1003.1j-2000 and also part of the XSI extension).
The DESCRIPTION is updated as follows:
Conditions under which writers have precedence over readers are specified.
Failure of pthread_rwlock_tryrdlock() is clarified.
A paragraph on the maximum number of read locks is added.
In the ERRORS sections, [EBUSY] is modified to take into account write priority, and [EDEADLK] is deleted as a
pthread_rwlock_tryrdlock() error.
The SEE ALSO section is updated.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/101 is applied, updating the ERRORS section so that the
[EDEADLK] error includes detection of a deadlock condition.
Issue 7
The pthread_rwlock_rdlock() and pthread_rwlock_tryrdlock() functions are moved from the Threads option to the
Base.
The [EINVAL] error for an uninitialized read-write lock object is removed; this condition results in undefined behavior.
Issue 8
Austin Group Defect 1111 is applied, changing "threads involved in the lock" to "threads that hold or are blocked on the
lock" and clarifying that a requirement when the read lock is not acquired applies regardless of whether or not the Thread
Execution Scheduling option is supported.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/atomic_fetch_sub_explicit.html =====
atomic_fetch_add
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
atomic_fetch_add, atomic_fetch_add_explicit, atomic_fetch_and, atomic_fetch_and_explicit, atomic_fetch_or,
atomic_fetch_or_explicit, atomic_fetch_sub, atomic_fetch_sub_explicit, atomic_fetch_xor, atomic_fetch_xor_explicit — atomically
replace the value of an object with the result of a computation
SYNOPSIS
#include
C atomic_fetch_add(volatile A *object, M operand); C
atomic_fetch_add_explicit(volatile A *object, M operand,
memory_order order); C atomic_fetch_and(volatile A
*object, M operand); C atomic_fetch_and_explicit(volatile A
*object, M operand,
memory_order order); C atomic_fetch_or(volatile A
*object, M operand); C atomic_fetch_or_explicit(volatile A
*object, M operand,
memory_order order); C atomic_fetch_sub(volatile A
*object, M operand); C atomic_fetch_sub_explicit(volatile A
*object, M operand,
memory_order order); C atomic_fetch_xor(volatile A
*object, M operand); C atomic_fetch_xor_explicit(volatile A
*object, M operand,
memory_order order);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
Implementations that define the macro __STDC_NO_ATOMICS__ need not provide the  header nor support these generic functions.
The atomic_fetch_add_explicit() generic function shall atomically replace the value pointed to by object with the
result of adding operand to this value. This operation shall be an atomic read-modify-write operation (see XBD 4.15.1 Memory Ordering). Memory shall be affected according to the value of
order.
The atomic_fetch_add() generic function shall be equivalent to atomic_fetch_add_explicit() called with
order set to memory_order_seq_cst.
The other atomic_fetch_*() generic functions shall be equivalent to atomic_fetch_add_explicit() if their name ends
with explicit, or to atomic_fetch_add() if it does not, respectively, except that they perform the computation
indicated in their name, instead of addition:
sub
subtraction
or
bitwise inclusive OR
xor
bitwise exclusive OR
and
bitwise AND
For addition and subtraction, the application shall ensure that A is an atomic integer type or an atomic pointer type and is not
atomic_bool. For the other operations, the application shall ensure that A is an atomic integer type and is not
atomic_bool.
For signed integer types, the computation shall silently wrap around on overflow; there are no undefined results. For pointer
types, the result can be an undefined address, but the computations otherwise have no undefined behavior.
RETURN VALUE
These generic functions shall return the value pointed to by object immediately before the effects.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The operation of these generic functions is nearly equivalent to the operation of the corresponding compound assignment
operators +=, -=, etc. The only differences are that the compound assignment operators are not guaranteed to
operate atomically, and the value yielded by a compound assignment operator is the updated value of the object, whereas the value
returned by these generic functions is the previous value of the atomic object.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD 4.15.1 Memory Ordering,
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/creat.html =====
creat
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
creat — create a new file or rewrite an existing one
SYNOPSIS
[OH] #include
#include
int creat(const char *path, mode_t mode);
DESCRIPTION
The creat() function shall behave as if it is implemented as follows:
int creat(const char *path, mode_t mode)
{
return open(path, O_WRONLY|O_CREAT|O_TRUNC, mode);
}
RETURN VALUE
Refer to open().
ERRORS
Refer to open().
The following sections are informative.
EXAMPLES
Creating a File
The following example creates the file /tmp/file with read and write permissions for the file owner and read permission
for group and others. The resulting file descriptor is assigned to the fd variable.
#include
...
int fd;
mode_t mode = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;
char *pathname = "/tmp/file";
...
fd = creat(pathname, mode);
...
APPLICATION USAGE
In multi-threaded applications, the creat() function can leak file descriptors into child processes. Applications should
instead use open() with the O_CLOEXEC and O_CLOFORK flags to avoid the leak.
RATIONALE
The creat() function is redundant. Its services are also provided by the open() function. It has been included primarily for historical purposes since many existing
applications depend on it. It is best considered a part of the C binding rather than a function that should be provided in other
languages.
FUTURE DIRECTIONS
None.
SEE ALSO
mknod(), open()
XBD , ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
In the SYNOPSIS, the optional include of the  header is
removed.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The requirement to include  has been removed. Although
was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.
Issue 7
SD5-XSH-ERN-186 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0064 [291] is applied.
Issue 8
Austin Group Defects 411 and 1318 are applied, changing the APPLICATION USAGE section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wctob.html =====
wctob
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wctob — wide-character to single-byte conversion
SYNOPSIS
#include
#include
int wctob(wint_t c);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The wctob() function shall determine whether c corresponds to a member of the extended character set whose
character representation is a single byte when in the initial shift state.
The behavior of this function shall be affected by the LC_CTYPE category of the current locale.
[CX]  The
wctob() function shall not change the setting of errno on valid input.
RETURN VALUE
The wctob() function shall return EOF if c does not correspond to a character with length one in the initial shift
state. Otherwise, it shall return the single-byte representation of that character as an unsigned char converted to
int.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
btowc()
XBD ,
CHANGE HISTORY
First released in Issue 5. Included for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E).
Issue 8
Austin Group Defect 448 is applied, adding a requirement that wctob() does not change the setting of errno on
valid input.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/atomic_flag_test_and_set_explicit.html =====
atomic_flag_test_and_set
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
atomic_flag_test_and_set, atomic_flag_test_and_set_explicit — test and set an atomic flag
SYNOPSIS
#include
_Bool atomic_flag_test_and_set(volatile atomic_flag *object);
_Bool atomic_flag_test_and_set_explicit(volatile atomic_flag *object,
memory_order order);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
Implementations that define the macro __STDC_NO_ATOMICS__ need not provide the  header nor support these generic functions.
The atomic_flag_test_and_set_explicit() function shall atomically place the atomic flag pointed to by object into
the set state and return the value corresponding to the immediately preceding state. This operation shall be an atomic
read-modify-write operation (see 4.15.1 Memory Ordering). Memory
shall be affected according to the value of order.
The atomic_flag_test_and_set() function shall be equivalent to atomic_flag_test_and_set_explicit() called with
order set to memory_order_seq_cst.
RETURN VALUE
These functions shall return the value that corresponds to the state of the atomic flag immediately before the effects. The
return value true shall correspond to the set state and the return value false shall correspond to the clear state.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD 4.15.1 Memory Ordering,
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/carg.html =====
carg
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
carg, cargf, cargl — complex argument functions
SYNOPSIS
#include
double carg(double complex z);
float cargf(float complex z);
long double cargl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the argument (also called phase angle) of z, with a branch cut along the negative real
axis.
RETURN VALUE
These functions shall return the value of the argument in the interval [-ℼ, +ℼ].
[MXC]
If z is -0 ± i0, ±ℼ shall be returned.
If z is +0 ± i0, ±0 shall be returned.
If z is x ± i0 where x is negative, ±ℼ shall be returned.
If z is x ± i0 where x is positive, ±0 shall be returned.
If z is ±0 + iy where y is negative, -ℼ/2 shall be returned.
If z is ±0 + iy where y is positive, ℼ/2 shall be returned.
If z is -Inf ± iy where y is positive and finite, ±ℼ shall be returned.
If z is +Inf ± iy where y is positive and finite, ±0 shall be returned.
If z is x ± iInf where x is finite, ±ℼ/2 shall be returned.
If z is -Inf ± iInf, ±3ℼ/4 shall be returned.
If z is +Inf ± iInf, ±ℼ/4 shall be returned.
If the real or imaginary part of z is NaN, NaN shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
cimag(), conj(), cproj()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/isgreaterequal.html =====
isgreater
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
isgreater, isgreaterequal, isless, islessequal, islessgreater — real-floating relational tests
SYNOPSIS
#include
int isgreater(real-floating x, real-floating y);
int isgreaterequal(real-floating x, real-floating y);
int isless(real-floating x, real-floating y);
int islessequal(real-floating x, real-floating y);
int islessgreater(real-floating x, real-floating y);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The isgreater() macro shall determine whether its first argument is greater than its second argument. The value of
isgreater(x, y) shall be equal to (x) > (y); however, unlike
(x) > (y), isgreater(x, y) shall not raise the invalid floating-point exception
when x and y are unordered.
The isgreaterequal() macro shall determine whether its first argument is greater than or equal to its second argument.
The value of isgreaterequal(x, y) shall be equal to (x) >= (y); however, unlike
(x) >= (y), isgreaterequal(x, y) shall not raise the invalid floating-point
exception when x and y are unordered.
The isless() macro shall determine whether its first argument is less than its second argument. The value of
isless(x, y) shall be equal to (x)  (y); however, islessgreater(x,
y) shall not raise the invalid floating-point exception when x and y are unordered (nor shall it evaluate
x and y twice).
[MX]
Relational operators and their corresponding comparison macros shall produce equivalent result values, even if argument values are
represented in wider formats. Thus, comparison macro arguments represented in formats wider than their semantic types shall not be
converted to the semantic types, unless the wide evaluation method converts operands of relational operators to their semantic
types. The standard wide evaluation methods characterized by FLT_EVAL_METHOD equal to 1 or 2 (see ) do not convert operands of relational operators to their semantic types.
RETURN VALUE
Upon successful completion, the isgreater() macro shall return the value of (x) > (y).
Upon successful completion, the isgreaterequal() macro shall return the value of
(x) >= (y).
Upon successful completion, the isless() macro shall return the value of (x)  (y).
If x or y is NaN, these functions shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The relational and equality operators support the usual mathematical relationships between numeric values. For any ordered pair
of numeric values, exactly one of the relationships (less, greater, and equal) is true. Relational operators may raise the invalid
floating-point exception when argument values are NaNs. For a NaN and a numeric value, or for two NaNs, just the unordered
relationship is true. This macro is a quiet (non-floating-point exception raising) version of a relational operator. It facilitates
writing efficient code that accounts for NaNs without suffering the invalid floating-point exception. In the SYNOPSIS section,
real-floating indicates that the argument shall be an expression of real-floating type.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
isunordered()
XBD ,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
The individual pages for these functions have been merged to form a single page, to reduce duplication.
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/timespec_get.html =====
timespec_get
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
timespec_get — get time
SYNOPSIS
#include
int timespec_get(struct timespec *ts, int base);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The timespec_get() function shall set the interval pointed to by ts to hold the current calendar time based on the
specified time base.
[CX]  If
base is TIME_UTC, the members of ts shall be set to the same values as would be set by a call to
clock_gettime(CLOCK_REALTIME, ts). If the number of seconds will not fit in an object of type time_t, the
function shall return zero.
RETURN VALUE
If the timespec_get() function is successful it shall return the non-zero value base; otherwise, it shall return
zero.
ERRORS
See DESCRIPTION.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
clock_getres(), time()
XBD
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_spin_trylock.html =====
pthread_spin_lock
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_spin_lock, pthread_spin_trylock — lock a spin lock object
SYNOPSIS
#include
int pthread_spin_lock(pthread_spinlock_t *lock);
int pthread_spin_trylock(pthread_spinlock_t *lock);
DESCRIPTION
The pthread_spin_lock() function shall lock the spin lock referenced by lock. The calling thread shall acquire the
lock if it is not held by another thread. Otherwise, the thread shall spin (that is, shall not return from the
pthread_spin_lock() call) until the lock becomes available. The results are undefined if the calling thread holds the lock
at the time the call is made. The pthread_spin_trylock() function shall lock the spin lock referenced by lock if it
is not held by any thread. Otherwise, the function shall fail.
The results are undefined if any of these functions is called with an uninitialized spin lock.
RETURN VALUE
Upon successful completion, these functions shall return zero; otherwise, an error number shall be returned to indicate the
error.
ERRORS
The pthread_spin_lock() function may fail if:
[EDEADLK]
A deadlock condition was detected.
The pthread_spin_trylock() function shall fail if:
[EBUSY]
A thread currently holds the lock.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Applications using this function may be subject to priority inversion, as discussed in XBD 3.275 Priority Inversion.
RATIONALE
If an implementation detects that the value specified by the lock argument to pthread_spin_lock() or
pthread_spin_trylock() does not refer to an initialized spin lock object, it is recommended that the function should fail
and report an [EINVAL] error.
If an implementation detects that the value specified by the lock argument to pthread_spin_lock() refers to a spin
lock object for which the calling thread already holds the lock, it is recommended that the function should fail and report an
[EDEADLK] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_spin_destroy(), pthread_spin_unlock()
XBD 3.275 Priority Inversion, 4.15.2 Memory Synchronization,
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1j-2000.
In the SYNOPSIS, the inclusion of  is no longer
required.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/107 is applied, updating the ERRORS section so that the
[EDEADLK] error includes detection of a deadlock condition.
Issue 7
The pthread_spin_lock() and pthread_spin_trylock() functions are moved from the Spin Locks option to the Base.
The [EINVAL] error for an uninitialized spin lock object is removed; this condition results in undefined behavior.
The [EDEADLK] error for a spin lock object for which the calling thread already holds the lock is removed; this condition
results in undefined behavior.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fseeko.html =====
fseek
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fseek, fseeko — reposition a file-position indicator in a stream
SYNOPSIS
#include
int fseek(FILE *stream, long offset, int whence);
[CX]  int fseeko(FILE *stream, off_t offset, int whence);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The fseek() function shall set the file-position indicator for the stream pointed to by stream. If a read or write
error occurs, the error indicator for the stream shall be set and fseek() fails.
The new position, measured in bytes from the beginning of the file, [CX]
except in the case of streams opened with open_wmemstream() for which the position shall be measured in wide characters,
shall be obtained by adding offset to the position specified
by whence. The specified point is the beginning of the file for SEEK_SET, the current value of the file-position indicator
for SEEK_CUR, or end-of-file for SEEK_END.
If the stream is to be used with wide-character input/output functions, the application shall ensure that offset is
either 0 or a value returned by an earlier call to ftell() on the same stream and
whence is SEEK_SET.
A successful call to fseek() shall clear the end-of-file indicator for the stream and undo any effects of ungetc() and ungetwc() on the same stream.
After an fseek() call, the next operation on an update stream may be either input or output.
[CX]  If
the most recent operation, other than ftell(), on a given stream is fflush(), the file offset in the underlying open file description shall be adjusted to
reflect the location specified by fseek().
The fseek() function shall allow the file-position indicator to be set beyond the end of existing data in the file. If
data is later written at this point, subsequent reads of data in the gap shall return bytes with the value 0 until data is actually
written into the gap.
The behavior of fseek() on devices which are incapable of seeking is implementation-defined. The value of the file offset
associated with such a device is undefined.
If the stream has an underlying file description and is writable, and buffered data had not been written to the underlying file,
fseek() shall cause the unwritten data to be written to the file and shall mark the last data modification and last file
status change timestamps of the file for update. If the stream was created by fmemopen(), open_memstream(), or
open_wmemstream() and the stream is writable, and if the stream is buffered
and data in the stream's buffer has not been written to the underlying memory buffer, fseek() shall cause the unwritten data
to be written to the underlying memory buffer.
In a locale with state-dependent encoding, whether fseek() restores the stream's shift state is
implementation-defined.
The fseeko() function shall be equivalent to the fseek() function except that the offset argument is of
type off_t.
RETURN VALUE
The fseek() [CX]   and fseeko()  functions
shall return 0 if they succeed.
[CX]
Otherwise, they shall return -1 and set errno to indicate the error.
ERRORS
The fseek() [CX]   and fseeko()
functions shall fail if, [CX]   either the stream is unbuffered or the stream's buffer needed to be flushed, and
the call to fseek() or fseeko() causes an underlying lseek() or write() to be invoked, and:
[EAGAIN]
[CX]
The O_NONBLOCK flag is set for the file descriptor and the thread would be delayed in the write operation.
[EBADF]
[CX]
The file descriptor underlying the stream file is not open for writing or the stream's buffer needed to be flushed and the file is
not open.
[EFBIG]
[CX]  An
attempt was made to write a file that exceeds the maximum file size.
[EFBIG]
[CX]  An
attempt was made to write a file that exceeds the file size limit of the process.
[XSI]
A SIGXFSZ signal shall also be generated for the thread.
[EFBIG]
[CX]
The file is a regular file and an attempt was made to write at or beyond the offset maximum associated with the corresponding
stream.
[EINTR]
[CX]
The write operation was terminated due to the receipt of a signal, and no data was transferred.
[EINVAL]
[CX]
The whence argument is invalid, the resulting file-position indicator would be set to a negative value, or the stream was
created by fmemopen() and the resulting file-position indicator would be beyond the
end of the underlying memory buffer.
[EIO]
[CX]  A
physical I/O error has occurred, or the process is a member of a background process group attempting to perform a write() to its controlling terminal, TOSTOP is set, the calling thread is not blocking
SIGTTOU, the process is not ignoring SIGTTOU, and the process group of the process is orphaned. This error may also be returned
under implementation-defined conditions.
[ENOMEM]
[CX]
The stream was created by open_memstream() or open_wmemstream() and insufficient memory is available.
[ENOSPC]
[CX]
There was no free space remaining on the device containing the file or in the buffer used by the fmemopen() function.
[EOVERFLOW]
[CX]
For fseek(), the resulting file offset would be a value which cannot be represented correctly in an object of type
long.
[EOVERFLOW]
[CX]
For fseeko(), the resulting file offset would be a value which cannot be represented correctly in an object of type
off_t.
[EPIPE]
[CX]  An
attempt was made to write to a pipe or FIFO that is not open for reading by any process; a SIGPIPE signal shall also be sent to the
thread.
[ESPIPE]
[CX]
The file descriptor underlying stream is associated with a pipe, FIFO, or socket.
The fseek() [CX]   and fseeko()
functions may fail if:
[ENXIO]
[CX]  A
request was made of a nonexistent device, or the request was outside the capabilities of the device.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
When the stream was created by fmemopen(), fseek() fails if an attempt is
made to seek beyond the end of the underlying memory buffer. This is different than fseek() on a file when a file size limit
is in effect because the size specified to fmemopen() is a fixed, absolute limit
whereas a file size limit is artificial and can be changed. With a file size limit, it is possible to seek past the limit, then
raise the limit and successfully write at the new position; there is no equivalent possibility with the buffer size specified to
fmemopen().
See also the rationale for ftell().
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, fopen(), fmemopen(), fsetpos(), ftell(), getrlimit(), lseek(), open_memstream(), rewind(),
ungetc(), write()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
Normative text previously in the APPLICATION USAGE section is moved to the DESCRIPTION.
Large File Summit extensions are added.
Issue 6
Extensions beyond the ISO C standard are marked.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The fseeko() function is added.
The [EFBIG], [EOVERFLOW], and [ENXIO] mandatory error conditions are added.
The following change is incorporated for alignment with the FIPS requirements:
The [EINTR] error is no longer an indication that the implementation does not report partial transfers.
The normative text is updated to avoid use of the term "must" for application requirements.
The DESCRIPTION is updated to explicitly state that fseek() sets the file-position indicator, and then on error the error
indicator is set and fseek() fails. This is for alignment with the ISO/IEC 9899:1999 standard.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/42 is applied, updating the [EAGAIN] error in the ERRORS section
from "the process would be delayed" to "the thread would be delayed".
Issue 7
Changes are made related to support for finegrained timestamps.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0188 [79], XSH/TC1-2008/0189 [122], XSH/TC1-2008/0190 [225], and
XSH/TC1-2008/0191 [14] are applied.
Issue 8
Austin Group Defect 308 is applied, clarifying the handling of [EFBIG] errors.
Austin Group Defect 1027 is applied, specifying that for streams opened with open_wmemstream() the position is measured in wide characters, not bytes.
Austin Group Defect 1225 is applied, clarifying the behavior for memory streams.
Austin Group Defect 1669 is applied, removing XSI shading from part of the [EFBIG] error relating to the file size limit for the
process.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_mutex_consistent.html =====
pthread_mutex_consistent
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_mutex_consistent — mark state protected by robust mutex as consistent
SYNOPSIS
#include
int pthread_mutex_consistent(pthread_mutex_t *mutex);
DESCRIPTION
If mutex is a robust mutex in an inconsistent state, the pthread_mutex_consistent() function can be used to mark
the state protected by the mutex referenced by mutex as consistent again.
If an owner of a robust mutex terminates while holding the mutex, the mutex becomes inconsistent and the next thread that
acquires the mutex lock shall be notified of the state by the return value [EOWNERDEAD]. In this case, the mutex does not become
normally usable again until the state is marked consistent.
If the thread which acquired the mutex lock with the return value [EOWNERDEAD] terminates before calling either
pthread_mutex_consistent() or pthread_mutex_unlock(), the next
thread that acquires the mutex lock shall be notified about the state of the mutex by the return value [EOWNERDEAD].
The behavior is undefined if the value specified by the mutex argument to pthread_mutex_consistent() does not
refer to an initialized mutex.
RETURN VALUE
Upon successful completion, the pthread_mutex_consistent() function shall return zero. Otherwise, an error value shall be
returned to indicate the error.
ERRORS
The pthread_mutex_consistent() function shall fail if:
[EINVAL]
The mutex object referenced by mutex is not robust or does not protect an inconsistent state.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The pthread_mutex_consistent() function is only responsible for notifying the implementation that the state protected by
the mutex has been recovered and that normal operations with the mutex can be resumed. It is the responsibility of the application
to recover the state so it can be reused. If the application is not able to perform the recovery, it can notify the implementation
that the situation is unrecoverable by a call to pthread_mutex_unlock()
without a prior call to pthread_mutex_consistent(), in which case subsequent threads that attempt to lock the mutex will
fail to acquire the lock and be returned [ENOTRECOVERABLE].
RATIONALE
If an implementation detects that the value specified by the mutex argument to pthread_mutex_consistent() does not
refer to an initialized mutex, it is recommended that the function should fail and report an [EINVAL] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_mutex_lock(), pthread_mutexattr_getrobust()
XBD
CHANGE HISTORY
First released in Issue 7.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wcsspn.html =====
wcsspn
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wcsspn — get the length of a wide substring
SYNOPSIS
#include
size_t wcsspn(const wchar_t *ws1, const wchar_t *ws2);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The wcsspn() function shall compute the length (in wide characters) of the maximum initial segment of the wide-character
string pointed to by ws1 which consists entirely of wide-character codes from the wide-character string pointed to by
ws2.
[CX]  The
wcsspn() function shall not change the setting of errno on valid input.
RETURN VALUE
The wcsspn() function shall return the length of the initial substring of ws1; no return value is reserved to
indicate an error.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
wcscspn()
XBD
CHANGE HISTORY
First released in Issue 4. Derived from the MSE working draft.
Issue 5
The RETURN VALUE section is updated to indicate that wcsspn() returns the length of ws1 rather that ws1
itself.
Issue 8
Austin Group Defect 448 is applied, adding a requirement that wcsspn() does not change the setting of errno on
valid input.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fminl.html =====
fmin
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fmin, fminf, fminl — determine minimum numeric value of two floating-point numbers
SYNOPSIS
#include
double fmin(double x, double y);
float fminf(float x, float y);
long double fminl(long double x, long double y);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall determine the minimum numeric value of their arguments. [MX]   NaN arguments
shall be treated as missing data: if one argument is a NaN and the other numeric, then these functions shall choose the numeric
value.
RETURN VALUE
Upon successful completion, these functions shall return the minimum numeric value of their arguments.
[MX]  The
returned value shall be exact and shall be independent of the current rounding direction mode.
If just one argument is a NaN, the other argument shall be returned.
If x and y are NaN, a NaN shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
fdim(), fmax()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
Austin Group Interpretation 1003.1-2001 #008 is applied.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/posix_getdents.html =====
posix_getdents
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
posix_getdents — read directory entries
SYNOPSIS
#include
ssize_t posix_getdents(int fildes, void *buf, size_t nbyte, int
flags);
DESCRIPTION
The posix_getdents() function shall attempt to read directory entries from the directory associated with the open file
descriptor fildes and shall place information about the directory entries and the files they refer to in posix_dent
structures in the buffer pointed to by buf, up to a maximum of nbyte bytes. The number of posix_dent
structures populated in buf may be fewer than the number that will fit in nbyte bytes, but shall be at least one if
nbyte is greater than the size of the posix_dent structure plus {NAME_MAX} and fildes is not currently at
end-of-file.
The application shall ensure that buf is aligned suitably to point to a posix_dent structure. The alignment needed
shall not be more restrictive than the alignment provided by malloc(). Strictly
conforming applications shall ensure that the value of flags is zero; other applications can set it to a value constructed
by a bitwise-inclusive OR of implementation-defined bitwise-distinct flag values.
Each posix_dent structure returned in buf shall be located at an address that satisfies the implementation's
alignment requirements for the posix_dent structure and shall be populated as follows:
The value of the d_ino member shall be set to the file serial number of the file named by the d_name member.
The value of the d_reclen member shall be set to the number of bytes occupied by this entry in buf, including any
padding bytes needed before the next entry, if any. If this is the last entry in buf, d_reclen shall include any
padding bytes needed to make the address of this entry plus d_reclen bytes satisfy the alignment requirements for the
posix_dent structure.
The value of the d_type member shall be set to indicate the file type of the named file, if the file type can be
determined without needing to use the file serial number to obtain the file's metadata; otherwise it may be set to DT_UNKNOWN. If
the file type is determined and it is one of the file types defined in this standard, the value of d_type shall be DT_BLK,
DT_CHR, DT_DIR, DT_FIFO, DT_LNK, DT_REG, DT_SOCK, DT_MQ, DT_SEM, DT_SHM, [TYM]
or DT_TMO   (see ). If it is determined but is
not a standard file type, the value of d_type shall not equal any of those listed here.
The d_name member shall be a filename string, and (if not dot or dot-dot) shall contain the same byte sequence as the
last pathname component of the string used to create the directory entry, plus the terminating NUL byte.
If the d_name member names a symbolic link, the values of the d_ino and d_type members shall be set to the
values for the symbolic link itself.
The posix_getdents() function shall start reading at the current file offset in the open file description associated with
fildes. On successful return, the file offset shall be incremented to point to the directory entry immediately following the
last entry whose information was returned in buf, or to point to end-of-file if there are no more directory entries. On
failure, the value of the file offset is unspecified. The current file offset can be set and retrieved using lseek() on the open file description associated with fildes. The behavior is
unspecified if lseek() is used to set the file offset to a value other than zero or a
value returned by a previous call to lseek() on the same open file description.
The posix_getdents() function shall not return directory entries containing empty names. If entries for dot or dot-dot
exist, a sequence of calls that reads from offset zero to end-of-file shall return one entry for dot and one entry for dot-dot;
otherwise, they shall not be returned.
Upon successful completion, posix_getdents() shall mark for update the last data access timestamp of the directory.
If fildes is a file descriptor associated with a directory stream opened using fdopendir() or opendir(), the behavior is
unspecified.
If posix_getdents() is called concurrently with an operation that adds, deletes, or modifies a directory entry, the
results from posix_getdents() shall reflect either all of the effects of the concurrent operation or none of them. If a
sequence of calls to posix_getdents() is made that reads from offset zero to end-of-file and a file is removed from or added
to the directory between the first and last of those calls, whether the sequence of calls returns an entry for that file is
unspecified.
RETURN VALUE
Upon successful completion, either a non-negative integer shall be returned indicating the number of bytes occupied by the
posix_dent structures placed in buf or 0 shall be returned indicating the end of the directory was reached without
any directory entries being placed in buf. Otherwise, -1 shall be returned and errno shall be set to indicate the
error.
ERRORS
The posix_getdents() function shall fail if:
[EBADF]
The fildes argument is not a valid file descriptor open for reading.
[EINVAL]
The nbyte argument is not large enough to contain the information to be returned about the directory entry located at
the current file offset.
[ENOENT]
The current file offset is not located at a valid directory entry.
[ENOTDIR]
The fildes argument is associated with a non-directory file.
[EOVERFLOW]
One of the values in a structure to be placed in buf cannot be represented correctly.
The posix_getdents() function may fail if:
[EIO]
A physical I/O error has occurred.
[ENOMEM]
Insufficient memory was available to fulfill the request.
The following sections are informative.
EXAMPLES
This example function lists the files in a specified directory with their file serial number and file type. If the file type is
not available from posix_getdents(), it is obtained using fstatat().
#include
#include
#include
#include
#include
#include
#define ENTBUFSIZ 10240
int list_dir(const char *dirnam)
{
int fd = open(dirnam, O_RDONLY | O_DIRECTORY);
if (fd == -1)
return -1;
char *buf = malloc(ENTBUFSIZ);
if (buf == NULL)
{
close(fd);
return -1;
}
ssize_t bytesinbuf;
for(;;)
{
ssize_t nextent = 0;
bytesinbuf = posix_getdents(fd, buf, ENTBUFSIZ, 0);
if (bytesinbuf d_type == DT_UNKNOWN)
{
struct stat stbuf;
if (fstatat(fd, entp->d_name, &stbuf,
AT_SYMLINK_NOFOLLOW) == -1)
ftype = "?";
else
ftype = S_ISBLK(stbuf.st_mode) ? "b" :
S_ISCHR(stbuf.st_mode) ? "c" :
S_ISDIR(stbuf.st_mode) ? "d" :
S_ISFIFO(stbuf.st_mode) ? "p" :
S_ISLNK(stbuf.st_mode) ? "l" :
S_ISREG(stbuf.st_mode) ? "r" :
S_ISSOCK(stbuf.st_mode) ? "s" :
S_TYPEISMQ(&stbuf) ? "mq" :
S_TYPEISSEM(&stbuf) ? "sem" :
S_TYPEISSHM(&stbuf) ? "shm" :
#ifdef S_TYPEISTMO
S_TYPEISTMO(&stbuf) ? "tmo" :
#endif
"?";
}
else
{
ftype = entp->d_type == DT_BLK ? "b" :
entp->d_type == DT_CHR ? "c" :
entp->d_type == DT_DIR ? "d" :
entp->d_type == DT_FIFO ? "p" :
entp->d_type == DT_LNK ? "l" :
entp->d_type == DT_REG ? "r" :
entp->d_type == DT_SOCK ? "s" :
entp->d_type == DT_MQ ? "mq" :
entp->d_type == DT_SEM ? "sem" :
entp->d_type == DT_SHM ? "shm" :
#ifdef DT_TMO
entp->d_type == DT_TMO ? "tmo" :
#endif
"?";
}
printf("%ld\t%s\t%s\n", (long)entp->d_ino, ftype,
entp->d_name);
nextent += entp->d_reclen;
} while (nextent
CHANGE HISTORY
First released in Issue 8.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/labs.html =====
labs
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
labs, llabs — return a long integer absolute value
SYNOPSIS
#include
long labs(long i);
long long llabs(long long i);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The labs() function shall compute the absolute value of the long integer operand i. The llabs()
function shall compute the absolute value of the long long integer operand i. If the result cannot be represented,
the behavior is undefined.
RETURN VALUE
The labs() function shall return the absolute value of the long integer operand.
The llabs() function shall return the absolute value of the long long integer operand.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Since POSIX.1 requires a two's complement representation of long and long long, the absolute value of the negative
integers with the largest magnitude {LONG_MIN} and {LLONG_MIN} are not representable, thus labs(LONG_MIN) and
llabs(LLONG_MIN) are undefined.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
abs()
XBD
CHANGE HISTORY
First released in Issue 4. Derived from the ISO C standard.
Issue 6
The llabs() function is added for alignment with the ISO/IEC 9899:1999 standard.
Issue 7
SD5-XSH-ERN-152 is applied, correcting the RETURN VALUE section.
Issue 8
Austin Group Defect 1108 is applied, changing the APPLICATION USAGE section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_cancel.html =====
pthread_cancel
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_cancel — cancel execution of a thread
SYNOPSIS
#include
int pthread_cancel(pthread_t thread);
DESCRIPTION
The pthread_cancel() function shall request that thread be canceled. The target thread's cancelability state and
type determines when the cancellation takes effect. When the cancellation is acted on, the cancellation cleanup handlers for
thread shall be called. When the last cancellation cleanup handler returns, the thread-specific data destructor functions
shall be called for thread. When the last destructor function returns, thread shall be terminated. It shall not be an
error to request cancellation of a zombie thread.
The cancellation processing in the target thread shall run asynchronously with respect to the calling thread returning from
pthread_cancel().
If thread refers to a thread that was created using thrd_create(), the
behavior is undefined.
RETURN VALUE
If successful, the pthread_cancel() function shall return zero; otherwise, an error number shall be returned to indicate
the error.
ERRORS
The pthread_cancel() function shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
Two alternative functions were considered for sending the cancellation notification to a thread. One would be to define a new
SIGCANCEL signal that had the cancellation semantics when delivered; the other was to define the new pthread_cancel()
function, which would trigger the cancellation semantics.
The advantage of a new signal was that so much of the delivery criteria were identical to that used when trying to deliver a
signal that making cancellation notification a signal was seen as consistent. Indeed, many implementations implement cancellation
using a special signal. On the other hand, there would be no signal functions that could be used with this signal except pthread_kill(), and the behavior of the delivered cancellation signal would be unlike
any previously existing defined signal.
The benefits of a special function include the recognition that this signal would be defined because of the similar delivery
criteria and that this is the only common behavior between a cancellation request and a signal. In addition, the cancellation
delivery mechanism does not have to be implemented as a signal. There are also strong, if not stronger, parallels with language
exception mechanisms than with signals that are potentially obscured if the delivery mechanism is visibly closer to signals.
In the end, it was considered that as there were so many exceptions to the use of the new signal with existing signals functions
it would be misleading. A special function has resolved this problem. This function was carefully defined so that an implementation
wishing to provide the cancellation functions on top of signals could do so. The special function also means that implementations
are not obliged to implement cancellation with signals.
If an implementation detects use of a thread ID after the end of its lifetime, it is recommended that the function should fail
and report an [ESRCH] error.
Historical implementations varied on the result of a pthread_cancel() with a thread ID indicating a zombie thread. Some
indicated success with nothing further to do because the thread had already terminated, while others gave an error of [ESRCH].
Since the definition of thread lifetime in this standard covers zombie threads, the [ESRCH] error as described is inappropriate in
this case and implementations that give this error do not conform.
Use of pthread_cancel() to cancel a thread that was created using thrd_create() is undefined because thrd_join() has no way to indicate a thread was cancelled. The standard developers
considered adding a thrd_canceled enumeration constant that thrd_join()
would return in this case. However, this return would be unexpected in code that is written to conform to the ISO C standard,
and it would also not solve the problem that threads which use only ISO C  interfaces (such as ones created by third party libraries written to
conform to the ISO C standard) have no way to handle being cancelled, as the ISO C standard does not provide cancellation
cleanup handlers.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_exit(), pthread_cond_clockwait(), pthread_join(), pthread_setcancelstate()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
The pthread_cancel() function is marked as part of the Threads option.
Issue 7
The pthread_cancel() function is moved from the Threads option to the Base.
Austin Group Interpretation 1003.1-2001 #142 is applied, removing the [ESRCH] error condition.
Issue 8
Austin Group Defect 792 is applied, adding a requirement that passing the thread ID of a zombie thread to
pthread_cancel() is not treated as an error.
Austin Group Defect 1302 is applied, updating the page to account for the addition of  interfaces.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_mutexattr_setprioceiling.html =====
pthread_mutexattr_getprioceiling
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_mutexattr_getprioceiling, pthread_mutexattr_setprioceiling — get and set the prioceiling attribute of the mutex
attributes object (REALTIME THREADS)
SYNOPSIS
[RPP|TPP]  #include
int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t
*restrict attr, int *restrict prioceiling);
int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *attr,
int prioceiling);
DESCRIPTION
The pthread_mutexattr_getprioceiling() and pthread_mutexattr_setprioceiling() functions, respectively, shall get
and set the priority ceiling attribute of a mutex attributes object pointed to by attr which was previously created by the
function pthread_mutexattr_init().
The prioceiling attribute contains the priority ceiling of initialized mutexes. The values of prioceiling are
within the maximum range of priorities defined by SCHED_FIFO.
The prioceiling attribute defines the priority ceiling of initialized mutexes, which is the minimum priority level at
which the critical section guarded by the mutex is executed. In order to avoid priority inversion, the priority ceiling of the
mutex shall be set to a priority higher than or equal to the highest priority of all the threads that may lock that mutex. The
values of prioceiling are within the maximum range of priorities defined under the SCHED_FIFO scheduling policy.
The behavior is undefined if the value specified by the attr argument to pthread_mutexattr_getprioceiling() or
pthread_mutexattr_setprioceiling() does not refer to an initialized mutex attributes object.
RETURN VALUE
Upon successful completion, the pthread_mutexattr_getprioceiling() and pthread_mutexattr_setprioceiling()
functions shall return zero; otherwise, an error number shall be returned to indicate the error.
ERRORS
These functions may fail if:
[EINVAL]
The value specified by prioceiling is invalid.
[EPERM]
The caller does not have the privilege to perform the operation.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
If an implementation detects that the value specified by the attr argument to pthread_mutexattr_getprioceiling()
or pthread_mutexattr_setprioceiling() does not refer to an initialized mutex attributes object, it is recommended that the
function should fail and report an [EINVAL] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_cond_destroy(), pthread_create(), pthread_mutex_destroy()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Marked as part of the Realtime Threads Feature Group.
Issue 6
The pthread_mutexattr_getprioceiling() and pthread_mutexattr_setprioceiling() functions are marked as part of the
Threads and Thread Priority Protection options.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Thread
Priority Protection option.
The [ENOTSUP] error condition has been removed since these functions do not have a protocol argument.
The restrict keyword is added to the pthread_mutexattr_getprioceiling() prototype for alignment with the
ISO/IEC 9899:1999 standard.
Issue 7
The pthread_mutexattr_getprioceiling() and pthread_mutexattr_setprioceiling() functions are moved from the Threads
option to require support of either the Robust Mutex Priority Protection option or the Non-Robust Mutex Priority Protection
option.
The [EINVAL] error for an uninitialized mutex attributes object is removed; this condition results in undefined behavior.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/strlcpy.html =====
strlcat
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
strlcat, strlcpy — size-bounded string concatenation and copying
SYNOPSIS
[CX]  #include
size_t strlcat(char *restrict dst, const char *restrict src,
size_t dstsize);
size_t strlcpy(char *restrict dst, const char *restrict src,
size_t dstsize);
DESCRIPTION
The strlcpy() and strlcat() functions copy and concatenate strings, stopping when either a NUL terminator in the
source string is encountered or the specified full size of the destination buffer is reached. They NUL terminate the result if
there is room. The application should ensure that room for the NUL terminator is included in dstsize.
The strlcpy() function shall copy not more than dstsize - 1 bytes from the string pointed to by src to the
array pointed to by dst; a NUL byte in src and bytes that follow it shall not be copied. A terminating NUL byte shall
be appended to the result, unless dstsize is 0. If copying takes place between objects that overlap, the behavior is
undefined.
The strlcat() function shall append not more than dstsize - strlen(dst) - 1 bytes from the string
pointed to by src to the end of the string pointed to by dst; a NUL byte in src and bytes that follow it shall
not be appended. The initial byte of src shall overwrite the NUL byte at the end of dst. A terminating NUL byte shall
be appended to the result, unless its location would be at or beyond dst + dstsize. If copying takes place between
objects that overlap, the behavior is undefined.
The strlcpy() and strlcat() functions shall not change the setting of errno on valid input.
RETURN VALUE
Upon successful completion, the strlcpy() function shall return the length of the string pointed to by src; that
is, the number of bytes in the string, not including the terminating NUL byte.
Upon successful completion, the strlcat() function shall return the initial length of the string (if any) pointed to by
dst, as limited by dstsize, plus the length of the string pointed to by src; that is, the value that would be
returned by strnlen(dst, dstsize) + strlen(src) before the strlcat() call.
No return values are reserved to indicate an error.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
The following example detects truncation while combining a path prefix (including trailing ) and a filename to
produce a portable pathname:
char *prefix, *filenam, pathnam[_POSIX_PATH_MAX];
if (strlcpy(pathnam, prefix, sizeof pathnam) >= sizeof pathnam ||
strlcat(pathnam, filenam, sizeof pathnam) >= sizeof pathnam)
{
// truncation occurred
...
}
This code ensures there is room for the NUL terminator by:
Calling strlcpy() with a non-zero dstsize argument.
Only calling strlcat() if the return value of strlcpy() indicated that truncation did not occur.
APPLICATION USAGE
The return value of the strlcpy() and strlcat() functions follows the same convention as snprintf(); that is, they return the total length of the string they tried to create. If
the return value is greater than or equal to dstsize, the output string has been truncated.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
fprintf(), strlen(), strncat(), strncpy(), wcslcat()
XBD
CHANGE HISTORY
First released in Issue 8.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/posix_fadvise.html =====
posix_fadvise
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
posix_fadvise — file advisory information (ADVANCED REALTIME)
SYNOPSIS
[ADV]  #include
int posix_fadvise(int fd, off_t offset, off_t len, int advice);
DESCRIPTION
The posix_fadvise() function shall advise the implementation on the expected behavior of the application with respect to
the data in the file associated with the open file descriptor, fd, starting at offset and continuing for len
bytes. The specified range need not currently exist in the file. If len is zero, all data from offset to the largest
possible value of the file offset for that file shall be specified. The implementation may use this information to optimize
handling of the specified data. The posix_fadvise() function shall have no effect on the semantics of other operations on
the specified data, although it may affect the performance of other operations.
The advice to be applied to the data is specified by the advice parameter and may be one of the following values:
POSIX_FADV_NORMAL
Specifies that the application has no advice to give on its behavior with respect to the specified data. It is the default
characteristic if no advice is given for an open file.
POSIX_FADV_SEQUENTIAL
Specifies that the application expects to access the specified data sequentially from lower offsets to higher offsets.
POSIX_FADV_RANDOM
Specifies that the application expects to access the specified data in a random order.
POSIX_FADV_WILLNEED
Specifies that the application expects to access the specified data in the near future.
POSIX_FADV_DONTNEED
Specifies that the application expects that it will not access the specified data in the near future.
POSIX_FADV_NOREUSE
Specifies that the application expects to access the specified data once and then not reuse it thereafter.
These values are defined in .
RETURN VALUE
Upon successful completion, posix_fadvise() shall return zero; otherwise, an error number shall be returned to indicate
the error.
ERRORS
The posix_fadvise() function shall fail if:
[EBADF]
The fd argument is not a valid file descriptor.
[EINVAL]
The value of advice is invalid, or the value of len is less than zero.
[ESPIPE]
The fd argument is associated with a pipe or FIFO.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The posix_fadvise() function is part of the Advisory Information option and need not be provided on all
implementations.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
posix_madvise()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1d-1999.
In the SYNOPSIS, the inclusion of  is no longer
required.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/68 is applied, changing the function prototype in the SYNOPSIS
section. The previous prototype was not large file-aware, and the standard developers felt it acceptable to make this change before
implementations of this function become widespread.
Issue 7
Austin Group Interpretation 1003.1-2001 #024 is applied, changing the definition of the [EINVAL] error.
Issue 8
Austin Group Defect 1135 is applied, clarifying the requirements when len is zero.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/in6addr_loopback.html =====
in6addr_any
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
in6addr_any, in6addr_loopback — IPv6 address variables
SYNOPSIS
[IP6]  #include
const struct in6_addr in6addr_any;
const struct in6_addr in6addr_loopback;
DESCRIPTION
The in6addr_any variable is initialized by the system to contain the wildcard IPv6 address (::).
The in6addr_loopback variable is initialized by the system to contain the loopback IPv6 address (::1).
RETURN VALUE
None.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
These variables were only described on the XBD  page in
earlier versions of this standard.
FUTURE DIRECTIONS
None.
SEE ALSO
bind(), connect()
XBD
CHANGE HISTORY
First released in Issue 8. Derived from Issue 7 XBD .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/iswupper.html =====
iswupper
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
iswupper, iswupper_l — test for an uppercase letter wide-character code
SYNOPSIS
#include
int iswupper(wint_t wc);
[CX]  int iswupper_l(wint_t wc, locale_t locale);
DESCRIPTION
For iswupper(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The iswupper() [CX]   and iswupper_l()
functions shall test whether wc is a wide-character code representing a character of class upper in the current
locale, [CX]   or in the locale represented by locale,
respectively; see XBD 7. Locale.
The wc argument is a wint_t, the value of which the application shall ensure is a wide-character code
corresponding to a valid character in the locale used by the function, or equal to the value of the macro WEOF. If the argument has
any other value, the behavior is undefined.
[CX]  The
behavior is undefined if the locale argument to iswupper_l() is the special locale object LC_GLOBAL_LOCALE or is not
a valid locale object handle.
RETURN VALUE
The iswupper() [CX]   and iswupper_l()
functions shall return non-zero if wc is an uppercase letter wide-character code; otherwise, they shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
To ensure applications portability, especially across natural languages, only these functions and the functions in the reference
pages listed in the SEE ALSO section should be used for character classification.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
iswalnum(), iswalpha(),
iswcntrl(), iswctype(),
iswdigit(), iswgraph(),
iswlower(), iswprint(),
iswpunct(), iswspace(),
iswxdigit(), setlocale(),
uselocale()
XBD 7. Locale, ,
CHANGE HISTORY
First released in Issue 4.
Issue 5
The following change has been made in this version for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E):
The SYNOPSIS has been changed to indicate that this function and associated data types are now made visible by inclusion of the
header rather than .
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
The iswupper_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0341 [302], XSH/TC1-2008/0342 [283], and XSH/TC1-2008/0343 [283] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0192 [685] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/renameat.html =====
rename
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
rename, renameat — rename file
SYNOPSIS
#include
int rename(const char *old, const char *new);
[OH] #include
[CX]  int renameat(int oldfd, const char *old, int
newfd,
const char *new);
DESCRIPTION
For rename(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The rename() function shall change the name of a file. The old argument points to the pathname of the file to be
renamed. The new argument points to the new pathname of the file. [CX]
If the new argument does not resolve to an
existing directory entry for a file of type directory and the new argument contains at least one non- character
and ends with one or more trailing  characters after all symbolic links have been processed, rename() shall
fail.
If either the old or new argument names a symbolic link, rename() shall operate on the symbolic link
itself, and shall not resolve the last component of the argument. If the old argument and the new argument resolve to
either the same existing directory entry or different directory entries for the same existing file, rename() shall return
successfully and perform no other action.
If the old argument names a file that is not a directory and the new argument names a directory, or old
names a directory and new names a file that is not a directory, or new names a directory that is not empty,
rename() shall fail. Otherwise, if the directory entry named by new exists, it shall be removed and old
renamed to new. In this case, a directory entry named new shall remain visible to other threads throughout the
renaming operation and refer either to the file referred to by new or old before the operation began.
If either pathname argument refers to a path whose final component is either dot or dot-dot, rename() shall
fail.
If the old argument points to a pathname of a symbolic link, the symbolic link shall be renamed. If the new
argument points to a pathname of a symbolic link, the symbolic link shall be removed.
The old pathname shall not name an ancestor directory of the new pathname. Write access permission is required for
the directory containing old and the directory containing new. If the old argument points to the pathname of a
directory, write access permission may be required for the directory named by old, and, if it exists, the directory named by
new.
If the new argument names an existing file and the file's link count becomes 0 when it is removed and no process has the
file open, the space occupied by the file shall be freed and the file shall no longer be accessible. If one or more processes have
the file open when the last link is removed, the link shall be removed before rename() returns, but the removal of the file
contents shall be postponed until all references to the file are closed.
Upon successful completion, rename() shall mark for update the last data modification and last file status change
timestamps of the parent directory of each file.
If the rename() function fails for any reason other than [EIO], any file named by new shall be unaffected.
The renameat() function shall be equivalent to the rename() function except in the case where either old or
new specifies a relative path. If old is a relative path, the file to be renamed is located relative to the directory
associated with the file descriptor oldfd instead of the current working directory. If new is a relative path, the
same happens only relative to the directory associated with newfd. If the access mode of the open file description
associated with the file descriptor is not O_SEARCH, the function shall check whether directory searches are permitted using the
current permissions of the directory underlying the file descriptor. If the access mode is O_SEARCH, the function shall not perform
the check.
If renameat() is passed the special value AT_FDCWD in the oldfd or newfd parameter, the current working
directory shall be used in the determination of the file for the respective path parameter.
RETURN VALUE
Upon successful completion, the rename() function shall return 0. Otherwise, it shall return -1, [CX]  errno shall
be set to indicate the error,   and neither the file named by
old nor the file named by new shall be changed or created.
[CX]
Upon successful completion, the renameat() function shall return 0. Otherwise, it shall return -1 and set errno to
indicate the error.
ERRORS
The rename() [CX]   and renameat()
functions shall fail if:
[EACCES]
[CX]  A
component of either path prefix denies search permission; or one of the directories containing old or new denies
write permissions; or, write permission is required and is denied for a directory pointed to by the old or new
arguments.
[EBUSY]
[CX]
The directory named by old or new is currently in use by the system or another process, and the implementation
considers this an error.
[EEXIST] or [ENOTEMPTY]
[CX]
The new argument names a directory that is not empty.
[EILSEQ]
[CX]
The last pathname component of the new pathname is not a portable filename, and cannot be created in the target directory.
[EINVAL]
[CX]
The old pathname names an ancestor directory of the new pathname, or either pathname argument contains a final
component that is dot or dot-dot.
[EIO]
[CX]  A
physical I/O error has occurred.
[EISDIR]
[CX]
The new argument points to a directory and the old argument points to a file that is not a directory.
[ELOOP]
[CX]  A
loop exists in symbolic links encountered during resolution of the old or new argument.
[EMLINK]
[CX]
The file named by old is a directory, and the link count of the parent directory of new would exceed {LINK_MAX}.
[ENAMETOOLONG]
[CX]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOENT]
[CX]
The old argument does not name an existing file, a component of the path prefix of new does not exist, or either
old or new points to an empty string.
[ENOSPC]
[CX]
The directory that would contain new cannot be extended.
[ENOTDIR]
[CX]  A
component of either path prefix names an existing file that is neither a directory nor a symbolic link to a directory; or the
old argument names a directory and the new argument names a non-directory file; or the old argument contains
at least one non- character and ends with one or more trailing  characters and the last pathname
component names an existing file that is neither a directory nor a symbolic link to a directory; or the old argument names
an existing non-directory file and the new argument names a nonexistent file, contains at least one non-
character, and ends with one or more trailing  characters; or the new argument names an existing non-directory
file, contains at least one non- character, and ends with one or more trailing  characters.
[EPERM] or [EACCES]
[XSI]
The S_ISVTX flag is set on the directory containing the file referred to by old and the process does not satisfy the
criteria specified in XBD 4.5 Directory Protection with respect to
old; or new refers to an existing file, the S_ISVTX flag is set on the directory containing this file, and the
process does not satisfy the criteria specified in XBD 4.5 Directory
Protection with respect to this file.
[EROFS]
[CX]
The requested operation requires writing in a directory on a read-only file system.
[EXDEV]
[CX]
The file named by old and the directory in which the directory entry named by new is to be created or replaced are on
different file systems and the implementation does not support hard links between file systems.
[CX]  In
addition, the renameat() function shall fail if:
[EACCES]
The access mode of the open file description associated with oldfd or newfd is not O_SEARCH and the permissions
of the directory underlying oldfd or newfd, respectively, do not permit directory searches.
[EBADF]
The old argument does not specify an absolute path and the oldfd argument is neither AT_FDCWD nor a valid file
descriptor open for reading or searching, or the new argument does not specify an absolute path and the newfd
argument is neither AT_FDCWD nor a valid file descriptor open for reading or searching.
[ENOTDIR]
The old or new argument is not an absolute path and oldfd or newfd, respectively, is a file
descriptor associated with a non-directory file.
The rename() [CX]   and renameat()
functions may fail if:
[ELOOP]
[CX]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the old or new argument.
[ENAMETOOLONG]
[CX]
The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a
length that exceeds {PATH_MAX}.
[ETXTBSY]
[CX]
The file named by new exists and is the last directory entry to a pure procedure (shared text) file that is being executed.
The following sections are informative.
EXAMPLES
Renaming a File
The following example shows how to rename a file named /home/cnd/mod1 to /home/cnd/mod2.
#include
int status;
...
status = rename("/home/cnd/mod1", "/home/cnd/mod2");
APPLICATION USAGE
Some implementations mark for update the last file status change timestamp of renamed files and some do not. Applications which
make use of the last file status change timestamp may behave differently with respect to renamed files unless they are designed to
allow for either behavior.
RATIONALE
This rename() function is equivalent for regular files to that defined by the ISO C standard. Its inclusion here
expands that definition to include actions on directories and specifies behavior when the new parameter names a file that
already exists. That specification requires that the action of the function be atomic.
One of the reasons for introducing this function was to have a means of renaming directories while permitting implementations to
prohibit the use of link() and unlink()
with directories, thus constraining links to directories to those made by mkdir().
The specification that if old and new refer to the same file is intended to guarantee that:
rename("x", "x");
does not remove the file.
Renaming dot or dot-dot is prohibited in order to prevent cyclical file system paths.
See also the descriptions of [ENOTEMPTY] and [ENAMETOOLONG] in rmdir() and [EBUSY]
in unlink(). For a discussion of [EXDEV], see link().
The purpose of the renameat() function is to rename files in directories other than the current working directory without
exposure to race conditions. Any part of the path of a file could be changed in parallel to a call to rename(), resulting in
unspecified behavior. By opening file descriptors for the source and target directories and using the renameat() function it
can be guaranteed that that renamed file is located correctly and the resulting file is in the desired directory.
Implementations are encouraged to have rename() and renameat() report an [EILSEQ] error if the file named by
new does not already exist and the last component of that pathname contains any bytes that have the encoded value of a
character.
FUTURE DIRECTIONS
None.
SEE ALSO
link(), rmdir()
, symlink(), unlink()
XBD 4.5 Directory Protection, ,
CHANGE HISTORY
First released in Issue 3. Included for alignment with the POSIX.1-1988 standard.
Issue 5
The [EBUSY] error is added to the optional part of the ERRORS section.
Issue 6
Extensions beyond the ISO C standard are marked.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The [EIO] mandatory error condition is added.
The [ELOOP] mandatory error condition is added.
A second [ENAMETOOLONG] is added as an optional error condition.
The [ETXTBSY] optional error condition is added.
The following changes were made to align with the IEEE P1003.1a draft standard:
Details are added regarding the treatment of symbolic links.
The [ELOOP] optional error condition is added.
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
Austin Group Interpretation 1003.1-2001 #016 is applied, changing the definition of the [ENOTDIR] error.
Austin Group Interpretation 1003.1-2001 #076 is applied, clarifying the behavior if the final component of a path is either dot
or dot-dot, and adding the associated [EINVAL] error case.
Austin Group Interpretation 1003.1-2001 #143 is applied.
Austin Group Interpretation 1003.1-2001 #145 is applied, clarifying that the [ENOENT] error condition also applies to the case
in which a component of new does not exist.
Austin Group Interpretations 1003.1-2001 #174 and #181 are applied.
The renameat() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 2.
Changes are made related to support for finegrained timestamps.
Changes are made to allow a directory to be opened for searching.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0508 [324], XSH/TC1-2008/0509 [147], XSH/TC1-2008/0510 [379],
XSH/TC1-2008/0511 [278], and XSH/TC1-2008/0512 [278] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0311 [873], XSH/TC2-2008/0312 [591], XSH/TC2-2008/0313 [716],
XSH/TC2-2008/0314 [817], XSH/TC2-2008/0315 [817], and XSH/TC2-2008/0316 [591] are applied.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to disallow the creation of filenames containing any bytes that
have the encoded value of a  character.
Austin Group Defect 293 is applied, adding the [EILSEQ] error.
Austin Group Defect 1200 is applied, correcting the argument names in the [ELOOP] errors.
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
Austin Group Defect 1380 is applied, changing text using the term "link" in line with its updated definition.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/nextafterl.html =====
nextafter
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
nextafter, nextafterf, nextafterl, nexttoward, nexttowardf, nexttowardl — next representable floating-point
number
SYNOPSIS
#include
double nextafter(double x, double y);
float nextafterf(float x, float y);
long double nextafterl(long double x, long double y);
double nexttoward(double x, long double y);
float nexttowardf(float x, long double y);
long double nexttowardl(long double x, long double y);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The nextafter(), nextafterf(), and nextafterl() functions shall compute the next representable
floating-point value following x in the direction of y. Thus, if y is less than x, nextafter()
shall return the largest representable floating-point number less than x. The nextafter(), nextafterf(), and
nextafterl() functions shall return y if x equals y.
The nexttoward(), nexttowardf(), and nexttowardl() functions shall be equivalent to the corresponding
nextafter() functions, except that the second parameter shall have type long double and the functions shall return
y converted to the type of the function if x equals y.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the next representable floating-point value following x in the
direction of y.
If x==y, y (of the type x) shall be returned.
[MX]
Even though underflow or overflow can occur, the returned value shall be independent of the current rounding direction mode.
If x is finite and the correct function value would overflow, a range error shall occur and ±HUGE_VAL, ±HUGE_VALF, and
±HUGE_VALL (with the same sign as x) shall be returned as appropriate for the return type of the function.
[MX]  If
x or y is NaN, a NaN shall be returned.
[MX]  If
x!=y and the correct function value is subnormal, zero, or underflows, a range error shall occur, and
[MXX]
the correct function value (if representable) or
[MX]  0.0 shall be returned.
ERRORS
These functions shall fail if:
Range Error
The correct value overflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall be
raised.
Range Error
[MX]
The correct value is subnormal or underflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
When  is included, note that the return type of
nextafter() depends on the generic typing deduced from both arguments, while the return type of nexttoward() depends
only on the generic typing of the first argument.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
The nextafter() function is no longer marked as an extension.
The nextafterf(), nextafterl(), nexttoward(), nexttowardf(), and nexttowardl() functions are
added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0407 [68] and XSH/TC1-2008/0408 [357] are applied.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/setsid.html =====
setsid
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
setsid — create session and set process group ID
SYNOPSIS
#include
pid_t setsid(void);
DESCRIPTION
The setsid() function shall create a new session, if the calling process is not a process group leader. Upon return the
calling process shall be the session leader of this new session, shall be the process group leader of a new process group, and
shall have no controlling terminal. The process group ID of the calling process shall be set equal to the process ID of the calling
process. The calling process shall be the only process in the new process group and the only process in the new session.
RETURN VALUE
Upon successful completion, setsid() shall return the value of the new process group ID of the calling process.
Otherwise, it shall return -1 and set errno to indicate the error.
ERRORS
The setsid() function shall fail if:
[EPERM]
The calling process is already a process group leader, or the process group ID of a process other than the calling process
matches the process ID of the calling process.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
The setsid() function is similar to the setpgrp() function of System V. System V, without job control, groups
processes into process groups and creates new process groups via setpgrp(); only one process group may be part of a login
session.
Job control allows multiple process groups within a login session. In order to limit job control actions so that they can only
affect processes in the same login session, this volume of POSIX.1-2024 adds the concept of a session that is created via
setsid(). The setsid() function also creates the initial process group contained in the session. Additional process
groups can be created via the setpgid() function. A System V process group would
correspond to a POSIX System Interfaces session containing a single POSIX process group. Note that this function requires that the
calling process not be a process group leader. The usual way to ensure this is true is to create a new process with fork() and have it call setsid(). The fork()
function guarantees that the process ID of the new process does not match any existing process group ID.
FUTURE DIRECTIONS
None.
SEE ALSO
getsid(), setpgid()
XBD ,
CHANGE HISTORY
First released in Issue 3. Included for alignment with the POSIX.1-1988 standard.
Issue 6
In the SYNOPSIS, the optional include of the  header is
removed.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The requirement to include  has been removed. Although
was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0570 [421] is applied.
Issue 8
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sinh.html =====
sinh
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sinh, sinhf, sinhl — hyperbolic sine functions
SYNOPSIS
#include
double sinh(double x);
float sinhf(float x);
long double sinhl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the hyperbolic sine of their argument x.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the hyperbolic sine of x.
If the result would cause an overflow, a range error shall occur and ±HUGE_VAL, ±HUGE_VALF, and ±HUGE_VALL (with the same sign
as x) shall be returned as appropriate for the type of the function.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0 or ±Inf, x shall be returned.
[MXX]
If x is subnormal, x should be returned.
[MX]  If x is subnormal, a range error may occur and, if x is
not returned, sinh(), sinhf(), and sinhl() shall return an implementation-defined value no greater in
magnitude than DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
ERRORS
These functions shall fail if:
Range Error
The result would cause an overflow.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall be
raised.
These functions may fail if:
Range Error
[MX]
The value x is subnormal.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
asinh(), cosh(), feclearexcept(), fetestexcept()
, isnan(), tanh()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The sinhf() and sinhl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0587 [68] is applied.
Issue 8
Austin Group Defect 1382 is applied, rearranging the text describing the behavior when x is subnormal to avoid the need
for two shading changes.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getpwent.html =====
endpwent
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
endpwent, getpwent, setpwent — user database functions
SYNOPSIS
[XSI]  #include
void endpwent(void);
struct passwd *getpwent(void);
void setpwent(void);
DESCRIPTION
These functions shall retrieve information about users.
The getpwent() function shall return a pointer to a structure containing the broken-out fields of an entry in the user
database. Each entry in the user database contains a passwd structure. If the user database is not already open,
getpwent() shall open it and return a pointer to a passwd structure containing the first entry in the database.
Thereafter, it shall return a pointer to a passwd structure containing the next entry in the user database. Successive calls
can be used to search the entire user database.
If an end-of-file or an error is encountered on reading, getpwent() shall return a null pointer.
An implementation that provides extended security controls may impose further implementation-defined restrictions on accessing
the user database. In particular, the system may deny the existence of some or all of the user database entries associated with
users other than the caller.
The setpwent() function shall rewind the user database so that the next getpwent() call returns the first entry,
allowing repeated searches.
The endpwent() function shall close the user database.
The setpwent() and endpwent() functions shall not change the setting of errno if successful.
On error, the setpwent() and endpwent() functions shall set errno to indicate the error.
Since no value is returned by the setpwent() and endpwent() functions, an application wishing to check for error
situations should set errno to 0, then call the function, then check errno.
These functions need not be thread-safe.
RETURN VALUE
On successful completion, getpwent() shall return a pointer to a passwd structure. On end-of-file,
getpwent() shall return a null pointer and shall not change the setting of errno. On error, getpwent() shall
return a null pointer and errno shall be set to indicate the error.
The application shall not modify the structure to which the return value points, nor any storage areas pointed to by pointers
within the structure. The returned pointer, and pointers within the structure, might be invalidated or the structure or the storage
areas might be overwritten by a subsequent call to getpwuid(), getpwnam(), or getpwent(). The returned pointer, and pointers within the structure,
might also be invalidated if the calling thread is terminated.
ERRORS
These functions may fail if:
[EINTR]
A signal was caught during the operation.
[EIO]
An I/O error has occurred.
In addition, getpwent() and setpwent() may fail if:
[EMFILE]
All file descriptors available to the process are currently open.
[ENFILE]
The maximum allowable number of files is currently open in the system.
The following sections are informative.
EXAMPLES
Searching the User Database
The following example uses the getpwent() function to get successive entries in the user database, returning a pointer to
a passwd structure that contains information about each user. The call to endpwent() closes the user database and
cleans up.
#include
#include
void printname(uid_t uid)
{
struct passwd *pwd;
setpwent();
while((pwd = getpwent()) != NULL) {
if (pwd->pw_uid == uid) {
printf("name=%s\n",pwd->pw_name);
break;
}
}
endpwent();
}
APPLICATION USAGE
These functions are provided due to their historical usage. Applications should avoid dependencies on fields in the password
database, whether the database is a single file, or where in the file system name space the database resides. Applications should
use getpwuid() whenever possible because it avoids these dependencies.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
endgrent(), getlogin(),
getpwnam(), getpwuid()
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Normative text previously in the APPLICATION USAGE section is moved to the RETURN VALUE section.
A note indicating that these functions need not be reentrant is added to the DESCRIPTION.
Issue 6
In the DESCRIPTION, the note about reentrancy is expanded to cover thread-safety.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
SD5-XBD-ERN-4 is applied, changing the definition of the [EMFILE] error.
The EXAMPLES section is revised.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0087 [75] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0092 [493], XSH/TC2-2008/0093 [656], and XSH/TC2-2008/0094 [493] are
applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/atomic_compare_exchange_weak_explicit.html =====
atomic_compare_exchange_strong
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
atomic_compare_exchange_strong, atomic_compare_exchange_strong_explicit, atomic_compare_exchange_weak,
atomic_compare_exchange_weak_explicit — atomically compare and exchange the values of two objects
SYNOPSIS
#include
_Bool atomic_compare_exchange_strong(volatile A *object,
C *expected, C desired);
_Bool atomic_compare_exchange_strong_explicit(volatile A *object,
C *expected, C desired, memory_order
success, memory_order failure);
_Bool atomic_compare_exchange_weak(volatile A *object,
C *expected, C desired);
_Bool atomic_compare_exchange_weak_explicit(volatile A *object,
C *expected, C desired, memory_order
success, memory_order failure);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
Implementations that define the macro __STDC_NO_ATOMICS__ need not provide the  header nor support these generic functions.
The atomic_compare_exchange_strong_explicit() generic function shall atomically compare the contents of the memory
pointed to by object for equality with that pointed to by expected, and if true, shall replace the contents of the
memory pointed to by object with desired, and if false, shall update the contents of the memory pointed to by
expected with that pointed to by object. This operation shall be an atomic read-modify-write operation (see XBD
4.15.1 Memory Ordering). If the comparison is true, memory
shall be affected according to the value of success, and if the comparison is false, memory shall be affected
according to the value of failure. The application shall ensure that failure is not memory_order_release nor
memory_order_acq_rel, and shall ensure that failure is no stronger than success.
The atomic_compare_exchange_strong() generic function shall be equivalent to
atomic_compare_exchange_strong_explicit() called with success and failure both set to
memory_order_seq_cst.
The atomic_compare_exchange_weak_explicit() generic function shall be equivalent to
atomic_compare_exchange_strong_explicit(), except that the compare-and-exchange operation may fail spuriously. That is, even
when the contents of memory referred to by expected and object are equal, it may return zero and store back to
expected the same memory contents that were originally there.
The atomic_compare_exchange_weak() generic function shall be equivalent to atomic_compare_exchange_weak_explicit()
called with success and failure both set to memory_order_seq_cst.
RETURN VALUE
These generic functions shall return the result of the comparison.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
A consequence of spurious failure is that nearly all uses of weak compare-and-exchange will be in a loop. For example:
exp = atomic_load(&cur);
do {
des = function(exp);
} while (!atomic_compare_exchange_weak(&cur, &exp, des));
When a compare-and-exchange is in a loop, the weak version will yield better performance on some platforms. When a weak
compare-and-exchange would require a loop and a strong one would not, the strong one is preferable.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD 4.15.1 Memory Ordering,
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/mbsrtowcs.html =====
mbsrtowcs
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
mbsnrtowcs, mbsrtowcs — convert a character string to a wide-character string (restartable)
SYNOPSIS
#include
[CX]  size_t mbsnrtowcs(wchar_t *restrict dst, const char **restrict
src,
size_t nmc, size_t len, mbstate_t *restrict
ps);
size_t mbsrtowcs(wchar_t *restrict dst, const char **restrict src,
size_t len, mbstate_t *restrict ps);
DESCRIPTION
For mbsrtowcs(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The mbsrtowcs() function shall convert a sequence of characters, beginning in the conversion state described by the
object pointed to by ps, from the array indirectly pointed to by src into a sequence of corresponding wide
characters. If dst is not a null pointer, the converted characters shall be stored into the array pointed to by dst.
Conversion continues up to and including a terminating null character, which shall also be stored. Conversion shall stop early in
either of the following cases:
A sequence of bytes is encountered that does not form a valid character.
len codes have been stored into the array pointed to by dst (and dst is not a null pointer).
Each conversion shall take place as if by a call to the mbrtowc() function.
If dst is not a null pointer, the pointer object pointed to by src shall be assigned either a null pointer (if
conversion stopped due to reaching a terminating null character) or the address just past the last character converted (if any). If
conversion stopped due to reaching a terminating null character, and if dst is not a null pointer, the resulting state
described shall be the initial conversion state.
If ps is a null pointer, the mbsrtowcs() function shall use its own internal mbstate_t object, which is
initialized at program start-up to the initial conversion state. Otherwise, the mbstate_t object pointed to by ps
shall be used to completely describe the current conversion state of the associated character sequence.
[CX]  The
mbsnrtowcs() function shall be equivalent to the mbsrtowcs() function, except that the conversion of characters
indirectly pointed to by src is limited to at most nmc bytes (the size of the input buffer), and under conditions
where mbsrtowcs() would assign the address just past the last character converted (if any) to the pointer object pointed to
by src, mbsnrtowcs() shall instead assign the address just past the last byte processed (if any) to that pointer
object. If the input buffer ends with an incomplete character, conversion shall stop at the end of the input buffer; a subsequent
call to mbsnrtowcs() with an input buffer that starts with the remainder of the incomplete character shall correctly
complete the conversion of that character.
The behavior of these functions shall be affected by the LC_CTYPE category of the current locale.
The implementation shall behave as if no function defined in this volume of POSIX.1-2024 calls these functions.
[CX]  If
called with a null ps argument, the mbsnrtowcs() function need not be thread-safe; however, such calls shall avoid
data races with calls to mbsnrtowcs() with a non-null argument and with calls to all other functions.
If called with a null ps argument, the mbsrtowcs() function need not be thread-safe; however, such calls shall
avoid data races with calls to mbsrtowcs() with a non-null argument and with calls to all other functions.
The mbsrtowcs() function shall not change the setting of errno if successful.
RETURN VALUE
If the input conversion encounters a sequence of bytes that do not form a valid character, an encoding error occurs. In this
case, these functions shall store the value of the macro [EILSEQ] in errno and shall return (size_t)-1; the
conversion state is undefined. Otherwise, these functions shall return the number of characters successfully converted, not
including the terminating null (if any).
ERRORS
These functions shall fail if:
[EILSEQ]
An invalid character sequence is detected. [CX]   In the POSIX locale an [EILSEQ] error cannot occur since all byte
values are valid characters.
These functions may fail if:
[EINVAL]
[CX]
ps points to an object that contains an invalid conversion state.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
iconv(), mbrtowc(),
mbsinit()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E).
Issue 6
The mbsrtowcs() prototype is updated for alignment with the ISO/IEC 9899:1999 standard.
The [EINVAL] error condition is marked CX.
Issue 7
Austin Group Interpretation 1003.1-2001 #170 is applied.
The mbsnrtowcs() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 1.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0370 [109,105] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0205 [601], XSH/TC2-2008/0206 [663], and XSH/TC2-2008/0207 [601] are
applied.
Issue 8
Austin Group Defect 616 is applied, requiring that when the mbsnrtowcs() input buffer ends with an incomplete character,
conversion stops at the end of the input buffer (not at the end of the previous character, if any).
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_rwlockattr_init.html =====
pthread_rwlockattr_destroy
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_rwlockattr_destroy, pthread_rwlockattr_init — destroy and initialize the read-write lock attributes
object
SYNOPSIS
#include
int pthread_rwlockattr_destroy(pthread_rwlockattr_t *attr);
int pthread_rwlockattr_init(pthread_rwlockattr_t *attr);
DESCRIPTION
The pthread_rwlockattr_destroy() function shall destroy a read-write lock attributes object. A destroyed attr
attributes object can be reinitialized using pthread_rwlockattr_init(); the results of otherwise referencing the object
after it has been destroyed are undefined. An implementation may cause pthread_rwlockattr_destroy() to set the object
referenced by attr to an invalid value.
The pthread_rwlockattr_init() function shall initialize a read-write lock attributes object attr with the default
value for all of the attributes defined by the implementation.
Results are undefined if pthread_rwlockattr_init() is called specifying an already initialized attr attributes
object.
After a read-write lock attributes object has been used to initialize one or more read-write locks, any function affecting the
attributes object (including destruction) shall not affect any previously initialized read-write locks.
The behavior is undefined if the value specified by the attr argument to pthread_rwlockattr_destroy() does not
refer to an initialized read-write lock attributes object.
RETURN VALUE
If successful, the pthread_rwlockattr_destroy() and pthread_rwlockattr_init() functions shall return zero;
otherwise, an error number shall be returned to indicate the error.
ERRORS
The pthread_rwlockattr_init() function shall fail if:
[ENOMEM]
Insufficient memory exists to initialize the read-write lock attributes object.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
If an implementation detects that the value specified by the attr argument to pthread_rwlockattr_destroy() does
not refer to an initialized read-write lock attributes object, it is recommended that the function should fail and report an
[EINVAL] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_rwlock_destroy(), pthread_rwlockattr_getpshared()
XBD
CHANGE HISTORY
First released in Issue 5.
Issue 6
The following changes are made for alignment with IEEE Std 1003.1j-2000:
The margin code in the SYNOPSIS is changed to THR to indicate that the functionality is now part of the Threads option
(previously it was part of the Read-Write Locks option in IEEE Std 1003.1j-2000 and also part of the XSI extension).
The SEE ALSO section is updated.
Issue 7
The pthread_rwlockattr_destroy() and pthread_rwlockattr_init() functions are moved from the Threads option to the
Base.
The [EINVAL] error for an uninitialized read-write lock attributes object is removed; this condition results in undefined
behavior.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sigemptyset.html =====
sigemptyset
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sigemptyset — initialize and empty a signal set
SYNOPSIS
[CX]  #include
int sigemptyset(sigset_t *set);
DESCRIPTION
The sigemptyset() function initializes the signal set pointed to by set, such that all signals defined in
POSIX.1-2024 are excluded.
RETURN VALUE
Upon successful completion, sigemptyset() shall return 0; otherwise, it shall return -1 and set errno to indicate
the error.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
The implementation of the sigemptyset() (or sigfillset()) function
could quite trivially clear (or set) all the bits in the signal set. Alternatively, it would be reasonable to initialize part of
the structure, such as a version field, to permit binary-compatibility between releases where the size of the set varies. For such
reasons, either sigemptyset() or sigfillset() must be called prior to any
other use of the signal set, even if such use is read-only (for example, as an argument to sigpending()). This function is not intended for dynamic allocation.
The sigfillset() and sigemptyset() functions require that the resulting
signal set include (or exclude) all the signals defined in this volume of POSIX.1-2024. Although it is outside the scope of this
volume of POSIX.1-2024 to place this requirement on signals that are implemented as extensions, it is recommended that
implementation-defined signals also be affected by these functions. However, there may be a good reason for a particular signal not
to be affected. For example, blocking or ignoring an implementation-defined signal may have undesirable side-effects, whereas the
default action for that signal is harmless. In such a case, it would be preferable for such a signal to be excluded from the signal
set returned by sigfillset().
In early proposals there was no distinction between invalid and unsupported signals (the names of optional signals that were not
supported by an implementation were not defined by that implementation). The [EINVAL] error was thus specified as a required error
for invalid signals. With that distinction, it is not necessary to require implementations of these functions to determine whether
an optional signal is actually supported, as that could have a significant performance impact for little value. The error could
have been required for invalid signals and optional for unsupported signals, but this seemed unnecessarily complex. Thus, the error
is optional in both cases.
FUTURE DIRECTIONS
None.
SEE ALSO
2.4 Signal Concepts, pthread_sigmask(), sigaction(),
sigaddset(), sigdelset(),
sigfillset(), sigismember()
, sigpending(), sigsuspend()
XBD
CHANGE HISTORY
First released in Issue 3. Included for alignment with the POSIX.1-1988 standard.
Issue 6
The SYNOPSIS is marked CX since the presence of this function in the  header is an extension over the ISO C standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/dbm_fetch.html =====
dbm_clearerr
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
dbm_clearerr, dbm_close, dbm_delete, dbm_error, dbm_fetch, dbm_firstkey, dbm_nextkey, dbm_open, dbm_store — database
functions
SYNOPSIS
[XSI]  #include
int dbm_clearerr(DBM *db);
void dbm_close(DBM *db);
int dbm_delete(DBM *db, datum key);
int dbm_error(DBM *db);
datum dbm_fetch(DBM *db, datum key);
datum dbm_firstkey(DBM *db);
datum dbm_nextkey(DBM *db);
DBM *dbm_open(const char *file, int open_flags, mode_t file_mode);
int dbm_store(DBM *db, datum key, datum content, int
store_mode);
DESCRIPTION
These functions create, access, and modify a database.
A datum consists of at least two members, dptr and dsize. The dptr member points to an object that
is dsize bytes in length. Arbitrary binary data, as well as character strings, may be stored in the object pointed to by
dptr.
A database shall be stored in one or two files. When one file is used, the name of the database file shall be formed by
appending the suffix .db to the file argument given to dbm_open(). When two files are used, the names of the
database files shall be formed by appending the suffixes .dir and .pag respectively to the file argument.
The dbm_open() function shall open a database. The file argument to the function is the pathname of the database.
Values for the open_flags argument are constructed by a bitwise-inclusive OR of flags from the following list, defined in
. Applications shall specify exactly one of the first three values
(file access modes) below in the value of open_flags:
O_RDONLY
Open the database, and the underlying file(s) used to store the database, for reading only.
O_RDWR
Open the database, and the underlying file(s) used to store the database, for reading and writing.
O_WRONLY
Open the database for writing only. The underlying file(s) used to store the database shall be opened for reading and
writing.
Any combination of the following can be used:
O_CLOEXEC
If set, the FD_CLOEXEC flag for the new file descriptor(s) used to open the underlying file(s) shall be set.
O_CREAT
If the database exists, this flag has no effect except as noted under O_EXCL below. Otherwise, the database shall be created;
the user ID of the underlying file(s) shall be set to the effective user ID of the process; the group ID of the underlying file(s)
shall be set to the group ID of the file's parent directory or to the effective group ID of the process. Implementations shall
provide a way to initialize the group ID to the group ID of the parent directory. Implementations may, but need not, provide an
implementation-defined way to initialize the group ID to the effective group ID of the calling process.
O_DSYNC
[SIO]
Write I/O operations on the file(s) used to store the database shall complete as defined by synchronized I/O data integrity
completion.
O_EXCL
If O_CREAT and O_EXCL are set, dbm_open() shall fail if the database exists according to the following criteria. If the
database is stored in a file with a .db suffix, a check for the existence of the file and the creation of the file if it
does not exist shall be performed as a single atomic operation. If the database is stored in files with .pag and .dir
suffixes, this atomic existence check and creation operation shall be performed for each file, but it is unspecified which file is
first. If the first file is successfully created and the second file is found to exist, the first file should be removed before
dbm_open() returns.
If O_EXCL is set and O_CREAT is not set, the result is undefined.
O_RSYNC
[SIO]
Read I/O operations on the file(s) used to store the database shall complete at the same level of integrity as specified by the
O_DSYNC and O_SYNC flags. If both O_DSYNC and O_RSYNC are set in oflag, all I/O operations on the file(s) shall complete as defined
by synchronized I/O data integrity completion. If both O_SYNC and O_RSYNC are set in flags, all I/O operations on the file(s) shall
complete as defined by synchronized I/O file integrity completion.
O_SYNC
Write I/O operations on the file(s) used to store the database shall complete as defined by synchronized I/O file integrity
completion.
O_TRUNC
If the database exists and is successfully opened O_RDWR or O_WRONLY, it shall be emptied, and the mode and owner of the
underlying file(s) shall be unchanged. The result of using O_TRUNC without either O_RDWR or O_WRONLY is undefined.
The behaviour of other flags described for the flags argument of open() is
unspecified.
The file_mode argument has the same meaning as the third argument of open()
and shall apply to the underlying file(s) used to store the database.
The dbm_open() function need not accept pathnames longer than {PATH_MAX}-4 bytes (including the terminating null), or
pathnames with a last component longer than {NAME_MAX}-4 bytes (excluding the terminating null).
The dbm_close() function shall close a database. The application shall ensure that argument db is a pointer to a
dbm structure that has been returned from a call to dbm_open().
These database functions shall support an internal block size large enough to support key/content pairs of at least 1023
bytes.
The dbm_fetch() function shall read a record from a database. The argument db is a pointer to a database structure
that has been returned from a call to dbm_open(). The argument key is a datum that has been initialized by the
application to the value of the key that matches the key of the record the program is fetching.
The dbm_store() function shall write a record to a database. The argument db is a pointer to a database structure
that has been returned from a call to dbm_open(). The argument key is a datum that has been initialized by the
application to the value of the key that identifies (for subsequent reading, writing, or deleting) the record the application is
writing. The argument content is a datum that has been initialized by the application to the value of the record the
program is writing. The argument store_mode controls whether dbm_store() replaces any pre-existing record that has
the same key that is specified by the key argument. The application shall set store_mode to either DBM_INSERT or
DBM_REPLACE. If the database contains a record that matches the key argument and store_mode is DBM_REPLACE, the
existing record shall be replaced with the new record. If the database contains a record that matches the key argument and
store_mode is DBM_INSERT, the existing record shall be left unchanged and the new record ignored. If the database does not
contain a record that matches the key argument and store_mode is either DBM_INSERT or DBM_REPLACE, the new record
shall be inserted in the database.
If the sum of a key/content pair exceeds the internal block size, the result is unspecified. Moreover, the application shall
ensure that all key/content pairs that hash together fit on a single block. The dbm_store() function shall return an error
in the event that a disk block fills with inseparable data.
The dbm_delete() function shall delete a record and its key from the database. The argument db is a pointer to a
database structure that has been returned from a call to dbm_open(). The argument key is a datum that has been
initialized by the application to the value of the key that identifies the record the program is deleting.
The dbm_firstkey() function shall return the first key in the database. The argument db is a pointer to a database
structure that has been returned from a call to dbm_open().
The dbm_nextkey() function shall return the next key in the database. The argument db is a pointer to a database
structure that has been returned from a call to dbm_open(). The application shall ensure that the dbm_firstkey()
function is called before calling dbm_nextkey(). Subsequent calls to dbm_nextkey() return the next key until all of
the keys in the database have been returned.
The dbm_error() function shall return the error condition of the database. The argument db is a pointer to a
database structure that has been returned from a call to dbm_open().
The dbm_clearerr() function shall clear the error condition of the database. The argument db is a pointer to a
database structure that has been returned from a call to dbm_open().
The dptr pointers returned by these functions may point into static storage that may be changed by subsequent calls.
These functions need not be thread-safe.
RETURN VALUE
The dbm_store() and dbm_delete() functions shall return 0 when they succeed and a negative value when they
fail.
The dbm_store() function shall return 1 if it is called with a flags value of DBM_INSERT and the function finds an
existing record with the same key.
The dbm_error() function shall return 0 if the error condition is not set and return a non-zero value if the error
condition is set.
The return value of dbm_clearerr() is unspecified.
The dbm_firstkey() and dbm_nextkey() functions shall return a key datum. When the end of the database is
reached, the dptr member of the key is a null pointer. If an error is detected, the dptr member of the key shall be a
null pointer and the error condition of the database shall be set.
The dbm_fetch() function shall return a content datum. If no record in the database matches the key or if an error
condition has been detected in the database, the dptr member of the content shall be a null pointer.
The dbm_open() function shall return a pointer to a database structure. If an error is detected during the operation,
dbm_open() shall return a (DBM *)0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The following code can be used to traverse the database:
for(key = dbm_firstkey(db); key.dptr != NULL; key = dbm_nextkey(db))
The dbm_* functions provided in this library should not be confused in any way with those of a general-purpose database
management system. These functions do not provide for multiple search keys per entry, they do not protect against multi-user access
(in other words they do not lock records or files), and they do not provide the many other useful database functions that are found
in more robust database management systems. Creating and updating databases by use of these functions is relatively slow because of
data copies that occur upon hash collisions. These functions are useful for applications requiring fast lookup of relatively static
information that is to be indexed by a single key.
Note that a strictly conforming application is extremely limited by these functions: since there is no way to determine that the
keys in use do not all hash to the same value (although that would be rare), a strictly conforming application cannot be guaranteed
that it can store more than one block's worth of data in the database. As long as a key collision does not occur, additional data
may be stored, but because there is no way to determine whether an error is due to a key collision or some other error condition
(dbm_error() being effectively a Boolean), once an error is detected, the
application is effectively limited to guessing what the error might be if it wishes to continue using these functions.
The dbm_delete() function need not physically reclaim file space, although it does make it available for reuse by the
database.
After calling dbm_store() or dbm_delete() during a pass through the keys by dbm_firstkey() and
dbm_nextkey(), the application should reset the database by calling dbm_firstkey() before again calling
dbm_nextkey(). The contents of these files are unspecified and may not be portable.
Applications should take care that database pathname arguments specified to dbm_open() are not prefixes of unrelated
files. This might be done, for example, by placing databases in a separate directory.
Since some implementations use three characters for a suffix and others use four characters for a suffix, applications should
ensure that the maximum portable pathname length passed to dbm_open() is no greater than {PATH_MAX}-4 bytes, with the last
component of the pathname no greater than {NAME_MAX}-4 bytes.
RATIONALE
and having .dir as its suffix. The second file containing all data and having .pag as its suffix. This has been
changed not to specify the use of the files and to allow newer implementations of the Berkeley DB interface using a single file
that have evolved while remaining compatible with the application programming interface. The standard developers considered
removing the specific suffixes altogether but decided to retain them so as not to pollute the application file name space more than
necessary and to allow for portable backups of the database.
FUTURE DIRECTIONS
A future revision of this standard may mandate the file removal that is currently recommended (by the use of "should") in the
description of O_EXCL.
SEE ALSO
open()
XBD ,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Normative text previously in the APPLICATION USAGE section is moved to the DESCRIPTION.
A note indicating that these functions need not be reentrant is added to the DESCRIPTION.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
Austin Group Interpretation 1003.1-2001 #042 is applied so that the DESCRIPTION permits newer implementations of the Berkeley DB
interface.
Austin Group Interpretation 1003.1-2001 #156 is applied.
Issue 8
Austin Group Defect 1057 is applied, clarifying how the O_ flags defined for use with open() apply to dbm_open().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fmaf.html =====
fma
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fma, fmaf, fmal — floating-point multiply-add
SYNOPSIS
#include
double fma(double x, double y, double z);
float fmaf(float x, float y, float z);
long double fmal(long double x, long double y, long double z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute (x * y) + z, rounded as one ternary operation: they shall
compute the value (as if) to infinite precision and round once to the result format, according to the rounding mode characterized
by the value of FLT_ROUNDS.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return (x * y) + z, rounded as one ternary
operation.
If the result overflows or underflows, a range error may occur. [MX]
On systems that support the IEC 60559 Floating-Point
option, if the result overflows a range error shall occur.
If x or y are NaN, a NaN shall be returned.
If x multiplied by y is an exact infinity and z is also an infinity but with the opposite sign, a domain
error shall occur, and either a NaN (if supported), or an implementation-defined value shall be returned.
If one of x and y is infinite, the other is zero, and z is not a NaN, a domain error shall occur, and
either a NaN (if supported), or an implementation-defined value shall be returned.
If one of x and y is infinite, the other is zero, and z is a NaN, a NaN shall be returned and a domain
error may occur.
If x*y is not 0*Inf nor Inf*0 and z is a NaN, a NaN shall be returned.
ERRORS
These functions shall fail if:
Domain Error
[MX]
The value of x*y+z is invalid, or the value x*y is invalid and z is not a NaN.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
Range Error
[MX]
The result overflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall be
raised.
These functions may fail if:
Domain Error
[MX]
The value x*y is invalid and z is a NaN.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
Range Error
The result underflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
Range Error
The result overflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
In many cases, clever use of floating (fused) multiply-add leads to much improved code; but its unexpected use by the
compiler can undermine carefully written code. The FP_CONTRACT macro can be used to disallow use of floating multiply-add; and the
fma() function guarantees its use where desired. Many current machines provide hardware floating multiply-add instructions;
software implementation can be used for others.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
ISO/IEC 9899:1999 standard, Technical Corrigendum 2 #57 (SD5-XSH-ERN-69) is applied, adding a "may fail" range error for
non-MX systems.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sinhl.html =====
sinh
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sinh, sinhf, sinhl — hyperbolic sine functions
SYNOPSIS
#include
double sinh(double x);
float sinhf(float x);
long double sinhl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the hyperbolic sine of their argument x.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the hyperbolic sine of x.
If the result would cause an overflow, a range error shall occur and ±HUGE_VAL, ±HUGE_VALF, and ±HUGE_VALL (with the same sign
as x) shall be returned as appropriate for the type of the function.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0 or ±Inf, x shall be returned.
[MXX]
If x is subnormal, x should be returned.
[MX]  If x is subnormal, a range error may occur and, if x is
not returned, sinh(), sinhf(), and sinhl() shall return an implementation-defined value no greater in
magnitude than DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
ERRORS
These functions shall fail if:
Range Error
The result would cause an overflow.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall be
raised.
These functions may fail if:
Range Error
[MX]
The value x is subnormal.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
asinh(), cosh(), feclearexcept(), fetestexcept()
, isnan(), tanh()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The sinhf() and sinhl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0587 [68] is applied.
Issue 8
Austin Group Defect 1382 is applied, rearranging the text describing the behavior when x is subnormal to avoid the need
for two shading changes.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/lockf.html =====
lockf
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
lockf — record locking on files
SYNOPSIS
[XSI]  #include
int lockf(int fildes, int function, off_t size);
DESCRIPTION
The lockf() function shall lock sections of a file with advisory-mode process-owned file locks. Calls to lockf()
from threads in other processes which attempt to lock the locked file section shall either return an error value or block until the
section becomes unlocked. All the locks for a process are removed when the process terminates. Record locking with lockf()
shall be supported for regular files and may be supported for other files.
The fildes argument is an open file descriptor. To establish a lock with this function, the file descriptor shall be
opened with write-only permission (O_WRONLY) or with read/write permission (O_RDWR).
The function argument is a control value which specifies the action to be taken. The permissible values for
function are defined in  as follows:
Function
Description
F_ULOCK
Unlock locked sections.
F_LOCK
Lock a section for exclusive use.
F_TLOCK
Test and lock a section for exclusive use.
F_TEST
Test a section for locks by other processes.
F_TEST shall detect if a lock by another process is present on the specified section.
F_LOCK and F_TLOCK shall both lock a section of a file if the section is available.
F_ULOCK shall remove locks from a section of the file.
The size argument is the number of contiguous bytes to be locked or unlocked. The section to be locked or
unlocked starts at the current offset in the file and extends forward for a positive size or backward for a negative size (the
preceding bytes up to but not including the current offset). If size is 0, the section from the current offset through the
largest possible file offset shall be locked (that is, from the current offset through the present or any future end-of-file). An
area need not be allocated to the file to be locked because locks may exist past the end-of-file.
The sections locked with F_LOCK or F_TLOCK may, in whole or in part, contain or be contained by a previously locked
section for the same process. When this occurs, or if adjacent locked sections would occur, the sections shall be combined into a
single locked section. If the request would cause the number of locks to exceed a system-imposed limit, the request shall fail.
F_LOCK and F_TLOCK requests differ only by the action taken if the section is not available. F_LOCK shall block the
calling thread until the section is available. F_TLOCK shall cause the function to fail if the section is already locked by another
process.
Process-owned file locks shall be released on first close by the locking process of any file descriptor for the
file.
F_ULOCK requests may release (wholly or in part) one or more locked sections controlled by the process. Locked
sections shall be unlocked starting at the current file offset through size bytes or to the end-of-file if size is
(off_t)0. When all of a locked section is not released (that is, when the beginning or end of the area to be unlocked falls
within a locked section), the remaining portions of that section shall remain locked by the process. Releasing the center portion
of a locked section shall cause the remaining locked beginning and end portions to become two separate locked sections. If the
request would cause the number of locks in the system to exceed a system-imposed limit, the request shall fail.
A potential for deadlock occurs if the threads of a process controlling a locked section are blocked by accessing a
locked section of another process. If the system detects that deadlock would occur, lockf() shall fail with an [EDEADLK]
error.
The interaction between fcntl() and lockf() locks is
unspecified.
Blocking on a section shall be interrupted by any signal.
An F_ULOCK request in which size is non-zero and the offset of the last byte of the requested section is the
maximum value for an object of type off_t, when the process has an existing lock in which size is 0 and which
includes the last byte of the requested section, shall be treated as a request to unlock from the start of the requested section
with a size equal to 0. Otherwise, an F_ULOCK request shall attempt to unlock only the requested section.
Attempting to lock a section of a file that is associated with a buffered stream produces unspecified results.
RETURN VALUE
Upon successful completion, lockf() shall return 0. Otherwise, it shall return -1, set errno to indicate an error,
and existing locks shall not be changed.
ERRORS
The lockf() function shall fail if:
[EBADF]
The fildes argument is not a valid open file descriptor; or function is F_LOCK or F_TLOCK and fildes is
not a valid file descriptor open for writing.
[EACCES] or [EAGAIN]
The function argument is F_TLOCK or F_TEST and the section is already locked by another process.
[EDEADLK]
The function argument is F_LOCK and a deadlock is detected.
[EINTR]
A signal was caught during execution of the function.
[EINVAL]
The function argument is not one of F_LOCK, F_TLOCK, F_TEST, or F_ULOCK; or size plus the current file offset is
less than 0.
[EOVERFLOW]
The offset of the first, or if size is not 0 then the last, byte in the requested section cannot be represented
correctly in an object of type off_t.
The lockf() function may fail if:
[EAGAIN]
The function argument is F_LOCK or F_TLOCK and the file is mapped with mmap().
[EDEADLK] or [ENOLCK]
The function argument is F_LOCK, F_TLOCK, or F_ULOCK, and the request would cause the number of locks to exceed a
system-imposed limit.
[EOPNOTSUPP] or [EINVAL]
The implementation does not support the locking of files of the type indicated by the fildes argument.
The following sections are informative.
EXAMPLES
Locking a Portion of a File
In the following example, a file named /home/cnd/mod1 is being modified. Other processes that use locking
are prevented from changing it during this process. Only the first 10000 bytes are locked, and the lock call fails if another
process has any part of this area locked already.
#include
#include
int fildes;
int status;
...
fildes = open("/home/cnd/mod1", O_RDWR);
status = lockf(fildes, F_TLOCK, (off_t)10000);
APPLICATION USAGE
Record-locking should not be used in combination with buffered standard I/O streams (see 2.5 Standard I/O Streams). Instead, non-buffered I/O should be used. Unexpected
results may occur in processes that do buffering in the user address space. The process may later read/write data which is/was
locked. Functions that operate on standard I/O streams are the most common source of such buffering.
The alarm() function may be used to provide a timeout facility in
applications requiring it.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
alarm(), chmod(),
close(), creat(), fcntl(), fopen(), mmap(), open(), read(), write()
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Large File Summit extensions are added. In particular, the description of [EINVAL] is clarified and moved from
optional to mandatory status.
A note is added to the DESCRIPTION indicating the effects of attempting to lock a section of a file that is
associated with a buffered stream.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
Austin Group Interpretation 1003.1-2001 #054 is applied, updating the DESCRIPTION.
Issue 8
Austin Group Defect 768 is applied, adding OFD-owned file locks.
Austin Group Defect 1672 is applied, changing the APPLICATION USAGE section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/atomic_thread_fence.html =====
atomic_signal_fence
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
atomic_signal_fence, atomic_thread_fence — fence operations
SYNOPSIS
#include
void atomic_signal_fence(memory_order order);
void atomic_thread_fence(memory_order order);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
Implementations that define the macro __STDC_NO_ATOMICS__ need not provide the  header nor support these generic functions.
The atomic_signal_fence() and atomic_thread_fence() functions provide synchronization primitives called
fences. Fences can have acquire semantics, release semantics, or both. A fence with acquire semantics is called an
acquire fence; a fence with release semantics is called a release fence.
A release fence A synchronizes with an acquire fence B if there exist atomic operations X and Y,
both operating on some atomic object M, such that A is sequenced before X, X modifies M,
Y is sequenced before B, and Y reads the value written by X or a value written by any side effect in
the hypothetical release sequence X would head if it were a release operation.
A release fence A synchronizes with an atomic operation B that performs an acquire operation on an atomic object
M if there exists an atomic operation X such that A is sequenced before X, X modifies M,
and B reads the value written by X or a value written by any side effect in the hypothetical release sequence
X would head if it were a release operation.
An atomic operation A that is a release operation on an atomic object M synchronizes with an acquire fence
B if there exists some atomic operation X on M such that X is sequenced before B and reads the
value written by A or a value written by any side effect in the release sequence headed by A.
Depending on the value of order, the operation performed by atomic_thread_fence() shall:
have no effects, if order is equal to memory_order_relaxed;
be an acquire fence, if order is equal to memory_order_acquire or memory_order_consume;
be a release fence, if order is equal to memory_order_release;
be both an acquire fence and a release fence, if order is equal to memory_order_acq_rel;
be a sequentially consistent acquire and release fence, if order is equal to memory_order_seq_cst.
The atomic_signal_fence() function shall be equivalent to atomic_thread_fence(), except that the resulting
ordering constraints shall be established only between a thread and a signal handler executed in the same thread.
RETURN VALUE
These functions shall not return a value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The atomic_signal_fence() function can be used to specify the order in which actions performed by the thread become
visible to the signal handler. Implementation reorderings of loads and stores are inhibited in the same way as with
atomic_thread_fence(), but the hardware fence instructions that atomic_thread_fence() would have inserted are not
emitted.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD 4.15.1 Memory Ordering,
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/cimagf.html =====
cimag
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
cimag, cimagf, cimagl — complex imaginary functions
SYNOPSIS
#include
double cimag(double complex z);
float cimagf(float complex z);
long double cimagl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the imaginary part of z.
RETURN VALUE
These functions shall return the imaginary part value (as a real).
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
For a variable z of complex type:
z == creal(z) + cimag(z)*I
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
carg(), conj(), cproj(), creal()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/atomic_fetch_and_explicit.html =====
atomic_fetch_add
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
atomic_fetch_add, atomic_fetch_add_explicit, atomic_fetch_and, atomic_fetch_and_explicit, atomic_fetch_or,
atomic_fetch_or_explicit, atomic_fetch_sub, atomic_fetch_sub_explicit, atomic_fetch_xor, atomic_fetch_xor_explicit — atomically
replace the value of an object with the result of a computation
SYNOPSIS
#include
C atomic_fetch_add(volatile A *object, M operand); C
atomic_fetch_add_explicit(volatile A *object, M operand,
memory_order order); C atomic_fetch_and(volatile A
*object, M operand); C atomic_fetch_and_explicit(volatile A
*object, M operand,
memory_order order); C atomic_fetch_or(volatile A
*object, M operand); C atomic_fetch_or_explicit(volatile A
*object, M operand,
memory_order order); C atomic_fetch_sub(volatile A
*object, M operand); C atomic_fetch_sub_explicit(volatile A
*object, M operand,
memory_order order); C atomic_fetch_xor(volatile A
*object, M operand); C atomic_fetch_xor_explicit(volatile A
*object, M operand,
memory_order order);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
Implementations that define the macro __STDC_NO_ATOMICS__ need not provide the  header nor support these generic functions.
The atomic_fetch_add_explicit() generic function shall atomically replace the value pointed to by object with the
result of adding operand to this value. This operation shall be an atomic read-modify-write operation (see XBD 4.15.1 Memory Ordering). Memory shall be affected according to the value of
order.
The atomic_fetch_add() generic function shall be equivalent to atomic_fetch_add_explicit() called with
order set to memory_order_seq_cst.
The other atomic_fetch_*() generic functions shall be equivalent to atomic_fetch_add_explicit() if their name ends
with explicit, or to atomic_fetch_add() if it does not, respectively, except that they perform the computation
indicated in their name, instead of addition:
sub
subtraction
or
bitwise inclusive OR
xor
bitwise exclusive OR
and
bitwise AND
For addition and subtraction, the application shall ensure that A is an atomic integer type or an atomic pointer type and is not
atomic_bool. For the other operations, the application shall ensure that A is an atomic integer type and is not
atomic_bool.
For signed integer types, the computation shall silently wrap around on overflow; there are no undefined results. For pointer
types, the result can be an undefined address, but the computations otherwise have no undefined behavior.
RETURN VALUE
These generic functions shall return the value pointed to by object immediately before the effects.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The operation of these generic functions is nearly equivalent to the operation of the corresponding compound assignment
operators +=, -=, etc. The only differences are that the compound assignment operators are not guaranteed to
operate atomically, and the value yielded by a compound assignment operator is the updated value of the object, whereas the value
returned by these generic functions is the previous value of the atomic object.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD 4.15.1 Memory Ordering,
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/conjf.html =====
conj
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
conj, conjf, conjl — complex conjugate functions
SYNOPSIS
#include
double complex conj(double complex z);
float complex conjf(float complex z);
long double complex conjl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex conjugate of z, by reversing the sign of its imaginary part.
RETURN VALUE
These functions return the complex conjugate value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
carg(), cimag(), cproj(), creal()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getservbyname.html =====
endservent
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
endservent, getservbyname, getservbyport, getservent, setservent — network services database functions
SYNOPSIS
#include
void endservent(void);
struct servent *getservbyname(const char *name, const char *proto);
struct servent *getservbyport(int port, const char *proto);
struct servent *getservent(void);
void setservent(int stayopen);
DESCRIPTION
These functions shall retrieve information about network services. This information is considered to be stored in a database
that can be accessed sequentially or randomly. The implementation of this database is unspecified.
The setservent() function shall open a connection to the database, and set the next entry to the first entry. If the
stayopen argument is non-zero, the net database shall not be closed after each call to the getservent()
function (either directly, or indirectly through one of the other getserv*() functions), and the implementation may maintain
an open file descriptor for the database. If a file descriptor is used, the FD_CLOEXEC flag shall be set; see .
The getservent() function shall read the next entry of the database, opening and closing a connection to the database as
necessary.
The getservbyname() function shall search the database from the beginning and find the first entry for which the service
name specified by name matches the s_name member and the protocol name specified by proto matches the
s_proto member, opening and closing a connection to the database as necessary. If proto is a null pointer, any value
of the s_proto member shall be matched.
The getservbyport() function shall search the database from the beginning and find the first entry for which the port
specified by port matches the s_port member and the protocol name specified by proto matches the
s_proto member, opening and closing a connection to the database as necessary. If proto is a null pointer, any value
of the s_proto member shall be matched. The port argument shall be a value obtained by converting a uint16_t
in network byte order to int.
The getservbyname(), getservbyport(), and getservent() functions shall each return a pointer to a
servent structure, the members of which shall contain the fields of an entry in the network services database.
The endservent() function shall close the database, releasing any open file descriptor.
These functions need not be thread-safe.
RETURN VALUE
Upon successful completion, getservbyname(), getservbyport(), and getservent() return a pointer to a
servent structure if the requested entry was found, and a null pointer if the end of the database was reached or the
requested entry was not found. Otherwise, a null pointer is returned.
The application shall not modify the structure to which the return value points, nor any storage areas pointed to by pointers
within the structure. The returned pointer, and pointers within the structure, might be invalidated or the structure or the storage
areas might be overwritten by a subsequent call to getservbyname(), getservbyport(), or getservent(). The
returned pointer, and pointers within the structure, might also be invalidated if the calling thread is terminated.
ERRORS
The getservbyname(), getservbyport(), getservent(), and setservent() functions may fail if:
[EMFILE]
All file descriptors available to the process are currently open.
[ENFILE]
The maximum allowable number of files is currently open in the system.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The port argument of getservbyport() need not be compatible with the port values of all address families.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
endhostent(), endprotoent(), htonl(), inet_addr()
XBD ,
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
SD5-XBD-ERN-14 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0088 [75] and XSH/TC1-2008/0089 [75] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0095 [656] is applied.
Issue 8
Austin Group Defect 368 is applied, adding a requirement for FD_CLOEXEC to be set if a file descriptor is used, and adding the
[EMFILE] and [ENFILE] errors.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wcscspn.html =====
wcscspn
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wcscspn — get the length of a complementary wide substring
SYNOPSIS
#include
size_t wcscspn(const wchar_t *ws1, const wchar_t *ws2);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The wcscspn() function shall compute the length (in wide characters) of the maximum initial segment of the wide-character
string pointed to by ws1 which consists entirely of wide-character codes not from the wide-character string pointed
to by ws2.
[CX]  The
wcscspn() function shall not change the setting of errno on valid input.
RETURN VALUE
The wcscspn() function shall return the length of the initial substring of ws1; no return value is reserved to
indicate an error.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
wcsspn()
XBD
CHANGE HISTORY
First released in Issue 4. Derived from the MSE working draft.
Issue 5
The RETURN VALUE section is updated to indicate that wcscspn() returns the length of ws1, rather than ws1
itself.
Issue 8
Austin Group Defect 448 is applied, adding a requirement that wcscspn() does not change the setting of errno on
valid input.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/aio_cancel.html =====
aio_cancel
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
aio_cancel — cancel an asynchronous I/O request
SYNOPSIS
#include
int aio_cancel(int fildes, struct aiocb *aiocbp);
DESCRIPTION
The aio_cancel() function shall attempt to cancel one or more asynchronous I/O requests currently outstanding against
file descriptor fildes. The aiocbp argument points to the asynchronous I/O control block for a particular request to
be canceled. If aiocbp is NULL, then all outstanding cancelable asynchronous I/O requests against fildes shall be
canceled.
Normal asynchronous notification shall occur for asynchronous I/O operations that are successfully canceled. If there are
requests that cannot be canceled, then the normal asynchronous completion process shall take place for those requests when they are
completed.
For requested operations that are successfully canceled, the associated error status shall be set to [ECANCELED] and the return
status shall be -1. For requested operations that are not successfully canceled, the aiocbp shall not be modified by
aio_cancel().
If aiocbp is not NULL, then if fildes does not have the same value as the file descriptor with which the
asynchronous operation was initiated, unspecified results occur.
Which operations are cancelable is implementation-defined.
RETURN VALUE
The aio_cancel() function shall return the value AIO_CANCELED if the requested operation(s) were canceled. The value
AIO_NOTCANCELED shall be returned if at least one of the requested operation(s) cannot be canceled because it is in progress. In
this case, the state of the other operations, if any, referenced in the call to aio_cancel() is not indicated by the return
value of aio_cancel(). The application may determine the state of affairs for these operations by using aio_error(). The value AIO_ALLDONE is returned if all of the operations have already
completed. Otherwise, the function shall return -1 and set errno to indicate the error.
ERRORS
The aio_cancel() function shall fail if:
[EBADF]
The fildes argument is not a valid file descriptor.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
aio_read(), aio_write()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Issue 6
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the
Asynchronous Input and Output option.
The APPLICATION USAGE section is added.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/10 is applied, removing the words "to the calling process" in
the RETURN VALUE section. The term was unnecessary and precluded threads.
Issue 7
The aio_cancel() function is moved from the Asynchronous Input and Output option to the Base.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pwrite.html =====
write
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pwrite, write — write on a file
SYNOPSIS
#include
ssize_t pwrite(int fildes, const void *buf, size_t nbyte,
off_t offset);
ssize_t write(int fildes, const void *buf, size_t nbyte);
DESCRIPTION
The write() function shall attempt to write nbyte bytes from the buffer pointed to by buf to the file
associated with the open file descriptor, fildes.
Before any action described below is taken, and if nbyte is zero and the file is a regular file, the write()
function may detect and return errors as described below. In the absence of errors, or if error detection is not performed, the
write() function shall return zero and have no other results. If nbyte is zero and the file is not a regular file,
the results are unspecified.
On a regular file or other file capable of seeking, the actual writing of data shall proceed from the position in the file
indicated by the file offset associated with fildes. Before successful return from write(), the file offset shall be
incremented by the number of bytes actually written. On a regular file, if the position of the last byte written is greater than or
equal to the length of the file, the length of the file shall be set to this position plus one.
On a file not capable of seeking, writing shall always take place starting at the current position. The value of a file offset
associated with such a device is undefined.
If the O_APPEND flag of the file status flags is set, the file offset shall be set to the end of the file prior to each write
and no intervening file modification operation shall occur between changing the file offset and the write operation.
If a write() requests that more bytes be written than there is room for (for example, the file size limit of the process
or the physical end of a medium), only as many bytes as there is room for shall be written. For example, suppose there is space for
20 bytes more in a file before reaching a limit. A write of 512 bytes will return 20. The next write of a non-zero number of bytes
would give a failure return (except as noted below).
If the request would cause the file size to exceed the soft file size limit for the process and there is no room for any bytes
to be written, the request shall fail [XSI]   and the implementation shall generate a SIGXFSZ signal for the thread.
If write() is interrupted by a signal before it writes any data, it shall return -1 with errno set to [EINTR].
If write() is interrupted by a signal after it successfully writes some data, it shall return the number of bytes
written.
If the value of nbyte is greater than {SSIZE_MAX}, the result is implementation-defined.
After a write() to a regular file has successfully returned:
Any successful read() from each byte position in the file that was modified by that
write shall return the data specified by the write() for that position until such byte positions are again modified.
Any subsequent successful write() to the same byte position in the file shall overwrite that file data.
Write requests to a pipe or FIFO shall be handled in the same way as a regular file with the following exceptions:
There is no file offset associated with a pipe or FIFO, hence each write request shall append to the end of the pipe or
FIFO.
Write requests of {PIPE_BUF} bytes or less shall not be interleaved with data from other threads performing write operations on
the same pipe or FIFO. Writes of greater than {PIPE_BUF} bytes may have data interleaved, on arbitrary boundaries, with write
operations by other threads, whether or not the O_NONBLOCK flag of the file status flags is set.
If the O_NONBLOCK flag is clear, a write request may cause the thread to block, but on normal completion it shall return
nbyte.
If the O_NONBLOCK flag is set, write() requests shall be handled differently, in the following ways:
The write() function shall not block the thread.
A write request for {PIPE_BUF} or fewer bytes shall have the following effect: if there is sufficient space available in the
pipe or FIFO, write() shall transfer all the data and return the number of bytes requested. Otherwise, write() shall
transfer no data and return -1 with errno set to [EAGAIN].
A write request for more than {PIPE_BUF} bytes shall cause one of the following:
When at least one byte can be written, transfer what it can and return the number of bytes written. When all data previously
written to the pipe or FIFO is read, it shall transfer at least {PIPE_BUF} bytes.
When no data can be written, transfer no data, and return -1 with errno set to [EAGAIN].
When attempting to write to a file descriptor (other than a pipe or FIFO) that supports non-blocking writes and cannot accept
the data immediately:
If the O_NONBLOCK flag is clear, write() shall block the calling thread until the data can be accepted.
If the O_NONBLOCK flag is set, write() shall not block the thread. If some data can be written without blocking the
thread, write() shall write what it can and return the number of bytes written. Otherwise, it shall return -1 and set
errno to [EAGAIN].
Upon successful completion, where nbyte is greater than 0, write() shall mark for update the last data
modification and last file status change timestamps of the file, and if the file is a regular file, the S_ISUID and S_ISGID bits of
the file mode may be cleared.
For regular files, no data transfer shall occur past the offset maximum established in the open file description associated with
fildes.
If fildes refers to a socket, write() shall be equivalent to send()
with no flags set.
[SIO]
If the O_DSYNC bit has been set, write I/O operations on the file descriptor shall complete as defined by synchronized I/O data
integrity completion.
If the O_SYNC bit has been set, write I/O operations on the file descriptor shall complete as defined by synchronized I/O file
integrity completion.
[SHM]
If fildes refers to a shared memory object, the result of the write() function is unspecified.
[TYM]
If fildes refers to a typed memory object, the result of the write() function is unspecified.
The pwrite() function shall be equivalent to write(), except that it writes into a given position and does not
change the file offset (regardless of whether O_APPEND is set). The first three arguments to pwrite() are the same as
write() with the addition of a fourth argument offset for the desired position inside the file. An attempt to perform
a pwrite() on a file that is incapable of seeking shall result in an error.
RETURN VALUE
Upon successful completion, these functions shall return the number of bytes actually written to the file associated with
fildes. This number shall never be greater than nbyte. Otherwise, -1 shall be returned and errno set to
indicate the error.
ERRORS
These functions shall fail if:
[EAGAIN]
The file is neither a pipe, nor a FIFO, nor a socket, the O_NONBLOCK flag is set for the file descriptor, and the thread would
be delayed in the write() operation.
[EBADF]
The fildes argument is not a valid file descriptor open for writing.
[EFBIG]
An attempt was made to write a file that exceeds the implementation-defined maximum file size and there was no room for any
bytes to be written.
[EFBIG]
An attempt was made to write a file that exceeds the file size limit of the process, and there was no room for any bytes to be
written. [XSI]   A SIGXFSZ signal shall also be generated for the thread.
[EFBIG]
The file is a regular file, nbyte is greater than 0, and the starting position is greater than or equal to the offset
maximum established in the open file description associated with fildes.
[EINTR]
The write operation was terminated due to the receipt of a signal, and no data was transferred.
[EIO]
The process is a member of a background process group attempting to write to its controlling terminal, TOSTOP is set, the
calling thread is not blocking SIGTTOU, the process is not ignoring SIGTTOU, and the process group of the process is orphaned. This
error may also be returned under implementation-defined conditions.
[ENOSPC]
There was no free space remaining on the device containing the file.
The pwrite() function shall fail if:
[EINVAL]
The file is a regular file or block special file, and the offset argument is negative. The file offset shall remain
unchanged.
[ESPIPE]
The file is incapable of seeking.
The write() function shall fail if:
[EAGAIN]
The file is a pipe or FIFO, the O_NONBLOCK flag is set for the file descriptor, and the thread would be delayed in the write
operation.
[EAGAIN] or [EWOULDBLOCK]
The file is a socket, the O_NONBLOCK flag is set for the file descriptor, and the thread would be delayed in the write
operation.
[ECONNRESET]
A write was attempted on a socket that is not connected.
[EPIPE]
An attempt is made to write to a pipe or FIFO that is not open for reading by any process, or that only has one end open. A
SIGPIPE signal shall also be sent to the thread.
[EPIPE]
A write was attempted on a socket that is shut down for writing, or is no longer connected. In the latter case, if the socket
is of type SOCK_STREAM, a SIGPIPE signal shall also be sent to the thread.
These functions may fail if:
[EIO]
A physical I/O error has occurred.
[ENOBUFS]
Insufficient resources were available in the system to perform the operation.
[ENXIO]
A request was made of a nonexistent device, or the request was outside the capabilities of the device.
The write() function may fail if:
[EACCES]
A write was attempted on a socket and the calling process does not have appropriate privileges.
[ENETDOWN]
A write was attempted on a socket and the local network interface used to reach the destination is down.
[ENETUNREACH]
A write was attempted on a socket and no route to the network is present.
The following sections are informative.
EXAMPLES
Writing from a Buffer
The following example writes data from the buffer pointed to by buf to the file associated with the file descriptor
fd.
#include
#include
...
char buf[20];
size_t nbytes;
ssize_t bytes_written;
int fd;
...
strcpy(buf, "This is a test\n");
nbytes = strlen(buf);
bytes_written = write(fd, buf, nbytes);
...
APPLICATION USAGE
None.
RATIONALE
See also the RATIONALE section in read().
An attempt to write to a pipe or FIFO has several major characteristics:
Atomic/non-atomic: A write is atomic if the whole amount written in one operation is not interleaved with data from any
other thread. This is useful when there are multiple writers sending data to a single reader. Applications need to know how large a
write request can be expected to be performed atomically. This maximum is called {PIPE_BUF}. This volume of POSIX.1-2024 does not
say whether write requests for more than {PIPE_BUF} bytes are atomic, but requires that writes of {PIPE_BUF} or fewer bytes shall
be atomic.
Blocking/immediate: Blocking is only possible with O_NONBLOCK clear. If there is enough space for all the data requested
to be written immediately, the implementation should do so. Otherwise, the calling thread may block; that is, pause until enough
space is available for writing. The effective size of a pipe or FIFO (the maximum amount that can be written in one operation
without blocking) may vary dynamically, depending on the implementation, so it is not possible to specify a fixed value for it.
Complete/partial/deferred: A write request:
int fildes;
size_t nbyte;
ssize_t ret;
char *buf;
ret = write(fildes, buf, nbyte);
may return:
Complete
ret=nbyte
Partial
ret{PIPE_BUF}), this volume of
POSIX.1-2024 does not guarantee atomicity, even if ret{PIPE_BUF} and perhaps do later
writes with a smaller value, on the assumption that the effective size of the pipe or FIFO may have decreased.
Partial and deferred writes are only possible with O_NONBLOCK set.
The relations of these properties are shown in the following tables:
Write to a Pipe or FIFO with O_NONBLOCK clear
Immediately Writable:
None
Some
nbyte
nbyte{PIPE_BUF}
Blocking nbyte
Blocking nbyte
Blocking nbyte
If the O_NONBLOCK flag is clear, a write request shall block if the amount writable immediately is less than that
requested. If the flag is set (by fcntl()), a write request shall never block.
Write to a Pipe or FIFO with O_NONBLOCK set
Immediately Writable:
None
Some
nbyte
nbyte{PIPE_BUF}
-1, [EAGAIN]
, ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Realtime Extension and the POSIX Threads Extension.
Large File Summit extensions are added.
The pwrite() function is added.
Issue 6
The DESCRIPTION states that the write() function does not block the thread. Previously this said "process" rather than
"thread".
The DESCRIPTION and ERRORS sections are updated so that references to STREAMS are marked as part of the XSI STREAMS
Option Group.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX
Specification:
The DESCRIPTION now states that if write() is interrupted by a signal after it has successfully written
some data, it returns the number of bytes written. In the POSIX.1-1988 standard, it was optional whether write() returned
the number of bytes written, or whether it returned -1 with errno set to [EINTR]. This is a FIPS requirement.
The following changes are made to support large files:
For regular files, no data transfer occurs past the offset maximum established in the open file description
associated with the fildes.
A second [EFBIG] error condition is added.
The [EIO] error condition is added.
The [EPIPE] error condition is added for when a pipe has only one end open.
The [ENXIO] optional error condition is added.
Text referring to sockets is added to the DESCRIPTION.
The following changes were made to align with the IEEE P1003.1a draft standard:
The effect of reading zero bytes is clarified.
The DESCRIPTION is updated for alignment with IEEE Std 1003.1j-2000 by specifying that write()
results are unspecified for typed memory objects.
The following error conditions are added for operations on sockets: [EAGAIN], [EWOULDBLOCK], [ECONNRESET],
[ENOTCONN], and [EPIPE].
The [EIO] error is made optional.
The [ENOBUFS] error is added for sockets.
The following error conditions are added for operations on sockets: [EACCES], [ENETDOWN], and [ENETUNREACH].
The writev() function is split out into a separate reference
page.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/146 is applied, updating text in the ERRORS section
from "a SIGPIPE signal is generated to the calling process" to "a SIGPIPE signal shall also be sent to the thread".
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/147 is applied, making a correction to the
RATIONALE.
Issue 7
The pwrite() function is moved from the XSI option to the Base.
Functionality relating to the XSI STREAMS option is marked obsolescent.
SD5-XSH-ERN-160 is applied, updating the DESCRIPTION to clarify the requirements for the pwrite() function,
and to change the use of the phrase "file pointer" to "file offset".
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0742 [219], XSH/TC1-2008/0743 [215], XSH/TC1-2008/0744 [79],
and XSH/TC1-2008/0745 [215] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0401 [676,710] and XSH/TC2-2008/0402 [966] are applied.
Issue 8
Austin Group Defect 308 is applied, clarifying the handling of [EFBIG] errors.
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
Austin Group Defect 1430 is applied, clarifying that requirements relating to data interleaving on pipes and FIFOs
apply to write operations in other threads, not just other processes, and changing some uses of "pipe" to "pipe or FIFO".
Austin Group Defect 1669 is applied, removing XSI shading from part of the [EFBIG] error relating to the file size
limit for the process.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/tcsetpgrp.html =====
tcsetpgrp
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
tcsetpgrp — set the foreground process group ID
SYNOPSIS
#include
int tcsetpgrp(int fildes, pid_t pgid_id);
DESCRIPTION
If the process has a controlling terminal, tcsetpgrp() shall set the foreground process group ID associated with the
terminal to pgid_id. The application shall ensure that the file associated with fildes is the controlling terminal of
the calling process and the controlling terminal is currently associated with the session of the calling process. The application
shall ensure that the value of pgid_id matches a process group ID of a process in the same session as the calling
process.
Attempts to use tcsetpgrp() from a process which is a member of a background process group on a fildes associated
with its controlling terminal shall cause the process group to be sent a SIGTTOU signal. If the calling thread is blocking SIGTTOU
signals or the process is ignoring SIGTTOU signals, the process shall be allowed to perform the operation, and no signal is
sent.
RETURN VALUE
Upon successful completion, 0 shall be returned. Otherwise, -1 shall be returned and errno set to indicate the error.
ERRORS
The tcsetpgrp() function shall fail if:
[EBADF]
The fildes argument is not a valid file descriptor.
[EINTR]
A signal interrupted tcsetpgrp().
[EINVAL]
This implementation does not support the value in the pgid_id argument.
[EIO]
The process group of the writing process is orphaned, the calling thread is not blocking SIGTTOU, and the process is not
ignoring SIGTTOU.
[ENOTTY]
The calling process does not have a controlling terminal, or the file is not the controlling terminal, or the controlling
terminal is no longer associated with the session of the calling process.
[EPERM]
The value of pgid_id is a value supported by the implementation, but does not match the process group ID of a process in
the same session as the calling process.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
tcgetpgrp()
XBD ,
CHANGE HISTORY
First released in Issue 3. Included for alignment with the POSIX.1-1988 standard.
Issue 6
In the SYNOPSIS, the inclusion of  is no longer
required.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The requirement to include  has been removed. Although
was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.
In the DESCRIPTION and ERRORS sections, text previously conditional on _POSIX_JOB_CONTROL is now mandated. This is a FIPS
requirement.
The normative text is updated to avoid use of the term "must" for application requirements.
The Open Group Corrigendum U047/4 is applied.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0655 [79] and XSH/TC1-2008/0656 [79] are applied.
Issue 8
Austin Group Defect 1126 is applied, adding the [EINTR] error.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/closelog.html =====
closelog
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
closelog, openlog, setlogmask, syslog — control system log
SYNOPSIS
[XSI]  #include
void closelog(void);
void openlog(const char *ident, int logopt, int facility);
int setlogmask(int maskpri);
void syslog(int priority, const char *message, ... /* arguments */);
DESCRIPTION
The syslog() function shall send a message to an implementation-defined logging facility, which may log it in an
implementation-defined system log, write it to the system console, forward it to a list of users, or forward it to the logging
facility on another host over the network. The logged message shall include a message header and a message body. The message header
contains at least a timestamp and a tag string.
The message body is generated from the message and following arguments in the same manner as if these were arguments to
printf(), except that the additional conversion specification %m shall be
recognized; it shall convert no arguments, shall cause the output of the error message string associated with the value of
errno on entry to syslog(), and may be mixed with argument specifications of the "%n$" form.
If a complete conversion specification with the m conversion specifier character is not just %m, the behavior is
undefined. A trailing  may be added if needed.
Values of the priority argument are formed by OR'ing together a severity-level value and an optional facility value. If
no facility value is specified, the current default facility value is used.
Possible values of severity level include:
LOG_EMERG
A panic condition.
LOG_ALERT
A condition that should be corrected immediately, such as a corrupted system database.
LOG_CRIT
Critical conditions, such as hard device errors.
LOG_ERR
Errors.
LOG_WARNING
Warning messages.
LOG_NOTICE
Conditions that are not error conditions, but that may require special handling.
LOG_INFO
Informational messages.
LOG_DEBUG
Messages that contain information normally of use only when debugging a program.
The facility indicates the application or system component generating the message. Possible facility values include:
LOG_USER
Messages generated by arbitrary processes. This is the default facility identifier if none is specified.
LOG_LOCAL0
Reserved for local use.
LOG_LOCAL1
Reserved for local use.
LOG_LOCAL2
Reserved for local use.
LOG_LOCAL3
Reserved for local use.
LOG_LOCAL4
Reserved for local use.
LOG_LOCAL5
Reserved for local use.
LOG_LOCAL6
Reserved for local use.
LOG_LOCAL7
Reserved for local use.
The openlog() function shall set process attributes that affect subsequent calls to syslog(). The ident
argument is a a pointer to a null-terminated identifier that shall be prepended (without the null terminator) to every message. The
application shall ensure that the string pointed to by ident remains valid during the syslog() calls that will
prepend this identifier; however, it is unspecified whether changes made to the string will change the identifier prepended by
later syslog() calls. The logopt argument indicates logging options. Values for logopt are constructed by a
bitwise-inclusive OR of zero or more of the following:
LOG_PID
Log the process ID with each message. This is useful for identifying specific processes.
LOG_CONS
Write messages to the system console if they cannot be sent to the logging facility. The syslog() function ensures that
the process does not acquire the console as a controlling terminal in the process of writing the message.
LOG_NDELAY
Open the connection to the logging facility immediately. Normally the open is delayed until the first message is logged. This
is useful for programs that need to manage the order in which file descriptors are allocated.
LOG_ODELAY
Delay open until syslog() is called.
LOG_NOWAIT
Do not wait for child processes that may have been created during the course of logging the message. This option should be used
by processes that enable notification of child termination using SIGCHLD, since syslog() may otherwise block waiting for a
child whose exit status has already been collected.
The facility argument encodes a default facility to be assigned to all messages that do not have an explicit facility
already encoded. The initial default facility is LOG_USER.
The openlog() and syslog() functions may allocate a file descriptor. It is not necessary to call openlog()
prior to calling syslog(). If a file descriptor is allocated, the FD_CLOEXEC flag shall be set; see .
The closelog() function shall close any open file descriptors allocated by previous calls to openlog() or
syslog().
The setlogmask() function shall set the log priority mask for the current process to maskpri and return the
previous mask. If the maskpri argument is 0, the current log mask is not modified. Calls by the current process to
syslog() with a priority not set in maskpri shall be rejected. The default log mask allows all priorities to be
logged. A call to openlog() is not required prior to calling setlogmask().
The LOG_MASK(pri) and LOG_UPTO(pri) macros can be used to ensure a value or range of severity levels is properly
encoded for the setlogmask() maskpri argument in a portable manner. The masks produced by these macros can be OR'ed
or AND'ed with other priority masks (for example,
LOG_UPTO(LOG_WARNING) | LOG_MASK(LOG_DEBUG)
and
LOG_UPTO(LOG_DEBUG) & ~((LOG_MASK(LOG_NOTICE) | LOG_MASK(LOG_INFO))
would produce the same priority mask).
Symbolic constants for use as values of the logopt, facility, priority, and maskpri arguments are
defined in the  header.
RETURN VALUE
The setlogmask() function shall return the previous log priority mask. The closelog(), openlog(), and
syslog() functions shall not return a value.
ERRORS
The openlog() and syslog() functions may fail if:
[EMFILE]
All file descriptors available to the process are currently open.
[ENFILE]
The maximum allowable number of files is currently open in the system.
The following sections are informative.
EXAMPLES
Using openlog()
The following example causes subsequent calls to syslog() to log the process ID with each message, and to write messages
to the system console if they cannot be sent to the logging facility.
#include
char *ident = "Process demo";
int logopt = LOG_PID | LOG_CONS;
int facility = LOG_USER;
...
openlog(ident, logopt, facility);
Using setlogmask()
The following example causes subsequent calls to syslog() to accept error messages, and to reject all other messages.
#include
int result;
int mask = LOG_MASK (LOG_ERR);
...
result = setlogmask(mask);
Using syslog
The following example sends the message "This is a message" to the default logging facility, marking the message as an
error message generated by random processes.
#include
char *message = "This is a message";
int priority = LOG_ERR | LOG_USER;
...
syslog(priority, message);
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
fprintf()
XBD ,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/13 is applied, correcting the EXAMPLES section.
Issue 8
Austin Group Defect 368 is applied, adding a requirement for FD_CLOEXEC to be set if a file descriptor is allocated, and adding
the [EMFILE] and [ENFILE] errors.
Austin Group Defect 1033 is applied, adding the LOG_UPTO macro.
Austin Group Defect 1244 is applied, clarifying the handling of the ident argument.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/lstat.html =====
fstatat
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fstatat, lstat, stat — get file status
SYNOPSIS
[OH] #include
#include
int fstatat(int fd, const char *restrict path,
struct stat *restrict buf, int flag);
int lstat(const char *restrict path, struct stat *restrict buf);
int stat(const char *restrict path, struct stat *restrict buf);
DESCRIPTION
The stat() function shall obtain information about the named file and write it to the area pointed to by the buf
argument. The path argument points to a pathname naming a file. Read, write, or execute permission of the named file is not
required. An implementation that provides additional or alternate file access control mechanisms may, under implementation-defined
conditions, cause stat() to fail. In particular, the system may deny the existence of the file specified by path.
If the named file is a symbolic link, the stat() function shall continue pathname resolution using the contents of the
symbolic link, and shall return information pertaining to the resulting file if the file exists.
The buf argument is a pointer to a stat structure, as defined in the  header, into which information is placed concerning the file.
The stat() function shall update any time-related fields (as described in XBD 4.12 File Times Update), before writing into the stat structure.
[SHM]
If the named file is a shared memory object, the implementation shall update in the stat structure pointed to by the
buf argument the st_uid, st_gid, st_size, and st_mode fields, and only the S_IRUSR, S_IWUSR,
S_IRGRP, S_IWGRP, S_IROTH, and S_IWOTH file permission bits need be valid. The implementation may update other fields and flags.
[TYM]
If the named file is a typed memory object, the implementation shall update in the stat structure pointed to by the
buf argument the st_uid, st_gid, st_size, and st_mode fields, and only the S_IRUSR, S_IWUSR,
S_IRGRP, S_IWGRP, S_IROTH, and S_IWOTH file permission bits need be valid. The implementation may update other fields and flags.
For all other file types defined in this volume of POSIX.1-2024, the structure members st_mode, st_ino,
st_dev, st_uid, st_gid, st_atim, st_ctim, and st_mtim shall have meaningful values and
the value of the member st_nlink shall be set to the number of hard links to the file.
The lstat() function shall be equivalent to stat(), except when path refers to a symbolic link. In that
case lstat() shall return information about the link, while stat() shall return information about the file the link
references.
For symbolic links, the st_mode member shall contain meaningful information when used with the file type macros. The file
mode bits in st_mode are unspecified. The structure members st_ino, st_dev, st_uid, st_gid,
st_atim, st_ctim, and st_mtim shall have meaningful values and the value of the st_nlink member shall
be set to the number of hard links to the symbolic link. The value of the st_size member shall be set to the length of the
pathname contained in the symbolic link not including any terminating null byte.
The fstatat() function shall be equivalent to the stat() or lstat() function, depending on the value of
flag (see below), except in the case where path specifies a relative path. In this case the status shall be retrieved
from a file relative to the directory associated with the file descriptor fd instead of the current working directory. If
the access mode of the open file description associated with the file descriptor is not O_SEARCH, the function shall check whether
directory searches are permitted using the current permissions of the directory underlying the file descriptor. If the access mode
is O_SEARCH, the function shall not perform the check.
Values for flag are constructed by a bitwise-inclusive OR of flags from the following list, defined in :
AT_SYMLINK_NOFOLLOW
If path names a symbolic link, the status of the symbolic link is returned.
If fstatat() is passed the special value AT_FDCWD in the fd parameter, the current working directory shall be used
and the behavior shall be identical to a call to stat() or lstat() respectively, depending on whether or not the
AT_SYMLINK_NOFOLLOW bit is set in flag.
RETURN VALUE
Upon successful completion, these functions shall return 0. Otherwise, these functions shall return -1 and set errno to
indicate the error.
ERRORS
These functions shall fail if:
[EACCES]
Search permission is denied for a component of the path prefix.
[EIO]
An error occurred while reading from the file system.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOENT]
A component of path does not name an existing file or path is an empty string.
[ENOTDIR]
A component of the path prefix names an existing file that is neither a directory nor a symbolic link to a directory, or the
path argument contains at least one non- character and ends with one or more trailing  characters
and the last pathname component names an existing file that is neither a directory nor a symbolic link to a directory.
[EOVERFLOW]
The file size in bytes or the number of blocks allocated to the file or the file serial number cannot be represented correctly
in the structure pointed to by buf.
The fstatat() function shall fail if:
[EACCES]
The access mode of the open file description associated with fd is not O_SEARCH and the permissions of the directory
underlying fd do not permit directory searches.
[EBADF]
The path argument does not specify an absolute path and the fd argument is neither AT_FDCWD nor a valid file
descriptor open for reading or searching.
[ENOTDIR]
The path argument is not an absolute path and fd is a file descriptor associated with a non-directory file.
These functions may fail if:
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a
length that exceeds {PATH_MAX}.
[EOVERFLOW]
A value to be stored would overflow one of the members of the stat structure.
The fstatat() function may fail if:
[EINVAL]
The value of the flag argument is not valid.
The following sections are informative.
EXAMPLES
Obtaining File Status Information
The following example shows how to obtain file status information for a file named /home/cnd/mod1. The structure variable
buffer is defined for the stat structure.
#include
#include
#include
struct stat buffer;
int         status;
...
status = stat("/home/cnd/mod1", &buffer);
Getting Directory Information
The following example fragment gets status information for each entry in a directory. The call to the stat() function
stores file information in the stat structure pointed to by statbuf. The lines that follow the stat() call
format the fields in the stat structure for presentation to the user of the program.
#include
#include
#include
#include
#include
#include
#include
#include
#include
#include
struct dirent  *dp;
struct stat     statbuf;
struct passwd  *pwd;
struct group   *grp;
struct tm      *tm;
char            datestring[256];
...
/* Loop through directory entries. */
while ((dp = readdir(dir)) != NULL) {
/* Get entry's information. */
if (stat(dp->d_name, &statbuf) == -1)
continue;
/* Print out type, permissions, and number of links. */
printf("%10.10s", mode_string(statbuf.st_mode));
printf(" %4ju", (uintmax_t)statbuf.st_nlink);
/* Print out owner's name if it is found using getpwuid(). */
if ((pwd = getpwuid(statbuf.st_uid)) != NULL)
printf(" %-8.8s", pwd->pw_name);
else
printf(" %-8ju", (uintmax_t)statbuf.st_uid);
/* Print out group name if it is found using getgrgid(). */
if ((grp = getgrgid(statbuf.st_gid)) != NULL)
printf(" %-8.8s", grp->gr_name);
else
printf(" %-8ju", (uintmax_t)statbuf.st_gid);
/* Print size of file. */
printf(" %9jd", (intmax_t)statbuf.st_size);
tm = localtime(&statbuf.st_mtime);
/* Get localized date string. */
strftime(datestring, sizeof(datestring), nl_langinfo(D_T_FMT), tm);
printf(" %s %s\n", datestring, dp->d_name);
}
Obtaining Symbolic Link Status Information
The following example shows how to obtain status information for a symbolic link named /modules/pass1. The structure
variable buffer is defined for the stat structure. If the path argument specified the pathname for the file
pointed to by the symbolic link (/home/cnd/mod1), the results of calling the function would be the same as those returned by
a call to the stat() function.
#include
struct stat buffer;
int status;
...
status = lstat("/modules/pass1", &buffer);
APPLICATION USAGE
None.
RATIONALE
The intent of the paragraph describing "additional or alternate file access control mechanisms" is to allow a secure
implementation where a process with a label that does not dominate the file's label cannot perform a stat() function. This
is not related to read permission; a process with a label that dominates the file's label does not need read permission. An
implementation that supports write-up operations could fail fstat() function calls
even though it has a valid file descriptor open for writing.
The purpose of the fstatat() function is to obtain the status of files in directories other than the current working
directory without exposure to race conditions. Any part of the path of a file could be changed in parallel to a call to
stat(), resulting in unspecified behavior. By opening a file descriptor for the target directory and using the
fstatat() function it can be guaranteed that the file for which status is returned is located relative to the desired
directory.
FUTURE DIRECTIONS
None.
SEE ALSO
access(), chmod(),
fdopendir(), fstat(), mknod(), readlink(), symlink()
XBD 4.12 File Times Update, , ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
Large File Summit extensions are added.
Issue 6
In the SYNOPSIS, the optional include of the  header is
removed.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The requirement to include  has been removed. Although
was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.
The [EIO] mandatory error condition is added.
The [ELOOP] mandatory error condition is added.
The [EOVERFLOW] mandatory error condition is added. This change is to support large files.
The [ENAMETOOLONG] and the second [EOVERFLOW] optional error conditions are added.
The following changes were made to align with the IEEE P1003.1a draft standard:
Details are added regarding the treatment of symbolic links.
The [ELOOP] optional error condition is added.
The normative text is updated to avoid use of the term "must" for application requirements.
The restrict keyword is added to the stat() prototype for alignment with the ISO/IEC 9899:1999 standard.
Issue 7
Austin Group Interpretation 1003.1-2001 #143 is applied.
XSH-SD5-ERN-161 is applied, updating the DESCRIPTION to clarify to which file types st_nlink applies.
The fstatat() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 2.
Changes are made related to support for finegrained timestamps.
The lstat() function is now required to return meaningful data for symbolic links in all stat structure fields,
except for the permission bits of st_mode.
Changes are made to allow a directory to be opened for searching.
The [ENOTDIR] error condition is clarified to cover the condition where the last component of a pathname exists but is not a
directory or a symbolic link to a directory.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0198 [461], XSH/TC1-2008/0199 [324], XSH/TC1-2008/0200 [278],
XSH/TC1-2008/0201 [278], and XSH/TC1-2008/0202 [291] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0136 [591], XSH/TC2-2008/0137 [817], XSH/TC2-2008/0138 [817], and
XSH/TC2-2008/0139 [889] are applied.
Issue 8
Austin Group Defect 1380 is applied, changing text using the term "link" in line with its updated definition.
Austin Group Defect 1409 is applied, changing the EXAMPLES section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_barrier_destroy.html =====
pthread_barrier_destroy
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_barrier_destroy, pthread_barrier_init — destroy and initialize a barrier object
SYNOPSIS
#include
int pthread_barrier_destroy(pthread_barrier_t *barrier);
int pthread_barrier_init(pthread_barrier_t *restrict barrier,
const pthread_barrierattr_t *restrict attr, unsigned
count);
DESCRIPTION
The pthread_barrier_destroy() function shall destroy the barrier referenced by barrier and release any resources
used by the barrier. The effect of subsequent use of the barrier is undefined until the barrier is reinitialized by another call to
pthread_barrier_init(). An implementation may use this function to set barrier to an invalid value. The results are
undefined if pthread_barrier_destroy() is called when any thread is blocked on the barrier, or if this function is called
with an uninitialized barrier.
The pthread_barrier_init() function shall allocate any resources required to use the barrier referenced by barrier
and shall initialize the barrier with attributes referenced by attr. If attr is NULL, the default barrier attributes
shall be used; the effect is the same as passing the address of a default barrier attributes object. The results are undefined if
pthread_barrier_init() is called when any thread is blocked on the barrier (that is, has not returned from the pthread_barrier_wait() call). The results are undefined if a barrier is used
without first being initialized. The results are undefined if pthread_barrier_init() is called specifying an already
initialized barrier.
The count argument specifies the number of threads that have to call pthread_barrier_wait() before any of them successfully return from the call.
The value specified by count needs to be greater than zero.
If the pthread_barrier_init() function fails, the barrier shall not be initialized and the contents of barrier are
undefined.
See 2.9.9 Synchronization Object Copies and Alternative Mappings
for further requirements.
RETURN VALUE
Upon successful completion, these functions shall return zero; otherwise, an error number shall be returned to indicate the
error.
ERRORS
The pthread_barrier_init() function shall fail if:
[EAGAIN]
The system lacks the necessary resources to initialize another barrier.
[EINVAL]
The value specified by count is equal to zero.
[ENOMEM]
Insufficient memory exists to initialize the barrier.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
If an implementation detects that the value specified by the barrier argument to pthread_barrier_destroy() does
not refer to an initialized barrier object, it is recommended that the function should fail and report an [EINVAL] error.
If an implementation detects that the value specified by the attr argument to pthread_barrier_init() does not
refer to an initialized barrier attributes object, it is recommended that the function should fail and report an [EINVAL]
error.
If an implementation detects that the value specified by the barrier argument to pthread_barrier_destroy() or
pthread_barrier_init() refers to a barrier that is in use (for example, in a pthread_barrier_wait() call) by another thread, or detects that the value
specified by the barrier argument to pthread_barrier_init() refers to an already initialized barrier object, it is
recommended that the function should fail and report an [EBUSY] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_barrier_wait()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1j-2000.
Issue 7
The pthread_barrier_destroy() and pthread_barrier_init() functions are moved from the Barriers option to the
Base.
The [EINVAL] error for an uninitialized barrier object and an uninitialized barrier attributes object is removed; this condition
results in undefined behavior.
The [EBUSY] error for a barrier that is in use or an already initialized barrier object is removed; this condition results in
undefined behavior.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0266 [972] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/creall.html =====
creal
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
creal, crealf, creall — complex real functions
SYNOPSIS
#include
double creal(double complex z);
float crealf(float complex z);
long double creall(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the real part of z.
RETURN VALUE
These functions shall return the real part value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
For a variable z of type complex:
z == creal(z) + cimag(z)*I
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
carg(), cimag(), conj(), cproj()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/catanh.html =====
catanh
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
catanh, catanhf, catanhl — complex arc hyperbolic tangent functions
SYNOPSIS
#include
double complex catanh(double complex z);
float complex catanhf(float complex z);
long double complex catanhl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex arc hyperbolic tangent of z, with branch cuts outside the interval
[-1, +1] along the real axis.
RETURN VALUE
These functions shall return the complex arc hyperbolic tangent value, in the range of a strip mathematically unbounded along
the real axis and in the interval [-iℼ/2, +iℼ/2] along the imaginary axis.
[MXC]
catanh(conj(z)), catanhf(conjf(z)), and catanhl(conjl(z)) shall
return exactly the same value as conj(catanh(z)), conjf(catanhf(z)), and
conjl(catanhl(z)), respectively, and catanh(-z), catanhf(-z), and
catanhl(-z) shall return exactly the same value as -catanh(z), -catanhf(z), and
-catanhl(z), respectively, including for the special values of z below.
If z is +0 + i0, +0 + i0 shall be returned.
If z is +0 + iNaN, +0 + iNaN shall be returned.
If z is +1 + i0, +Inf + i0 shall be returned and the divide-by-zero floating-point exception shall be
raised.
If z is x + iInf where x is positive-signed and finite, +0 + iℼ/2 shall be returned.
If z is x + iNaN where x is non-zero and finite, NaN + iNaN shall be returned and the invalid
floating-point exception may be raised.
If z is +Inf + iy where y is positive-signed and finite, +0 + iℼ/2 shall be returned.
If z is +Inf + iInf, +0 + iℼ/2 shall be returned.
If z is +Inf + iNaN, +0 + iNaN shall be returned.
If z is NaN + iy where y is finite, NaN + iNaN shall be returned and the invalid floating-point
exception may be raised.
If z is NaN + iInf, ±0 + iℼ/2 shall be returned; the sign of the real part of the result is
unspecified.
If z is NaN + iNaN, NaN + iNaN shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
ctanh()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/syslog.html =====
closelog
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
closelog, openlog, setlogmask, syslog — control system log
SYNOPSIS
[XSI]  #include
void closelog(void);
void openlog(const char *ident, int logopt, int facility);
int setlogmask(int maskpri);
void syslog(int priority, const char *message, ... /* arguments */);
DESCRIPTION
The syslog() function shall send a message to an implementation-defined logging facility, which may log it in an
implementation-defined system log, write it to the system console, forward it to a list of users, or forward it to the logging
facility on another host over the network. The logged message shall include a message header and a message body. The message header
contains at least a timestamp and a tag string.
The message body is generated from the message and following arguments in the same manner as if these were arguments to
printf(), except that the additional conversion specification %m shall be
recognized; it shall convert no arguments, shall cause the output of the error message string associated with the value of
errno on entry to syslog(), and may be mixed with argument specifications of the "%n$" form.
If a complete conversion specification with the m conversion specifier character is not just %m, the behavior is
undefined. A trailing  may be added if needed.
Values of the priority argument are formed by OR'ing together a severity-level value and an optional facility value. If
no facility value is specified, the current default facility value is used.
Possible values of severity level include:
LOG_EMERG
A panic condition.
LOG_ALERT
A condition that should be corrected immediately, such as a corrupted system database.
LOG_CRIT
Critical conditions, such as hard device errors.
LOG_ERR
Errors.
LOG_WARNING
Warning messages.
LOG_NOTICE
Conditions that are not error conditions, but that may require special handling.
LOG_INFO
Informational messages.
LOG_DEBUG
Messages that contain information normally of use only when debugging a program.
The facility indicates the application or system component generating the message. Possible facility values include:
LOG_USER
Messages generated by arbitrary processes. This is the default facility identifier if none is specified.
LOG_LOCAL0
Reserved for local use.
LOG_LOCAL1
Reserved for local use.
LOG_LOCAL2
Reserved for local use.
LOG_LOCAL3
Reserved for local use.
LOG_LOCAL4
Reserved for local use.
LOG_LOCAL5
Reserved for local use.
LOG_LOCAL6
Reserved for local use.
LOG_LOCAL7
Reserved for local use.
The openlog() function shall set process attributes that affect subsequent calls to syslog(). The ident
argument is a a pointer to a null-terminated identifier that shall be prepended (without the null terminator) to every message. The
application shall ensure that the string pointed to by ident remains valid during the syslog() calls that will
prepend this identifier; however, it is unspecified whether changes made to the string will change the identifier prepended by
later syslog() calls. The logopt argument indicates logging options. Values for logopt are constructed by a
bitwise-inclusive OR of zero or more of the following:
LOG_PID
Log the process ID with each message. This is useful for identifying specific processes.
LOG_CONS
Write messages to the system console if they cannot be sent to the logging facility. The syslog() function ensures that
the process does not acquire the console as a controlling terminal in the process of writing the message.
LOG_NDELAY
Open the connection to the logging facility immediately. Normally the open is delayed until the first message is logged. This
is useful for programs that need to manage the order in which file descriptors are allocated.
LOG_ODELAY
Delay open until syslog() is called.
LOG_NOWAIT
Do not wait for child processes that may have been created during the course of logging the message. This option should be used
by processes that enable notification of child termination using SIGCHLD, since syslog() may otherwise block waiting for a
child whose exit status has already been collected.
The facility argument encodes a default facility to be assigned to all messages that do not have an explicit facility
already encoded. The initial default facility is LOG_USER.
The openlog() and syslog() functions may allocate a file descriptor. It is not necessary to call openlog()
prior to calling syslog(). If a file descriptor is allocated, the FD_CLOEXEC flag shall be set; see .
The closelog() function shall close any open file descriptors allocated by previous calls to openlog() or
syslog().
The setlogmask() function shall set the log priority mask for the current process to maskpri and return the
previous mask. If the maskpri argument is 0, the current log mask is not modified. Calls by the current process to
syslog() with a priority not set in maskpri shall be rejected. The default log mask allows all priorities to be
logged. A call to openlog() is not required prior to calling setlogmask().
The LOG_MASK(pri) and LOG_UPTO(pri) macros can be used to ensure a value or range of severity levels is properly
encoded for the setlogmask() maskpri argument in a portable manner. The masks produced by these macros can be OR'ed
or AND'ed with other priority masks (for example,
LOG_UPTO(LOG_WARNING) | LOG_MASK(LOG_DEBUG)
and
LOG_UPTO(LOG_DEBUG) & ~((LOG_MASK(LOG_NOTICE) | LOG_MASK(LOG_INFO))
would produce the same priority mask).
Symbolic constants for use as values of the logopt, facility, priority, and maskpri arguments are
defined in the  header.
RETURN VALUE
The setlogmask() function shall return the previous log priority mask. The closelog(), openlog(), and
syslog() functions shall not return a value.
ERRORS
The openlog() and syslog() functions may fail if:
[EMFILE]
All file descriptors available to the process are currently open.
[ENFILE]
The maximum allowable number of files is currently open in the system.
The following sections are informative.
EXAMPLES
Using openlog()
The following example causes subsequent calls to syslog() to log the process ID with each message, and to write messages
to the system console if they cannot be sent to the logging facility.
#include
char *ident = "Process demo";
int logopt = LOG_PID | LOG_CONS;
int facility = LOG_USER;
...
openlog(ident, logopt, facility);
Using setlogmask()
The following example causes subsequent calls to syslog() to accept error messages, and to reject all other messages.
#include
int result;
int mask = LOG_MASK (LOG_ERR);
...
result = setlogmask(mask);
Using syslog
The following example sends the message "This is a message" to the default logging facility, marking the message as an
error message generated by random processes.
#include
char *message = "This is a message";
int priority = LOG_ERR | LOG_USER;
...
syslog(priority, message);
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
fprintf()
XBD ,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/13 is applied, correcting the EXAMPLES section.
Issue 8
Austin Group Defect 368 is applied, adding a requirement for FD_CLOEXEC to be set if a file descriptor is allocated, and adding
the [EMFILE] and [ENFILE] errors.
Austin Group Defect 1033 is applied, adding the LOG_UPTO macro.
Austin Group Defect 1244 is applied, clarifying the handling of the ident argument.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/isgraph.html =====
isgraph
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
isgraph, isgraph_l — test for a visible character
SYNOPSIS
#include
int isgraph(int c);
[CX]  int isgraph_l(int c, locale_t locale);
DESCRIPTION
For isgraph(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The isgraph() [CX]   and isgraph_l()
functions shall test whether c is a character of class graph in the current locale, [CX]   or in the
locale represented by locale,  respectively; see XBD 7. Locale.
The c argument is an int, the value of which the application shall ensure is a character representable as an
unsigned char or equal to the value of the macro EOF. If the argument has any other value, the behavior is undefined.
[CX]  The
behavior is undefined if the locale argument to isgraph_l() is the special locale object LC_GLOBAL_LOCALE or is not a
valid locale object handle.
RETURN VALUE
The isgraph() [CX]   and isgraph_l()
functions shall return non-zero if c is a character with a visible representation; otherwise, they shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
To ensure applications portability, especially across natural languages, only these functions and the functions in the reference
pages listed in the SEE ALSO section should be used for character classification.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
isalnum(), isalpha(), isblank(), iscntrl(), isdigit(), islower(), isprint(), ispunct(), isspace(), isupper(), isxdigit(), setlocale(), uselocale()
XBD 7. Locale, ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
The isgraph_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0289 [302], XSH/TC1-2008/0290 [283], and XSH/TC1-2008/0291 [283] are
applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/htole64.html =====
be16toh
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
be16toh, be32toh, be64toh, htobe16, htobe32, htobe64, htole16, htole32, htole64, le16toh, le32toh, le64toh — convert
values between host and specified byte order
SYNOPSIS
#include
uint16_t be16toh(uint16_t big_endian_16bits);
uint32_t be32toh(uint32_t big_endian_32bits);
uint64_t be64toh(uint64_t big_endian_64bits);
uint16_t htobe16(uint16_t host_16bits);
uint32_t htobe32(uint32_t host_32bits);
uint64_t htobe64(uint64_t host_64bits);
uint16_t htole16(uint16_t host_16bits);
uint32_t htole32(uint32_t host_32bits);
uint64_t htole64(uint64_t host_64bits);
uint16_t le16toh(uint16_t little_endian_16bits);
uint32_t le32toh(uint32_t little_endian_32bits);
uint64_t le64toh(uint64_t little_endian_64bits);
DESCRIPTION
These functions shall convert integer values of various sizes between host representations and representations in a specified
order.
On some implementations, these functions are defined as macros.
A little-endian representation of an integer has the least significant byte stored as the first byte, with the significance of
the bytes increasing as the byte address increases. A big-endian representation has the most significant byte as the first byte,
with the significance of the bytes reducing as the byte address increases.
Note:
Network byte order is big-endian.
For example, the uint32_t value 0x01020304 is represented as the four bytes 0x04, 0x03, 0x02, 0x01 on a little-endian
host, and as 0x01, 0x02, 0x03, 0x04 on a big-endian host.
For each of the sizes 16, 32 and 64, the htobeSIZE() function shall convert from whatever order the host uses to
big-endian representation, htoleSIZE() shall convert to little-endian representation, beSIZEtoh() shall convert from
big-endian to host order, and leSIZEtoh() shall convert from little-endian to host order.
RETURN VALUE
These functions shall return an unsigned integer of the appropriate size and representation.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
#include
#include
#include
int main(int argc, char *argv[])
{
uint32_t val;
if (argc > 1) {
val = (uint32_t)strtoul(argv[1], NULL, 0);
printf("Value: %08x\n", val);
printf("As bytes:\n");
union {
uint32_t asint;
unsigned char asbytes[sizeof(uint32_t)];
} u;
printf("Little endian: ");
u.asint = htole32(val);
for (int i = 0; i  is included:
htobe32
htonl
htobe16
htons
be32toh
ntohl
be16toh
ntohs
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
htonl()
XBD ,
CHANGE HISTORY
First released in Issue 8.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/lgamma.html =====
lgamma
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
lgamma, lgammaf, lgammal, signgam — log gamma function
SYNOPSIS
#include
double lgamma(double x);
float lgammaf(float x);
long double lgammal(long double x);
[XSI]  extern int signgam;
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute
\(
\log _e \mid \Gamma(x) \mid \text { where } \Gamma(x) \text { is defined as } \int_0^{\infty} e^{-t} t^{x-1} d t \text {. }
\)
The argument \(x\) need not be a non-positive integer \( (\Gamma(x) \) is defined over the reals,
except the non-positive integers).
[XSI]
The sign of
\( \Gamma(x) \)
shall be returned in the external integer signgam. If \(x\) is NaN,
-Inf, or a negative integer, the value of signgam is unspecified.
If concurrent calls are made to these functions, the value of signgam is indeterminate.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the logarithmic gamma of \(x\).
If \(x\) is a non-positive integer, a pole error shall occur and lgamma(), lgammaf(), and lgammal()
shall return +HUGE_VAL, +HUGE_VALF, and +HUGE_VALL, respectively.
If the correct value would cause overflow, a range error shall occur and lgamma(), lgammaf(), and lgammal()
shall return ±HUGE_VAL, ±HUGE_VALF, and ±HUGE_VALL (having the same sign as the correct value), respectively.
[MX]  If
\(x\) is NaN, a NaN shall be returned.
If \(x\) is 1 or 2, +0 shall be returned.
If \(x\) is ±Inf, +Inf shall be returned.
ERRORS
These functions shall fail if:
Pole Error
The \(x\) argument is a negative integer or zero.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If
the integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the divide-by-zero floating-point exception
shall be raised.
Range Error
The result overflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If
the integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall
be raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are
independent of each other, but at least one of them must be non-zero.
If the value of signgam will be obtained after a call to lgamma(), lgammaf(), or lgammal(), in order
to ensure that the value will not be altered by another call in a different thread, applications should either restrict calls to
these functions to be from a single thread or use a lock such as a mutex or spin lock to protect a critical section starting before
the function call and ending after the value of signgam has been obtained.
RATIONALE
Earlier versions of this standard did not require lgamma(), lgammaf(), and lgammal() to be thread-safe
because signgam was a global variable. They are now required to be thread-safe to align with the ISO C standard (which,
since the introduction of threads in 2011, requires that they avoid data races), with the exception that they need not avoid data
races when storing a value in the signgam variable. Since signgam is not specified by the ISO C standard, this
exception is not a conflict with that standard.
FUTURE DIRECTIONS
None.
SEE ALSO
exp, feclearexcept, fetestexcept, isnan
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 3.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
A note indicating that this function need not be reentrant is added to the DESCRIPTION.
Issue 6
The lgamma() function is no longer marked as an extension.
The lgammaf() and lgammal() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Functionality relating to the XSI option is marked.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
The DESCRIPTION is clarified regarding the value of signgam when \(x\) is Nan, -Inf, or a negative integer.
Issue 8
Austin Group Defect 1002 is applied, reinstating the requirement for the sign of \( \Gamma(x) \) to be
returned in signgam, which had been accidentally removed in Issue 7.
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sigaltstack.html =====
sigaltstack
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sigaltstack — set and get signal alternate stack context
SYNOPSIS
[XSI]  #include
int sigaltstack(const stack_t *restrict ss, stack_t *restrict oss);
DESCRIPTION
The sigaltstack() function allows a process to define and examine the state of an alternate stack for signal handlers for
the current thread. Signals that have been explicitly declared to execute on the alternate stack shall be delivered on the
alternate stack.
If ss is not a null pointer, it points to a stack_t structure that specifies the alternate signal stack that shall
take effect upon return from sigaltstack(). The ss_flags member specifies the new stack state. If it is set to
SS_DISABLE, the stack is disabled and ss_sp and ss_size are ignored. Otherwise, the stack shall be enabled, and the
ss_sp and ss_size members specify the new address and size of the stack.
The range of addresses starting at ss_sp up to but not including ss_sp+ss_size is available to the
implementation for use as the stack. This function makes no assumptions regarding which end is the stack base and in which
direction the stack grows as items are pushed.
If oss is not a null pointer, upon successful completion it shall point to a stack_t structure that specifies the
alternate signal stack that was in effect prior to the call to sigaltstack(). The ss_sp and ss_size members
specify the address and size of that stack. The ss_flags member specifies the stack's state, and may contain one of the
following values:
SS_ONSTACK
The process is currently executing on the alternate signal stack. Attempts to modify the alternate signal stack while the
process is executing on it fail. This flag shall not be modified by processes.
SS_DISABLE
The alternate signal stack is currently disabled.
The value SIGSTKSZ is a system default specifying the number of bytes that would be used to cover the usual case when manually
allocating an alternate stack area. The value MINSIGSTKSZ is defined to be the minimum stack size for a signal handler. In
computing an alternate stack size, a program should add that amount to its stack requirements to allow for the system
implementation overhead. The constants SS_ONSTACK, SS_DISABLE, SIGSTKSZ, and MINSIGSTKSZ are defined in .
After a successful call to one of the exec functions, there are no alternate signal
stacks in the new process image.
In some implementations, a signal (whether or not indicated to execute on the alternate stack) shall always execute on the
alternate stack if it is delivered while another signal is being caught using the alternate stack.
Use of this function by library threads that are not bound to kernel-scheduled entities results in undefined behavior.
RETURN VALUE
Upon successful completion, sigaltstack() shall return 0; otherwise, it shall return -1 and set errno to indicate
the error.
ERRORS
The sigaltstack() function shall fail if:
[EINVAL]
The ss argument is not a null pointer, and the ss_flags member pointed to by ss has SS_ONSTACK or invalid
flags set.
[ENOMEM]
The size of the alternate stack area is less than MINSIGSTKSZ.
[EPERM]
An attempt was made to modify an active stack.
The following sections are informative.
EXAMPLES
Allocating Memory for an Alternate Stack
The following example illustrates a method for allocating memory for an alternate stack.
#include
...
if ((sigstk.ss_sp = malloc(SIGSTKSZ)) == NULL)
/* Error return. */
sigstk.ss_size = SIGSTKSZ;
sigstk.ss_flags = 0;
if (sigaltstack(&sigstk,(stack_t *)0)
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
The last sentence of the DESCRIPTION was included as an APPLICATION USAGE note in previous issues.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
The restrict keyword is added to the sigaltstack() prototype for alignment with the ISO/IEC 9899:1999
standard.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/58 is applied, updating the first sentence to include "for the
current thread".
Issue 8
Austin Group Defect 1187 is applied, changing the description of the [EINVAL] error.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/strspn.html =====
strspn
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
strspn — get length of a substring
SYNOPSIS
#include
size_t strspn(const char *s1, const char *s2);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The strspn() function shall compute the length (in bytes) of the maximum initial segment of the string pointed to by
s1 which consists entirely of bytes from the string pointed to by s2.
[CX]  The
strspn() function shall not change the setting of errno on valid input.
RETURN VALUE
The strspn() function shall return the computed length; no return value is reserved to indicate an error.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
strcspn()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The RETURN VALUE section is updated to indicate that strspn() returns the length of s, and not s itself as
was previously stated.
Issue 7
SD5-XSH-ERN-182 is applied.
Issue 8
Austin Group Defect 448 is applied, adding a requirement that strspn() does not change the setting of errno on
valid input.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fabsl.html =====
fabs
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fabs, fabsf, fabsl — absolute value function
SYNOPSIS
#include
double fabs(double x);
float fabsf(float x);
long double fabsl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the absolute value of their argument x,|x|.
RETURN VALUE
Upon successful completion, these functions shall return the absolute value of x.
[MX]  The
returned value shall be exact and shall be independent of the current rounding direction mode.
If x is NaN, a NaN shall be returned.
If x is ±0, +0 shall be returned.
If x is ±Inf, +Inf shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
Computing the 1-Norm of a Floating-Point Vector
This example shows the use of fabs() to compute the 1-norm of a vector defined as follows:
norm1(v) = |v[0]| + |v[1]| + ... + |v[n-1]|
where |x| denotes the absolute value of x, n denotes the vector's dimension v[i] denotes the
i-th component of v (0
double
norm1(const double v[], const int n)
{
int     i;
double  n1_v;  /* 1-norm of v */
n1_v = 0;
for (i=0; i
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The fabsf() and fabsl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/27 is applied, adding the example to the EXAMPLES section.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/posix_spawn_file_actions_init.html =====
posix_spawn_file_actions_destroy
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
posix_spawn_file_actions_destroy, posix_spawn_file_actions_init — destroy and initialize spawn file actions object
(ADVANCED REALTIME)
SYNOPSIS
[SPN]  #include
int posix_spawn_file_actions_destroy(posix_spawn_file_actions_t
*file_actions);
int posix_spawn_file_actions_init(posix_spawn_file_actions_t
*file_actions);
DESCRIPTION
The posix_spawn_file_actions_destroy() function shall destroy the object referenced by file_actions; the object
becomes, in effect, uninitialized. An implementation may cause posix_spawn_file_actions_destroy() to set the object
referenced by file_actions to an invalid value. A destroyed spawn file actions object can be reinitialized using
posix_spawn_file_actions_init(); the results of otherwise referencing the object after it has been destroyed are
undefined.
The posix_spawn_file_actions_init() function shall initialize the object referenced by file_actions to contain no
file actions for posix_spawn() or posix_spawnp() to perform.
A spawn file actions object is as defined in posix_spawn_file_actions_addclose().
The effect of initializing an already initialized spawn file actions object is undefined.
RETURN VALUE
Upon successful completion, these functions shall return zero; otherwise, an error number shall be returned to indicate the
error.
ERRORS
The posix_spawn_file_actions_init() function shall fail if:
[ENOMEM]
Insufficient memory exists to initialize the spawn file actions object.
The posix_spawn_file_actions_destroy() function may fail if:
[EINVAL]
The value specified by file_actions is invalid.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
These functions are part of the Spawn option and need not be provided on all implementations.
RATIONALE
Refer to the RATIONALE section in posix_spawn_file_actions_addclose().
FUTURE DIRECTIONS
None.
SEE ALSO
posix_spawn(), posix_spawn_file_actions_addclose()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1d-1999.
In the SYNOPSIS, the inclusion of  is no longer
required.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_barrierattr_setpshared.html =====
pthread_barrierattr_getpshared
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_barrierattr_getpshared, pthread_barrierattr_setpshared — get and set the process-shared attribute of the
barrier attributes object
SYNOPSIS
[TSH]  #include
int pthread_barrierattr_getpshared(const pthread_barrierattr_t
*restrict attr, int *restrict pshared);
int pthread_barrierattr_setpshared(pthread_barrierattr_t *attr,
int pshared);
DESCRIPTION
The pthread_barrierattr_getpshared() function shall obtain the value of the process-shared attribute from the
attributes object referenced by attr. The pthread_barrierattr_setpshared() function shall set the
process-shared attribute in an initialized attributes object referenced by attr.
The process-shared attribute is set to PTHREAD_PROCESS_SHARED to permit a barrier to be operated upon by any thread that
has access to the memory where the barrier is allocated. See 2.9.9
Synchronization Object Copies and Alternative Mappings for further requirements. The default value of the attribute shall
be PTHREAD_PROCESS_PRIVATE. Both constants PTHREAD_PROCESS_SHARED and PTHREAD_PROCESS_PRIVATE are defined in .
Additional attributes, their default values, and the names of the associated functions to get and set those attribute values are
implementation-defined.
The behavior is undefined if the value specified by the attr argument to pthread_barrierattr_getpshared() or
pthread_barrierattr_setpshared() does not refer to an initialized barrier attributes object.
RETURN VALUE
If successful, the pthread_barrierattr_getpshared() function shall return zero and store the value of the
process-shared attribute of attr into the object referenced by the pshared parameter. Otherwise, an error
number shall be returned to indicate the error.
If successful, the pthread_barrierattr_setpshared() function shall return zero; otherwise, an error number shall be
returned to indicate the error.
ERRORS
The pthread_barrierattr_setpshared() function may fail if:
[EINVAL]
The new value specified for the process-shared attribute is not one of the legal values PTHREAD_PROCESS_SHARED or
PTHREAD_PROCESS_PRIVATE.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The pthread_barrierattr_getpshared() and pthread_barrierattr_setpshared() functions are part of the Thread
Process-Shared Synchronization option and need not be provided on all implementations.
RATIONALE
If an implementation detects that the value specified by the attr argument to pthread_barrierattr_getpshared() or
pthread_barrierattr_setpshared() does not refer to an initialized barrier attributes object, it is recommended that the
function should fail and report an [EINVAL] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_barrier_destroy(), pthread_barrierattr_destroy()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1j-2000
Issue 7
The pthread_barrierattr_getpshared() and pthread_barrierattr_setpshared() functions are marked only as part of the
Thread Process-Shared Synchronization option as the Threads option is now part of the Base.
The [EINVAL] error for an uninitialized barrier attributes object is removed; this condition results in undefined behavior.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0266 [972] and XSH/TC2-2008/0267 [757] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_key_delete.html =====
pthread_key_delete
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_key_delete — thread-specific data key deletion
SYNOPSIS
#include
int pthread_key_delete(pthread_key_t key);
DESCRIPTION
The pthread_key_delete() function shall delete a thread-specific data key previously returned by pthread_key_create(). The thread-specific data values associated with key
need not be NULL at the time pthread_key_delete() is called. It is the responsibility of the application to free any
application storage or perform any cleanup actions for data structures related to the deleted key or associated thread-specific
data in any threads; this cleanup can be done either before or after pthread_key_delete() is called. Any attempt to use
key following the call to pthread_key_delete() results in undefined behavior.
The pthread_key_delete() function shall be callable from within destructor functions. No destructor functions shall be
invoked by pthread_key_delete(). Any destructor function that may have been associated with key shall no longer be
called upon thread exit.
RETURN VALUE
If successful, the pthread_key_delete() function shall return zero; otherwise, an error number shall be returned to
indicate the error.
ERRORS
The pthread_key_delete() function shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
A thread-specific data key deletion function has been included in order to allow the resources associated with an unused
thread-specific data key to be freed. Unused thread-specific data keys can arise, among other scenarios, when a dynamically loaded
module that allocated a key is unloaded.
Conforming applications are responsible for performing any cleanup actions needed for data structures associated with the key to
be deleted, including data referenced by thread-specific data values. No such cleanup is done by pthread_key_delete(). In
particular, destructor functions are not called. There are several reasons for this division of responsibility:
The associated destructor functions used to free thread-specific data at thread exit time are only guaranteed to work correctly
when called in the thread that allocated the thread-specific data. (Destructors themselves may utilize thread-specific data.) Thus,
they cannot be used to free thread-specific data in other threads at key deletion time. Attempting to have them called by other
threads at key deletion time would require other threads to be asynchronously interrupted. But since interrupted threads could be
in an arbitrary state, including holding locks necessary for the destructor to run, this approach would fail. In general, there is
no safe mechanism whereby an implementation could free thread-specific data at key deletion time.
Even if there were a means of safely freeing thread-specific data associated with keys to be deleted, doing so would require
that implementations be able to enumerate the threads with non-NULL data and potentially keep them from creating more
thread-specific data while the key deletion is occurring. This special case could cause extra synchronization in the normal case,
which would otherwise be unnecessary.
For an application to know that it is safe to delete a key, it has to know that all the threads that might potentially ever use
the key do not attempt to use it again. For example, it could know this if all the client threads have called a cleanup procedure
declaring that they are through with the module that is being shut down, perhaps by setting a reference count to zero.
If an implementation detects that the value specified by the key argument to pthread_key_delete() does not refer
to a a key value obtained from pthread_key_create() or refers to a key
that has been deleted with pthread_key_delete(), it is recommended that the function should fail and report an [EINVAL]
error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_key_create()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
The pthread_key_delete() function is marked as part of the Threads option.
Issue 7
The pthread_key_delete() function is moved from the Threads option to the Base.
The [EINVAL] error for a key value not obtained from pthread_key_create() or a key deleted with pthread_key_delete() is
removed; this condition results in undefined behavior.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/frexpl.html =====
frexp
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
frexp, frexpf, frexpl — extract significand and exponent from a double precision number
SYNOPSIS
#include
double frexp(double num, int *exp);
float frexpf(float num, int *exp);
long double frexpl(long double num, int *exp);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall break a floating-point number num into a normalized fraction and an integral power of 2. The
integer exponent shall be stored in the int object pointed to by exp; if the integer exponent is outside the range of
int, the results are unspecified.
RETURN VALUE
For finite arguments, these functions shall return the value x, such that x has a magnitude in the interval [½,1)
or 0, and num equals x times 2 raised to the power *exp.
[MX]
When the radix of the argument is a power of 2, the returned value shall be exact and shall be independent of the current rounding
direction mode.
If num is NaN, a NaN shall be returned, and the value of *exp is unspecified.
If num is ±0, ±0 shall be returned, and the value of *exp shall be 0.
If num is ±Inf, num shall be returned, and the value of *exp is unspecified.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
isnan(), ldexp(), modf()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The frexpf() and frexpl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
Austin Group Defect 1753 is applied, changing the NAME section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sendmsg.html =====
sendmsg
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sendmsg — send a message on a socket using a message structure
SYNOPSIS
#include
ssize_t sendmsg(int socket, const struct msghdr *message, int flags);
DESCRIPTION
The sendmsg() function shall send a message through a connection-mode or connectionless-mode socket. If the socket is a
connectionless-mode socket, the message shall be sent to the address specified by msghdr if no pre-specified peer address
has been set. If a peer address has been pre-specified, either the message shall be sent to the address specified in msghdr
(overriding the pre-specified peer address), or the function shall return -1 and set errno to [EISCONN]. If the socket is
connection-mode, the destination address in msghdr shall be ignored.
The sendmsg() function takes the following arguments:
socket
Specifies the socket file descriptor.
message
Points to a msghdr structure, containing both the destination address and the buffers for the outgoing message. The
length and format of the address depend on the address family of the socket. The msg_flags member is ignored.
flags
Specifies the type of message transmission. The application may specify 0 or the following flag:
MSG_EOR
Terminates a record (if supported by the protocol).
MSG_OOB
Sends out-of-band data on sockets that support out-of-bound data. The significance and semantics of out-of-band data are
protocol-specific.
MSG_NOSIGNAL
Requests not to send the SIGPIPE signal if an attempt to send is made on a stream-oriented socket that is no longer connected.
The [EPIPE] error shall still be returned.
The msg_iov and msg_iovlen fields of message specify zero or more buffers containing the data to be sent.
msg_iov points to an array of iovec structures; msg_iovlen shall be set to the dimension of this array. In
each iovec structure, the iov_base field specifies a storage area and the iov_len field gives its size in
bytes. Some of these sizes can be zero. The data from each storage area indicated by msg_iov is sent in turn.
Successful completion of a call to sendmsg() does not guarantee delivery of the message. A return value of -1 indicates
only locally-detected errors.
If space is not available at the sending socket to hold the message to be transmitted and the socket file descriptor does not
have O_NONBLOCK set, the sendmsg() function shall block until space is available or a timeout occurs (see SO_SNDTIMEO in
2.10.16 Use of Options). If space is not available at the sending
socket to hold the message to be transmitted and the socket file descriptor does have O_NONBLOCK set, the sendmsg() function
shall fail.
If the socket protocol supports broadcast and the specified address is a broadcast address for the socket protocol,
sendmsg() shall fail if the SO_BROADCAST option is not set for the socket.
The socket in use may require the process to have appropriate privileges to use the sendmsg() function.
RETURN VALUE
Upon successful completion, sendmsg() shall return the number of bytes sent. Otherwise, -1 shall be returned and
errno set to indicate the error.
ERRORS
The sendmsg() function shall fail if:
[EAGAIN] or [EWOULDBLOCK]
The socket's file descriptor is marked O_NONBLOCK and the requested operation would block. See also SO_SNDTIMEO in 2.10.16 Use of Options.
[EAFNOSUPPORT]
Addresses in the specified address family cannot be used with this socket.
[EBADF]
The socket argument is not a valid file descriptor.
[ECONNRESET]
A connection was forcibly closed by a peer.
[EINTR]
A signal interrupted sendmsg() before any data was transmitted.
[EINVAL]
The sum of the iov_len values overflows an ssize_t.
[EMSGSIZE]
The message is too large to be sent all at once (as the socket requires), or the msg_iovlen member of the msghdr
structure pointed to by message is less than or equal to 0 or is greater than {IOV_MAX}.
[ENOTCONN]
The socket is connection-mode but is not connected.
[ENOTSOCK]
The socket argument does not refer to a socket.
[EOPNOTSUPP]
The socket argument is associated with a socket that does not support one or more of the values set in
flags.
[EPIPE]
The socket is shut down for writing, or the socket is connection-mode and is no longer connected. In the latter case, and if
the socket is of type SOCK_STREAM or SOCK_SEQPACKET and the MSG_NOSIGNAL flag is not set, the SIGPIPE signal is generated to the
calling thread.
If the address family of the socket is AF_UNIX, then sendmsg() shall fail if:
[EIO]
An I/O error occurred while reading from or writing to the file system.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the pathname in the socket address.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOENT]
A component of the pathname does not name an existing file or the path name is an empty string.
[ENOTDIR]
A component of the path prefix of the pathname in the socket address names an existing file that is neither a directory nor a
symbolic link to a directory, or the pathname in the socket address contains at least one non- character and ends with
one or more trailing  characters and the last pathname component names an existing file that is neither a directory
nor a symbolic link to a directory.
The sendmsg() function may fail if:
[EACCES]
Search permission is denied for a component of the path prefix; or write access to the named socket is denied.
[EDESTADDRREQ]
The socket is not connection-mode and does not have its peer address set, and no destination address was specified.
[EHOSTUNREACH]
The destination host cannot be reached (probably because the host is down or a remote router cannot reach it).
[EIO]
An I/O error occurred while reading from or writing to the file system.
[EISCONN]
A destination address was specified and the socket is already connected.
[ENETDOWN]
The local network interface used to reach the destination is down.
[ENETUNREACH]
No route to the network is present.
[ENOBUFS]
Insufficient resources were available in the system to perform the operation.
[ENOMEM]
Insufficient memory was available to fulfill the request.
If the address family of the socket is AF_UNIX, then sendmsg() may fail if:
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the pathname in the socket address.
[ENAMETOOLONG]
The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a
length that exceeds {PATH_MAX}.
The following sections are informative.
EXAMPLES
Done.
APPLICATION USAGE
The select() and poll() functions can
be used to determine when it is possible to send more data.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
getsockopt(), poll(), pselect(), recv(), recvfrom(), recvmsg(), send(), sendto(), setsockopt(), shutdown(), socket()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
The wording of the mandatory [ELOOP] error condition is updated, and a second optional [ELOOP] error condition is added.
Issue 7
Austin Group Interpretation 1003.1-2001 #073 is applied, updating the DESCRIPTION.
Austin Group Interpretation 1003.1-2001 #143 is applied.
The MSG_NOSIGNAL flag is added from The Open Group Technical Standard, 2006, Extended API Set Part 2.
The [EPIPE] error is modified.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0544 [324] is applied.
Issue 8
Austin Group Defect 1429 is applied, clarifying the behavior on timeout by adding references to 2.10.16 Use of Options.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/log2l.html =====
log2
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
log2, log2f, log2l — compute base 2 logarithm functions
SYNOPSIS
#include
double log2(double x);
float log2f(float x);
long double log2l(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the base 2 logarithm of their argument x, log2(x).
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the base 2 logarithm of x.
If x is ±0, a pole error shall occur and log2(), log2f(), and log2l() shall return -HUGE_VAL,
-HUGE_VALF, and -HUGE_VALL, respectively.
For finite values of x that are less than 0, [MX]   or if x is -Inf,  a domain error shall occur, and [MX]   either a NaN (if supported), or   an implementation-defined value shall be returned.
[MX]  If
x is NaN, a NaN shall be returned.
If x is 1, +0 shall be returned.
If x is +Inf, x shall be returned.
ERRORS
These functions shall fail if:
Domain Error
The finite value of x is less than zero, [MX]   or x is -Inf.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
Pole Error
The value of x is zero.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the divide-by-zero floating-point exception shall
be raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), log()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/cargl.html =====
carg
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
carg, cargf, cargl — complex argument functions
SYNOPSIS
#include
double carg(double complex z);
float cargf(float complex z);
long double cargl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the argument (also called phase angle) of z, with a branch cut along the negative real
axis.
RETURN VALUE
These functions shall return the value of the argument in the interval [-ℼ, +ℼ].
[MXC]
If z is -0 ± i0, ±ℼ shall be returned.
If z is +0 ± i0, ±0 shall be returned.
If z is x ± i0 where x is negative, ±ℼ shall be returned.
If z is x ± i0 where x is positive, ±0 shall be returned.
If z is ±0 + iy where y is negative, -ℼ/2 shall be returned.
If z is ±0 + iy where y is positive, ℼ/2 shall be returned.
If z is -Inf ± iy where y is positive and finite, ±ℼ shall be returned.
If z is +Inf ± iy where y is positive and finite, ±0 shall be returned.
If z is x ± iInf where x is finite, ±ℼ/2 shall be returned.
If z is -Inf ± iInf, ±3ℼ/4 shall be returned.
If z is +Inf ± iInf, ±ℼ/4 shall be returned.
If the real or imaginary part of z is NaN, NaN shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
cimag(), conj(), cproj()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getgrnam.html =====
getgrnam
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getgrnam, getgrnam_r — search group database for a name
SYNOPSIS
#include
struct group *getgrnam(const char *name);
int getgrnam_r(const char *name, struct group *grp, char *buffer,
size_t bufsize, struct group **result);
DESCRIPTION
The getgrnam() function shall search the group database for an entry with a matching name.
The getgrnam() function need not be thread-safe.
Applications wishing to check for error situations should set errno to 0 before calling getgrnam(). If
getgrnam() returns a null pointer and errno is set to non-zero, an error occurred.
The getgrnam_r() function shall update the group structure pointed to by grp and store a pointer to that
structure at the location pointed to by result. The structure shall contain an entry from the group database with a matching
name. Storage referenced by the group structure is allocated from the memory provided with the buffer
parameter, which is bufsize bytes in size. A call to sysconf(_SC_GETGR_R_SIZE_MAX) returns either -1 without changing
errno or an initial value suggested for the size of this buffer. A null pointer is returned at the location pointed to by
result on error or if the requested entry is not found.
RETURN VALUE
The getgrnam() function shall return a pointer to a struct group with the structure defined in  with a matching entry if one is found. The getgrnam() function shall
return a null pointer if either the requested entry was not found, or an error occurred. If the requested entry was not found,
errno shall not be changed. On error, errno shall be set to indicate the error.
The application shall not modify the structure to which the return value points, nor any storage areas pointed to by pointers
within the structure. The returned pointer, and pointers within the structure, might be invalidated or the structure or the storage
areas might be overwritten by a subsequent call to getgrent(), getgrgid(), or getgrnam(). The returned pointer, and pointers within the structure,
might also be invalidated if the calling thread is terminated.
The getgrnam_r() function shall return zero on success or if the requested entry was not found and no error has occurred.
If any error has occurred, an error number shall be returned to indicate the error.
ERRORS
The getgrnam() and getgrnam_r() functions may fail if:
[EIO]
An I/O error has occurred.
[EINTR]
A signal was caught during getgrnam().
[EMFILE]
All file descriptors available to the process are currently open.
[ENFILE]
The maximum allowable number of files is currently open in the system.
The getgrnam_r() function shall fail if:
[ERANGE]
Insufficient storage was supplied via buffer and bufsize to contain the data to be referenced by the resulting
group structure.
The following sections are informative.
EXAMPLES
Note that sysconf(_SC_GETGR_R_SIZE_MAX) may return -1 if there is no hard limit on the size of the buffer needed to store
all the groups returned. This example shows how an application can allocate a buffer of sufficient size to work with
getgrnam_r().
long int initlen = sysconf(_SC_GETGR_R_SIZE_MAX);
size_t len;
if (initlen == -1)
/* Default initial length. */
len = 1024;
else
len = (size_t) initlen;
struct group result;
struct group *resultp;
char *buffer = malloc(len);
if (buffer == NULL)
...handle error...
int e;
while ((e = getgrnam_r("somegroup", &result, buffer, len, &resultp))
== ERANGE)
{
size_t newlen = 2 * len;
if (newlen ,
CHANGE HISTORY
First released in Issue 1. Derived from System V Release 2.0.
Issue 5
Normative text previously in the APPLICATION USAGE section is moved to the RETURN VALUE section.
The getgrnam_r() function is included for alignment with the POSIX Threads Extension.
A note indicating that the getgrnam() function need not be reentrant is added to the DESCRIPTION.
Issue 6
The getgrnam_r() function is marked as part of the Thread-Safe Functions option.
In the DESCRIPTION, the note about reentrancy is expanded to cover thread-safety.
In the SYNOPSIS, the optional include of the  header is
removed.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The requirement to include  has been removed. Although
was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.
In the RETURN VALUE section, the requirement to set errno on error is added.
The [EIO], [EINTR], [EMFILE], and [ENFILE] optional error conditions are added.
The APPLICATION USAGE section is updated to include a note on the thread-safe function and its avoidance of possibly using a
static data area.
IEEE PASC Interpretation 1003.1 #116 is applied, changing the description of the size of the buffer from bufsize
characters to bytes.
Issue 7
Austin Group Interpretation 1003.1-2001 #081 is applied, clarifying the RETURN VALUE section.
Austin Group Interpretation 1003.1-2001 #156 is applied.
SD5-XBD-ERN-4 is applied, changing the definition of the [EMFILE] error.
SD5-XSH-ERN-166 is applied.
The getgrnam_r() function is moved from the Thread-Safe Functions option to the Base.
A minor addition is made to the EXAMPLES section, reminding the application developer to free memory allocated as if by malloc().
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0242 [75] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0164 [808], XSH/TC2-2008/0165 [808], XSH/TC2-2008/0166 [656], and
XSH/TC2-2008/0167 [808] are applied.
Issue 8
Austin Group Defect 398 is applied, changing the [ERANGE] error from "may fail" to "shall fail".
Austin Group Defect 1570 is applied, removing extra spacing in "==".
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/isnan.html =====
isnan
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
isnan — test for a NaN
SYNOPSIS
#include
int isnan(real-floating x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The isnan() macro shall determine whether its argument value is a NaN. First, an argument represented in a format wider
than its semantic type is converted to its semantic type. Then determination is based on the type of the argument.
RETURN VALUE
The isnan() macro shall return a non-zero value if and only if its argument has a NaN value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
fpclassify(), isfinite(),
isinf(), isnormal(), signbit()
XBD
CHANGE HISTORY
First released in Issue 3.
Issue 5
The DESCRIPTION is updated to indicate the return value when NaN is not supported. This text was previously published in the
APPLICATION USAGE section.
Issue 6
Re-written for alignment with the ISO/IEC 9899:1999 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/atoi.html =====
atoi
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
atoi — convert a string to an integer
SYNOPSIS
#include
int atoi(const char *str);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The call atoi(str) shall be equivalent to:
(int) strtol(str, (char **)NULL, 10)
except that the handling of errors may differ. If the value cannot be represented, the behavior is undefined.
RETURN VALUE
The atoi() function shall return the converted value if the value can be represented.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
Converting an Argument
The following example checks for proper usage of the program. If there is an argument and the decimal conversion of this
argument (obtained using atoi()) is greater than 0, then the program has a valid number of minutes to wait for an event.
#include
#include
...
int minutes_to_event;
...
if (argc
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 8
Austin Group Defect 1541 is applied, changing the EXAMPLES section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/atomic_fetch_or.html =====
atomic_fetch_add
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
atomic_fetch_add, atomic_fetch_add_explicit, atomic_fetch_and, atomic_fetch_and_explicit, atomic_fetch_or,
atomic_fetch_or_explicit, atomic_fetch_sub, atomic_fetch_sub_explicit, atomic_fetch_xor, atomic_fetch_xor_explicit — atomically
replace the value of an object with the result of a computation
SYNOPSIS
#include
C atomic_fetch_add(volatile A *object, M operand); C
atomic_fetch_add_explicit(volatile A *object, M operand,
memory_order order); C atomic_fetch_and(volatile A
*object, M operand); C atomic_fetch_and_explicit(volatile A
*object, M operand,
memory_order order); C atomic_fetch_or(volatile A
*object, M operand); C atomic_fetch_or_explicit(volatile A
*object, M operand,
memory_order order); C atomic_fetch_sub(volatile A
*object, M operand); C atomic_fetch_sub_explicit(volatile A
*object, M operand,
memory_order order); C atomic_fetch_xor(volatile A
*object, M operand); C atomic_fetch_xor_explicit(volatile A
*object, M operand,
memory_order order);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
Implementations that define the macro __STDC_NO_ATOMICS__ need not provide the  header nor support these generic functions.
The atomic_fetch_add_explicit() generic function shall atomically replace the value pointed to by object with the
result of adding operand to this value. This operation shall be an atomic read-modify-write operation (see XBD 4.15.1 Memory Ordering). Memory shall be affected according to the value of
order.
The atomic_fetch_add() generic function shall be equivalent to atomic_fetch_add_explicit() called with
order set to memory_order_seq_cst.
The other atomic_fetch_*() generic functions shall be equivalent to atomic_fetch_add_explicit() if their name ends
with explicit, or to atomic_fetch_add() if it does not, respectively, except that they perform the computation
indicated in their name, instead of addition:
sub
subtraction
or
bitwise inclusive OR
xor
bitwise exclusive OR
and
bitwise AND
For addition and subtraction, the application shall ensure that A is an atomic integer type or an atomic pointer type and is not
atomic_bool. For the other operations, the application shall ensure that A is an atomic integer type and is not
atomic_bool.
For signed integer types, the computation shall silently wrap around on overflow; there are no undefined results. For pointer
types, the result can be an undefined address, but the computations otherwise have no undefined behavior.
RETURN VALUE
These generic functions shall return the value pointed to by object immediately before the effects.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The operation of these generic functions is nearly equivalent to the operation of the corresponding compound assignment
operators +=, -=, etc. The only differences are that the compound assignment operators are not guaranteed to
operate atomically, and the value yielded by a compound assignment operator is the updated value of the object, whereas the value
returned by these generic functions is the previous value of the atomic object.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD 4.15.1 Memory Ordering,
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/setgid.html =====
setgid
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
setgid — set-group-ID
SYNOPSIS
#include
int setgid(gid_t gid);
DESCRIPTION
If the process has appropriate privileges, setgid() shall set the real group ID, effective group ID, and the saved
set-group-ID of the calling process to gid.
If the process does not have appropriate privileges, but gid is equal to the real group ID or the saved set-group-ID,
setgid() shall set the effective group ID to gid; the real group ID and saved set-group-ID shall remain
unchanged.
The setgid() function shall not affect the supplementary group list in any way.
Any supplementary group IDs of the calling process shall remain unchanged.
RETURN VALUE
Upon successful completion, 0 is returned. Otherwise, -1 shall be returned and errno set to indicate the error.
ERRORS
The setgid() function shall fail if:
[EINVAL]
The value of the gid argument is invalid and is not supported by the implementation.
[EPERM]
The process does not have appropriate privileges and gid does not match the real group ID or the saved
set-group-ID.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
Refer to the RATIONALE section in setuid().
FUTURE DIRECTIONS
None.
SEE ALSO
exec, getegid(), geteuid(), getgid(), getresgid(), getresuid(), getuid(), setegid(), seteuid(), setregid(), setresgid(), setresuid(), setreuid(), setuid()
XBD ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
In the SYNOPSIS, the optional include of the  header is
removed.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The requirement to include  has been removed. Although
was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.
Functionality associated with _POSIX_SAVED_IDS is now mandated. This is a FIPS requirement.
The following changes were made to align with the IEEE P1003.1a draft standard:
The effects of setgid() in processes without appropriate privileges are changed.
A requirement that the supplementary group list is not affected is added.
Issue 8
Austin Group Defect 1344 is applied, adding getresgid(), getresuid(), setresgid(), and setresuid() to SEE ALSO.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/strtok_r.html =====
strtok
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
strtok, strtok_r — split string into tokens
SYNOPSIS
#include
char *strtok(char *restrict s, const char *restrict sep);
[CX]  char *strtok_r(char *restrict s, const char *restrict sep,
char **restrict state);
DESCRIPTION
For strtok(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
A sequence of calls to strtok() breaks the string pointed to by s into a sequence of tokens, each of which is
delimited by a byte from the string pointed to by sep. The first call in the sequence has s as its first argument,
and is followed by calls with a null pointer as their first argument. The separator string pointed to by sep may be
different from call to call.
The first call in the sequence searches the string pointed to by s for the first byte that is not contained in the
current separator string pointed to by sep. If no such byte is found, then there are no tokens in the string pointed to by
s and strtok() shall return a null pointer. If such a byte is found, it is the start of the first token.
The strtok() function then searches from there for a byte that is contained in the current separator string. If no
such byte is found, the current token extends to the end of the string pointed to by s, and subsequent searches for a token
shall return a null pointer. If such a byte is found, it is overwritten by a NUL character, which terminates the current token. The
strtok() function saves a pointer to the following byte, from which the next search for a token shall start.
Each subsequent call, with a null pointer as the value of the first argument, starts searching from the saved pointer and
behaves as described above.
The implementation shall behave as if no function defined in this volume of POSIX.1-2024 calls strtok().
The strtok() function need not be thread-safe; however, strtok() shall avoid data races with all other
functions.
[CX]  The
strtok_r() function shall be equivalent to strtok(), except that strtok_r() shall be thread-safe and the
argument state points to a user-provided pointer that allows strtok_r() to maintain state between calls which scan
the same string. The application shall ensure that the pointer pointed to by state is unique for each string (s)
being processed concurrently by strtok_r() calls. The application need not initialize the pointer pointed to by state
to any particular value. The implementation shall not update the pointer pointed to by state to point (directly or
indirectly) to resources, other than within the string s, that need to be freed or released by the caller.
[CX]  The
strtok() and strtok_r() functions shall not change the setting of errno on valid input.
RETURN VALUE
Upon successful completion, strtok() shall return a pointer to the first byte of a token. Otherwise, if there is no
token, strtok() shall return a null pointer.
[CX]  The
strtok_r() function shall return a pointer to the token found, or a null pointer when no token is found.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
Searching for Word Separators
The following example searches for tokens separated by  characters.
#include
...
char *token;
char line[] = "LINE TO BE SEPARATED";
char *search = " ";
/* Token will point to "LINE". */
token = strtok(line, search);
/* Token will point to "TO". */
token = strtok(NULL, search);
Find First two Fields in a Buffer
The following example uses strtok() to find two character strings (a key and data associated with that key) separated by
any combination of , , or  characters at the start of the array of characters pointed to by
buffer.
#include
...
char    *buffer;
...
struct element {
char *key;
char *data;
} e;
...
// Load the buffer...
...
// Get the key and its data...
e.key = strtok(buffer, " \t\n");
e.data = strtok(NULL, " \t\n");
// Process the rest of the contents of the buffer...
...
APPLICATION USAGE
Note that if sep is the empty string, strtok() and strtok_r() return a pointer to the remainder of the
string being tokenized.
The strtok_r() function is thread-safe and stores its state in a user-supplied buffer instead of possibly using a static
data area that may be overwritten by an unrelated call from another thread.
RATIONALE
The strtok() function searches for a separator string within a larger string. It returns a pointer to the last substring
between separator strings. This function uses static storage to keep track of the current string position between calls. The new
function, strtok_r(), takes an additional argument, state, to keep track of the current position in the string.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The strtok_r() function is included for alignment with the POSIX Threads Extension.
A note indicating that the strtok() function need not be reentrant is added to the DESCRIPTION.
Issue 6
Extensions beyond the ISO C standard are marked.
The strtok_r() function is marked as part of the Thread-Safe Functions option.
In the DESCRIPTION, the note about reentrancy is expanded to cover thread-safety.
The APPLICATION USAGE section is updated to include a note on the thread-safe function and its avoidance of possibly using a
static data area.
The restrict keyword is added to the strtok() and strtok_r() prototypes for alignment with the
ISO/IEC 9899:1999 standard.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
SD5-XSH-ERN-235 is applied, correcting an example.
The strtok_r() function is moved from the Thread-Safe Functions option to the Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0615 [177] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0350 [878] is applied.
Issue 8
Austin Group Defect 448 is applied, adding a requirement that strtok() and strtok_r() do not change the setting of
errno on valid input.
Austin Group Defect 1302 is applied, aligning the strtok() function with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_spin_lock.html =====
pthread_spin_lock
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_spin_lock, pthread_spin_trylock — lock a spin lock object
SYNOPSIS
#include
int pthread_spin_lock(pthread_spinlock_t *lock);
int pthread_spin_trylock(pthread_spinlock_t *lock);
DESCRIPTION
The pthread_spin_lock() function shall lock the spin lock referenced by lock. The calling thread shall acquire the
lock if it is not held by another thread. Otherwise, the thread shall spin (that is, shall not return from the
pthread_spin_lock() call) until the lock becomes available. The results are undefined if the calling thread holds the lock
at the time the call is made. The pthread_spin_trylock() function shall lock the spin lock referenced by lock if it
is not held by any thread. Otherwise, the function shall fail.
The results are undefined if any of these functions is called with an uninitialized spin lock.
RETURN VALUE
Upon successful completion, these functions shall return zero; otherwise, an error number shall be returned to indicate the
error.
ERRORS
The pthread_spin_lock() function may fail if:
[EDEADLK]
A deadlock condition was detected.
The pthread_spin_trylock() function shall fail if:
[EBUSY]
A thread currently holds the lock.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Applications using this function may be subject to priority inversion, as discussed in XBD 3.275 Priority Inversion.
RATIONALE
If an implementation detects that the value specified by the lock argument to pthread_spin_lock() or
pthread_spin_trylock() does not refer to an initialized spin lock object, it is recommended that the function should fail
and report an [EINVAL] error.
If an implementation detects that the value specified by the lock argument to pthread_spin_lock() refers to a spin
lock object for which the calling thread already holds the lock, it is recommended that the function should fail and report an
[EDEADLK] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_spin_destroy(), pthread_spin_unlock()
XBD 3.275 Priority Inversion, 4.15.2 Memory Synchronization,
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1j-2000.
In the SYNOPSIS, the inclusion of  is no longer
required.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/107 is applied, updating the ERRORS section so that the
[EDEADLK] error includes detection of a deadlock condition.
Issue 7
The pthread_spin_lock() and pthread_spin_trylock() functions are moved from the Spin Locks option to the Base.
The [EINVAL] error for an uninitialized spin lock object is removed; this condition results in undefined behavior.
The [EDEADLK] error for a spin lock object for which the calling thread already holds the lock is removed; this condition
results in undefined behavior.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/atomic_fetch_add.html =====
atomic_fetch_add
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
atomic_fetch_add, atomic_fetch_add_explicit, atomic_fetch_and, atomic_fetch_and_explicit, atomic_fetch_or,
atomic_fetch_or_explicit, atomic_fetch_sub, atomic_fetch_sub_explicit, atomic_fetch_xor, atomic_fetch_xor_explicit — atomically
replace the value of an object with the result of a computation
SYNOPSIS
#include
C atomic_fetch_add(volatile A *object, M operand); C
atomic_fetch_add_explicit(volatile A *object, M operand,
memory_order order); C atomic_fetch_and(volatile A
*object, M operand); C atomic_fetch_and_explicit(volatile A
*object, M operand,
memory_order order); C atomic_fetch_or(volatile A
*object, M operand); C atomic_fetch_or_explicit(volatile A
*object, M operand,
memory_order order); C atomic_fetch_sub(volatile A
*object, M operand); C atomic_fetch_sub_explicit(volatile A
*object, M operand,
memory_order order); C atomic_fetch_xor(volatile A
*object, M operand); C atomic_fetch_xor_explicit(volatile A
*object, M operand,
memory_order order);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
Implementations that define the macro __STDC_NO_ATOMICS__ need not provide the  header nor support these generic functions.
The atomic_fetch_add_explicit() generic function shall atomically replace the value pointed to by object with the
result of adding operand to this value. This operation shall be an atomic read-modify-write operation (see XBD 4.15.1 Memory Ordering). Memory shall be affected according to the value of
order.
The atomic_fetch_add() generic function shall be equivalent to atomic_fetch_add_explicit() called with
order set to memory_order_seq_cst.
The other atomic_fetch_*() generic functions shall be equivalent to atomic_fetch_add_explicit() if their name ends
with explicit, or to atomic_fetch_add() if it does not, respectively, except that they perform the computation
indicated in their name, instead of addition:
sub
subtraction
or
bitwise inclusive OR
xor
bitwise exclusive OR
and
bitwise AND
For addition and subtraction, the application shall ensure that A is an atomic integer type or an atomic pointer type and is not
atomic_bool. For the other operations, the application shall ensure that A is an atomic integer type and is not
atomic_bool.
For signed integer types, the computation shall silently wrap around on overflow; there are no undefined results. For pointer
types, the result can be an undefined address, but the computations otherwise have no undefined behavior.
RETURN VALUE
These generic functions shall return the value pointed to by object immediately before the effects.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The operation of these generic functions is nearly equivalent to the operation of the corresponding compound assignment
operators +=, -=, etc. The only differences are that the compound assignment operators are not guaranteed to
operate atomically, and the value yielded by a compound assignment operator is the updated value of the object, whereas the value
returned by these generic functions is the previous value of the atomic object.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD 4.15.1 Memory Ordering,
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/iswcntrl.html =====
iswcntrl
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
iswcntrl, iswcntrl_l — test for a control wide-character code
SYNOPSIS
#include
int iswcntrl(wint_t wc);
[CX]  int iswcntrl_l(wint_t wc, locale_t locale);
DESCRIPTION
For iswcntrl(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The iswcntrl() [CX]   and iswcntrl_l()
functions shall test whether wc is a wide-character code representing a character of class cntrl in the current
locale, [CX]   or in the locale represented by locale,
respectively; see XBD 7. Locale.
The wc argument is a wint_t, the value of which the application shall ensure is a wide-character code
corresponding to a valid character in the locale used by the function, or equal to the value of the macro WEOF. If the argument has
any other value, the behavior is undefined.
[CX]  The
behavior is undefined if the locale argument to iswcntrl_l() is the special locale object LC_GLOBAL_LOCALE or is not
a valid locale object handle.
RETURN VALUE
The iswcntrl() [CX]   and iswcntrl_l()
functions shall return non-zero if wc is a control wide-character code; otherwise, they shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
To ensure applications portability, especially across natural languages, only these functions and the functions in the reference
pages listed in the SEE ALSO section should be used for character classification.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
iswalnum(), iswalpha(),
iswctype(), iswdigit(),
iswgraph(), iswlower(),
iswprint(), iswpunct(),
iswspace(), iswupper(),
iswxdigit(), setlocale(),
uselocale()
XBD 7. Locale, ,
CHANGE HISTORY
First released in Issue 4.
Issue 5
The following change has been made in this version for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E):
The SYNOPSIS has been changed to indicate that this function and associated data types are now made visible by inclusion of the
header rather than .
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
The iswcntrl_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0318 [302], XSH/TC1-2008/0319 [283], and XSH/TC1-2008/0320 [283] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0183 [685] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/regcomp.html =====
regcomp
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
regcomp, regerror, regexec, regfree — regular expression matching
SYNOPSIS
#include
int regcomp(regex_t *restrict preg, const char *restrict pattern,
int cflags);
size_t regerror(int errcode, const regex_t *restrict preg,
char *restrict errbuf, size_t errbuf_size);
int regexec(const regex_t *restrict preg, const char *restrict string,
size_t nmatch, regmatch_t pmatch[restrict], int
eflags);
void regfree(regex_t *preg);
DESCRIPTION
These functions interpret basic and extended regular expressions as described in XBD 9. Regular Expressions.
The regex_t structure is defined in  and contains at least
the following member:
Member Type
Member Name
Description
size_t
re_nsub
Number of parenthesized subexpressions.
The regmatch_t structure is defined in  and
contains at least the following members:
Member Type
Member Name
Description
regoff_t
rm_so
Byte offset from start of string to start of substring.
regoff_t
rm_eo
Byte offset from start of string of the first character after the end of substring.
The regcomp() function shall compile the regular expression contained in the string pointed to by the
pattern argument and place the results in the structure pointed to by preg. The cflags argument is the
bitwise-inclusive OR of zero or more of the following flags, which are defined in the  header:
REG_EXTENDED
Use Extended Regular Expressions.
REG_ICASE
Perform matching in a case-insensitive manner (see XBD 9.2 Regular Expression
General Requirements).
REG_MINIMAL
Change the matching behavior for duplication symbols to the leftmost shortest possible match, and invert the behavior of the
repetition modifier '?' () to match the longest possible match instead of the shortest. Only
applicable to REG_EXTENDED regular expressions.
REG_NOSUB
Report only success/fail in regexec().
REG_NEWLINE
Change the handling of  characters, as described in the text.
The default regular expression type for pattern is a Basic Regular Expression. The application can specify
Extended Regular Expressions using the REG_EXTENDED cflags flag.
If the REG_NOSUB flag was not set in cflags, then regcomp() shall set re_nsub to the number of
parenthesized subexpressions (delimited by "\(\)" in basic regular expressions or "()" in extended regular
expressions) found in pattern.
The regexec() function compares the null-terminated string specified by string with the compiled
regular expression preg initialized by a previous call to regcomp(). If it finds a match, regexec() shall
return 0; otherwise, it shall return non-zero indicating either no match or an error. The eflags argument is the
bitwise-inclusive OR of zero or more of the following flags, which are defined in the  header:
REG_NOTBOL
The first character of the string pointed to by string is not the beginning of the line. Therefore, the
character ('^'), when taken as a special character, shall not match the beginning of
string.
REG_NOTEOL
The last character of the string pointed to by string is not the end of the line. Therefore, the
('$'), when taken as a special character, shall not match the end of string.
If nmatch is 0 or REG_NOSUB was set in the cflags argument to regcomp(), then regexec()
shall ignore the pmatch argument. Otherwise, the application shall ensure that the pmatch argument points to an array
with at least nmatch elements, and regexec() shall fill in the elements of that array with offsets of the substrings
of string that correspond to the parenthesized subexpressions of pattern: pmatch[i].rm_so shall
be the byte offset of the beginning and pmatch[i].rm_eo shall be one greater than the byte offset of the end
of substring i. (Subexpression i begins at the ith matched open parenthesis, counting from 1.) Offsets in
pmatch[0] identify the substring that corresponds to the entire regular expression. Unused elements of pmatch up to
pmatch[nmatch-1] shall be filled with -1. If there are more than nmatch subexpressions in pattern
(pattern itself counts as a subexpression), then regexec() shall still do the match, but shall record only the first
nmatch substrings.
When matching a basic or extended regular expression, any given parenthesized subexpression of pattern might
participate in the match of several different substrings of string, or it might not match any substring even though the
pattern as a whole did match. The following rules shall be used to determine which substrings to report in pmatch when
matching regular expressions:
If subexpression i in a regular expression is not contained within another subexpression, and it
participated in the match several times, then the byte offsets in pmatch[i] shall delimit the last such match.
If subexpression i is not contained within another subexpression, and it did not participate in an
otherwise successful match, the byte offsets in pmatch[i] shall be -1. A subexpression does not participate in the
match when:
'*' or "\{\}" appears immediately after the subexpression in a basic regular expression, or
'*', '?', or "{}" appears immediately after the subexpression in an extended regular expression, and the
subexpression did not match (matched 0 times)
or:
'|' is used in an extended regular expression to select this subexpression or another, and the other
subexpression matched.
If subexpression i is contained within another subexpression j, and i is not contained within
any other subexpression that is contained within j, and a match of subexpression j is reported in
pmatch[j], then the match or non-match of subexpression i reported in pmatch[i] shall be as
described in 1. and 2. above, but within the substring reported in pmatch[j] rather than the whole string. The
offsets in pmatch[i] are still relative to the start of string.
If subexpression i is contained in subexpression j, and the byte offsets in pmatch[j]
are -1, then the pointers in pmatch[i] shall also be -1.
If subexpression i matched a zero-length string, then both byte offsets in pmatch[i] shall be
the byte offset of the character or null terminator immediately following the zero-length string.
If, when regexec() is called, the locale is different from when the regular expression was compiled, the
result is undefined.
If REG_NEWLINE is not set in cflags, then a  in pattern or string shall be
treated as an ordinary character. If REG_NEWLINE is set, then  shall be treated as an ordinary character except as
follows:
A  in string shall not be matched by a  outside a bracket expression or by any
form of a non-matching list (see XBD 9. Regular Expressions).
A  ('^') in pattern, when used to specify expression anchoring (see XBD 9.3.8 BRE Expression Anchoring), shall match the zero-length string
immediately after a  in string, regardless of the setting of REG_NOTBOL.
A  ('$') in pattern, when used to specify expression anchoring, shall match the
zero-length string immediately before a  in string, regardless of the setting of REG_NOTEOL.
The regfree() function shall free any memory allocated by regcomp() associated with preg. The
regfree() function shall not modify errno if preg was previously returned by regcomp() and not yet
freed.
The following constants are defined as the minimum set of error return values, although other errors listed as
implementation extensions in  are possible:
REG_BADBR
Content of "\{\}" invalid: not a number, number too large, more than two numbers, first larger than second.
REG_BADPAT
Invalid regular expression.
REG_BADRPT
'?', '*', or '+' not preceded by valid regular expression.
REG_EBRACE
"\{\}" imbalance.
REG_EBRACK
"[]" imbalance.
REG_ECOLLATE
Invalid collating element referenced.
REG_ECTYPE
Invalid character class type referenced.
REG_EESCAPE
Trailing  character in pattern.
REG_EPAREN
"\(\)" or "()" imbalance.
REG_ERANGE
Invalid endpoint in range expression.
REG_ESPACE
Out of memory.
REG_ESUBREG
Number in "\digit" invalid or in error.
REG_NOMATCH
regexec() failed to match.
If more than one error occurs in processing a function call, any one of the possible constants may be returned, as
the order of detection is unspecified.
The regerror() function provides a mapping from error codes returned by regcomp() and
regexec() to unspecified printable strings. It generates a string corresponding to the value of the errcode argument,
which the application shall ensure is the last non-zero value returned by regcomp() or regexec() with the given value
of preg. If errcode is not such a value, the content of the generated string is unspecified.
If preg is a null pointer, but errcode is a value returned by a previous call to regexec() or
regcomp(), the regerror() still generates an error string corresponding to the value of errcode, but it might
not be as detailed under some implementations.
If the errbuf_size argument is not 0, regerror() shall place the generated string into the buffer of
size errbuf_size bytes pointed to by errbuf. If the string (including the terminating null) cannot fit in the buffer,
regerror() shall truncate the string and null-terminate the result.
If errbuf_size is 0, regerror() shall ignore the errbuf argument, and return the size of the
buffer needed to hold the generated string.
If the preg argument to regexec() or regfree() is not a compiled regular expression returned
by regcomp(), the result is undefined. A preg is no longer treated as a compiled regular expression after it is given
to regfree().
RETURN VALUE
Upon successful completion, the regcomp() function shall return 0. Otherwise, it shall return an integer value indicating
an error as described in , and the content of preg is
undefined. If a code is returned, the interpretation shall be as given in .
If regcomp() detects an invalid RE, it may return REG_BADPAT, or it may return one of the error codes that
more precisely describes the error.
Upon successful completion, the regexec() function shall return 0. Otherwise, it shall return REG_NOMATCH to
indicate no match.
Upon successful completion, the regerror() function shall return the number of bytes needed to hold the
entire generated string, including the null termination. If the return value is greater than errbuf_size, the string
returned in the buffer pointed to by errbuf has been truncated.
The regfree() function shall not return a value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
#include
/*
* Match string against the extended regular expression in
* pattern, treating errors as no match.
*
* Return 1 for match, 0 for no match.
*/
int
match(const char *string, char *pattern)
{
int    status;
regex_t    re;
if (regcomp(&re, pattern, REG_EXTENDED|REG_NOSUB) != 0) {
return(0);      /* Report error. */
}
status = regexec(&re, string, (size_t) 0, NULL, 0);
regfree(&re);
if (status != 0) {
return(0);      /* Report error. */
}
return(1);
}
The following demonstrates how the REG_NOTBOL flag could be used with regexec() to find all substrings in a
line that match a pattern supplied by a user. (For simplicity of the example, very little error checking is done.)
(void) regcomp (&re, pattern, 0);
/* This call to regexec() finds the first match on the line. */
error = regexec (&re, &buffer[0], 1, &pm, 0);
while (error == 0) {  /* While matches found. */
/* Substring found between pm.rm_so and pm.rm_eo. */
/* This call to regexec() finds the next match. */
error = regexec (&re, buffer + pm.rm_eo, 1, &pm, REG_NOTBOL);
}
APPLICATION USAGE
An application could use:
regerror(code,preg,(char *)NULL,(size_t)0)
to find out how big a buffer is needed for the generated string, malloc() a buffer to hold the string, and then call regerror() again to get the
string. Alternatively, it could allocate a fixed, static buffer that is big enough to hold most strings, and then use malloc() to allocate a larger buffer if it finds that this is too small.
To match a pattern as described in XCU 2.14 Pattern Matching
Notation, use the fnmatch() function.
RATIONALE
The regexec() function must fill in all nmatch elements of pmatch, where nmatch and pmatch
are supplied by the application, even if some elements of pmatch do not correspond to subexpressions in pattern. The
application developer should note that there is probably no reason for using a value of nmatch that is larger than
preg->re_nsub+1.
The REG_NEWLINE flag supports a use of RE matching that is needed in some applications like text editors. In such
applications, the user supplies an RE asking the application to find a line that matches the given expression. An anchor in such an
RE anchors at the beginning or end of any line. Such an application can pass a sequence of -separated lines to
regexec() as a single long string and specify REG_NEWLINE to regcomp() to get the desired behavior. The application
must ensure that there are no explicit  characters in pattern if it wants to ensure that any match occurs
entirely within a single line.
The REG_NEWLINE flag affects the behavior of regexec(), but it is in the cflags parameter to
regcomp() to allow flexibility of implementation. Some implementations will want to generate the same compiled RE in
regcomp() regardless of the setting of REG_NEWLINE and have regexec() handle anchors differently based on the setting
of the flag. Other implementations will generate different compiled REs based on the REG_NEWLINE.
The REG_ICASE flag supports the operations taken by the grep -i
option and the historical implementations of ex and vi. Including this flag will make it easier for application code to be written that does the same
thing as these utilities.
The substrings reported in pmatch[] are defined using offsets from the start of the string rather than
pointers. This allows type-safe access to both constant and non-constant strings.
The type regoff_t is used for the elements of pmatch[] to ensure that the application can represent
large arrays in memory (important for an application conforming to the Shell and Utilities volume of POSIX.1-2024).
The 1992 edition of this standard required regoff_t to be at least as wide as off_t, to facilitate
future extensions in which the string to be searched is taken from a file. However, these future extensions have not appeared. The
requirement rules out popular implementations with 32-bit regoff_t and 64-bit off_t, so it has been removed.
The standard developers rejected the inclusion of a regsub() function that would be used to do substitutions
for a matched RE. While such a routine would be useful to some applications, its utility would be much more limited than the
matching function described here. Both RE parsing and substitution are possible to implement without support other than that
required by the ISO C standard, but matching is much more complex than substituting. The only difficult part of substitution,
given the information supplied by regexec(), is finding the next character in a string when there can be multi-byte
characters. That is a much larger issue, and one that needs a more general solution.
The errno variable has not been used for error returns to avoid filling the errno name space for this
feature.
The interface is defined so that the matched substrings rm_sp and rm_ep are in a separate
regmatch_t structure instead of in regex_t. This allows a single compiled RE to be used simultaneously in several
contexts; in main() and a signal handler, perhaps, or in multiple threads of lightweight processes. (The preg
argument to regexec() is declared with type const, so the implementation is not permitted to use the structure to
store intermediate results.) It also allows an application to request an arbitrary number of substrings from an RE. The number of
subexpressions in the RE is reported in re_nsub in preg. With this change to regexec(), consideration was
given to dropping the REG_NOSUB flag since the user can now specify this with a zero nmatch argument to regexec().
However, keeping REG_NOSUB allows an implementation to use a different (perhaps more efficient) algorithm if it knows in
regcomp() that no subexpressions need be reported. The implementation is only required to fill in pmatch if
nmatch is not zero and if REG_NOSUB is not specified. Note that the size_t type, as defined in the ISO C
standard, is unsigned, so the description of regexec() does not need to address negative values of nmatch.
REG_NOTBOL was added to allow an application to do repeated searches for the same pattern in a line. If the pattern
contains a  character that should match the beginning of a line, then the pattern should only match when matched
against the beginning of the line. Without the REG_NOTBOL flag, the application could rewrite the expression for subsequent
matches, but in the general case this would require parsing the expression. The need for REG_NOTEOL is not as clear; it was added
for symmetry.
The addition of the regerror() function addresses the historical need for conforming application programs to
have access to error information more than "Function failed to compile/match your RE for unknown reasons".
This interface provides for two different methods of dealing with error conditions. The specific error codes
(REG_EBRACE, for example), defined in , allow an application to
recover from an error if it is so able. Many applications, especially those that use patterns supplied by a user, will not try to
deal with specific error cases, but will just use regerror() to obtain a human-readable error message to present to the
user.
The regerror() function uses a scheme similar to confstr() to
deal with the problem of allocating memory to hold the generated string. The scheme used by strerror() in the ISO C standard was considered unacceptable since it creates
difficulties for multi-threaded applications.
The preg argument is provided to regerror() to allow an implementation to generate a more descriptive
message than would be possible with errcode alone. An implementation might, for example, save the character offset of the
offending character of the pattern in a field of preg, and then include that in the generated message string. The
implementation may also ignore preg.
A REG_FILENAME flag was considered, but omitted. This flag caused regexec() to match patterns as described
in XCU 2.14 Pattern Matching Notation instead of REs. This service is
now provided by the fnmatch() function.
Notice that there is a difference in philosophy between the ISO POSIX-2:1993 standard and POSIX.1-2024 in how
to handle a "bad" regular expression. The ISO POSIX-2:1993 standard says that many bad constructs "produce undefined
results", or that "the interpretation is undefined". POSIX.1-2024, however, says that the interpretation of such REs is
unspecified. The term "undefined" means that the action by the application is an error, of similar severity to passing a bad
pointer to a function.
The regcomp() and regexec() functions are required to accept any null-terminated string as the
pattern argument. If the meaning of the string is "undefined", the behavior of the function is "unspecified".
POSIX.1-2024 does not specify how the functions will interpret the pattern; they might return error codes, or they might do pattern
matching in some completely unexpected way, but they should not do something like abort the process.
FUTURE DIRECTIONS
None.
SEE ALSO
fnmatch(), glob()
XBD 9. Regular Expressions, ,
XCU 2.14 Pattern Matching Notation
CHANGE HISTORY
First released in Issue 4. Derived from the ISO POSIX-2 standard.
Issue 5
Moved from POSIX2 C-language Binding to BASE.
Issue 6
In the SYNOPSIS, the optional include of the  header is
removed.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX
Specification:
The requirement to include  has been removed.
Although  was required for conforming implementations of
previous POSIX specifications, it was not required for UNIX applications.
The normative text is updated to avoid use of the term "must" for application requirements.
The REG_ENOSYS constant is removed.
The restrict keyword is added to the regcomp(), regerror(), and regexec() prototypes
for alignment with the ISO/IEC 9899:1999 standard.
Issue 7
Austin Group Interpretation 1003.1-2001 #134 is applied, clarifying that if more than one error occurs in processing a function
call, any one of the possible constants may be returned.
SD5-XBD-ERN-60 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0505 [305] is applied.
Issue 8
Austin Group Defect 385 is applied, adding a requirement that regfree() does not modify errno when passed a
pointer to a regex_t that can be freed.
Austin Group Defects 793 and 1329 are applied, adding REG_MINIMAL.
Austin Group Defect 1031 is applied, changing the description of REG_ICASE.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getentropy.html =====
getentropy
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getentropy — fill a buffer with random bytes
SYNOPSIS
#include
int getentropy(void *buffer, size_t length);
DESCRIPTION
The getentropy() function shall write length bytes of data starting at the location pointed to by buffer.
The output shall be unpredictable high quality random data, generated by a cryptographically secure pseudo-random number generator.
The maximum permitted value for the length argument is given by the {GETENTROPY_MAX} symbolic constant defined in .
A successful call to getentropy() shall always provide the requested number of bytes of entropy.
RETURN VALUE
Upon successful completion, getentropy() shall return 0; otherwise, -1 shall be returned and errno set to indicate
the error.
ERRORS
The getentropy() function shall fail if:
[EINVAL]
The value of length is greater than {GETENTROPY_MAX}.
The getentropy() function may fail if:
[ENOSYS]
The system does not provide the necessary source of entropy.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The intended use of this function is to create a seed for other pseudo-random number generators.
RATIONALE
The getentropy() function is not a cancellation point. (See 2.9.5.2 Cancellation Points.)
FUTURE DIRECTIONS
None.
SEE ALSO
drand48(), initstate(),
rand()
XBD ,
CHANGE HISTORY
First released in Issue 8.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/scandir.html =====
alphasort
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
alphasort, scandir — scan a directory
SYNOPSIS
#include
int alphasort(const struct dirent **d1, const struct dirent **d2);
int scandir(const char *dir, struct dirent ***namelist,
int (*sel)(const struct dirent *),
int (*compar)(const struct dirent **, const struct dirent **));
DESCRIPTION
The alphasort() function can be used as the comparison function for the scandir() function to sort the directory
entries, d1 and d2, into alphabetical order. Sorting happens as if by calling the strcoll() function on the d_name element of the dirent structures passed as
the two parameters. If the strcoll() function fails, the return value of
alphasort() is unspecified.
The alphasort() function shall not change the setting of errno if successful. Since no return value is reserved to
indicate an error, an application wishing to check for error situations should set errno to 0, then call alphasort(),
then check errno.
The scandir() function shall scan the directory dir, calling the function referenced by sel on each
directory entry. Entries for which the function referenced by sel returns non-zero shall be stored in strings allocated as
if by a call to malloc(), and sorted as if by a call to qsort() with the comparison function compar, except that compar need not provide
total ordering. The strings are collected in array namelist which shall be allocated as if by a call to malloc(). If sel is a null pointer, all entries shall be selected. If the comparison
function compar does not provide total ordering, the order in which the directory entries are stored is unspecified.
RETURN VALUE
Upon successful completion, the alphasort() function shall return an integer greater than, equal to, or less than 0,
according to whether the name of the directory entry pointed to by d1 is lexically greater than, equal to, or less than the
directory pointed to by d2 when both are interpreted as appropriate to the current locale. There is no return value reserved
to indicate an error.
Upon successful completion, the scandir() function shall return the number of entries in the array and a pointer to the
array through the parameter namelist. Otherwise, the scandir() function shall return -1.
ERRORS
The scandir() function shall fail if:
[EACCES]
Search permission is denied for the component of the path prefix of dir or read permission is denied for
dir.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the dir argument.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOENT]
A component of dir does not name an existing directory or dir is an empty string.
[ENOMEM]
Insufficient storage space is available.
[ENOTDIR]
A component of dir names an existing file that is neither a directory nor a symbolic link to a directory.
[EOVERFLOW]
One of the values to be returned or passed to a callback function cannot be represented correctly.
The scandir() function may fail if:
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the dir argument.
[EMFILE]
All file descriptors available to the process are currently open.
[ENAMETOOLONG]
The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a
length that exceeds {PATH_MAX}.
[ENFILE]
Too many files are currently open in the system.
The following sections are informative.
EXAMPLES
An example to print the files in the current directory:
#include
#include
#include
...
struct dirent **namelist;
int i,n;
n = scandir(".", &namelist, 0, alphasort);
if (n d_name);
free(namelist[i]);
}
}
free(namelist);
...
APPLICATION USAGE
If dir contains filenames that do not form character strings, or which contain characters outside the domain of the
collating sequence of the current locale, the alphasort() function need not provide a total ordering. This condition is not
possible if all filenames within the directory consist only of characters from the portable filename character set.
The scandir() function may allocate dynamic storage during its operation. If scandir() is forcibly terminated,
such as by longjmp() or siglongjmp() being executed by the function pointed to by sel or compar, or
by an interrupt routine, scandir() does not have a chance to free that storage, so it remains permanently allocated. A safe
way to handle interrupts is to store the fact that an interrupt has occurred, then wait until scandir() returns to act on
the interrupt.
For functions that allocate memory as if by malloc(), the application should
release such memory when it is no longer required by a call to free(). For
scandir(), this is namelist (including all of the individual strings in namelist).
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
qsort(), strcoll()
XBD
CHANGE HISTORY
First released in Issue 7.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0029 [324], XSH/TC1-2008/0030 [404], XSH/TC1-2008/0031 [393], and
XSH/TC1-2008/0032 [291] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/iswpunct.html =====
iswpunct
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
iswpunct, iswpunct_l — test for a punctuation wide-character code
SYNOPSIS
#include
int iswpunct(wint_t wc);
[CX]  int iswpunct_l(wint_t wc, locale_t locale);
DESCRIPTION
For iswpunct(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The iswpunct() [CX]   and iswpunct_l()
functions shall test whether wc is a wide-character code representing a character of class punct in the current
locale, [CX]   or in the locale represented by locale,
respectively; see XBD 7. Locale.
The wc argument is a wint_t, the value of which the application shall ensure is a wide-character code
corresponding to a valid character in the locale used by the function, or equal to the value of the macro WEOF. If the argument has
any other value, the behavior is undefined.
[CX]  The
behavior is undefined if the locale argument to iswpunct_l() is the special locale object LC_GLOBAL_LOCALE or is not
a valid locale object handle.
RETURN VALUE
The iswpunct() [CX]   and iswpunct_l()
functions shall return non-zero if wc is a punctuation wide-character code; otherwise, they shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
To ensure applications portability, especially across natural languages, only these functions and the functions in the reference
pages listed in the SEE ALSO section should be used for character classification.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
iswalnum(), iswalpha(),
iswcntrl(), iswctype(),
iswdigit(), iswgraph(),
iswlower(), iswprint(),
iswspace(), iswupper(),
iswxdigit(), setlocale(),
uselocale()
XBD 7. Locale, ,
CHANGE HISTORY
First released in Issue 4.
Issue 5
The following change has been made in this version for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E):
The SYNOPSIS has been changed to indicate that this function and associated data types are now made visible by inclusion of the
header rather than .
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7