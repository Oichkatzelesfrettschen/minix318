SYNOPSIS
[CX]  #include
char *strdup(const char *s);
char *strndup(const char *s, size_t size);
DESCRIPTION
The strdup() function shall return a pointer to a new string, which is a duplicate of the string pointed to by s.
The returned pointer can be passed to free(). A null pointer is returned if the new
string cannot be created.
The strndup() function shall be equivalent to the strdup() function, duplicating the provided s in a new
block of memory allocated as if by using malloc(), with the exception being that
strndup() copies at most size bytes from the array s into the newly allocated memory, terminating the new
string with a null byte. If s contains a null terminator within the first size bytes, all bytes in s up to and
including the null terminator shall be copied into the new memory buffer. The strndup() function shall not examine more than
size bytes of the array pointed to by s. The newly created string shall always be properly terminated.
RETURN VALUE
The strdup() function shall return a pointer to a new string on success. Otherwise, it shall return a null pointer and
set errno to indicate the error.
Upon successful completion, the strndup() function shall return a pointer to the newly allocated memory containing the
duplicated string. Otherwise, it shall return a null pointer and set errno to indicate the error.
ERRORS
These functions shall fail if:
[ENOMEM]
Storage space available is insufficient.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
For functions that allocate memory as if by malloc(), the application should
release such memory when it is no longer required by a call to free(). For
strdup() and strndup(), this is the return value.
Implementations are free to malloc() a buffer containing either (size + 1)
bytes or (strnlen( s, size) + 1) bytes. Applications should not assume that strndup() will allocate
(size + 1) bytes when strlen( s) is smaller than size.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
free(), wcsdup()
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 7
Austin Group Interpretation 1003.1-2001 #044 is applied, changing the "may fail" [ENOMEM] error to become a "shall fail"
error.
The strdup() function is moved from the XSI option to the Base.
The strndup() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 1.
The APPLICATION USAGE section is updated to clarify that memory is allocated as if by malloc().
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0338 [738] is applied.
Issue 8
Austin Group Defect 1019 is applied, clarifying that the strndup() argument s need not point to a null-terminated
string.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/execle.html =====
exec
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
environ, execl, execle, execlp, execv, execve, execvp, fexecve — execute a file
SYNOPSIS
#include
extern char **environ;
int execl(const char *path, const char *arg0, ... /*, (char *)0 */);
int execle(const char *path, const char *arg0, ... /*,
(char *)0, char *const envp[]*/);
int execlp(const char *file, const char *arg0, ... /*, (char *)0 */);
int execv(const char *path, char *const argv[]);
int execve(const char *path, char *const argv[], char *const envp[]);
int execvp(const char *file, char *const argv[]);
int fexecve(int fd, char *const argv[], char *const envp[]);
DESCRIPTION
The exec family of functions shall replace the current process image with a new process image. The new image shall be
constructed from a regular, executable file called the new process image file. There shall be no return from a successful
exec, because the calling process image is overlaid by the new process image.
The fexecve() function shall be equivalent to the execve() function except that the file to be executed is
determined by the file descriptor fd instead of a pathname. The file offset of fd is ignored.
When a C-language program is executed as a result of a call to one of the exec family of functions, it shall be entered
as a C-language function call as follows:
int main (int argc, char *argv[]);
where argc is the argument count and argv is an array of character pointers to the arguments themselves. In
addition, the following variable, which needs to be declared by the user if it is to be used directly:
extern char **environ;
is initialized as a pointer to an array of character pointers to the environment strings. The argv and environ
arrays are each terminated by a null pointer. The null pointer terminating the argv array is not counted in argc.
Applications can change the entire environment in a single operation by assigning the environ variable to point to an
array of character pointers to the new environment strings. After assigning a new value to environ, applications should not
rely on the new environment strings remaining part of the environment, as a call to getenv(), secure_getenv(),
[XSI]
putenv(),  setenv(), unsetenv(), or any function that is
dependent on an environment variable may, on noticing that environ has changed, copy the environment strings to a new array
and assign environ to point to it.
Any application that directly modifies the pointers to which the environ variable points has undefined behavior.
Conforming multi-threaded applications shall not use the environ variable to access or modify any environment variable
while any other thread is concurrently modifying any environment variable. A call to any function dependent on any environment
variable shall be considered a use of the environ variable to access that environment variable.
The arguments specified by a program with one of the exec functions shall be passed on to the new process image in the
corresponding main() arguments.
For the execl(), execle(), execv(), and execve() functions, the argument path points to a
pathname that identifies the new process image file.
For the execlp() and execvp() functions, the argument file is used to construct a pathname that identifies
the new process image file. If the file argument contains a  character, the file argument shall be used
as the pathname for this file. Otherwise, the path prefix for this file is obtained by a search of the directories passed as the
environment variable PATH (see XBD 8. Environment Variables). If
this environment variable is not present, the results of the search are implementation-defined.
There are two distinct ways in which the contents of the process image file may cause the execution to fail, distinguished by
the setting of errno to either [ENOEXEC] or [EINVAL] (see the ERRORS section). In the cases where the other members of the
exec family of functions would fail and set errno to [ENOEXEC], the execlp() and execvp() functions
shall execute a command interpreter and the environment of the executed command shall be as if the process invoked the sh utility using execl() as follows:
execl(, , file, , (char *)0);
where  is an unspecified pathname for the sh utility,
is an unspecified string, file is the process image file, and where  is zero or more
parameters corresponding to any initial non-null arguments passed after arg0 for execlp() or to any initial non-null
members of argv starting at argv[1] for execvp().
The arguments represented by arg0,... are pointers to null-terminated character strings. These strings shall constitute
the argument list available to the new process image. The list is terminated by a null pointer. The argument arg0 should
point to a filename string that is associated with the process being started by one of the exec functions.
The argument argv is an array of character pointers to null-terminated strings. The application shall ensure that the
last member of this array is a null pointer. These strings shall constitute the argument list available to the new process image.
The value in argv[0] should point to a filename string that is associated with the process being started by one of the
exec functions.
The argument envp is an array of character pointers to null-terminated strings. These strings shall constitute the
environment for the new process image. The envp array is terminated by a null pointer.
For those forms not containing an envp pointer (execl(), execv(),
execlp(), and execvp()), the environment for the new process image shall be taken from the external variable
environ in the calling process.
The number of bytes available for the new process' combined argument and environment lists is {ARG_MAX}. It is
implementation-defined whether null terminators, pointers, and/or any alignment bytes are included in this total.
File descriptors open in the calling process image shall remain open in the new process image, except for those whose
close-on-exec flag FD_CLOEXEC is set. For those file descriptors that remain open, all attributes of the open file
description shall remain unchanged and the FD_CLOFORK file descriptor flag, if set, shall remain set. For any file descriptor that
is closed for this reason, process-owned file locks that the calling process owns on the file associated with the file descriptor
shall be unlocked as a result of the close, as described in close(). File locks that
are not unlocked by closing of file descriptors remain unchanged.
If file descriptor 0, 1, or 2 would otherwise be closed after a successful call to one of the exec family of functions,
implementations may open an unspecified file for the file descriptor in the new process image. If a standard utility or a
conforming application is executed with file descriptor 0 not open for reading or with file descriptor 1 or 2 not open for writing,
the environment in which the utility or application is executed shall be deemed non-conforming, and consequently the utility or
application might not behave as described in this standard.
Directory streams open in the calling process image shall be closed in the new process image.
The state of the floating-point environment in the initial thread of the new process image shall be set to the default.
The state of conversion descriptors and message catalog descriptors in the new process image is undefined.
For the new process image, the equivalent of:
setlocale(LC_ALL, "C")
shall be executed at start-up.
Signals set to the default action (SIG_DFL) in the calling process image shall be set to the default action in the new process
image. Except for SIGCHLD, signals set to be ignored (SIG_IGN) by the calling process image shall be set to be ignored by the new
process image. Signals set to be caught by the calling process image shall be set to the default action in the new process image
(see ).
If the SIGCHLD signal is set to be ignored by the calling process image, it is unspecified whether the SIGCHLD signal is set to
be ignored or to the default action in the new process image.
[XSI]
After a successful call to any of the exec functions, alternate signal stacks are not preserved and the SA_ONSTACK flag
shall be cleared for all signals.
After a successful call to any of the exec functions, any functions previously registered by the atexit(), at_quick_exit(), or pthread_atfork() functions are no longer registered.
[XSI]
If the ST_NOSUID bit is set for the file system containing the new process image file, then the effective user ID, effective group
ID, saved set-user-ID, and saved set-group-ID are unchanged in the new process image. Otherwise,  if the set-user-ID mode bit of the new process image file is set, the effective user ID of the new
process image shall be set to the user ID of the new process image file. Similarly, if the set-group-ID mode bit of the new process
image file is set, the effective group ID of the new process image shall be set to the group ID of the new process image file. The
real user ID, real group ID, and supplementary group IDs of the new process image shall remain the same as those of the calling
process image. The effective user ID and effective group ID of the new process image shall be saved (as the saved set-user-ID and
the saved set-group-ID) for use by setuid().
[XSI]
Any shared memory segments attached to the calling process image shall not be attached to the new process image.
Any named semaphores open in the calling process shall be closed as if by appropriate calls to sem_close(). Any unnamed semaphores open in the calling process shall be destroyed as if
by calls to sem_destroy().
[TYM]
Any blocks of typed memory that were mapped in the calling process are unmapped, as if munmap() was implicitly called to unmap them.
[ML]
Memory locks established by the calling process via calls to mlockall() or mlock() shall be removed. If locked pages in the address space of the calling process are also
mapped into the address spaces of other processes and are locked by those processes, the locks established by the other processes
shall be unaffected by the call by this process to the exec function. If the exec function fails, the effect on
memory locks is unspecified.
Memory mappings created in the process are unmapped before the address space is rebuilt for the new process image.
When the calling process image does not use the SCHED_FIFO, SCHED_RR, [SS]
or SCHED_SPORADIC   scheduling policies, the scheduling policy and parameters of the new process image and the initial
thread in that new process image are implementation-defined.
[PS]
When the calling process image uses the SCHED_FIFO, SCHED_RR, or SCHED_SPORADIC scheduling policies, the process policy and
scheduling parameter settings shall not be changed by a call to an exec function.  [TPS]   The initial thread in the new process image shall inherit the process scheduling policy and
parameters. It shall have the default system contention scope, but shall inherit its allocation domain from the calling process
image.
Per-process timers created by the calling process shall be deleted before replacing the current process image with the new
process image.
[MSG]
All open message queue descriptors in the calling process shall be closed, as described in mq_close().
Any outstanding asynchronous I/O operations may be canceled. Those asynchronous I/O operations that are not canceled shall
complete as if the exec function had not yet occurred, but any associated signal notifications shall be suppressed. It is
unspecified whether the exec function itself blocks awaiting such I/O completion. In no event, however, shall the new
process image created by the exec function be affected by the presence of outstanding asynchronous I/O operations at the
time the exec function is called. Whether any I/O is canceled, and which I/O may be canceled upon exec, is
implementation-defined.
[CPT]
The new process image shall inherit the CPU-time clock of the calling process image. This inheritance means that the process
CPU-time clock of the process being exec-ed shall not be reinitialized or altered as a result of the exec function
other than to reflect the time spent by the process executing the exec function itself.
[TCT]
The initial value of the CPU-time clock of the initial thread of the new process image shall be set to zero.
The thread ID of the initial thread in the new process image is unspecified.
The size and location of the stack on which the initial thread in the new process image runs is unspecified.
The initial thread in the new process image shall have its cancellation type set to PTHREAD_CANCEL_DEFERRED and its cancellation
state set to PTHREAD_CANCEL_ENABLED.
The initial thread in the new process image shall have all thread-specific data values set to NULL and all thread-specific data
keys shall be removed by the call to exec without running destructors.
The initial thread in the new process image shall be joinable, as if created with the detachstate attribute set to
PTHREAD_CREATE_JOINABLE.
The new process shall inherit at least the following attributes from the calling process image:
[XSI]
Nice value (see nice())
[XSI]
semadj values (see semop())
Process ID
Parent process ID
Process group ID
Session membership
Real user ID
Real group ID
Supplementary group IDs
Time left until an alarm clock signal (see alarm())
Current working directory
Root directory
File mode creation mask (see umask())
File size limit (see getrlimit() and setrlimit())
Process signal mask (see pthread_sigmask())
Pending signal (see sigpending())
tms_utime, tms_stime, tms_cutime, and tms_cstime (see times())
Resource limits
Controlling terminal
The initial thread of the new process shall inherit at least the following attributes from the calling thread:
Signal mask (see sigprocmask() and pthread_sigmask())
Pending signals (see sigpending())
All other process attributes defined in this volume of POSIX.1-2024 shall be inherited in the new process image from the old
process image. All other thread attributes defined in this volume of POSIX.1-2024 shall be inherited in the initial thread in the
new process image from the calling thread in the old process image. The inheritance of process or thread attributes not defined by
this volume of POSIX.1-2024 is implementation-defined.
A call to any exec function from a process with more than one thread shall result in all threads being terminated and the
new executable image being loaded and executed. No destructor functions or cleanup handlers shall be called.
Upon successful completion, the exec functions shall mark for update the last data access timestamp of the file. If an
exec function failed but was able to locate the process image file, whether the last data access timestamp is marked for
update is unspecified. Should the exec function succeed, the process image file shall be considered to have been opened with
open(). The corresponding close() shall be
considered to occur at a time after this open, but before process termination or successful completion of a subsequent call to one
of the exec functions, posix_spawn(), or posix_spawnp(). The argv[] and envp[] arrays of pointers and the strings
to which those arrays point shall not be modified by a call to one of the exec functions, except as a consequence of
replacing the process image.
The saved resource limits in the new process image are set to be a copy of the process' corresponding hard and soft limits.
RETURN VALUE
If one of the exec functions returns to the calling process image, an error has occurred; the return value shall be -1,
and errno shall be set to indicate the error.
ERRORS
The exec functions shall fail if:
[E2BIG]
The number of bytes used by the new process image's argument list and environment list is greater than the system-imposed limit
of {ARG_MAX} bytes.
[EACCES]
The new process image file is not a regular file and the implementation does not support execution of files of its type.
[EINVAL]
The new process image file has appropriate privileges and has a recognized executable binary format, but the system does not
support execution of a file with this format.
The exec functions, except for fexecve(), shall fail if:
[EACCES]
Search permission is denied for a directory listed in the new process image file's path prefix, or the new process image file
denies execution permission.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the path or file argument.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOENT]
A component of path or file does not name an existing file or path or file is an empty string.
[ENOTDIR]
A component of the new process image file's path prefix names an existing file that is neither a directory nor a symbolic link
to a directory, or the new process image file's pathname contains at least one non- character and ends with one or
more trailing  characters and the last pathname component names an existing file that is neither a directory nor a
symbolic link to a directory.
The exec functions, except for execlp() and execvp(), shall fail if:
[ENOEXEC]
The new process image file has the appropriate access permission but has an unrecognized format.
The fexecve() function shall fail if:
[EBADF]
The fd argument is not a valid file descriptor open for executing.
The exec functions may fail if:
[ENOMEM]
The new process image requires more memory than is allowed by the hardware or system-imposed memory management
constraints.
The exec functions, except for fexecve(), may fail if:
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the path or file argument.
[ENAMETOOLONG]
The length of the path argument or the length of the pathname constructed from the file argument exceeds {PATH_MAX},
or pathname resolution of a symbolic link produced an intermediate result with a length that exceeds {PATH_MAX}.
[ETXTBSY]
The new process image file is a pure procedure (shared text) file that is currently open for writing by some process.
The following sections are informative.
EXAMPLES
Using execl()
The following example executes the ls command, specifying the pathname of the
executable (/bin/ls) and using arguments supplied directly to the command to produce single-column output.
#include
int ret;
...
ret = execl ("/bin/ls", "ls", "-1", (char *)0);
Using execle()
The following example is similar to Using execl(). In addition, it specifies the environment
for the new process image using the env argument.
#include
int ret;
char *env[] = { "HOME=/usr/home", "LOGNAME=home", (char *)0 };
...
ret = execle ("/bin/ls", "ls", "-l", (char *)0, env);
Using execlp()
The following example searches for the location of the ls command among the
directories specified by the PATH environment variable.
#include
int ret;
...
ret = execlp ("ls", "ls", "-l", (char *)0);
Using execv()
The following example passes arguments to the ls command in the cmd array.
#include
int ret;
char *cmd[] = { "ls", "-l", (char *)0 };
...
ret = execv ("/bin/ls", cmd);
Using execve()
The following example passes arguments to the ls command in the cmd array, and
specifies the environment for the new process image using the env argument.
#include
int ret;
char *cmd[] = { "ls", "-l", (char *)0 };
char *env[] = { "HOME=/usr/home", "LOGNAME=home", (char *)0 };
...
ret = execve ("/bin/ls", cmd, env);
Using execvp()
The following example searches for the location of the ls command among the
directories specified by the PATH environment variable, and passes arguments to the ls command in the cmd array.
#include
int ret;
char *cmd[] = { "ls", "-l", (char *)0 };
...
ret = execvp ("ls", cmd);
APPLICATION USAGE
As the state of conversion descriptors and message catalog descriptors in the new process image is undefined, conforming
applications should not rely on their use and should close them prior to calling one of the exec functions.
Applications that require other than the default POSIX locale as the global locale in the new process image should call setlocale() with the appropriate parameters.
When assigning a new value to the environ variable, applications should ensure that the environment to which it will
point contains at least the following:
Any implementation-defined variables required by the implementation to provide a conforming environment. See the _CS_V8_ENV
entry in  and confstr() for details.
A value for PATH which finds conforming versions of all standard utilities before any other versions.
The same constraint applies to the envp array passed to execle() or execve(), in order to ensure that the
new process image is invoked in a conforming environment.
Applications should not execute programs with file descriptor 0 not open for reading or with file descriptor 1 or 2 not open for
writing, as this might cause the executed program to misbehave. In order not to pass on these file descriptors to an executed
program, applications should not just close them but should reopen them on, for example, /dev/null. Some implementations may
reopen them automatically, but applications should not rely on this being done.
If an application wants to perform an integrity test of the file being executed before executing it, the file will need to be
opened with read permission to perform the integrity test.
Since execute permission is checked by fexecve(), the file description fd need not have been opened with the
O_EXEC flag. However, if the file to be executed denies read and write permission for the process preparing to do the exec,
the only way to provide the fd to fexecve() will be to use the O_EXEC flag when opening fd. In this case, the
application will not be able to perform an integrity test since it will not be able to read the contents of the file.
Note that when a file descriptor is opened with O_RDONLY, O_RDWR, or O_WRONLY mode, the file descriptor can be used to read,
read and write, or write the file, respectively, even if the mode of the file changes after the file was opened. Using the O_EXEC
open mode is different; fexecve() will ignore the mode that was used when the file descriptor was opened and the exec
will fail if the mode of the file associated with fd does not grant execute permission to the calling process at the time
fexecve() is called.
RATIONALE
Early proposals required that the value of argc passed to main() be "one or greater". This was driven by the
same requirement in drafts of the ISO C standard. In fact, historical implementations have passed a value of zero when no
arguments are supplied to the caller of the exec functions. This requirement was removed from the ISO C standard and
subsequently removed from this volume of POSIX.1-2024 as well. The wording, in particular the use of the word should,
requires a Strictly Conforming POSIX Application to pass at least one argument to the exec function, thus guaranteeing that
argc be one or greater when invoked by such an application. In fact, this is good practice, since many existing applications
reference argv[0] without first checking the value of argc.
The requirement on a Strictly Conforming POSIX Application also states that the value passed as the first argument be a filename
string associated with the process being started. Although some existing applications pass a pathname rather than a filename string
in some circumstances, a filename string is more generally useful, since the common usage of argv[0] is in printing
diagnostics. In some cases the filename passed is not the actual filename of the file; for example, many implementations of the
login utility use a convention of prefixing a  ('-') to the actual filename, which indicates to
the command interpreter being invoked that it is a "login shell".
Also, note that the test and [ utilities require specific strings for the
argv[0] argument to have deterministic behavior across all implementations.
Historically, there have been two ways that implementations can exec shell scripts.
One common historical implementation is that the execl(), execv(), execle(), and execve() functions
return an [ENOEXEC] error for any file not recognizable as executable, including a shell script. When the execlp() and
execvp() functions encounter such a file, they assume the file to be a shell script and invoke a known command interpreter
to interpret such files. This is now required by POSIX.1-2024. These implementations of execvp() and execlp() only
give the [ENOEXEC] error in the rare case of a problem with the command interpreter's executable file. Because of these
implementations, the [ENOEXEC] error is not mentioned for execlp() or execvp(), although implementations can still
give it.
Another way that some historical implementations handle shell scripts is by recognizing the first two bytes of the file as the
character string "#!" and using the remainder of the first line of the file as the name of the command interpreter to
execute.
One potential source of confusion noted by the standard developers is over how the contents of a process image file affect the
behavior of the exec family of functions. The following is a description of the actions taken:
If the process image file is a valid executable (in a format that is executable and valid and having appropriate privileges) for
this system, then the system executes the file.
If the process image file has appropriate privileges and is in a format that is executable but not valid for this system (such
as a recognized binary for another architecture), then this is an error and errno is set to [EINVAL] (see later RATIONALE on
[EINVAL]).
If the process image file has appropriate privileges but is not otherwise recognized:
If this is a call to execlp() or execvp(), then they invoke a command interpreter assuming that the process image
file is a shell script.
If this is not a call to execlp() or execvp(), then an error occurs and errno is set to [ENOEXEC].
Applications that do not require to access their arguments may use the form:
main(void)
as specified in the ISO C standard. However, the implementation will always provide the two arguments argc and
argv, even if they are not used.
Some implementations provide a third argument to main() called envp. This is defined as a pointer to the
environment. The ISO C standard specifies invoking main() with two arguments, so implementations are required to
support applications written this way. Since this volume of POSIX.1-2024 defines the global variable environ, which is also
provided by historical implementations and can be used anywhere that envp could be used, there is no functional need for the
envp argument. Applications should use the getenv() function rather than
accessing the environment directly via either envp or environ. Implementations are required to support the
two-argument calling sequence, but this does not prohibit an implementation from supporting envp as an optional third
argument.
This volume of POSIX.1-2024 specifies that signals set to SIG_IGN remain set to SIG_IGN, and that the new process image inherits
the signal mask of the thread that called exec in the old process image. This is consistent with historical implementations,
and it permits some useful functionality, such as the nohup command. However, it
should be noted that many existing applications wrongly assume that they start with certain signals set to the default action
and/or unblocked. In particular, applications written with a simpler signal model that does not include blocking of signals, such
as the one in the ISO C standard, may not behave properly if invoked with some signals blocked. Therefore, it is best not to
block or ignore signals across execs without explicit reason to do so, and especially not to block signals across
execs of arbitrary (not closely cooperating) programs.
The exec functions always save the value of the effective user ID and effective group ID of the process at the completion
of the exec, whether or not the set-user-ID or the set-group-ID bit of the process image file is set.
The statement about argv[] and envp[] being constants is included to make explicit to future writers of language
bindings that these objects are completely constant. Due to a limitation of the ISO C standard, it is not possible to state
that idea in standard C. Specifying two levels of const-qualification for the argv[] and envp[]
parameters for the exec functions may seem to be the natural choice, given that these functions do not modify either the
array of pointers or the characters to which the function points, but this would disallow existing correct code. Instead, only the
array of pointers is noted as constant. The table of assignment compatibility for dst=src derived from the ISO C
standard summarizes the compatibility:
dst:
char *[]
const char *[]
char *const[]
const char *const[]
src:
char *[]
VALID
—
VALID
—
const char *[]
—
VALID
—
VALID
char * const []
—
—
VALID
—
const char *const[]
—
—
—
VALID
Since all existing code has a source type matching the first row, the column that gives the most valid combinations
is the third column. The only other possibility is the fourth column, but using it would require a cast on the argv or
envp arguments. It is unfortunate that the fourth column cannot be used, because the declaration a non-expert would
naturally use would be that in the second row.
The ISO C standard and this volume of POSIX.1-2024 do not conflict on the use of environ, but some
historical implementations of environ may cause a conflict. As long as environ is treated in the same way as an entry
point (for example, fork()), it conforms to both standards. A library can contain
fork(), but if there is a user-provided fork(), that fork() is given precedence and no
problem ensues. The situation is similar for environ: the definition in this volume of POSIX.1-2024 is to be used if there
is no user-provided environ to take precedence. At least three implementations are known to exist that solve this
problem.
[E2BIG]
The limit {ARG_MAX} applies not just to the size of the argument list, but to the sum of that and the size of the environment
list.
[EFAULT]
Some historical systems return [EFAULT] rather than [ENOEXEC] when the new process image file is corrupted. They are
non-conforming.
[EINVAL]
This error condition was added to POSIX.1-2024 to allow an implementation to detect executable files generated for different
architectures, and indicate this situation to the application. Historical implementations of shells, execvp(), and
execlp() that encounter an [ENOEXEC] error will execute a shell on the assumption that the file is a shell script. This will
not produce the desired effect when the file is a valid executable for a different architecture. An implementation may now choose
to avoid this problem by returning [EINVAL] when a valid executable for a different architecture is encountered. Some historical
implementations return [EINVAL] to indicate that the path argument contains a character with the high order bit set. The
standard developers chose to deviate from historical practice for the following reasons:
The new utilization of [EINVAL] will provide some measure of utility to the user community.
Historical use of [EINVAL] is not acceptable in an internationalized operating environment.
[ENAMETOOLONG]
Since the file pathname may be constructed by taking elements in the PATH variable and putting them together with the
filename, the [ENAMETOOLONG] error condition could also be reached this way.
[ETXTBSY]
System V returns this error when the executable file is currently open for writing by some process. This volume of POSIX.1-2024
neither requires nor prohibits this behavior.
Other systems (such as System V) may return [EINTR] from exec. This is not addressed by this volume of
POSIX.1-2024, but implementations may have a window between the call to exec and the time that a signal could cause one of
the exec calls to return with [EINTR].
An explicit statement regarding the floating-point environment (as defined in the  header) was added to make it clear that the floating-point environment is set
to its default when a call to one of the exec functions succeeds. The requirements for inheritance or setting to the default
for other process and thread start-up functions is covered by more generic statements in their descriptions and can be summarized
as follows:
posix_spawn()
Set to default.
fork()
Inherit.
pthread_create()
Inherit.
The purpose of the fexecve() function is to enable executing a file which has been verified to be the
intended file. It is possible to actively check the file by reading from the file descriptor and be sure that the file is not
exchanged for another between the reading and the execution. Alternatively, a function like openat() can be used to open a file which has been found by reading the content of a
directory using readdir().
When execlp() or execvp() fall back to invoking sh because
of an [ENOEXEC] condition, the standard leaves the process name (what becomes argv[0] in the resulting sh process) unspecified. Existing implementations vary on whether they pass a variation of
"sh", or preserve the original arg0. There are existing implementations of sh that behave differently depending on the contents of argv[0], such that blindly passing
the original arg0 on to the fallback execution can fail to invoke a compliant shell environment. Because of the requirements
on how sh handles its command line arguments, the shell script will see $0
containing the pathname of the script being executed, regardless of the value of argv[0].
FUTURE DIRECTIONS
None.
SEE ALSO
alarm(), atexit(), chmod(), close(), confstr(), exit(), fcntl(), fork(), fstatvfs(), getenv(), getrlimit(), mknod(), mmap(), nice(), open(), posix_spawn(), pthread_atfork(), pthread_sigmask(), putenv(),
readdir(), semop(), setlocale(), shmat(), sigaction(), sigaltstack(),
sigpending(), system(),
times(), umask()
XBD 8. Environment Variables,
XCU test
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Realtime Extension and the POSIX Threads Extension.
Large File Summit extensions are added.
Issue 6
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
In the DESCRIPTION, behavior is defined for when the process image file is not a valid executable.
In this version, _POSIX_SAVED_IDS is mandated, thus the effective user ID and effective group ID of the new
process image shall be saved (as the saved set-user-ID and the saved set-group-ID) for use by the setuid() function.
The [ELOOP] mandatory error condition is added.
A second [ENAMETOOLONG] is added as an optional error condition.
The [ETXTBSY] optional error condition is added.
The following changes were made to align with the IEEE P1003.1a draft standard:
The [EINVAL] mandatory error condition is added.
The [ELOOP] optional error condition is added.
The description of CPU-time clock semantics is added for alignment with IEEE Std 1003.1d-1999.
The DESCRIPTION is updated for alignment with IEEE Std 1003.1j-2000 by adding semantics for typed
memory.
The normative text is updated to avoid use of the term "must" for application requirements.
The description of tracing semantics is added for alignment with IEEE Std 1003.1q-2000.
IEEE PASC Interpretation 1003.1 #132 is applied.
The DESCRIPTION is updated to make it explicit that the floating-point environment in the new process image is set
to the default.
The DESCRIPTION and RATIONALE are updated to include clarifications of how the contents of a process image file
affect the behavior of the exec functions.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/15 is applied, adding a new paragraph to the
DESCRIPTION and text to the end of the APPLICATION USAGE section. This change addresses a security concern, where implementations
may want to reopen file descriptors 0, 1, and 2 for programs with the set-user-id or set-group-id file mode bits calling the
exec family of functions.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/24 is applied, applying changes to the DESCRIPTION,
addressing which attributes are inherited by threads, and behavioral requirements for threads attributes.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/25 is applied, updating text in the RATIONALE from
"the process signal mask be unchanged across an exec" to "the new process image inherits the signal mask of the thread
that called exec in the old process image".
Issue 7
Austin Group Interpretation 1003.1-2001 #047 is applied, adding the description of _CS_V7_ENV to the APPLICATION USAGE.
Austin Group Interpretation 1003.1-2001 #143 is applied.
The fexecve() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 2.
Functionality relating to the Asynchronous Input and Output, Memory Mapped Files, Threads, and Timers options is
moved to the Base.
Changes are made related to support for finegrained timestamps.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0095 [386], XSH/TC1-2008/0096 [167], XSH/TC1-2008/0097 [291],
XSH/TC1-2008/0098 [173], XSH/TC1-2008/0099 [296], XSH/TC1-2008/00100 [324], XSH/TC1-2008/00101 [296], XSH/TC1-2008/00102 [302],
XSH/TC1-2008/00103 [167], XSH/TC1-2008/00104 [173], and XSH/TC1-2008/00105 [291,429] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0097 [584], XSH/TC2-2008/0098 [898], and XSH/TC2-2008/0099
[734] are applied.
Issue 8
Austin Group Defects 51 and 1669 are applied, moving the getrlimit() and
setrlimit() functions from the XSI option to the Base.
Austin Group Defect 368 is applied, adding a requirement for unnamed semaphores to be destroyed.
Austin Group Defect 768 is applied, adding OFD-owned file locks.
Austin Group Defect 922 is applied, adding the secure_getenv()
function.
Austin Group Defect 1284 is applied, changing "checksum test" to "integrity test" in the APPLICATION USAGE
section.
Austin Group Defect 1318 is applied, adding FD_CLOFORK.
Austin Group Defect 1330 is applied, removing obsolescent interfaces and changing "_V7_" to "_V8_".
Austin Group Defect 1435 is applied, adding function lists to the descriptions of the path and file
arguments.
Austin Group Defect 1645 is applied, making it unspecified what string is passed to the shell in argv[0]
when executed by execlp() or execvp().
Austin Group Defect 1646 is applied, adding at_quick_exit() to
the list of registration functions whose registrations are not inherited across exec.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/erfcf.html =====
erfc
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
erfc, erfcf, erfcl — complementary error functions
SYNOPSIS
#include
double erfc(double x);
float erfcf(float x);
long double erfcl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complementary error function 1.0 - erf(x).
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the value of the complementary error function.
If the correct value would cause underflow, [MXX]   and is not representable,   a range error may occur, and erfc(), erfcf(), and erfcl() shall return
[MXX]
0.0, or   (if the IEC 60559 Floating-Point option is not
supported) an implementation-defined value no greater in magnitude than DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0, +1 shall be returned.
If x is -Inf, +2 shall be returned.
If x is +Inf, +0 shall be returned.
[MXX]
If the correct value would cause underflow and is representable, a range error may occur and the correct value shall be returned.
ERRORS
These functions may fail if:
Range Error
The result underflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The erfc() function is provided because of the extreme loss of relative accuracy if erf(x) is called for
large x and the result subtracted from 1.0.
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
erf(), feclearexcept(),
fetestexcept(), isnan()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The erfc() function is no longer marked as an extension.
These functions are split out from the erf() reference page.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0093 [68] and XSH/TC1-2008/0094 [68] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0096 [630] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/strtod.html =====
strtod
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
strtod, strtof, strtold — convert a string to a double-precision number
SYNOPSIS
#include
double strtod(const char *restrict nptr, char **restrict endptr);
float strtof(const char *restrict nptr, char **restrict endptr);
long double strtold(const char *restrict nptr, char **restrict endptr);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall convert the initial portion of the string pointed to by nptr to double, float, and
long double representation, respectively. First, they decompose the input string into three parts:
An initial, possibly empty, sequence of white-space bytes
A subject sequence interpreted as a floating-point constant or representing infinity or NaN
A final string of one or more unrecognized characters, including the terminating NUL character of the input string
Then they shall attempt to convert the subject sequence to a floating-point number, and return the result.
The expected form of the subject sequence is an optional '+' or '-' sign, then one of the following:
A non-empty sequence of decimal digits optionally containing a radix character; then an optional exponent part consisting of the
character 'e' or the character 'E', optionally followed by a '+' or '-' character, and then
followed by one or more decimal digits
A 0x or 0X, then a non-empty sequence of hexadecimal digits optionally containing a radix character; then an optional binary
exponent part consisting of the character 'p' or the character 'P', optionally followed by a '+' or
'-' character, and then followed by one or more decimal digits
One of INF or INFINITY, ignoring case
One of NAN or NAN(n-char-sequenceopt), ignoring case in the NAN part, where:
n-char-sequence:
digit
nondigit
n-char-sequence digit
n-char-sequence nondigit
The subject sequence is defined as the longest initial subsequence of the input string, starting with the first non-white-space
byte, that is of the expected form. The subject sequence contains no characters if the input string is not of the expected
form.
If the subject sequence has the expected form for a floating-point number, the sequence of characters starting with the first
digit or the decimal-point character (whichever occurs first) shall be interpreted as a floating constant of the C language, except
that the radix character shall be used in place of a period, and that if neither an exponent part nor a radix character appears in
a decimal floating-point number, or if a binary exponent part does not appear in a hexadecimal floating-point number, an exponent
part of the appropriate type with value zero is assumed to follow the last digit in the string. If the subject sequence begins with
a , the sequence shall be interpreted as negated. A character sequence INF or INFINITY shall be interpreted as
an infinity, if representable in the return type, else as if it were a floating constant that is too large for the range of the
return type. A character sequence NAN or NAN(n-char-sequenceopt) shall be interpreted as a quiet
NaN, if supported in the return type, else as if it were a subject sequence part that does not have the expected form; the meaning
of the n-char sequences is implementation-defined. A pointer to the final string is stored in the object pointed to by
endptr, provided that endptr is not a null pointer.
If the subject sequence has the hexadecimal form and FLT_RADIX is a power of 2, the value resulting from the conversion is
correctly rounded.
[CX]  The
radix character is defined in the current locale (category LC_NUMERIC ). In the POSIX locale, or in a locale where the radix
character is not defined, the radix character shall default to a  ('.').
In other than the C [CX]   or POSIX  locale, additional
locale-specific subject sequence forms may be accepted.
If the subject sequence is empty or does not have the expected form, no conversion shall be performed; the value of nptr
is stored in the object pointed to by endptr, provided that endptr is not a null pointer.
These functions shall not change the setting of errno if successful.
Since 0 is returned on error and is also a valid return on success, an application wishing to check for error situations should
set errno to 0, then call strtod(), strtof(), or strtold(), then check errno.
RETURN VALUE
Upon successful completion, these functions shall return the converted value. If no conversion could be performed, 0 shall be
returned, and errno may be set to [EINVAL].
If the correct value would cause an overflow and default rounding is in effect, ±HUGE_VAL, ±HUGE_VALF, or ±HUGE_VALL shall be
returned (according to the sign of the value), and errno shall be set to [ERANGE].
If the correct value would cause an underflow, a value whose magnitude is no greater than the smallest normalized positive
number in the return type shall be returned [CX]   and errno set to [ERANGE].
ERRORS
These functions shall fail if:
[ERANGE]
The value to be returned would cause overflow and default rounding is in effect [CX]   or the value
to be returned would cause underflow.
These functions may fail if:
[EINVAL]
[CX]  No
conversion could be performed.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
If the subject sequence has the hexadecimal form and FLT_RADIX is not a power of 2, and the result is not exactly representable,
the result should be one of the two numbers in the appropriate internal format that are adjacent to the hexadecimal floating source
value, with the extra stipulation that the error should have a correct sign for the current rounding direction.
If the subject sequence has the decimal form and at most DECIMAL_DIG (defined in ) significant digits, the result should be correctly rounded. If the subject
sequence D has the decimal form and more than DECIMAL_DIG significant digits, consider the two bounding, adjacent decimal
strings L and U, both having DECIMAL_DIG significant digits, such that the values of L, D, and U
satisfy L ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate that errno is not changed if the function is successful.
Issue 6
Extensions beyond the ISO C standard are marked.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
In the RETURN VALUE and ERRORS sections, the [EINVAL] optional error condition is added if no conversion could be performed.
The following changes are made for alignment with the ISO/IEC 9899:1999 standard:
The strtod() function is updated.
The strtof() and strtold() functions are added.
The DESCRIPTION is extensively revised.
ISO/IEC 9899:1999 standard, Technical Corrigendum 1 is incorporated.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/61 is applied, correcting the second paragraph in the RETURN
VALUE section. This change clarifies the sign of the return value.
Issue 7
Austin Group Interpretation 1003.1-2001 #015 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0610 [302], XSH/TC1-2008/0611 [94], and XSH/TC1-2008/0612 [105] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0348 [584] and XSH/TC2-2008/0349 [796] are applied.
Issue 8
Austin Group Defect 1163 is applied, clarifying the handling of white space in the input string.
Austin Group Defect 1213 is applied, correcting some typographic errors in the APPLICATION USAGE section.
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
Austin Group Defect 1686 is applied, adding CX shading to some text in the RETURN VALUE section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_setschedprio.html =====
pthread_setschedprio
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_setschedprio — dynamic thread scheduling parameters access (REALTIME THREADS)
SYNOPSIS
[TPS]  #include
int pthread_setschedprio(pthread_t thread, int prio);
DESCRIPTION
The pthread_setschedprio() function shall set the scheduling priority for the thread whose thread ID is given by
thread to the value given by prio. See Scheduling
Policies for a description on how this function call affects the ordering of the thread in the thread list for its new
priority.
If the pthread_setschedprio() function fails, the scheduling priority of the target thread shall not be changed.
RETURN VALUE
If successful, the pthread_setschedprio() function shall return zero; otherwise, an error number shall be returned to
indicate the error.
ERRORS
The pthread_setschedprio() function may fail if:
[EINVAL]
The value of prio is invalid for the scheduling policy of the specified thread.
[EPERM]
The caller does not have appropriate privileges to set the scheduling priority of the specified thread.
The pthread_setschedprio() function shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
The pthread_setschedprio() function provides a way for an application to temporarily raise its priority and then lower it
again, without having the undesired side-effect of yielding to other threads of the same priority. This is necessary if the
application is to implement its own strategies for bounding priority inversion, such as priority inheritance or priority ceilings.
This capability is especially important if the implementation does not support the Thread Priority Protection or Thread Priority
Inheritance options, but even if those options are supported it is needed if the application is to bound priority inheritance for
other resources, such as semaphores.
The standard developers considered that while it might be preferable conceptually to solve this problem by modifying the
specification of pthread_setschedparam(), it was too late to make such
a change, as there may be implementations that would need to be changed. Therefore, this new function was introduced.
If an implementation detects use of a thread ID after the end of its lifetime, it is recommended that the function should fail
and report an [ESRCH] error.
FUTURE DIRECTIONS
None.
SEE ALSO
Scheduling Policies, pthread_getschedparam()
XBD
CHANGE HISTORY
First released in Issue 6. Included as a response to IEEE PASC Interpretation 1003.1 #96.
Issue 7
The pthread_setschedprio() function is marked only as part of the Thread Execution Scheduling option as the Threads
option is now part of the Base.
Austin Group Interpretation 1003.1-2001 #069 is applied, updating the [EPERM] error.
Austin Group Interpretation 1003.1-2001 #142 is applied, removing the [ESRCH] error condition.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0466 [314] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0296 [757] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/strtoimax.html =====
strtoimax
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
strtoimax, strtoumax — convert string to integer type
SYNOPSIS
#include
intmax_t strtoimax(const char *restrict nptr, char **restrict endptr,
int base);
uintmax_t strtoumax(const char *restrict nptr, char **restrict endptr,
int base);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall be equivalent to the strtol(), strtoll(), strtoul(), and strtoull() functions, except that the initial portion of the string shall be converted to
intmax_t and uintmax_t representation, respectively.
RETURN VALUE
These functions shall return the converted value, if any.
If no conversion could be performed, zero shall be returned [CX]   and errno may be set to [EINVAL].
[CX]  If
the value of base is not supported, 0 shall be returned and errno shall be set to [EINVAL].
If the correct value is outside the range of representable values, {INTMAX_MAX}, {INTMAX_MIN}, or {UINTMAX_MAX} shall be
returned (according to the return type and sign of the value, if any), and errno shall be set to [ERANGE].
ERRORS
These functions shall fail if:
[EINVAL]
[CX]
The value of base is not supported.
[ERANGE]
The value to be returned is not representable.
These functions may fail if:
[EINVAL]
No conversion could be performed.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Since the value of *endptr is unspecified if the value of base is not supported, applications should either ensure
that base has a supported value (0 or between 2 and 36) before the call, or check for an [EINVAL] error before examining
*endptr.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
strtol(), strtoul()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0613 [453] and XSH/TC1-2008/0614 [453] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/ctermid.html =====
ctermid
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ctermid — generate a pathname for the controlling terminal
SYNOPSIS
[CX]  #include
char *ctermid(char *s);
DESCRIPTION
The ctermid() function shall generate a string that, when used as a pathname, refers to the current controlling terminal
for the current process. If ctermid() returns a pathname, access to the file is not guaranteed.
The ctermid() function need not be thread-safe if called with a NULL parameter.
RETURN VALUE
If s is a null pointer, the string shall be generated in an area that may be static, the address of which shall be
returned. The application shall not modify the string returned. The returned pointer might be invalidated or the string content
might be overwritten by a subsequent call to ctermid(). The returned pointer might also be invalidated if the calling thread
is terminated. If s is not a null pointer, s is assumed to point to a character array of at least L_ctermid bytes;
the string is placed in this array and the value of s shall be returned. The symbolic constant L_ctermid is defined in
, and shall have a value greater than 0.
The ctermid() function shall return an empty string if the pathname that would refer to the controlling terminal cannot
be determined, or if the function is unsuccessful.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
Determining the Controlling Terminal for the Current Process
The following example returns a pointer to a string that identifies the controlling terminal for the current process. The
pathname for the terminal is stored in the array pointed to by the ptr argument, which has a size of L_ctermid bytes, as
indicated by the term argument.
#include
...
char term[L_ctermid];
char *ptr;
ptr = ctermid(term);
APPLICATION USAGE
The difference between ctermid() and ttyname() is that ttyname() must be handed a file descriptor and return a path of the terminal associated with
that file descriptor, while ctermid() returns a string (such as "/dev/tty") that refers to the current controlling
terminal if used as a pathname.
RATIONALE
L_ctermid must be defined appropriately for a given implementation and must be greater than zero so that array declarations
using it are accepted by the compiler. The value includes the terminating null byte.
Conforming applications that use multiple threads cannot call ctermid() with NULL as the parameter. If s is not
NULL, the ctermid() function generates a string that, when used as a pathname, refers to the current controlling terminal
for the current process. If s is NULL, the return value of ctermid() is undefined.
There is no additional burden on the programmer—changing to use a hypothetical thread-safe version of ctermid() along
with allocating a buffer is more of a burden than merely allocating a buffer. Application code should not assume that the returned
string is short, as some implementations have more than two pathname components before reaching a logical device name.
FUTURE DIRECTIONS
None.
SEE ALSO
ttyname()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Threads Extension.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
Austin Group Interpretation 1003.1-2001 #148 is applied, updating the RATIONALE.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0065 [75,428] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0074 [656] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/jn.html =====
j0
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
j0, j1, jn — Bessel functions of the first kind
SYNOPSIS
[XSI]  #include
double j0(double x);
double j1(double x);
double jn(int n, double x);
DESCRIPTION
The j0(), j1(), and jn() functions shall compute Bessel functions of x of the first kind of orders
0, 1, and n, respectively.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the relevant Bessel value of x of the first kind.
If the x argument is finite and too large in magnitude, or the correct result would cause underflow [MXX]   and is not
representable,  a range error may occur, and the function shall
return [MXX]   0.0, or  (if the IEC 60559 Floating-Point option is not
supported) an implementation-defined value no greater in magnitude than DBL_MIN.
[MXX]  If
the correct result would cause underflow, and is representable, a range error may occur and the correct value shall be returned.
[MXX]
If x is +Inf, +0 shall be returned.
[MXX]
If x is NaN, a NaN shall be returned.
ERRORS
These functions may fail if:
Range Error
The value of x was too large in magnitude, or an underflow occurred.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
No other errors shall occur.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), isnan(), y0()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The may fail [EDOM] error is removed for the case for NaN.
The RETURN VALUE and ERRORS sections are reworked for alignment of the error handling with the ISO/IEC 9899:1999
standard.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0350 [68] is applied.
Issue 8
Austin Group Defect 714 is applied, changing the behavior of these functions for special cases to be a better match for their
mathematical behavior.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/strftime.html =====
strftime
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
strftime, strftime_l — convert date and time to a string
SYNOPSIS
#include
size_t strftime(char *restrict s, size_t maxsize,
const char *restrict format, const struct tm *restrict
timeptr);
[CX]  size_t strftime_l(char *restrict s, size_t maxsize,
const char *restrict format, const struct tm *restrict
timeptr,
locale_t locale);
DESCRIPTION
For strftime(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The strftime() function shall place bytes into the array pointed to by s as controlled by the string pointed to by
format. The application shall ensure that the format is a character string, beginning and ending in its initial shift state,
if any. The format string consists of zero or more conversion specifications and ordinary characters.
Each conversion specification is introduced by the '%' character after which the following appear in sequence:
[CX]  An
optional flag:
0
The zero character ('0'), which specifies that the character used as the padding character is '0',
+
The  character ('+'), which specifies that the character used as the padding character is
'0', and that if and only if the field being produced consumes more than four bytes to represent a year (for %F,
%G, or %Y) or more than two bytes to represent the year divided by 100 (for %C) then a leading
character shall be included if the year being processed is greater than or equal to zero or a leading
character ('-') shall be included if the year is less than zero.
The default padding character is unspecified.
An optional minimum field width. If the converted value, including any leading '+' or '-' sign, has fewer
bytes than the minimum field width and the padding character is not the NUL character, the output shall be padded on the left
(after any leading '+' or '-' sign) with the padding character.
An optional E or O modifier.
A terminating conversion specifier character that indicates the type of conversion to be applied.
[CX]  The
results are unspecified if more than one flag character is specified, a flag character is specified without a minimum field width;
a minimum field width is specified without a flag character; a modifier is specified with a flag or with a minimum field width; or
if a minimum field width is specified for any conversion specifier other than C, F, G, or Y.
All ordinary characters (including the terminating NUL character) are copied unchanged into the array. If copying takes place
between objects that overlap, the behavior is undefined. No more than maxsize bytes are placed into the array. Each
conversion specifier is replaced by appropriate characters as described in the following list. The appropriate characters are
determined using the LC_TIME category of the current locale and by the values of zero or more members of the broken-down
time structure pointed to by timeptr, as specified in brackets in the description. If any of the specified values are
outside the normal range, the characters stored are unspecified.
[CX]  The
strftime_l() function shall be equivalent to the strftime() function, except that the locale data used is from the
locale represented by locale.
Local timezone information shall be set as though strftime() called tzset().
The following conversion specifiers shall be supported:
a
Replaced by the locale's abbreviated weekday name. [tm_wday]
A
Replaced by the locale's full weekday name. [tm_wday]
b
Replaced by the locale's abbreviated month name. [tm_mon]
B
Replaced by the locale's full month name. [tm_mon]
c
Replaced by the locale's appropriate date and time representation. (See the Base Definitions volume of POSIX.1-2024, .)
C
Replaced by the year divided by 100 and truncated to an integer, as a decimal number. [tm_year]
If a minimum field width is not specified:
If the year is between 0 and 9999 inclusive, two characters shall be placed into the array pointed to by s, including a
leading '0' if there would otherwise be only a single digit.
[CX]  If
the year is less than 0 or greater than 9999, the number of characters placed into the array pointed to by s shall be the
number of digits and leading sign characters (if any) in the result of dividing the year by 100 and truncating, or two, whichever
is greater.
[CX]  If
a minimum field width is specified, the number of characters placed into the array pointed to by s shall be the number of
digits and leading sign characters (if any) in the result of dividing the year by 100 and truncating, or the minimum field width,
whichever is greater.
d
Replaced by the day of the month as a decimal number [01,31]. [tm_mday]
D
Equivalent to %m/%d/%y. [tm_mon, tm_mday, tm_year]
e
Replaced by the day of the month as a decimal number [1,31]; a single digit is preceded by a space. [tm_mday]
F
Equivalent to %Y-%m-%d if no flag and no minimum field width are specified. (For years between 1000 and 9999 inclusive this
provides the ISO 8601:2019 standard complete representation, extended format date representation of a specific day.)
[tm_year, tm_mon, tm_mday]
[CX]  If
a minimum field width of x is specified, the year shall be output as if by the Y specifier (described below) with
whatever flag was given and a minimum field width of x-6. If x is less than 6, the behavior shall be as if x
equalled 6.
If the minimum field width is specified to be 10, and the year is four digits long, then the output string produced shall match
the ISO 8601:2019 standard subclause 4.1.2.2 complete representation, extended format date representation of a specific day.
If a + flag is specified, a minimum field width of x is specified, and x-7 bytes are sufficient to hold the digits of
the year (not including any needed sign character), then the output shall match the ISO 8601:2019 standard subclause 4.1.2.4
complete representation, expanded format date representation of a specific day.
g
Replaced by the last 2 digits of the week-based year (see below) as a decimal number [00,99]. [tm_year, tm_wday,
tm_yday]
G
Replaced by the week-based year (see below) as a decimal number (for example, 1977). [tm_year, tm_wday,
tm_yday]
[CX]  If
a minimum field width is specified, the number of characters placed into the array pointed to by s shall be the number of
digits and leading sign characters (if any) in the year, or the minimum field width, whichever is greater.
h
Equivalent to %b. [tm_mon]
H
Replaced by the hour (24-hour clock) as a decimal number [00,23]. [tm_hour]
I
Replaced by the hour (12-hour clock) as a decimal number [01,12]. [tm_hour]
j
Replaced by the day of the year as a decimal number [001,366]. [tm_yday]
m
Replaced by the month as a decimal number [01,12]. [tm_mon]
M
Replaced by the minute as a decimal number [00,59]. [tm_min]
n
Replaced by a .
p
Replaced by the locale's equivalent of either a.m. or p.m. [tm_hour]
r
Replaced by the time in 12-hour clock notation; [CX]   if the 12-hour format is not supported in the locale, this shall
be either an empty string or the time in a 24-hour clock notation. In the POSIX locale this shall be equivalent to
%I:%M:%S %p.  [tm_hour,
tm_min, tm_sec]
R
Replaced by the time in 24-hour notation (%H:%M). [tm_hour, tm_min]
s
[CX]
Replaced by the number of seconds since the Epoch as a decimal number, calculated as described for mktime(). [tm_year, tm_mon, tm_mday, tm_hour, tm_min,
tm_sec, tm_isdst]
S
Replaced by the second as a decimal number [00,60]. [tm_sec]
t
Replaced by a .
T
Replaced by the time (%H:%M:%S). [tm_hour, tm_min, tm_sec]
u
Replaced by the weekday as a decimal number [1,7], with 1 representing Monday. [tm_wday]
U
Replaced by the week number of the year as a decimal number [00,53]. The first Sunday of January is the first day of week 1;
days in the new year before this are in week 0. [tm_year, tm_wday, tm_yday]
V
Replaced by the week number of the year (Monday as the first day of the week) as a decimal number [01,53]. If the week
containing 1 January has four or more days in the new year, then it is considered week 1. Otherwise, it is the last week of the
previous year, and the next week is week 1. Both January 4th and the first Thursday of January are always in week 1.
[tm_year, tm_wday, tm_yday]
w
Replaced by the weekday as a decimal number [0,6], with 0 representing Sunday. [tm_wday]
W
Replaced by the week number of the year as a decimal number [00,53]. The first Monday of January is the first day of week 1;
days in the new year before this are in week 0. [tm_year, tm_wday, tm_yday]
x
Replaced by the locale's appropriate date representation. (See the Base Definitions volume of POSIX.1-2024, .)
X
Replaced by the locale's appropriate time representation. (See the Base Definitions volume of POSIX.1-2024, .)
y
Replaced by the last two digits of the year as a decimal number [00,99]. [tm_year]
Y
Replaced by the year as a decimal number (for example, 1997). [tm_year]
[CX]  If
a minimum field width is specified, the number of characters placed into the array pointed to by s shall be the number of
digits and leading sign characters (if any) in the year, or the minimum field width, whichever is greater.
z
Replaced by the offset from UTC in the ISO 8601:2019 standard format (+hhmm or -hhmm), or by no
characters if no timezone is determinable. For example, "-0430" means 4 hours 30 minutes behind UTC (west of Greenwich).
[CX]
If tm_isdst is zero, the standard time offset is used. If tm_isdst is greater than zero, the daylight saving
time offset is used. If tm_isdst is negative, no characters are returned.
[tm_isdst, [CX]  tm_gmtoff  ]
Z
Replaced by the timezone name or abbreviation, or by no bytes if no timezone information exists. [tm_isdst,
[CX]
tm_zone  ]
%
Replaced by %.
If a conversion specification does not correspond to any of the above, the behavior is undefined.
[CX]  If
a struct tm broken-down time structure is created by localtime() or
localtime_r(), or modified by mktime(), and the value of TZ is subsequently modified, the results of the %Z
and %z strftime() conversion specifiers are undefined, when strftime() is called with such a broken-down
time structure.
If a struct tm broken-down time structure is created or modified by gmtime() or gmtime_r(), it is unspecified
whether the result of the %Z and %z conversion specifiers shall refer to UTC or the current local timezone, when
strftime() is called with such a broken-down time structure.
Modified Conversion Specifiers
Some conversion specifiers can be modified by the E or O modifier characters to indicate that an alternative
format or specification should be used rather than the one normally used by the unmodified conversion specifier. If the alternative
format or specification does not exist for the current locale (see ERA in XBD 7.3.5 LC_TIME), the behavior shall be as if the unmodified conversion
specification were used.
%Ec
Replaced by the locale's alternative appropriate date and time representation.
%EC
Replaced by the name of the base year (period) in the locale's alternative representation.
%Ex
Replaced by the locale's alternative date representation.
%EX
Replaced by the locale's alternative time representation.
%Ey
Replaced by the offset from %EC (year only) in the locale's alternative representation.
%EY
Replaced by the full alternative year representation.
%Ob
[CX]
Replaced by the locale's abbreviated alternative month name.
%OB
[CX]
Replaced by the locale's alternative appropriate full month name.
%Od
Replaced by the day of the month, using the locale's alternative numeric symbols, filled as needed with leading zeros if there
is any alternative symbol for zero; otherwise, with leading  characters.
%Oe
Replaced by the day of the month, using the locale's alternative numeric symbols, filled as needed with leading
characters.
%OH
Replaced by the hour (24-hour clock) using the locale's alternative numeric symbols.
%OI
Replaced by the hour (12-hour clock) using the locale's alternative numeric symbols.
%Om
Replaced by the month using the locale's alternative numeric symbols.
%OM
Replaced by the minutes using the locale's alternative numeric symbols.
%OS
Replaced by the seconds using the locale's alternative numeric symbols.
%Ou
Replaced by the weekday as a number in the locale's alternative representation (Monday=1).
%OU
Replaced by the week number of the year (Sunday as the first day of the week, rules corresponding to %U) using the
locale's alternative numeric symbols.
%OV
Replaced by the week number of the year (Monday as the first day of the week, rules corresponding to %V) using the
locale's alternative numeric symbols.
%Ow
Replaced by the number of the weekday (Sunday=0) using the locale's alternative numeric symbols.
%OW
Replaced by the week number of the year (Monday as the first day of the week) using the locale's alternative numeric
symbols.
%Oy
Replaced by the year (offset from %C) using the locale's alternative numeric symbols.
%g, %G, and %V give values according to the ISO 8601:2019 standard week-based year. In this
system, weeks begin on a Monday and week 1 of the year is the week that includes January 4th, which is also the week that includes
the first Thursday of the year, and is also the first week that contains at least four days in the year. If the first Monday of
January is the 2nd, 3rd, or 4th, the preceding days are part of the last week of the preceding year; thus, for Saturday 2nd January
1999, %G is replaced by 1998 and %V is replaced by 53. If December 29th, 30th, or 31st is a Monday, it and any
following days are part of week 1 of the following year. Thus, for Tuesday 30th December 1997, %G is replaced by 1998 and
%V is replaced by 01.
If a conversion specifier is not one of the above, the behavior is undefined.
[CX]  The
behavior is undefined if the locale argument to strftime_l() is the special locale object LC_GLOBAL_LOCALE or is not
a valid locale object handle.
RETURN VALUE
If successful, these functions shall return the number of bytes placed into the array pointed to by s, not including the
terminating NUL character. [CX]  If successful, errno shall not be changed.  Otherwise, 0 shall be returned, [CX]   errno shall be set to indicate the error,  and the contents of the array are unspecified.
ERRORS
[CX]
These functions shall fail if:
[ERANGE]
The total number of resulting bytes including the terminating NUL character is more than maxsize.
These functions may fail if:
[EINVAL]
The format string includes a %s conversion and the number of seconds since the Epoch would be negative.
[EOVERFLOW]
The format string includes a %s conversion and the number of seconds since the Epoch cannot be represented in a
time_t.
The following sections are informative.
EXAMPLES
Getting a Localized Date String
The following example first sets the locale to the user's default. The locale information will be used in the nl_langinfo() and strftime() functions. The nl_langinfo() function returns the localized date string which specifies how the date is
laid out. The strftime() function takes this information and, using the tm structure for values, places the date and
time information into datestring.
#include
#include
#include
...
struct tm *tm;
char datestring[256];
...
setlocale (LC_ALL, "");
...
strftime (datestring, sizeof(datestring), nl_langinfo (D_T_FMT), tm);
...
APPLICATION USAGE
A return value of 0 may indicate either success or failure if a format is the empty string or consists of conversion
specifications such as %p or %Z that are replaced by no characters in the current locale or because of the
current setting of tzname[], respectively. To distinguish between success and failure when strftime() returns 0, an
application can set errno to 0 before calling strftime() and test whether errno is 0 afterwards.
The range of values for %S is [00,60] rather than [00,59] to allow for the occasional leap second.
Some of the conversion specifications are duplicates of others. They are included for compatibility with nl_cxtime() and
nl_ascxtime(), which were published in Issue 2.
The %C, %F, %G, and %Y format specifiers in strftime() always print full values, but
the strptime() %C, %F, and %Y format specifiers only
scan two digits (assumed to be the first two digits of a four-digit year) for %C and four digits (assumed to be the entire
(four-digit) year) for %F and %Y. This mimics the behavior of printf() and scanf(); that is:
printf("%2d", x = 1000);
prints "1000", but:
scanf(%2d", &x);
when given "1000" as input will only store 10 in x). Applications using extended ranges of years must be sure
that the number of digits specified for scanning years with strptime() matches the
number of digits that will actually be present in the input stream. Historic implementations of the %Y conversion
specification (with no flags and no minimum field width) produced different output formats. Some always produced at least four
digits (with 0 fill for years from 0 through 999) while others only produced the number of digits present in the year (with no fill
and no padding). These two forms can be produced with the '0' flag and a minimum field width options using the conversions
specifications %04Y and %01Y, respectively. Similarly, because %Y is part of %F, field widths
of 10 and 7 (%010F, %07F), respectively, produce the same effect in the year portion of the %F
conversion result.
In the past, the C and POSIX standards specified that %F produced an ISO 8601:2019 standard date format, but
didn't specify which one. For years in the range [1000,9999], POSIX.1-2024 requires that the output produced match the
ISO 8601:2019 standard complete representation extended format (YYYY-MM-DD) and for years greater than 9999 produce output
that matches the ISO 8601:2019 standard expanded representation extended format
±Y'-[Ywidth]u".15m''[Ywidth]u"-.15m'YYYY-MM-DD). For years less than 1000, %F is not required to produce an
ISO 8601:2019 standard format when used without specifying at least a minimum field width. As stated above, some
implementations pad %Y conversions with zeros to four digits, in which case %F produces an ISO 8601:2019
standard format; other implementations do not pad %Y with zeros, in which case %F does not produce an
ISO 8601:2019 standard format. To fully meet ISO 8601:2019 standard requirements, the producer and consumer must agree on
a date format that has a specific number of bytes reserved to hold the characters used to represent the years that is sufficiently
large to hold all values that will be shared. For example, the %+13F conversion specification will produce output matching
the format "±YYYYYY-MM-DD" (a leading '+' or '-' sign; a six-digit, 0-filled year; a '-'; a
two-digit, leading 0-filled month; another '-'; and the two-digit, leading 0-filled day within the month).
Note that if the year being printed is greater than 9999, the resulting string from the unadorned %F conversion
specifications will not conform to the ISO 8601:2019 standard extended format, complete representation for a date and will
instead be an extended format, expanded representation (presumably without the required agreement between the date's producer and
consumer).
In the C or POSIX locale, the E and O modifiers are ignored and the replacement strings for the following
specifiers are:
%a
The first three characters of %A.
%A
One of Sunday, Monday, ..., Saturday.
%b
The first three characters of %B.
%B
One of January, February, ..., December.
%c
Equivalent to %a %b %e %T %Y.
%p
One of AM or PM.
%r
Equivalent to %I:%M:%S %p.
%x
Equivalent to %m/%d/%y.
%X
Equivalent to %T.
%Z
Implementation-defined.
RATIONALE
The %Y conversion specification to strftime() was frequently assumed to be a four-digit year, but the ISO C
standard does not specify that %Y is restricted to any subset of allowed values from the tm_year field. Similarly,
the %C conversion specification was assumed to be a two-digit field and the first part of the output from the %F
conversion specification was assumed to be a four-digit field. Since tm_year is a signed int with a width of at least
32 bits and time_t is required to have a width of at least 64 bits (in conforming programming environments), these
assumptions no longer hold.
POSIX.1-2024 now allows the format specifications %0xC, %0xF, %0xG, and %0xY (where
'x' is a string of decimal digits used to specify printing and scanning of a string of x decimal digits) with
leading zero fill characters. Allowing applications to set the field width enables them to agree on the number of digits to be
printed and scanned in the ISO 8601:2019 standard expanded representation of a year (for %F, %G, and
%Y) or all but the last two digits of the year (for %C). This is based on a feature in some versions of GNU
libc's strftime(). The GNU version allows specifying space, zero, or no-fill characters in strftime() format
strings, but does not allow any flags to be specified in strptime() format strings.
These implementations also allow these flags to be specified for any numeric field. POSIX.1-2024 only requires the zero fill flag
('0') and only requires that it be recognized when processing %C, %F, %G, and %Y
specifications when a minimum field width is also specified. The '0' flag is the only flag needed to produce and scan the
ISO 8601:2019 standard year fields using the extended format forms. POSIX.1-2024 also allows applications to specify the same
flag and field width specifiers to be used in both strftime() and strptime()
format strings for symmetry. Systems may provide other flag characters and may accept flags in conjunction with conversion
specifiers other than %C, %F, %G, and %Y; but portable applications cannot depend on such
extensions.
POSIX.1-2024 now also allows the format specifications %+xC, %+xF, %+xG, and %+xY (where
'x' is a string of decimal digits used to specify printing and scanning of a string of 'x' decimal digits) with
leading zero fill characters and a leading '+' sign character if the year being converted is more than four digits or a
minimum field width is specified that allows room for more than four digits for the year. This allows date providers and consumers
to agree on a specific number of digits to represent a year as required by the ISO 8601:2019 standard expanded representation
formats. The expanded representation formats all require the year to begin with a leading '+' or '-' sign. (All
of these specifiers can also provide a leading '-' sign for negative years. Since negative years and the year 0 don't fit
well with the Gregorian or Julian calendars, the normal ranges of dates start with year 1. The ISO C standard allows
tm_year to assume values corresponding to years before year 1, but the use of such years provided unspecified results.)
Some earlier version of this standard specified that applications wanting to use strptime() to scan dates and times printed by strftime() should provide non-digit
characters between fields to separate years from months and days. It also supported %F to print and scan the
ISO 8601:2019 standard extended format, complete representation date for years 1 through 9999 (i.e., YYYY-MM-DD). However,
many applications were written to print (using strftime()) and scan (using strptime()) dates written using the basic format complete representation (four-digit years)
and truncated representation (two-digit years) specified by the ISO 8601:2019 standard representation of dates and times which
do not have any separation characters between fields. The ISO 8601:2019 standard also specifies basic format expanded
representation where the creator and consumer of these fields agree beforehand to represent years as leading zero-filled strings of
an agreed length of more than four digits to represent a year (again with no separation characters when year, month, and day are
all displayed). Applications producing and consuming expanded representations are encouraged to use the '+' flag and an
appropriate maximum field width to scan the year including the leading sign. Note that even without the '+' flag, years
less than zero may be represented with a leading  for %F, %G, and %Y conversion
specifications. Using negative years results in unspecified behavior.
If a format specification %+xF with the field width x greater than 11 is specified and the width is large enough
to display the full year, the output string produced will match the ISO 8601:2019 standard subclause 4.1.2.4 expanded
representation, extended format date representation for a specific day. (For years in the range [1,99999], %+12F is
sufficient for an agreed five-digit year with a leading sign using the ISO 8601:2019 standard expanded representation,
extended format for a specific day "±YYYYY-MM-DD".) Note also that years less than 0 may produce a leading
character ('-') when using %Y or %C whether or not the '0' or '+'
flags are used.
The difference between the '0' flag and the '+' flag is whether the leading '+' character will be
provided for years >9999 as required for the ISO 8601:2019 standard extended representation format containing a year. For
example:
Year
Conversion Specification
strftime() Output
strptime() Scan Back
1970
%Y
1970
1970
1970
%+4Y
1970
1970
27
%Y
27 or 0027
27
270
%Y
270 or 0270
270
270
%+4Y
0270
270
17
%C%y
0017
17
270
%C%y
0270
270
12345
%Y
12345
1234*
12345
%+4Y
+12345
123*
12345
%05Y
12345
12345
270
%+5Y or %+3C%y
+0270
270
12345
%+5Y or %+3C%y
+12345
1234*
12345
%06Y or %04C%y
012345
12345
12345
%+6Y or %+4C%y
+12345
12345
123456
%08Y or %06C%y
00123456
123456
123456
%+8Y or %+6C%y
+0123456
123456
In the cases above marked with a * in the strptime() scan back
field, the implied or specified number of characters scanned by strptime() was less
than the number of characters output by strftime() using the same format; so the remaining digits of the year were dropped
when the output date produced by strftime() was scanned back in by strptime().
FUTURE DIRECTIONS
None.
SEE ALSO
asctime(), clock(), ctime(), difftime(), futimens(), getdate(), gmtime(), localtime(), mktime(), strptime(), time(), tzset(), uselocale()
XBD 7.3.5 LC_TIME,
CHANGE HISTORY
First released in Issue 3.
Issue 5
The description of %OV is changed to be consistent with %V and defines Monday as the first day of the
week.
The description of %Oy is clarified.
Issue 6
Extensions beyond the ISO C standard are marked.
The Open Group Corrigendum U033/8 is applied. The %V conversion specifier is changed from "Otherwise, it
is week 53 of the previous year, and the next week is week 1" to "Otherwise, it is the last week of the previous year, and the
next week is week 1".
The following new requirements on POSIX implementations derive from alignment with the Single UNIX
Specification:
The %C, %D, %e, %h, %n, %r, %R, %t, and
%T conversion specifiers are added.
The modified conversion specifiers are added for consistency with the ISO POSIX-2 standard date utility.
The following changes are made for alignment with the ISO/IEC 9899:1999 standard:
The strftime() prototype is updated.
The DESCRIPTION is extensively revised.
The %z conversion specifier is added.
An example is added.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/60 is applied.
Issue 7
Austin Group Interpretation 1003.1-2001 #163 is applied.
The strftime_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part
4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0605 [283], XSH/TC1-2008/0606 [283], XSH/TC1-2008/0607 [193],
and XSH/TC1-2008/0608 [193] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0340 [584], XSH/TC2-2008/0341 [796], XSH/TC2-2008/0342 [584],
and XSH/TC2-2008/0343 [584] are applied.
Issue 8
Austin Group Defects 169, 1386, and 1612 are applied, adding the s conversion and requiring errno to be
unchanged on success and set on error.
Austin Group Defects 258 and 1166 are applied, adding the OB and Ob modified conversions.
Austin Group Defect 472 is applied, changing the description of the C conversion.
Austin Group Defect 739 is applied, changing the %F conversion to match the ISO C standard when no
flag and no minimum field width are specified.
Austin Group Defect 1125 is applied, changing "Local timezone information is used" to "Local timezone
information shall be set".
Austin Group Defect 1253 is applied, changing "daylight savings" to "daylight saving".
Austin Group Defect 1307 is applied, changing the r conversion in relation to locales that do not support
the 12-hour clock format.
Austin Group Defects 1313 and 1354 are applied, changing text relating to the ISO 8601:2019 standard in the
APPLICATION USAGE section.
Austin Group Defect 1462 is applied, changing the RATIONALE section.
Austin Group Defect 1533 is applied, adding tm_gmtoff and tm_zone to the tm structure.
Austin Group Defect 1562 is applied, clarifying that it is the application's responsibility to ensure that the
format is a character string, beginning and ending in its initial shift state, if any.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sprintf.html =====
fprintf
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
asprintf, dprintf, fprintf, printf, snprintf, sprintf — print formatted output
SYNOPSIS
#include
[CX]  int asprintf(char **restrict ptr, const char *restrict format,
...);
int dprintf(int fildes, const char *restrict format, ...);
int fprintf(FILE *restrict stream, const char *restrict format, ...);
int printf(const char *restrict format, ...);
int snprintf(char *restrict s, size_t n,
const char *restrict format, ...);
int sprintf(char *restrict s, const char *restrict format, ...);
DESCRIPTION
[CX]  Except for asprintf(), dprintf(), and the behavior of the %lc conversion when passed a null wide
character, the functionality described on this reference page is aligned with the ISO C standard. Any other conflict between
the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard for all fprintf(), printf(), snprintf(), and sprintf() functionality except in relation to the
%lc conversion when passed a null wide character.
The fprintf() function shall place output on the named output stream. The printf() function shall place
output on the standard output stream stdout. The sprintf() function shall place output followed by the null byte,
'\0', in consecutive bytes starting at *s; it is the user's responsibility to ensure that enough space is
available.
[CX]  The
asprintf() function shall be equivalent to sprintf(), except that the output string shall be written to dynamically
allocated memory, allocated as if by a call to malloc(), of sufficient length to hold
the resulting string, including a terminating null byte. If the call to asprintf() is successful, the address of this
dynamically allocated string shall be stored in the location referenced by ptr.
The dprintf() function shall be equivalent to the fprintf() function, except that dprintf() shall write
output to the file associated with the file descriptor specified by the fildes argument rather than place output on a
stream.
The snprintf() function shall be equivalent to sprintf(), with the addition of the n argument which limits
the number of bytes written to the buffer referred to by s. If n is zero, nothing shall be written and s may
be a null pointer. Otherwise, output bytes beyond the n-1st shall be discarded instead of being written to the array, and a
null byte is written at the end of the bytes actually written into the array.
If copying takes place between objects that overlap as a result of a call to sprintf() or snprintf(), the results
are undefined.
Each of these functions converts, formats, and prints its arguments under control of the format. The application shall
ensure that the format is a character string, beginning and ending in its initial shift state, if any. The format is composed of
zero or more directives: ordinary characters, which are simply copied to the output stream, and conversion
specifications, each of which shall result in the fetching of zero or more arguments. The results are undefined if there are
insufficient arguments for the format. If the format is exhausted while arguments remain, the excess arguments shall be evaluated
but are otherwise ignored.
[CX]
Conversions can be applied to the nth argument after the format in the argument list, rather than to the next unused
argument. In this case, the conversion specifier character % (see below) is replaced by the sequence
"%n$", where n is a decimal integer in the range [1,{NL_ARGMAX}], giving the position of the
argument in the argument list. This feature provides for the definition of format strings that select arguments in an order
appropriate to specific languages (see the EXAMPLES section).
The format can contain either numbered argument conversion specifications (that is, those introduced by
"%n$" and optionally containing the "*m$" forms of field width and precision), or
unnumbered argument conversion specifications (that is, those introduced by the % character and optionally containing the
* form of field width and precision), but not both. The only exception to this is that %% can be mixed with the
"%n$" form. The results of mixing numbered and unnumbered argument specifications in a format string are
undefined. When numbered argument specifications are used, specifying the Nth argument requires that all the leading
arguments, from the first to the (N-1)th, are specified in the format string.
In format strings containing the "%n$" form of conversion specification, numbered arguments in the
argument list can be referenced from the format string as many times as required.
In format strings containing the % form of conversion specification, each conversion specification uses the first
unused argument in the argument list.
[CX]  All
forms of the fprintf() functions allow for the insertion of a language-dependent radix character in the output string. The
radix character is defined in the current locale (category LC_NUMERIC ). In the POSIX locale, or in a locale where the radix
character is not defined, the radix character shall default to a  ('.').
Each conversion specification is introduced by the '%' character [CX]   or by the
character sequence "%n$",   after
which the following appear in sequence:
Zero or more flags (in any order), which modify the meaning of the conversion specification.
An optional minimum field width. If the converted value has fewer bytes than the field width, it shall be padded with
characters by default on the left; it shall be padded on the right if the left-adjustment flag ('-'),
described below, is given to the field width. The field width takes the form of an  ('*'), [CX]   or in
conversion specifications introduced by "%n$" the "*m$" string,  described below, or a decimal integer.
An optional precision that gives the minimum number of digits to appear for the d, i, o,
u, x, and X conversion specifiers; the number of digits to appear after the radix character for the
a, A, e, E, f, and F conversion specifiers; the maximum number of significant
digits for the g and G conversion specifiers; or the maximum number of bytes to be printed from a string in the
s [XSI]   and S   conversion specifiers. The
precision takes the form of a  ('.') followed either by an  ('*'), [CX]   or in
conversion specifications introduced by "%n$" the "*m$" string,  described below, or an optional decimal digit string, where a null digit
string is treated as zero. If a precision appears with any other conversion specifier, the behavior is undefined.
An optional length modifier that specifies the size of the argument.
A conversion specifier character that indicates the type of conversion to be applied.
A field width, or precision, or both, may be indicated by an  ('*'). In this case an argument of type
int supplies the field width or precision. Applications shall ensure that arguments specifying field width, or precision, or
both appear in that order before the argument, if any, to be converted. A negative field width is taken as a '-' flag
followed by a positive field width. A negative precision is taken as if the precision were omitted. [CX]   In format
strings containing conversion specifications introduced by "%n$", in addition to being indicated by the
decimal digit string, a field width may be indicated by the sequence "*m$" and precision by the sequence
".*m$", where m is a decimal integer in the range [1,{NL_ARGMAX}] giving the position in the
argument list (after the format argument) of an integer argument containing the field width or precision, for example:
printf("%1$d:%2$.*3$d:%4$.*3$d\n", hour, min, precision, sec);
The flag characters and their meanings are:
'
[CX]
(The .) The integer portion of the result of a decimal conversion (%i, %d, %u,
%f, %F, %g, or %G) shall be formatted with thousands' grouping characters. For other
conversions the behavior is undefined. The non-monetary grouping character is used.
-
The result of the conversion shall be left-justified within the field. The conversion is right-justified if this flag is not
specified.
+
The result of a signed conversion shall always begin with a sign ('+' or '-'). The conversion shall begin
with a sign only when a negative value is converted if this flag is not specified.
If the first character of a signed conversion is not a sign or if a signed conversion results in no characters, a
shall be prefixed to the result. This means that if the  and '+' flags both appear, the  flag
shall be ignored.
#
Specifies that the value is to be converted to an alternative form. For o conversion, it shall increase the precision,
if and only if necessary, to force the first digit of the result to be a zero (if the value and precision are both 0, a single 0 is
printed). For x or X conversion specifiers, a non-zero result shall have 0x (or 0X) prefixed to it. For
a, A, e, E, f, F, g, and G conversion specifiers, the
result shall always contain a radix character, even if no digits follow the radix character. Without this flag, a radix character
appears in the result of these conversions only if a digit follows it. For g and G conversion specifiers,
trailing zeros shall not be removed from the result as they normally are. For other conversion specifiers, the behavior is
undefined.
0
For d, i, o, u, x, X, a, A, e, E,
f, F, g, and G conversion specifiers, leading zeros (following any indication of sign or base)
are used to pad to the field width rather than performing space padding, except when converting an infinity or NaN. If the
'0' and '-' flags both appear, the '0' flag is ignored. For d, i, o,
u, x, and X conversion specifiers, if a precision is specified, the '0' flag shall be ignored.
[CX]
If the '0' and  flags both appear, the grouping characters are inserted before zero padding. For
other conversions, the behavior is undefined.
The length modifiers and their meanings are:
hh
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to a signed char or unsigned char argument (the argument will have been promoted according to the integer
promotions, but its value shall be converted to signed char or unsigned char before printing); or that a following
n conversion specifier applies to a pointer to a signed char argument.
h
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to a short or unsigned short argument (the argument will have been promoted according to the integer
promotions, but its value shall be converted to short or unsigned short before printing); or that a following
n conversion specifier applies to a pointer to a short argument.
l (ell)
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to a long or unsigned long argument; that a following n conversion specifier applies to a pointer to
a long argument; that a following c conversion specifier applies to a wint_t argument; that a following
s conversion specifier applies to a pointer to a wchar_t argument; or has no effect on a following a,
A, e, E, f, F, g, or G conversion specifier.
ll (ell-ell)
Specifies that a following d, i, o, u, x, or X conversion specifier applies
to a long long or unsigned long long argument; or that a following n conversion specifier applies to a
pointer to a long long argument.
j
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to an intmax_t or uintmax_t argument; or that a following n conversion specifier applies to a
pointer to an intmax_t argument.
z
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to a size_t or the corresponding signed integer type argument; or that a following n conversion specifier
applies to a pointer to a signed integer type corresponding to a size_t argument.
t
Specifies that a following d, i, o, u, x, or X conversion specifier
applies to a ptrdiff_t or the corresponding unsigned type argument; or that a following n conversion
specifier applies to a pointer to a ptrdiff_t argument.
L
Specifies that a following a, A, e, E, f, F, g, or G
conversion specifier applies to a long double argument.
If a length modifier appears with any conversion specifier other than as specified above, the behavior is undefined.
The conversion specifiers and their meanings are:
d, i
The int argument shall be converted to a signed decimal in the style "[-]dddd". The precision
specifies the minimum number of digits to appear; if the value being converted can be represented in fewer digits, it shall be
expanded with leading zeros. The default precision is 1. The result of converting zero with an explicit precision of zero shall be
no characters.
o
The unsigned argument shall be converted to unsigned octal format in the style "dddd". The
precision specifies the minimum number of digits to appear; if the value being converted can be represented in fewer digits, it
shall be expanded with leading zeros. The default precision is 1. The result of converting zero with an explicit precision of zero
shall be no characters.
u
The unsigned argument shall be converted to unsigned decimal format in the style "dddd". The
precision specifies the minimum number of digits to appear; if the value being converted can be represented in fewer digits, it
shall be expanded with leading zeros. The default precision is 1. The result of converting zero with an explicit precision of zero
shall be no characters.
x
The unsigned argument shall be converted to unsigned hexadecimal format in the style "dddd";
the letters "abcdef" are used. The precision specifies the minimum number of digits to appear; if the value being
converted can be represented in fewer digits, it shall be expanded with leading zeros. The default precision is 1. The result of
converting zero with an explicit precision of zero shall be no characters.
X
Equivalent to the x conversion specifier, except that letters "ABCDEF" are used instead of
"abcdef".
f, F
The double argument shall be converted to decimal notation in the style
"[-]ddd.ddd", where the number of digits after the radix character is equal to the
precision specification. If the precision is missing, it shall be taken as 6; if the precision is explicitly zero and no
'#' flag is present, no radix character shall appear. If a radix character appears, at least one digit appears before it.
The low-order digit shall be rounded in an implementation-defined manner.
A double argument representing an infinity shall be converted in one of the styles "[-]inf" or
"[-]infinity"; which style is implementation-defined. A double argument representing a NaN shall be converted in
one of the styles "[-]nan(n-char-sequence)" or "[-]nan"; which style, and the meaning of any
n-char-sequence, is implementation-defined. The F conversion specifier produces "INF",
"INFINITY", or "NAN" instead of "inf", "infinity", or "nan", respectively.
e, E
The double argument shall be converted in the style
"[-]d.ddde±dd", where there is one digit before the radix character (which
is non-zero if the argument is non-zero) and the number of digits after it is equal to the precision; if the precision is missing,
it shall be taken as 6; if the precision is zero and no '#' flag is present, no radix character shall appear. The
low-order digit shall be rounded in an implementation-defined manner. The E conversion specifier shall produce a number
with 'E' instead of 'e' introducing the exponent. The exponent shall always contain at least two digits. If the
value is zero, the exponent shall be zero.
A double argument representing an infinity or NaN shall be converted in the style of an f or F
conversion specifier.
g, G
The double argument representing a floating-point number shall be converted in the style f or e (or in
the style F or E in the case of a G conversion specifier), depending on the value converted and the
precision. Let P equal the precision if non-zero, 6 if the precision is omitted, or 1 if the precision is zero. Then, if a
conversion with style E would have an exponent of X:
If P>X>=-4, the conversion shall be with style f (or F) and precision
P-(X+1).
Otherwise, the conversion shall be with style e (or E) and precision P-1.
Finally, unless the '#' flag is used, any trailing zeros shall be removed from the fractional portion of the result and
the decimal-point character shall be removed if there is no fractional portion remaining.
A double argument representing an infinity or NaN shall be converted in the style of an f or F
conversion specifier.
a, A
A double argument representing a floating-point number shall be converted in the style
"[-]0xh.hhhhp±d", where there is one hexadecimal digit (which shall be
non-zero if the argument is a normalized floating-point number and is otherwise unspecified) before the decimal-point character and
the number of hexadecimal digits after it is equal to the precision; if the precision is missing and FLT_RADIX is a power of 2,
then the precision shall be sufficient for an exact representation of the value; if the precision is missing and FLT_RADIX is not a
power of 2, then the precision shall be sufficient to distinguish values of type double, except that trailing zeros may be
omitted; if the precision is zero and the '#' flag is not specified, no decimal-point character shall appear. The letters
"abcdef" shall be used for a conversion and the letters "ABCDEF" for A conversion. The
A conversion specifier produces a number with 'X' and 'P' instead of 'x' and 'p'. The
exponent shall always contain at least one digit, and only as many more digits as necessary to represent the decimal exponent of 2.
If the value is zero, the exponent shall be zero.
A double argument representing an infinity or NaN shall be converted in the style of an f or F
conversion specifier.
c
The int argument shall be converted to an unsigned char, and the resulting byte shall be written.
If an l (ell) qualifier is present, [CX]   the wint_t argument shall be converted to a multi-byte
sequence as if by a call to wcrtomb() with a pointer to storage of at least
MB_CUR_MAX bytes, the wint_t argument converted to wchar_t, and an initial shift state, and the resulting byte(s)
written.
s
The argument shall be a pointer to an array of char. Bytes from the array shall be written up to (but not including) any
terminating null byte. If the precision is specified, no more than that many bytes shall be written. If the precision is not
specified or is greater than the size of the array, the application shall ensure that the array contains a null byte.
If an l (ell) qualifier is present, the argument shall be a pointer to an array of type wchar_t. Wide characters
from the array shall be converted to characters (each as if by a call to the wcrtomb() function, with the conversion state described by an mbstate_t object
initialized to zero before the first wide character is converted) up to and including a terminating null wide character. The
resulting characters shall be written up to (but not including) the terminating null character (byte). If no precision is
specified, the application shall ensure that the array contains a null wide character. If a precision is specified, no more than
that many characters (bytes) shall be written (including shift sequences, if any), and the array shall contain a null wide
character if, to equal the character sequence length given by the precision, the function would need to access a wide character one
past the end of the array. In no case shall a partial character be written.
p
The argument shall be a pointer to void. The value of the pointer is converted to a sequence of printable characters, in
an implementation-defined manner.
n
The argument shall be a pointer to an integer into which is written the number of bytes written to the output so far by this
call to one of the fprintf() functions. No argument is converted.
C
[XSI]
Equivalent to lc.
S
[XSI]
Equivalent to ls.
%
Write a '%' character; no argument shall be converted. The application shall ensure that the complete conversion
specification is %%.
If a conversion specification does not match one of the above forms, the behavior is undefined. If any argument is not the
correct type for the corresponding conversion specification, the behavior is undefined.
In no case shall a nonexistent or small field width cause truncation of a field; if the result of a conversion is wider than the
field width, the field shall be expanded to contain the conversion result. Characters generated by fprintf() and
printf() are printed as if fputc() had been called.
For the a and A conversion specifiers, if FLT_RADIX is a power of 2, the value shall be correctly rounded to a
hexadecimal floating number with the given precision.
For a and A conversions, if FLT_RADIX is not a power of 2 and the result is not exactly representable in the
given precision, the result should be one of the two adjacent numbers in hexadecimal floating style with the given precision, with
the extra stipulation that the error should have a correct sign for the current rounding direction.
For the e, E, f, F, g, and G conversion specifiers, if the number of
significant decimal digits is at most DECIMAL_DIG, then the result should be correctly rounded. If the number of significant
decimal digits is more than DECIMAL_DIG but the source value is exactly representable with DECIMAL_DIG digits, then the result
should be an exact representation with trailing zeros. Otherwise, the source value is bounded by two adjacent decimal strings
L
#include
#include
#include
char *strperm (mode_t);
...
struct stat statbuf;
struct passwd *pwd;
struct group *grp;
...
printf("%10.10s", strperm (statbuf.st_mode));
printf("%4d", statbuf.st_nlink);
if ((pwd = getpwuid(statbuf.st_uid)) != NULL)
printf(" %-8.8s", pwd->pw_name);
else
printf(" %-8ld", (long) statbuf.st_uid);
if ((grp = getgrgid(statbuf.st_gid)) != NULL)
printf(" %-8.8s", grp->gr_name);
else
printf(" %-8ld", (long) statbuf.st_gid);
printf("%9jd", (intmax_t) statbuf.st_size);
...
Printing a Localized Date String
The following example gets a localized date string. The nl_langinfo()
function shall return the localized date string, which specifies the order and layout of the date. The strftime() function takes this information and, using the tm structure for values,
places the date and time information into datestring. The printf() function then outputs datestring and the
name of the entry.
#include
#include
#include
...
struct dirent *dp;
struct tm *tm;
char datestring[256];
...
strftime(datestring, sizeof(datestring), nl_langinfo (D_T_FMT), tm);
printf(" %s %s\n", datestring, dp->d_name);
...
Printing Error Information
The following example uses fprintf() to write error information to standard error.
In the first group of calls, the program tries to open the password lock file named LOCKFILE. If the file already exists,
this is an error, as indicated by the O_EXCL flag on the open() function. If the call
fails, the program assumes that someone else is updating the password file, and the program exits.
The next group of calls saves a new password file as the current password file by creating a link between LOCKFILE and
the new password file PASSWDFILE.
#include
#include
#include
#include
#include
#include
#include
#include
#define LOCKFILE "/etc/ptmp"
#define PASSWDFILE "/etc/passwd"
...
int pfd;
...
if ((pfd = open(LOCKFILE, O_WRONLY | O_CREAT | O_EXCL,
S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) == -1)
{
fprintf(stderr, "Cannot open /etc/ptmp. Try again later.\n");
exit(1);
}
...
if (link(LOCKFILE,PASSWDFILE) == -1) {
fprintf(stderr, "Link error: %s\n", strerror(errno));
exit(1);
}
...
Printing Usage Information
The following example checks to make sure the program has the necessary arguments, and uses fprintf() to print usage
information if the expected number of arguments is not present.
#include
#include
...
char *Options = "hdbtl";
...
if (argc  ('*') in the format
string; this ensures the correct number of decimal places for the element based on the number of elements requested.
#include
...
long i;
char *keystr;
int elementlen, len;
...
while (len
#include
#include
#include
#include
#include
...
char *pathname;
struct passwd *pw;
size_t len;
...
// digits required for pid_t is number of bits times
// log2(10) = approx 10/33
len = strlen(pw->pw_dir) + 1 + 1+(sizeof(pid_t)*80+32)/33 +
sizeof ".out";
pathname = malloc(len);
if (pathname != NULL)
{
snprintf(pathname, len, "%s/%jd.out", pw->pw_dir,
(intmax_t)getpid());
...
}
Reporting an Event
The following example loops until an event has timed out. The pause() function
waits forever unless it receives a signal. The fprintf() statement should never occur due to the possible return values of
pause().
#include
#include
#include
#include
...
while (!event_complete) {
...
if (pause() != -1 || errno != EINTR)
fprintf(stderr, "pause: unknown error: %s\n", strerror(errno));
}
...
Printing Monetary Information
The following example uses strfmon() to convert a number and store it as a
formatted monetary string named convbuf. If the first number is printed, the program prints the format and the description;
otherwise, it just prints the number.
#include
#include
...
struct tblfmt {
char *format;
char *description;
};
struct tblfmt table[] = {
{ "%n", "default formatting" },
{ "%11n", "right align within an 11 character field" },
{ "%#5n", "aligned columns for values up to 99999" },
{ "%=*#5n", "specify a fill character" },
{ "%=0#5n", "fill characters do not use grouping" },
{ "%^#5n", "disable the grouping separator" },
{ "%^#5.0n", "round off to whole units" },
{ "%^#5.4n", "increase the precision" },
{ "%(#5n", "use an alternative pos/neg style" },
{ "%!(#5n", "disable the currency symbol" },
};
...
float input[3];
int i, j;
char convbuf[100];
...
strfmon(convbuf, sizeof(convbuf), table[i].format, input[j]);
if (j == 0) {
printf("%s  %s      %s\n", table[i].format,
convbuf, table[i].description);
}
else {
printf("    %s\n", convbuf);
}
...
Printing Wide Characters
The following example prints a series of wide characters. Suppose that "L`@`" expands to three bytes:
wchar_t wz [3] = L"@@";       // Zero-terminated
wchar_t wn [3] = L"@@@";      // Unterminated
fprintf (stdout,"%ls", wz);   // Outputs 6 bytes
fprintf (stdout,"%ls", wn);   // Undefined because wn has no terminator
fprintf (stdout,"%4ls", wz);  // Outputs 3 bytes
fprintf (stdout,"%4ls", wn);  // Outputs 3 bytes; no terminator needed
fprintf (stdout,"%9ls", wz);  // Outputs 6 bytes
fprintf (stdout,"%9ls", wn);  // Outputs 9 bytes; no terminator needed
fprintf (stdout,"%10ls", wz); // Outputs 6 bytes
fprintf (stdout,"%10ls", wn); // Undefined because wn has no terminator
In the last line of the example, after processing three characters, nine bytes have been output. The fourth character must then
be examined to determine whether it converts to one byte or more. If it converts to more than one byte, the output is only nine
bytes. Since there is no fourth character in the array, the behavior is undefined.
APPLICATION USAGE
If the application calling fprintf() has any objects of type wint_t or wchar_t, it must also include the
header to have these objects defined.
The space allocated by a successful call to asprintf() should be subsequently freed by a call to free().
RATIONALE
If an implementation detects that there are insufficient arguments for the format, it is recommended that the function should
fail and report an [EINVAL] error.
The behavior specified for the %lc conversion differs slightly from the specification in the ISO C standard, in
that printing the null wide character produces a null byte instead of 0 bytes of output as would be required by a strict reading of
the ISO C standard's direction to behave as if applying the %ls specifier to a wchar_t array whose first
element is the null wide character. Requiring a multi-byte output for every possible wide character, including the null character,
matches historical practice, and provides consistency with %c in fprintf() and with both %c and
%lc in fwprintf(). It is anticipated that a future edition of the
ISO C standard will change to match the behavior specified here.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, fputc(), fscanf(), setlocale(), strfmon(), strlcat(), wcrtomb(), wcslcat()
XBD 7. Locale, , ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
Aligned with ISO/IEC 9899:1990/Amendment 1:1995 (E). Specifically, the l (ell) qualifier can now be used with
c and s conversion specifiers.
The snprintf() function is new in Issue 5.
Issue 6
Extensions beyond the ISO C standard are marked.
The normative text is updated to avoid use of the term "must" for application requirements.
The following changes are made for alignment with the ISO/IEC 9899:1999 standard:
The prototypes for fprintf(), printf(), snprintf(), and sprintf() are updated, and the XSI shading
is removed from snprintf().
The description of snprintf() is aligned with the ISO C standard. Note that this supersedes the snprintf()
description in The Open Group Base Resolution bwg98-006, which changed the behavior from Issue 5.
The DESCRIPTION is updated.
The DESCRIPTION is updated to use the terms "conversion specifier" and "conversion specification" consistently.
ISO/IEC 9899:1999 standard, Technical Corrigendum 1 is incorporated.
An example of printing wide characters is added.
Issue 7
Austin Group Interpretation 1003.1-2001 #161 is applied, updating the DESCRIPTION of the 0 flag.
Austin Group Interpretation 1003.1-2001 #170 is applied.
ISO/IEC 9899:1999 standard, Technical Corrigendum 2 #68 (SD5-XSH-ERN-70) is applied, revising the description of g
and G.
SD5-XSH-ERN-174 is applied.
The dprintf() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 1.
Functionality relating to the %n$ form of conversion specification and the  flag is moved from the
XSI option to the Base.
Changes are made related to support for finegrained timestamps.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0163 [302], XSH/TC1-2008/0164 [316], XSH/TC1-2008/0165 [316],
XSH/TC1-2008/0166 [451,291], and XSH/TC1-2008/0167 [14] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0126 [894], XSH/TC2-2008/0127 [557], and XSH/TC2-2008/0128 [936] are
applied.
Issue 8
Austin Group Defect 986 is applied, adding strlcat() and wcslcat() to the SEE ALSO section.
Austin Group Defect 1020 is applied, clarifying that the snprintf() argument n limits the number of bytes written
to s; it is not necessarily the same as the size of s.
Austin Group Defect 1021 is applied, changing "output error" to "error" in the RETURN VALUE section.
Austin Group Defect 1137 is applied, clarifying the use of "%n$" and "*m$" in
conversion specifications.
Austin Group Defect 1205 is applied, changing the description of the % conversion specifier.
Austin Group Defect 1219 is applied, removing the snprintf()-specific [EOVERFLOW] error.
Austin Group Defect 1496 is applied, adding the asprintf() function.
Austin Group Defect 1562 is applied, clarifying that it is the application's responsibility to ensure that the format is a
character string, beginning and ending in its initial shift state, if any.
Austin Group Defect 1647 is applied, changing the description of the c conversion specifier and updating the statement
that this volume of POSIX.1-2024 defers to the ISO C standard so that it excludes the %lc conversion when passed a
null wide character.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_once.html =====
pthread_once
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_once — dynamic package initialization
SYNOPSIS
#include
int pthread_once(pthread_once_t *once_control,
void (*init_routine)(void));
pthread_once_t once_control = PTHREAD_ONCE_INIT;
DESCRIPTION
The first call to pthread_once() by any thread in a process, with a given once_control, shall call the
init_routine with no arguments. Subsequent calls of pthread_once() with the same once_control shall not call
the init_routine. On return from pthread_once(), init_routine shall have completed. The once_control
parameter shall determine whether the associated initialization routine has been called.
The pthread_once() function is not a cancellation point. However, if init_routine is a cancellation point and is
canceled, the effect on once_control shall be as if pthread_once() was never called.
If the call to init_routine is terminated by a call to longjmp() or
siglongjmp(), the behavior is undefined.
The constant PTHREAD_ONCE_INIT is defined in the  header.
The behavior of pthread_once() is undefined if once_control has automatic storage duration or is not initialized
by PTHREAD_ONCE_INIT.
RETURN VALUE
Upon successful completion, pthread_once() shall return zero; otherwise, an error number shall be returned to indicate
the error.
ERRORS
The pthread_once() function shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
If init_routine recursively calls pthread_once() with the same once_control, the recursive call will not
call the specified init_routine, and thus the specified init_routine will not complete, and thus the recursive call
to pthread_once() will not return. Use of longjmp() or siglongjmp() within an init_routine to jump to a point outside of
init_routine prevents init_routine from returning.
RATIONALE
Some C libraries are designed for dynamic initialization. That is, the global initialization for the library is performed when
the first procedure in the library is called. In a single-threaded program, this is normally implemented using a static variable
whose value is checked on entry to a routine, as follows:
static int random_is_initialized = 0;
extern void initialize_random(void);
int random_function()
{
if (random_is_initialized == 0) {
initialize_random();
random_is_initialized = 1;
}
... /* Operations performed after initialization. */
}
To keep the same structure in a multi-threaded program, a new primitive is needed. Otherwise, library initialization has to be
accomplished by an explicit call to a library-exported initialization function prior to any use of the library.
For dynamic library initialization in a multi-threaded process, if an initialization flag is used the flag needs to be protected
against modification by multiple threads simultaneously calling into the library. This can be done by using a mutex (initialized by
assigning PTHREAD_MUTEX_INITIALIZER). However, the better solution is to use pthread_once() which is designed for exactly
this purpose, as follows:
#include
static pthread_once_t random_is_initialized = PTHREAD_ONCE_INIT;
extern void initialize_random(void);
int random_function()
{
(void) pthread_once(&random_is_initialized, initialize_random);
... /* Operations performed after initialization. */
}
If an implementation detects that the value specified by the once_control argument to pthread_once() does not
refer to a pthread_once_t object initialized by PTHREAD_ONCE_INIT, it is recommended that the function should fail and
report an [EINVAL] error.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
The pthread_once() function is marked as part of the Threads option.
The [EINVAL] error is added as a "may fail" case for if either argument is invalid.
Issue 7
The pthread_once() function is moved from the Threads option to the Base.
The [EINVAL] error for an uninitialized pthread_once_t object is removed; this condition results in undefined
behavior.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0284 [863], XSH/TC2-2008/0285 [874], XSH/TC2-2008/0286 [874], and
XSH/TC2-2008/0287 [747] are applied.
Issue 8
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_rwlockattr_setpshared.html =====
pthread_rwlockattr_getpshared
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_rwlockattr_getpshared, pthread_rwlockattr_setpshared — get and set the process-shared attribute of the
read-write lock attributes object
SYNOPSIS
[TSH]  #include
int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t
*restrict attr, int *restrict pshared);
int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *attr,
int pshared);
DESCRIPTION
The pthread_rwlockattr_getpshared() function shall obtain the value of the process-shared attribute from the
initialized attributes object referenced by attr. The pthread_rwlockattr_setpshared() function shall set the
process-shared attribute in an initialized attributes object referenced by attr.
The process-shared attribute shall be set to PTHREAD_PROCESS_SHARED to permit a read-write lock to be operated upon by
any thread that has access to the memory where the read-write lock is allocated, even if the read-write lock is allocated in memory
that is shared by multiple processes. See 2.9.9 Synchronization Object Copies
and Alternative Mappings for further requirements. The default value of the process-shared attribute shall be
PTHREAD_PROCESS_PRIVATE.
Additional attributes, their default values, and the names of the associated functions to get and set those attribute values are
implementation-defined.
The behavior is undefined if the value specified by the attr argument to pthread_rwlockattr_getpshared() or
pthread_rwlockattr_setpshared() does not refer to an initialized read-write lock attributes object.
RETURN VALUE
Upon successful completion, the pthread_rwlockattr_getpshared() function shall return zero and store the value of the
process-shared attribute of attr into the object referenced by the pshared parameter. Otherwise, an error
number shall be returned to indicate the error.
If successful, the pthread_rwlockattr_setpshared() function shall return zero; otherwise, an error number shall be
returned to indicate the error.
ERRORS
The pthread_rwlockattr_setpshared() function may fail if:
[EINVAL]
The new value specified for the attribute is outside the range of legal values for that attribute.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_rwlock_destroy(), pthread_rwlockattr_destroy()
XBD
CHANGE HISTORY
First released in Issue 5.
Issue 6
The following changes are made for alignment with IEEE Std 1003.1j-2000:
The margin code in the SYNOPSIS is changed to THR TSH to indicate that the functionality is now part of the Threads option
(previously it was part of the Read-Write Locks option in IEEE Std 1003.1j-2000 and also part of the XSI extension).
The DESCRIPTION notes that additional attributes are implementation-defined.
The SEE ALSO section is updated.
The restrict keyword is added to the pthread_rwlockattr_getpshared() prototype for alignment with the
ISO/IEC 9899:1999 standard.
Issue 7
The pthread_rwlockattr_getpshared() and pthread_rwlockattr_setpshared() functions are marked only as part of the
Thread Process-Shared Synchronization option as the Threads option is now part of the Base.
The [EINVAL] error for an uninitialized read-write lock attributes object is removed; this condition results in undefined
behavior.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0292 [972] and XSH/TC2-2008/0293 [757] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/log2.html =====
log2
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
log2, log2f, log2l — compute base 2 logarithm functions
SYNOPSIS
#include
double log2(double x);
float log2f(float x);
long double log2l(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the base 2 logarithm of their argument x, log2(x).
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the base 2 logarithm of x.
If x is ±0, a pole error shall occur and log2(), log2f(), and log2l() shall return -HUGE_VAL,
-HUGE_VALF, and -HUGE_VALL, respectively.
For finite values of x that are less than 0, [MX]   or if x is -Inf,  a domain error shall occur, and [MX]   either a NaN (if supported), or   an implementation-defined value shall be returned.
[MX]  If
x is NaN, a NaN shall be returned.
If x is 1, +0 shall be returned.
If x is +Inf, x shall be returned.
ERRORS
These functions shall fail if:
Domain Error
The finite value of x is less than zero, [MX]   or x is -Inf.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
Pole Error
The value of x is zero.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the divide-by-zero floating-point exception shall
be raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), log()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fopen.html =====
fopen
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fopen — open a stream
SYNOPSIS
#include
FILE *fopen(const char *restrict pathname, const char *restrict mode);
DESCRIPTION
[CX]  Except for the "exclusive access" requirement (see below), the functionality described on this reference page is
aligned with the ISO C standard. Any other conflict between the requirements described here and the ISO C standard is
unintentional. This volume of POSIX.1-2024 defers to the ISO C standard for all fopen() functionality except in
relation to "exclusive access".
The fopen() function shall open the file whose pathname is the string pointed to by pathname, and associates a
stream with it.
The mode argument points to a character string. The behavior is unspecified if any character occurs more than once in the
string. If the string begins with one of the following characters, then the file shall be opened in the indicated mode. Otherwise,
the behavior is undefined.
'r'
Open file for reading.
'w'
Truncate to zero length or create file for writing.
'a'
Append; open or create file for writing at end-of-file.
The remainder of the string can contain any of the following characters, [CX]   in any order,
and further affect how the file is opened:
'b'
[CX]
This character shall have no effect, but is allowed for ISO C standard conformance.
'e'
[CX]
The underlying file descriptor shall have the FD_CLOEXEC flag atomically set.
'x'
If the first character of mode is 'w' [CX]   or 'a',  then the function shall fail if the file already exists, or cannot be created; if the file does not
exist and can be created, it shall be created with [CX]   an implementation-defined form of   exclusive (also known as non-shared) access,
[CX]  if
supported by the underlying file system, provided the resulting file permissions are the same as they would be without the
'x' modifier. If the first character of mode is 'r', the effect is implementation-defined.
Note:
The ISO C standard requires exclusive access "to the extent that the underlying file system supports exclusive access",
but does not define what it means by this. Taken at face value—that systems must do whatever they are capable of, at the file
system level, in order to exclude access by others—this would require POSIX.1 systems to set the file permissions in a way that
prevents access by other users and groups. Consequently, this volume of POSIX.1-2024 does not defer to the ISO C standard as
regards the "exclusive access" requirement.
'+'
The file shall be opened for update (both reading and writing), rather than just reading or just writing.
Opening a file with read mode ('r' as the first character in the mode argument) shall fail if the file does not
exist or cannot be read.
Opening a file with append mode ('a' as the first character in the mode argument) shall cause all subsequent
writes to the file to be forced to the then current end-of-file, regardless of intervening calls to fseek().
When a file is opened with update mode ('+' in the mode argument), both input and output can be performed on the
associated stream. However, the application shall ensure that output is not directly followed by input without an intervening call
to fflush() or to a file positioning function (fseek(), fsetpos(), or rewind()), and input is not directly followed by output without an intervening call to a file
positioning function, unless the input operation encounters end-of-file.
When opened, a stream is fully buffered if and only if it can be determined not to refer to an interactive device. The error and
end-of-file indicators for the stream shall be cleared.
[CX]  If
the first character in mode is 'w' or 'a' and the file did not previously exist, upon successful
completion, fopen() shall mark for update the last data access, last data modification, and last file status change
timestamps of the file and the last file status change and last data modification timestamps of the parent directory.
If the first character in mode is 'w' or 'a' and the file did not previously exist, the fopen()
function shall create a file as if it called the open() function with a value
appropriate for the path argument interpreted from pathname, a value for the oflag argument as specified
below, and a value of S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH for the third argument.
If the first character in mode is 'w' and the file did previously exist, upon successful completion,
fopen() shall mark for update the last data modification and last file status change timestamps of the file.
After a successful call to the fopen() function, the orientation of the stream shall be cleared, [XSI]   the encoding
rule shall be cleared,  and the associated mbstate_t object
shall be set to describe an initial conversion state.
[CX]  The
file descriptor associated with the opened stream shall be allocated and opened as if by a call to open() using the following flags:
fopen() Mode First Character
fopen() Mode Includes '+'
Initial open() Flags
'r'
no
O_RDONLY
'w'
no
O_WRONLY|O_CREAT|O_TRUNC
'a'
no
O_WRONLY|O_CREAT|O_APPEND
'r'
yes
O_RDWR
'w'
yes
O_RDWR|O_CREAT|O_TRUNC
'a'
yes
O_RDWR|O_CREAT|O_APPEND
If, and only if, the 'e' mode string character is specified, the O_CLOEXEC flag shall be OR'ed into
the initial open() flags specified in the above table.
If, and only if, the 'x' mode string character is specified together with either 'w' or
'a', the O_EXCL flag shall be OR'ed into the initial open() flags specified in
the above table.
If mode includes 'x' and the underlying file system supports exclusive access (see above) enabled
by the use of implementation-specific flags to open(), then the behavior shall be as if
those flags are also included.
When using mode strings specified by this standard, the implementation shall behave as if no other flags had
been passed to open().
RETURN VALUE
Upon successful completion, fopen() shall return a pointer to the object controlling the stream. Otherwise, a null
pointer shall be returned, [CX]   and errno shall be set to indicate the error.
ERRORS
The fopen() function shall fail if:
[EACCES]
[CX]
Search permission is denied on a component of the path prefix, or the file exists and the permissions specified by mode are
denied, or the file does not exist and write permission is denied for the parent directory of the file to be created.
[EEXIST]
[CX]
The mode argument begins with w or a and includes x, but the file already exists.
[EILSEQ]
[CX]
The mode argument begins with w or a, the file did not previously exist, and the last pathname component is
not a portable filename and cannot be created in the target directory.
[EINTR]
[CX]  A
signal was caught during fopen().
[EISDIR]
[CX]
The named file is a directory and mode requires write access.
[ELOOP]
[CX]  A
loop exists in symbolic links encountered during resolution of the pathname argument.
[EMFILE]
[CX]
All file descriptors available to the process are currently open.
[EMFILE]
[CX]
{STREAM_MAX} streams are currently open in the calling process.
[ENAMETOOLONG]
[CX]
The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a
length that exceeds {PATH_MAX}.
[ENFILE]
[CX]
The maximum allowable number of files is currently open in the system.
[ENOENT]
[CX]
The mode string begins with 'r' and a component of pathname does not name an existing file, or mode
begins with 'w' or 'a' and a component of the path prefix of pathname does not name an existing file, or
pathname is an empty string.
[ENOENT] or [ENOTDIR]
[CX]
The pathname argument contains at least one non- character and ends with one or more trailing
characters. If pathname without the trailing  characters would name an existing file, an [ENOENT] error shall
not occur.
[ENOSPC]
[CX]
The directory or file system that would contain the new file cannot be expanded, the file does not exist, and the file was to be
created.
[ENOTDIR]
[CX]  A
component of the path prefix names an existing file that is neither a directory nor a symbolic link to a directory, or the
pathname argument contains at least one non- character and ends with one or more trailing
characters and the last pathname component names an existing file that is neither a directory nor a symbolic link to a directory.
[ENXIO]
[CX]
The named file is a character special or block special file, and the device associated with this special file does not exist.
[EOVERFLOW]
[CX]
The named file is a regular file and the size of the file cannot be represented correctly in an object of type off_t.
[EROFS]
[CX]
The named file resides on a read-only file system and mode requires write access.
The fopen() function may fail if:
[EINVAL]
[CX]
The value of the mode argument is not valid.
[ELOOP]
[CX]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the pathname argument.
[EMFILE]
[CX]
{FOPEN_MAX} streams are currently open in the calling process.
[ENAMETOOLONG]
[CX]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOMEM]
[CX]
Insufficient storage space is available.
[ETXTBSY]
[CX]
The file is a pure procedure (shared text) file that is being executed and mode requires write access.
The following sections are informative.
EXAMPLES
Opening a File
The following example tries to open the file named file for reading. The fopen() function returns a
file pointer that is used in subsequent fgets() and fclose() calls. If the program cannot open the file, it just ignores it.
#include
...
FILE *fp;
...
void rgrep(const char *file)
{
...
if ((fp = fopen(file, "r")) == NULL)
return;
...
}
APPLICATION USAGE
If an application needs to create a file in a way that fails if the file already exists, and either requires that it does not
have exclusive access to the file or does not need exclusive access, it should use open() with the O_CREAT and O_EXCL flags instead of using fopen() with an 'x'
in the mode. A stream can then be created, if needed, by calling fdopen() on the file
descriptor returned by open().
RATIONALE
The 'e' mode character is provided as a convenience to avoid a data race in multi-threaded applications. Without it, a
file descriptor is leaked into a child process created by one thread in the window between another thread creating a file
descriptor with fopen() and then using fileno() and fcntl() to set the FD_CLOEXEC flag. It is also possible to avoid the race by using open() with O_CLOEXEC followed by fdopen(),
however, there is no safe alternative for the freopen() function, and consistency
dictates that the 'e' modifier should be standardized for all functions that accept mode strings.
The ISO C standard only recognizes the '+', 'b', and 'x' characters in certain
positions of the mode string, leaving other arrangements as unspecified, and only permits 'x' in mode
strings beginning with 'w'. This standard specifically requires support for all characters other than the first in the
mode string to be recognized in any order. Thus, "wxe" and "wex" behave the same, and while "wx+"
is unspecified in the ISO C standard, this standard requires it to have the same behavior as "w+x". This standard
also requires that 'x' work for mode strings beginning with 'a', as well as having implementation-defined
behavior for mode strings beginning with 'r'. Therefore, while open()
has undefined behavior if O_EXCL is specified without O_CREAT, the same is not true of fopen().
When 'x' is in mode, the ISO C standard requires that the file is created with exclusive access to
the extent that the underlying system supports exclusive access. Although POSIX.1 does not specify any method of enabling exclusive
access, it allows for the existence of an implementation-specific flag, or flags, that enable it. Note that they should be file
creation flags if a file is being created, not file access mode flags (that is, ones that are included in O_ACCMODE) or file status
flags, so that they do not affect the value returned by fcntl() with F_GETFL. On
implementations that have such flags, if support for them is file system dependent and exclusive access is requested when using
fopen() to create a file on a file system that does not support it, the flags must not be used if they would cause
fopen() to fail.
Some implementations support mandatory file locking as a means of enabling exclusive access to a file. Locks are
set in the normal way, but instead of only preventing others from setting conflicting locks they prevent others from accessing the
contents of the locked part of the file in a way that conflicts with the lock. However, unless the implementation has a way of
setting a whole-file write lock on file creation, this does not satisfy the requirement in the ISO C standard that the file is
"created with exclusive access to the extent that the underlying system supports exclusive access". (Having fopen() create
the file and set a lock on the file as two separate operations is not the same, and it would introduce a race condition whereby
another process could open the file and write to it (or set a lock) in between the two operations.) However, on all implementations
that support mandatory file locking, its use is discouraged; therefore, it is recommended that implementations which support
mandatory file locking do not add a means of creating a file with a whole-file exclusive lock set, so that fopen() is not
required to enable mandatory file locking in order to conform to the ISO C standard. An implementation that has a means of
creating a file with a whole-file exclusive lock set would need to provide a way to change the behavior of fopen() depending
on whether the calling process is executing in a POSIX.1 conforming environment or an ISO C conforming environment.
The typical implementation-defined behavior for mode "rx" is to ignore the 'x', but the standard
developers did not wish to mandate this behavior. For example, an implementation could allow shared access for reading; that is,
disallow a file that has been opened this way from also being opened for writing.
Implementations are encouraged to have fopen() and freopen()
report an [EILSEQ] error if mode begins with 'w' or 'a', the file did not previously exist, and the last
component of pathname contains any bytes that have the encoded value of a  character.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, creat(), fclose(), fdopen(), fmemopen(), freopen(), open_memstream()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
Large File Summit extensions are added.
Issue 6
Extensions beyond the ISO C standard are marked.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX
Specification:
In the DESCRIPTION, text is added to indicate setting of the offset maximum in the open file description. This
change is to support large files.
In the ERRORS section, the [EOVERFLOW] condition is added. This change is to support large files.
The [ELOOP] mandatory error condition is added.
The [EINVAL], [EMFILE], [ENAMETOOLONG], [ENOMEM], and [ETXTBSY] optional error conditions are added.
The normative text is updated to avoid use of the term "must" for application requirements.
The following changes are made for alignment with the ISO/IEC 9899:1999 standard:
The prototype for fopen() is updated.
The DESCRIPTION is updated to note that if the argument mode points to a string other than those listed,
then the behavior is undefined.
The wording of the mandatory [ELOOP] error condition is updated, and a second optional [ELOOP] error condition is
added.
Issue 7
Austin Group Interpretation 1003.1-2001 #025 is applied, clarifying the file creation mode.
Austin Group Interpretation 1003.1-2001 #143 is applied.
Austin Group Interpretation 1003.1-2001 #159 is applied, clarifying requirements for the flags set on the open file
description.
SD5-XBD-ERN-4 is applied, changing the definition of the [EMFILE] error.
SD5-XSH-ERN-149 is applied, changing the {STREAM_MAX} [EMFILE] error condition from a "may fail" to a "shall
fail".
Changes are made related to support for finegrained timestamps.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0156 [291,433], XSH/TC1-2008/0157 [146,433], XSH/TC1-2008/0158
[324], and XSH/TC1-2008/0159 [14] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0122 [822] is applied.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to disallow the creation of filenames containing any bytes that
have the encoded value of a  character.
Austin Group Defect 293 is applied, adding the [EILSEQ] error.
Austin Group Defects 411 and 1524 are applied, adding the 'e' and 'x' mode string
characters.
Austin Group Defect 1200 is applied, correcting the argument name in the [ELOOP] errors.
Austin Group Defect 1302 is applied, aligning this function with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wcstoll.html =====
wcstol
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wcstol, wcstoll — convert a wide-character string to a long integer
SYNOPSIS
#include
long wcstol(const wchar_t *restrict nptr, wchar_t **restrict endptr,
int base);
long long wcstoll(const wchar_t *restrict nptr,
wchar_t **restrict endptr, int base);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall convert the initial portion of the wide-character string pointed to by nptr to long and
long long, respectively. First, they shall decompose the input string into three parts:
An initial, possibly empty, sequence of white-space wide characters
A subject sequence interpreted as an integer represented in some radix determined by the value of base
A final wide-character string of one or more unrecognized wide-character codes, including the terminating null wide-character
code of the input wide-character string
Then they shall attempt to convert the subject sequence to an integer, and return the result.
If base is 0, the expected form of the subject sequence is that of a decimal constant, octal constant, or hexadecimal
constant, any of which may be preceded by a '+' or '-' sign. A decimal constant begins with a non-zero digit, and
consists of a sequence of decimal digits. An octal constant consists of the prefix '0' optionally followed by a sequence
of the digits '0' to '7' only. A hexadecimal constant consists of the prefix 0x or 0X followed by a sequence of
the decimal digits and letters 'a' (or 'A') to 'f' (or 'F') with values 10 to 15
respectively.
If the value of base is between 2 and 36, the expected form of the subject sequence is a sequence of letters and digits
representing an integer with the radix specified by base, optionally preceded by a '+' or '-' sign, but
not including an integer suffix. The letters from 'a' (or 'A') to 'z' (or 'Z') inclusive are
ascribed the values 10 to 35; only letters whose ascribed values are less than that of base shall be permitted. If the value
of base is 16, the wide-character code representations of 0x or 0X may optionally precede the sequence of letters and
digits, following the sign if present.
The subject sequence is defined as the longest initial subsequence of the input wide-character string, starting with the first
non-white-space wide character, that is of the expected form. The subject sequence contains no wide-character codes if the input
wide-character string is empty or consists entirely of white-space wide characters, or if the first non-white-space wide character
is other than a sign or a permissible letter or digit.
If the subject sequence has the expected form and base is 0, the sequence of wide-character codes starting with the first
digit shall be interpreted as an integer constant. If the subject sequence has the expected form and the value of base is
between 2 and 36, it shall be used as the base for conversion, ascribing to each letter its value as given above. If the subject
sequence begins with a , the resulting value shall be the negative of the converted value. A pointer to the
final wide-character string shall be stored in the object pointed to by endptr, provided that endptr is not a null
pointer.
In other than the C [CX]   or POSIX  locale, additional
locale-specific subject sequence forms may be accepted.
If the subject sequence is empty or does not have the expected form, no conversion shall be performed; the value of nptr
shall be stored in the object pointed to by endptr, provided that endptr is not a null pointer.
These functions shall not change the setting of errno if successful.
Since 0, {LONG_MIN} or {LLONG_MIN} and {LONG_MAX} or {LLONG_MAX} are returned on error and are also valid returns on success, an
application wishing to check for error situations should set errno to 0, then call wcstol() or wcstoll(), then
check errno.
RETURN VALUE
Upon successful completion, these functions shall return the converted value, if any. If no conversion could be performed, 0
shall be returned [CX]   and errno may be set to indicate the error.  If the correct value is outside the range of representable values, {LONG_MIN}, {LONG_MAX}, {LLONG_MIN}, or {LLONG_MAX} shall
be returned (according to the sign of the value), and errno set to [ERANGE].
ERRORS
These functions shall fail if:
[EINVAL]
[CX]
The value of base is not supported.
[ERANGE]
The value to be returned is not representable.
These functions may fail if:
[EINVAL]
[CX]  No
conversion could be performed.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
fscanf(), iswalpha(), wcstod()
XBD
CHANGE HISTORY
First released in Issue 4. Derived from the MSE working draft.
Issue 5
The DESCRIPTION is updated to indicate that errno is not changed if the function is successful.
Issue 6
Extensions beyond the ISO C standard are marked.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
In the RETURN VALUE and ERRORS sections, the [EINVAL] optional error condition is added if no conversion could be performed.
The following changes are made for alignment with the ISO/IEC 9899:1999 standard:
The wcstol() prototype is updated.
The wcstoll() function is added.
Issue 7
SD5-XSH-ERN-56 is applied, removing the reference to unsigned long and unsigned long long from the
DESCRIPTION.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0725 [105] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0393 [584] and XSH/TC2-2008/0394 [796] are applied.
Issue 8
Austin Group Defect 700 is applied, clarifying how a subject sequence beginning with  is converted.
Austin Group Defect 1163 is applied, clarifying the handling of white space in the input string.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sigismember.html =====
sigismember
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sigismember — test for a signal in a signal set
SYNOPSIS
[CX]  #include
int sigismember(const sigset_t *set, int signo);
DESCRIPTION
The sigismember() function shall test whether the signal specified by signo is a member of the set pointed to by
set.
Applications should call either sigemptyset() or sigfillset() at least once for each object of type sigset_t prior to any other use
of that object. If such an object is not initialized in this way, but is nonetheless supplied as an argument to any of pthread_sigmask(), sigaction(),
sigaddset(), sigdelset(),
sigismember(), sigpending(), sigprocmask(), sigsuspend(), sigtimedwait(), sigwait(), or sigwaitinfo(), the results are undefined.
RETURN VALUE
Upon successful completion, sigismember() shall return 1 if the specified signal is a member of the specified set, or 0
if it is not. Otherwise, it shall return -1 and set errno to indicate the error.
ERRORS
The sigismember() function may fail if:
[EINVAL]
The signo argument is not a valid signal number, or is an unsupported signal number.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.4 Signal Concepts, pthread_sigmask(), sigaction(),
sigaddset(), sigdelset(),
sigfillset(), sigemptyset()
, sigpending(), sigsuspend()
XBD
CHANGE HISTORY
First released in Issue 3. Included for alignment with the POSIX.1-1988 standard.
Issue 5
The last paragraph of the DESCRIPTION was included as an APPLICATION USAGE note in previous issues.
Issue 6
The SYNOPSIS is marked CX since the presence of this function in the  header is an extension over the ISO C standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/clock_getcpuclockid.html =====
clock_getcpuclockid
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
clock_getcpuclockid — access a process CPU-time clock (ADVANCED REALTIME)
SYNOPSIS
[CPT]  #include
int clock_getcpuclockid(pid_t pid, clockid_t *clock_id);
DESCRIPTION
The clock_getcpuclockid() function shall return the clock ID of the CPU-time clock of the process specified by
pid. If the process described by pid exists and the calling process has permission, the clock ID of this clock shall
be returned in clock_id.
If pid is zero, the clock_getcpuclockid() function shall return the clock ID of the CPU-time clock of the process
making the call, in clock_id.
The conditions under which one process has permission to obtain the CPU-time clock ID of other processes are
implementation-defined.
RETURN VALUE
Upon successful completion, clock_getcpuclockid() shall return zero; otherwise, an error number shall be returned to
indicate the error.
ERRORS
The clock_getcpuclockid() function shall fail if:
[EPERM]
The requesting process does not have permission to access the CPU-time clock for the process.
The clock_getcpuclockid() function may fail if:
[ESRCH]
No process can be found corresponding to the process specified by pid.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The clock_getcpuclockid() function is part of the Process CPU-Time Clocks option and need not be provided on all
implementations.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
clock_getres(), timer_create()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1d-1999.
In the SYNOPSIS, the inclusion of  is no longer
required.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/htole16.html =====
be16toh
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
be16toh, be32toh, be64toh, htobe16, htobe32, htobe64, htole16, htole32, htole64, le16toh, le32toh, le64toh — convert
values between host and specified byte order
SYNOPSIS
#include
uint16_t be16toh(uint16_t big_endian_16bits);
uint32_t be32toh(uint32_t big_endian_32bits);
uint64_t be64toh(uint64_t big_endian_64bits);
uint16_t htobe16(uint16_t host_16bits);
uint32_t htobe32(uint32_t host_32bits);
uint64_t htobe64(uint64_t host_64bits);
uint16_t htole16(uint16_t host_16bits);
uint32_t htole32(uint32_t host_32bits);
uint64_t htole64(uint64_t host_64bits);
uint16_t le16toh(uint16_t little_endian_16bits);
uint32_t le32toh(uint32_t little_endian_32bits);
uint64_t le64toh(uint64_t little_endian_64bits);
DESCRIPTION
These functions shall convert integer values of various sizes between host representations and representations in a specified
order.
On some implementations, these functions are defined as macros.
A little-endian representation of an integer has the least significant byte stored as the first byte, with the significance of
the bytes increasing as the byte address increases. A big-endian representation has the most significant byte as the first byte,
with the significance of the bytes reducing as the byte address increases.
Note:
Network byte order is big-endian.
For example, the uint32_t value 0x01020304 is represented as the four bytes 0x04, 0x03, 0x02, 0x01 on a little-endian
host, and as 0x01, 0x02, 0x03, 0x04 on a big-endian host.
For each of the sizes 16, 32 and 64, the htobeSIZE() function shall convert from whatever order the host uses to
big-endian representation, htoleSIZE() shall convert to little-endian representation, beSIZEtoh() shall convert from
big-endian to host order, and leSIZEtoh() shall convert from little-endian to host order.
RETURN VALUE
These functions shall return an unsigned integer of the appropriate size and representation.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
#include
#include
#include
int main(int argc, char *argv[])
{
uint32_t val;
if (argc > 1) {
val = (uint32_t)strtoul(argv[1], NULL, 0);
printf("Value: %08x\n", val);
printf("As bytes:\n");
union {
uint32_t asint;
unsigned char asbytes[sizeof(uint32_t)];
} u;
printf("Little endian: ");
u.asint = htole32(val);
for (int i = 0; i  is included:
htobe32
htonl
htobe16
htons
be32toh
ntohl
be16toh
ntohs
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
htonl()
XBD ,
CHANGE HISTORY
First released in Issue 8.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wscanf.html =====
fwscanf
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fwscanf, swscanf, wscanf — convert formatted wide-character input
SYNOPSIS
#include
#include
int fwscanf(FILE *restrict stream, const wchar_t *restrict format, ...);
int swscanf(const wchar_t *restrict ws,
const wchar_t *restrict format, ...);
int wscanf(const wchar_t *restrict format, ...);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The fwscanf() function shall read from the named input stream. The wscanf() function shall read from the
standard input stream stdin. The swscanf() function shall read from the wide-character string ws. Each
function reads wide characters, interprets them according to a format, and stores the results in its arguments. Each expects, as
arguments, a control wide-character string format described below, and a set of pointer arguments indicating where
the converted input should be stored. The result is undefined if there are insufficient arguments for the format. If the
format is exhausted while arguments remain, the excess arguments are evaluated but are otherwise ignored.
[CX]
Conversions can be applied to the nth argument after the format in the argument list, rather than to the next unused
argument. In this case, the conversion specifier wide character % (see below) is replaced by the sequence "%n$",
where n is a decimal integer in the range [1,{NL_ARGMAX}]. This feature provides for the definition of format
wide-character strings that select arguments in an order appropriate to specific languages. In format wide-character strings
containing the "%n$" form of conversion specifications, it is unspecified whether numbered arguments in
the argument list can be referenced from the format wide-character string more than once.
The format can contain either form of a conversion specification—that is, % or "%n$"—
but the two forms cannot normally be mixed within a single format wide-character string. The only exception to this is that
%% or %* can be mixed with the "%n$" form. When numbered argument specifications are
used, specifying the Nth argument requires that all the leading arguments, from the first to the (N-1)th, are
pointers.
The fwscanf() function in all its forms allows for detection of a language-dependent radix character in the input string,
encoded as a wide-character value. The radix character is defined in the current locale (category LC_NUMERIC ). In the POSIX
locale, or in a locale where the radix character is not defined, the radix character shall default to a
('.').
The format is a wide-character string composed of zero or more directives. Each directive is composed of one of the
following: one or more white-space wide characters; an ordinary wide character (neither '%' nor a white-space wide
character); or a conversion specification. It is unspecified whether an encoding error occurs if the format string contains
wchar_t values that do not correspond to members of the character set of the current locale and the specified semantics do
not require that value to be processed by wcrtomb().
Each conversion specification is introduced by the '%' [CX]
or by the character sequence
"%n$",   after which the following
appear in sequence:
An optional assignment-suppressing character '*'.
An optional non-zero decimal integer that specifies the maximum field width.
[CX]  An
optional assignment-allocation character 'm'.
An optional length modifier that specifies the size of the receiving object.
A conversion specifier wide character that specifies the type of conversion to be applied. The valid conversion specifiers are
described below.
The fwscanf() functions shall execute each directive of the format in turn. When all directives have been executed, or if
a directive fails (as detailed below), the function shall return. Failures are described as input failures (due to the
unavailability of input bytes) or matching failures (due to inappropriate input).
A directive composed of one or more white-space wide characters shall be executed by reading input up to the first wide
character that is not a white-space wide character, which shall remain unread, or until no more wide characters can be read. The
directive shall never fail.
A directive that is an ordinary wide character shall be executed as follows. The next wide character is read from the input and
compared with the wide character that comprises the directive; if the comparison shows that they are not equivalent, the directive
shall fail, and the differing and subsequent wide characters remain unread. Similarly, if end-of-file, an encoding error, or a read
error prevents a wide character from being read, the directive shall fail.
A directive that is a conversion specification defines a set of matching input sequences, as described below for each conversion
wide character. A conversion specification is executed in the following steps.
Input white-space wide characters shall be skipped, unless the conversion specification includes a [, c, or
n conversion specifier.
An item shall be read from the input, unless the conversion specification includes an n conversion specifier wide
character. An input item is defined as the longest sequence of input wide characters, not exceeding any specified field width,
which is an initial subsequence of a matching sequence. The first wide character, if any, after the input item shall remain unread.
If the length of the input item is zero, the execution of the conversion specification shall fail; this condition is a matching
failure, unless end-of-file, an encoding error, or a read error prevented input from the stream, in which case it is an input
failure.
Except in the case of a % conversion specifier, the input item (or, in the case of a %n conversion
specification, the count of input wide characters) shall be converted to a type appropriate to the conversion wide character. If
the input item is not a matching sequence, the execution of the conversion specification shall fail; this condition is a matching
failure. Unless assignment suppression was indicated by a '*', the result of the conversion shall be placed in the object
pointed to by the first argument following the format argument that has not already received a conversion result if the
conversion specification is introduced by %, [CX]   or in the nth argument if introduced by the wide-character
sequence "%n$".   If this object does
not have an appropriate type, or if the result of the conversion cannot be represented in the space provided, the behavior is
undefined.
[CX]  The
c, s, and [ conversion specifiers shall accept an optional assignment-allocation character 'm',
which shall cause a memory buffer to be allocated to hold the conversion results. If the conversion specifier is s or
[, the allocated buffer shall include space for a terminating null character (or wide character). In such a case, the
argument corresponding to the conversion specifier should be a reference to a pointer value that will receive a pointer to the
allocated buffer. The system shall allocate a buffer as if malloc() had been called.
The application shall be responsible for freeing the memory after usage. If there is insufficient memory to allocate a buffer, the
function shall set errno to [ENOMEM] and a conversion error shall result. If the function returns EOF, any memory
successfully allocated for parameters using assignment-allocation character 'm' by this call shall be freed before the
function returns.
The length modifiers and their meanings are:
hh
Specifies that a following d, i, o, u, x, X, or n conversion
specifier applies to an argument with type pointer to signed char or unsigned char.
h
Specifies that a following d, i, o, u, x, X, or n conversion
specifier applies to an argument with type pointer to short or unsigned short.
l (ell)
Specifies that a following d, i, o, u, x, X, or n conversion
specifier applies to an argument with type pointer to long or unsigned long; that a following a, A,
e, E, f, F, g, or G conversion specifier applies to an argument with type
pointer to double; or that a following c, s, or [ conversion specifier applies to an argument
with type pointer to wchar_t. [CX]   If the 'm' assignment-allocation character is specified, the conversion applies to
an argument with the type pointer to a pointer to wchar_t.
ll (ell-ell)
Specifies that a following d, i, o, u, x, X, or n conversion
specifier applies to an argument with type pointer to long long or unsigned long long.
j
Specifies that a following d, i, o, u, x, X, or n conversion
specifier applies to an argument with type pointer to intmax_t or uintmax_t.
z
Specifies that a following d, i, o, u, x, X, or n conversion
specifier applies to an argument with type pointer to size_t or the corresponding signed integer type.
t
Specifies that a following d, i, o, u, x, X, or n conversion
specifier applies to an argument with type pointer to ptrdiff_t or the corresponding unsigned type.
L
Specifies that a following a, A, e, E, f, F, g, or G
conversion specifier applies to an argument with type pointer to long double.
If a length modifier appears with any conversion specifier other than as specified above, the behavior is undefined.
The following conversion specifier wide characters are valid:
d
Matches an optionally signed decimal integer, whose format is the same as expected for the subject sequence of wcstol() with the value 10 for the base argument. In the absence of a size modifier,
the application shall ensure that the corresponding argument is a pointer to int.
i
Matches an optionally signed integer, whose format is the same as expected for the subject sequence of wcstol() with 0 for the base argument. In the absence of a size modifier, the
application shall ensure that the corresponding argument is a pointer to int.
o
Matches an optionally signed octal integer, whose format is the same as expected for the subject sequence of wcstoul() with the value 8 for the base argument. In the absence of a size modifier,
the application shall ensure that the corresponding argument is a pointer to unsigned.
u
Matches an optionally signed decimal integer, whose format is the same as expected for the subject sequence of wcstoul() with the value 10 for the base argument. In the absence of a size modifier,
the application shall ensure that the corresponding argument is a pointer to unsigned.
x
Matches an optionally signed hexadecimal integer, whose format is the same as expected for the subject sequence of wcstoul() with the value 16 for the base argument. In the absence of a size modifier,
the application shall ensure that the corresponding argument is a pointer to unsigned.
a, e, f, g
Matches an optionally signed floating-point number, infinity, or NaN whose format is the same as expected for the subject sequence
of wcstod(). In the absence of a size modifier, the application shall ensure that the
corresponding argument is a pointer to float.
If the fwprintf() family of functions generates character string representations
for infinity and NaN (a symbolic entity encoded in floating-point format) to support IEEE Std 754-1985, the
fwscanf() family of functions shall recognize them as input.
s
Matches a sequence of non-white-space wide characters. If no l (ell) qualifier is present, characters from the input
field shall be converted as if by repeated calls to the wcrtomb() function, with the
conversion state described by an mbstate_t object initialized to zero before the first wide character is converted. If the
'm' assignment-allocation character is not specified, the application shall ensure that the corresponding argument is a
pointer to a character array large enough to accept the sequence and the terminating null character, which shall be added
automatically. [CX]   Otherwise, the application shall ensure that the corresponding argument is a pointer to a pointer to a
char.
If the l (ell) qualifier is present and the 'm' assignment-allocation character is not specified, the
application shall ensure that the corresponding argument is a pointer to an array of wchar_t large enough to accept the
sequence and the terminating null wide character, which shall be added automatically. [CX]   If the
l (ell) qualifier is present and the 'm' assignment-allocation character is present, the application shall ensure
that the corresponding argument is a pointer to a pointer to a wchar_t.
[
Matches a non-empty sequence of wide characters from a set of expected wide characters (the scanset). If no l
(ell) qualifier is present, wide characters from the input field shall be converted as if by repeated calls to the wcrtomb() function, with the conversion state described by an mbstate_t object
initialized to zero before the first wide character is converted. If the 'm' assignment-allocation character is not
specified, the application shall ensure that the corresponding argument is a pointer to a character array large enough to accept
the sequence and the terminating null character, which shall be added automatically. [CX]   Otherwise, the
application shall ensure that the corresponding argument is a pointer to a pointer to a char.
If an l (ell) qualifier is present and the 'm' assignment-allocation character is not specified, the
application shall ensure that the corresponding argument is a pointer to an array of wchar_t large enough to accept the
sequence and the terminating null wide character. [CX]   If an l (ell) qualifier is present and the 'm'
assignment-allocation character is specified, the application shall ensure that the corresponding argument is a pointer to a
pointer to a wchar_t.
The conversion specification includes all subsequent wide characters in the format string up to and including the
matching  (']'). The wide characters between the square brackets (the scanlist)
comprise the scanset, unless the wide character after the  is a  ('^'), in
which case the scanset contains all wide characters that do not appear in the scanlist between the  and the
. If the conversion specification begins with "[]" or "[^]", the
is included in the scanlist and the next  is the matching
that ends the conversion specification; otherwise, the first  is the one
that ends the conversion specification. If a '-' is in the scanlist and is not the first wide character, nor the second
where the first wide character is a '^', nor the last wide character, the behavior is implementation-defined.
c
Matches a sequence of wide characters of exactly the number specified by the field width (1 if no field width is present in the
conversion specification).
If no l (ell) length modifier is present, characters from the input field shall be converted as if by repeated calls to
the wcrtomb() function, with the conversion state described by an mbstate_t
object initialized to zero before the first wide character is converted. No null character is added. If the 'm'
assignment-allocation character is not specified, the application shall ensure that the corresponding argument is a pointer to the
initial element of a character array large enough to accept the sequence. [CX]
Otherwise, the application shall ensure that the
corresponding argument is a pointer to a pointer to a char.
No null wide character is added. If an l (ell) length modifier is present and the 'm' assignment-allocation
character is not specified, the application shall ensure that the corresponding argument shall be a pointer to the initial element
of an array of wchar_t large enough to accept the sequence. [CX]
If an l (ell) qualifier is present and the
'm' assignment-allocation character is specified, the application shall ensure that the corresponding argument is a
pointer to a pointer to a wchar_t.
p
Matches an implementation-defined set of sequences, which shall be the same as the set of sequences that is produced by the
%p conversion specification of the corresponding fwprintf() functions. The
application shall ensure that the corresponding argument is a pointer to a pointer to void. The interpretation of the input
item is implementation-defined. If the input item is a value converted earlier during the same program execution, the pointer that
results shall compare equal to that value; otherwise, the behavior of the %p conversion is undefined.
n
No input is consumed. The application shall ensure that the corresponding argument is a pointer to the integer into which is to
be written the number of wide characters read from the input so far by this call to the fwscanf() functions. Execution of a
%n conversion specification shall not increment the assignment count returned at the completion of execution of the
function. No argument shall be converted, but one shall be consumed. If the conversion specification includes an
assignment-suppressing wide character or a field width, the behavior is undefined.
C
[XSI]
Equivalent to lc.
S
[XSI]
Equivalent to ls.
%
Matches a single '%' wide character; no conversion or assignment shall occur. The complete conversion specification
shall be %%.
If a conversion specification is invalid, the behavior is undefined.
The conversion specifiers A, E, F, G, and X are also valid and shall be equivalent
to, respectively, a, e, f, g, and x.
If end-of-file is encountered during input, conversion is terminated. If end-of-file occurs before any wide characters matching
the current conversion specification (except for %n) have been read (other than leading white-space wide characters, where
permitted), execution of the current conversion specification shall terminate with an input failure. Otherwise, unless execution of
the current conversion specification is terminated with a matching failure, execution of the following conversion specification (if
any) shall be terminated with an input failure.
Reaching the end of the string in swscanf() shall be equivalent to encountering end-of-file for fwscanf().
If conversion terminates on a conflicting input, the offending input shall be left unread in the input. Any trailing white-space
wide characters (including ) shall be left unread unless matched by a conversion specification. The success of
literal matches and suppressed assignments is only directly determinable via the %n conversion specification.
[CX]  The
fwscanf() and wscanf() functions may mark the last data access timestamp of the file associated with stream
for update. The last data access timestamp shall be marked for update by the first successful execution of fgetwc(), fgetws(), fwscanf(), getwc(), getwchar(), vfwscanf(), vwscanf(), or wscanf()
using stream that returns data not supplied by a prior call to ungetwc().
RETURN VALUE
Upon successful completion, these functions shall return the number of successfully matched and assigned input items; this
number can be zero in the event of an early matching failure. If the input ends before the first conversion (if any) has completed,
and without a matching failure having occurred, EOF shall be returned. If an error occurs before the first conversion (if any) has
completed, and without a matching failure having occurred, EOF shall be returned [CX]   and
errno shall be set to indicate the error.   If a read
error occurs, the error indicator for the stream shall be set.
ERRORS
For the conditions under which the fwscanf() functions shall fail and may fail, refer to fgetwc().
In addition, the fwscanf() function shall fail if:
[EILSEQ]
[CX]
Input byte sequence does not form a valid character.
[ENOMEM]
Insufficient storage space is available.
In addition, the fwscanf() function may fail if:
[EINVAL]
[CX]
There are insufficient arguments.
The following sections are informative.
EXAMPLES
The call:
int i, n; float x; char name[50];
n = wscanf(L"%d%f%s", &i, &x, name);
with the input line:
25 54.32E-1 Hamster
assigns to n the value 3, to i the value 25, to x the value 5.432, and name contains the string
"Hamster".
The call:
int i; float x; char name[50];
(void) wscanf(L"%2d%f%*d %[0123456789]", &i, &x, name);
with input:
56789 0123 56a72
assigns 56 to i, 789.0 to x, skips 0123, and places the string "56\0" in name. The next call to
getchar() shall return the character 'a'.
APPLICATION USAGE
In format strings containing the '%' form of conversion specifications, each argument in the argument list is used
exactly once.
For functions that allocate memory as if by malloc(), the application should
release such memory when it is no longer required by a call to free(). For
fwscanf(), this is memory allocated via use of the 'm' assignment-allocation character.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, getwc(), fwprintf(), setlocale(), wcstod(), wcstol(), wcstoul(), wcrtomb()
XBD 7. Locale, , ,
CHANGE HISTORY
First released in Issue 5. Included for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E).
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
The following changes are made for alignment with the ISO/IEC 9899:1999 standard:
The prototypes for fwscanf() and swscanf() are updated.
The DESCRIPTION is updated.
The hh, ll, j, t, and z length modifiers are added.
The a, A, and F conversion characters are added.
The DESCRIPTION is updated to use the terms "conversion specifier" and "conversion specification" consistently.
Issue 7
Austin Group Interpretation 1003.1-2001 #170 is applied.
SD5-XSH-ERN-132 is applied, adding the assignment-allocation character 'm'.
Functionality relating to the "%n$" form of conversion specification is moved from the XSI option to the Base.
Changes are made related to support for finegrained timestamps.
The APPLICATION USAGE section is updated to clarify that memory is allocated as if by malloc().
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0229 [302] and XSH/TC1-2008/0230 [14] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0148 [73], XSH/TC2-2008/0149 [823], and XSH/TC2-2008/0150 [936] are
applied.
Issue 8
Austin Group Defect 1163 is applied, clarifying the handling of white space in the format string.
Austin Group Defect 1173 is applied, clarifying the description of the assignment-allocation character 'm'.
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
Austin Group Defect 1375 is applied, changing "terminating null wide character" to "terminating null character (or wide
character)" and changing the first occurrence of wchar_t in the descriptions of the s and [ conversion
specifiers to char.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/semget.html =====
semget
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
semget — get set of XSI semaphores
SYNOPSIS
[XSI]  #include
int semget(key_t key, int nsems, int semflg);
DESCRIPTION
The semget() function operates on XSI semaphores (see XBD 4.20
Semaphore). It is unspecified whether this function interoperates with the realtime interprocess communication facilities
defined in 2.8 Realtime.
The semget() function shall return the semaphore identifier associated with key.
A semaphore identifier with its associated semid_ds data structure and its associated set of nsems semaphores (see
) is created for key if one of the following is true:
The argument key is equal to IPC_PRIVATE.
The argument key does not already have a semaphore identifier associated with it and (semflg &IPC_CREAT) is
non-zero.
Upon creation, the semid_ds data structure associated with the new semaphore identifier is initialized as follows:
In the operation permissions structure sem_perm.cuid, sem_perm.uid, sem_perm.cgid, and sem_perm.gid
shall be set to the effective user ID and effective group ID, respectively, of the calling process.
The low-order 9 bits of sem_perm.mode shall be set to the low-order 9 bits of semflg.
The variable sem_nsems shall be set to the value of nsems.
The variable sem_otime shall be set to 0 and sem_ctime shall be set to the current time, as described in 2.7.1 IPC General Description.
Upon creation, the value of the semval, sempid, semncnt, and semzcnt members of all nsems
semaphores in the associated semaphore set shall be set to zero.
RETURN VALUE
Upon successful completion, semget() shall return a non-negative integer, namely a semaphore identifier; otherwise, it
shall return -1 and set errno to indicate the error.
ERRORS
The semget() function shall fail if:
[EACCES]
A semaphore identifier exists for key, but operation permission as specified by the low-order 9 bits of semflg
would not be granted; see 2.7 XSI Interprocess Communication.
[EEXIST]
A semaphore identifier exists for the argument key but ((semflg &IPC_CREAT) &&(semflg
&IPC_EXCL)) is non-zero.
[EINVAL]
The value of nsems is either less than or equal to 0 or greater than the system-imposed limit, or a semaphore identifier
exists for the argument key, but the number of semaphores in the set associated with it is less than nsems and
nsems is not equal to 0.
[ENOENT]
A semaphore identifier does not exist for the argument key and (semflg &IPC_CREAT) is equal to 0.
[ENOSPC]
A semaphore identifier is to be created but the system-imposed limit on the maximum number of allowed semaphores system-wide
would be exceeded.
The following sections are informative.
EXAMPLES
Refer to semop().
APPLICATION USAGE
The POSIX Realtime Extension defines alternative interfaces for interprocess communication. Application developers who need to
use IPC should design their applications so that modules using the IPC routines described in 2.7 XSI Interprocess Communication can be easily modified to use the alternative
interfaces.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.7 XSI Interprocess Communication, 2.8 Realtime, ftok(), semctl(), semop(), sem_close(), sem_destroy(),
sem_getvalue(), sem_init(),
sem_open(), sem_post(),
sem_trywait(), sem_unlink()
XBD 4.20 Semaphore,
CHANGE HISTORY
First released in Issue 2. Derived from Issue 2 of the SVID.
Issue 5
The note about use of POSIX Realtime Extension IPC routines has been moved from FUTURE DIRECTIONS to a new APPLICATION USAGE
section.
Issue 6
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/122 is applied, updating the DESCRIPTION from "each semaphore
in the set shall not be initialized" to "each semaphore in the set need not be initialized".
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0536 [335,439] and XSH/TC1-2008/0537 [344] are applied.
Issue 8
Austin Group Defect 377 is applied, adding a requirement that the value of the semval, sempid, semncnt, and
semzcnt members of all semaphores in a semaphore set be initialized to zero when a call to semget() creates a
semaphore set.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/rmdir.html =====
rmdir
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
rmdir — remove a directory
SYNOPSIS
#include
int rmdir(const char *path);
DESCRIPTION
The rmdir() function shall remove a directory whose name is given by path. The directory shall be removed only if
it is an empty directory.
If the directory is the root directory or the current working directory of any process, it is unspecified whether the function
succeeds, or whether it shall fail and set errno to [EBUSY].
If path names a symbolic link, then rmdir() shall fail and set errno to [ENOTDIR].
If the path argument refers to a path whose final component is either dot or dot-dot, rmdir() shall fail.
If the directory's link count becomes 0 and no process has the directory open, the space occupied by the directory shall be
freed and the directory shall no longer be accessible. If one or more processes have the directory open when the last link is
removed, the dot and dot-dot entries, if present, shall be removed before rmdir() returns and no new entries may be created
in the directory, but the directory shall not be removed until all references to the directory are closed.
If the directory is not an empty directory, rmdir() shall fail and set errno to [EEXIST] or [ENOTEMPTY].
Upon successful completion, rmdir() shall mark for update the last data modification and last file status change
timestamps of the parent directory.
RETURN VALUE
Upon successful completion, the function rmdir() shall return 0. Otherwise, -1 shall be returned, and errno set to
indicate the error. If -1 is returned, the named directory shall not be changed.
ERRORS
The rmdir() function shall fail if:
[EACCES]
Search permission is denied on a component of the path prefix, or write permission is denied on the parent directory of the
directory to be removed.
[EBUSY]
The directory to be removed is currently in use by the system or some process and the implementation considers this to be an
error.
[EEXIST] or [ENOTEMPTY]
The path argument names a directory that is not an empty directory, or there are hard links to the directory other than dot
or a single entry in dot-dot.
[EINVAL]
The path argument contains a last component that is dot.
[EIO]
A physical I/O error has occurred.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOENT]
A component of path does not name an existing file, or the path argument names a nonexistent directory or points
to an empty string.
[ENOTDIR]
A component of path names an existing file that is neither a directory nor a symbolic link to a directory.
[EPERM] or [EACCES]
[XSI]
The S_ISVTX flag is set on the directory containing the file referred to by the path argument and the process does not
satisfy the criteria specified in XBD 4.5 Directory Protection.
[EROFS]
The directory entry to be removed resides on a read-only file system.
The rmdir() function may fail if:
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a
length that exceeds {PATH_MAX}.
The following sections are informative.
EXAMPLES
Removing a Directory
The following example shows how to remove a directory named /home/cnd/mod1.
#include
int status;
...
status = rmdir("/home/cnd/mod1");
APPLICATION USAGE
None.
RATIONALE
The rmdir() and rename() functions originated in 4.2 BSD, and they used
[ENOTEMPTY] for the condition when the directory to be removed does not exist or new already exists. When the 1984
/usr/group standard was published, it contained [EEXIST] instead. When these functions were adopted into System V, the 1984
/usr/group standard was used as a reference. Therefore, several existing applications and implementations support/use both forms,
and no agreement could be reached on either value. All implementations are required to supply both [EEXIST] and [ENOTEMPTY] in
with distinct values, so that applications can use both values in
C-language case statements.
The meaning of deleting pathname/dot is unclear, because the name of the file (directory) in the parent directory
to be removed is not clear, particularly in the presence of multiple links to a directory.
The POSIX.1-1990 standard was silent with regard to the behavior of rmdir() when there are multiple hard links to the
directory being removed. The requirement to set errno to [EEXIST] or [ENOTEMPTY] clarifies the behavior in this case.
If the current working directory of the process is being removed, that should be an allowed error.
Virtually all existing implementations detect [ENOTEMPTY] or the case of dot-dot. The text in 2.3 Error Numbers about returning any one of the possible errors permits that
behavior to continue. The [ELOOP] error may be returned if more than {SYMLOOP_MAX} symbolic links are encountered during resolution
of the path argument.
FUTURE DIRECTIONS
None.
SEE ALSO
2.3 Error Numbers, mkdir(), remove(), rename(), unlink()
XBD 4.5 Directory Protection,
CHANGE HISTORY
First released in Issue 3. Included for alignment with the POSIX.1-1988 standard.
Issue 6
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The DESCRIPTION is updated to indicate the results of naming a symbolic link in path.
The [EIO] mandatory error condition is added.
The [ELOOP] mandatory error condition is added.
A second [ENAMETOOLONG] is added as an optional error condition.
The following changes were made to align with the IEEE P1003.1a draft standard:
The [ELOOP] optional error condition is added.
Issue 7
Austin Group Interpretation 1003.1-2001 #143 is applied.
Austin Group Interpretation 1003.1-2001 #181 is applied, updating the requirements for operations when the S_ISVTX bit is
set.
Changes are made related to support for finegrained timestamps.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0519 [324] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/inet_ntoa.html =====
inet_addr
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
inet_addr, inet_ntoa — IPv4 address manipulation
SYNOPSIS
[OB]  #include
in_addr_t inet_addr(const char *cp);
char *inet_ntoa(struct in_addr in);
DESCRIPTION
The inet_addr() function shall convert the string pointed to by cp, in the standard IPv4 dotted decimal notation,
to an integer value suitable for use as an Internet address.
The inet_ntoa() function shall convert the Internet host address specified by in to a string in the Internet
standard dot notation.
The inet_ntoa() function need not be thread-safe.
All Internet addresses shall be returned in network order (bytes ordered from left to right).
Values specified using IPv4 dotted decimal notation take one of the following forms:
a.b.c.d
When four parts are specified, each shall be interpreted as a byte of data and assigned, from left to right, to the four bytes
of an Internet address.
a.b.c
When a three-part address is specified, the last part shall be interpreted as a 16-bit quantity and placed in the rightmost two
bytes of the network address. This makes the three-part address format convenient for specifying Class B network addresses as
"128.net.host".
a.b
When a two-part address is supplied, the last part shall be interpreted as a 24-bit quantity and placed in the rightmost three
bytes of the network address. This makes the two-part address format convenient for specifying Class A network addresses as
"net.host".
a
When only one part is given, the value shall be stored directly in the network address without any byte rearrangement.
All numbers supplied as parts in IPv4 dotted decimal notation may be decimal, octal, or hexadecimal, as specified in the
ISO C standard (that is, a leading 0x or 0X implies hexadecimal; otherwise, a leading '0' implies octal; otherwise,
the number is interpreted as decimal).
RETURN VALUE
Upon successful completion, inet_addr() shall return the Internet address. Otherwise, it shall return
(in_addr_t)(-1).
The inet_ntoa() function shall return a pointer to the network address in Internet standard dot notation.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The return value of inet_ntoa() may point to static data that may be overwritten by subsequent calls to
inet_ntoa().
Applications should prefer inet_pton() over inet_addr() for the
following reasons:
The return value from inet_addr() when converting 255.255.255.255 is indistinguishable from an error.
The inet_pton() function supports multiple address families.
The alternative textual representations supported by inet_addr() (but not by inet_pton()) are often used maliciously to confuse or mislead users (e.g., for
phishing).
Applications should prefer inet_ntop() over inet_ntoa() as it supports
multiple address families and is thread-safe.
RATIONALE
None.
FUTURE DIRECTIONS
These functions are included only for compatibility with older implementations and may be removed in a future version.
SEE ALSO
endhostent(), endnetent()
, inet_ntop()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
Issue 8
Austin Group Defects 1101 and 1102 are applied, marking inet_addr() and inet_ntoa() as obsolescent.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/strerror_l.html =====
strerror
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
strerror, strerror_l, strerror_r — get error message string
SYNOPSIS
#include
char *strerror(int errnum);
[CX]  char *strerror_l(int errnum, locale_t locale);
int strerror_r(int errnum, char *strerrbuf, size_t buflen);
DESCRIPTION
For strerror(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The strerror() function shall map the error number in errnum to a locale-dependent error message string and shall
return a pointer to it. Typically, the values for errnum come from errno, but strerror() shall map any value
of type int to a message.
The application shall not modify the string returned. [CX]   The returned string pointer might be invalidated or   the string content might be overwritten by a subsequent call to
strerror(), [CX]   or by a subsequent call to strerror_l() in the same thread. The returned pointer and the string content
might also be invalidated if the calling thread is terminated.
[CX]  The
string may be overwritten by a subsequent call to strerror_l() in the same thread.
The contents of the error message strings returned by strerror() should be determined by the setting of the
LC_MESSAGES category in the current locale.
The implementation shall behave as if no function defined in this volume of POSIX.1-2024 calls strerror().
[CX]  The
strerror() and strerror_l() functions shall not change the setting of errno if successful.
Since no return value is reserved to indicate an error of strerror(), an application wishing to check for error
situations should set errno to 0, then call strerror(), then check errno. Similarly, since strerror_l()
is required to return a string for some errors, an application wishing to check for all error situations should set errno to
0, then call strerror_l(), then check errno.
The strerror() function need not be thread-safe; however, strerror() shall avoid data races with all other
functions.
[CX]  The
strerror_l() function shall map the error number in errnum to a locale-dependent error message string in the locale
represented by locale and shall return a pointer to it.
The strerror_r() function shall map the error number in errnum to a locale-dependent error message string and
shall return the string in the buffer pointed to by strerrbuf, with length buflen.
[CX]  If
the value of errnum is a valid error number, the message string shall indicate what error occurred; if the value of
errnum is zero, the message string shall either be an empty string or indicate that no error occurred; otherwise, if these
functions complete successfully, the message string shall indicate that an unknown error occurred.
[CX]  The
behavior is undefined if the locale argument to strerror_l() is the special locale object LC_GLOBAL_LOCALE or is not
a valid locale object handle.
RETURN VALUE
Upon completion, whether successful or not, strerror() shall return a pointer to the generated message string.
[CX]
On error errno may be set, but no return value is reserved to indicate an error.
Upon successful completion, strerror_l() shall return a pointer to the generated message string. If errnum is not
a valid error number, errno may be set to [EINVAL], but a pointer to a message string shall still be returned. If any other
error occurs, errno shall be set to indicate the error and a null pointer shall be returned.
Upon successful completion, strerror_r() shall return 0. Otherwise, an error number shall be returned to indicate the
error.
ERRORS
These functions may fail if:
[EINVAL]
[CX]
The value of errnum is neither a valid error number nor zero.
The strerror_r() function shall fail if:
[ERANGE]
[CX]
Insufficient storage was supplied via strerrbuf and buflen to contain the generated message string.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Historically in some implementations, calls to perror() would overwrite the string
that the pointer returned by strerror() points to. Such implementations did not conform to the ISO C standard; however,
application developers should be aware of this behavior if they wish their applications to be portable to such implementations.
Applications should use strerror_l() rather than strerror() or strerror_r() to avoid thread safety and
possible alternative (non-conforming) versions of these functions in some implementations.
RATIONALE
The strerror_l() function is required to be thread-safe, thereby eliminating the need for an equivalent to the
strerror_r() function.
Earlier versions of this standard did not explicitly require that the error message strings returned by strerror() and
strerror_r() provide any information about the error. This version of the standard requires a meaningful message for any
successful completion.
Since no return value is reserved to indicate a strerror() error, but all calls (whether successful or not) must return a
pointer to a message string, on error strerror() can return a pointer to an empty string or a pointer to a meaningful string
that can be printed.
Note that the [EINVAL] error condition is a may fail error. If an invalid error number is supplied as the value of
errnum, applications should be prepared to handle any of the following:
Error (with no meaningful message): errno is set to [EINVAL], the return value is a pointer to an empty string.
Successful completion: errno is unchanged and the return value points to a string like "unknown error" or
"error number xxx" (where xxx is the value of errnum).
Combination of #1 and #2: errno is set to [EINVAL] and the return value points to a string like "unknown error"
or "error number xxx" (where xxx is the value of errnum). Since applications frequently use the return value
of strerror() as an argument to functions like fprintf() (without checking
the return value) and since applications have no way to parse an error message string to determine whether errnum represents
a valid error number, implementations are encouraged to implement #3. Similarly, implementations are encouraged to have
strerror_r() return [EINVAL] and put a string like "unknown error" or "error number xxx" in the buffer
pointed to by strerrbuf when the value of errnum is not a valid error number.
Additionally, implementations are encouraged to null terminate strerrbuf when failing with [ERANGE] for any size other
than buflen of zero.
Some applications rely on being able to set errno to 0 before calling a function with no reserved value to indicate an
error, then call strerror(errno) afterwards to detect whether an error occurred (because errno changed) or to
indicate success (because errno remained zero). This usage pattern requires that strerror(0) succeed with useful
results. Previous versions of the standard did not specify the behavior when errnum is zero.
FUTURE DIRECTIONS
None.
SEE ALSO
perror()
XBD
CHANGE HISTORY
First released in Issue 3.
Issue 5
The DESCRIPTION is updated to indicate that errno is not changed if the function is successful.
A note indicating that the strerror() function need not be reentrant is added to the DESCRIPTION.
Issue 6
Extensions beyond the ISO C standard are marked.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
In the RETURN VALUE section, the fact that errno may be set is added.
The [EINVAL] optional error condition is added.
The normative text is updated to avoid use of the term "must" for application requirements.
The strerror_r() function is added in response to IEEE PASC Interpretation 1003.1c #39.
The strerror_r() function is marked as part of the Thread-Safe Functions option.
Issue 7
Austin Group Interpretation 1003.1-2001 #072 is applied, updating the ERRORS section.
Austin Group Interpretation 1003.1-2001 #156 is applied.
Austin Group Interpretation 1003.1-2001 #187 is applied, clarifying the behavior when the generated error message is an empty
string.
SD5-XSH-ERN-191 is applied, updating the APPLICATION USAGE section.
The strerror_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
The strerror_r() function is moved from the Thread-Safe Functions option to the Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0595 [75], XSH/TC1-2008/0596 [447], XSH/TC1-2008/0597 [382,428],
XSH/TC1-2008/0598 [283], XSH/TC1-2008/0599 [382,428], XSH/TC1-2008/0600 [283], and XSH/TC1-2008/0601 [382,428] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0339 [656] is applied.
Issue 8
Austin Group Defect 398 is applied, changing the [ERANGE] error from "may fail" to "shall fail".
Austin Group Defect 655 is applied, changing the APPLICATION USAGE section.
Austin Group Defect 1302 is applied, aligning the strerror() function with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/copysignl.html =====
copysign
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
copysign, copysignf, copysignl — number manipulation function
SYNOPSIS
#include
double copysign(double x, double y);
float copysignf(float x, float y);
long double copysignl(long double x, long double y);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall produce a value with the magnitude of x and the sign of y. On implementations that represent
a signed zero but do not treat negative zero consistently in arithmetic operations, these functions regard the sign of zero as
positive.
RETURN VALUE
Upon successful completion, these functions shall return a value with the magnitude of x and the sign of y.
[MX]  The
returned value shall be exact and shall be independent of the current rounding direction mode.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
signbit()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/ilogbl.html =====
ilogb
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ilogb, ilogbf, ilogbl — return an unbiased exponent
SYNOPSIS
#include
int ilogb(double x);
int ilogbf(float x);
int ilogbl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall return the exponent part of their argument x. Formally, the return value is the integral part of
\(\log _r|x|\) as a signed integral value, for non-zero x, where r is the radix of the machine's floating-point
arithmetic, which is the value of FLT_RADIX defined in .
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the exponent part of x as a signed integer value. They are
equivalent to calling the corresponding logb() function and casting the returned value
to type int.
[MX]
When the correct result is representable in the range of the return type, the returned value shall be exact and shall be
independent of the current rounding direction mode.
If x is 0, the value FP_ILOGB0 shall be returned. [XSI|MX]   On XSI-conformant systems and on systems that support the IEC
60559 Floating-Point option, a domain error shall occur;
otherwise, a
[CX]  domain
error may occur.
If x is ±Inf, the value {INT_MAX} shall be returned. [XSI|MX]
On XSI-conformant systems and on systems that support the
IEC 60559 Floating-Point option, a domain error shall occur;
otherwise, a [CX]   domain   error may occur.
If x is a NaN, the value FP_ILOGBNAN shall be returned. [XSI|MX]
On XSI-conformant systems and on systems that support the
IEC 60559 Floating-Point option, a domain error shall occur;
otherwise, a [CX]   domain   error may occur.
If the correct value is greater than {INT_MAX} or less than {INT_MIN}, an unspecified value shall be returned. [XSI]  On XSI-conformant
systems, a domain error shall occur and {INT_MAX} or {INT_MIN}, respectively, shall be returned;
[MX]  if the IEC 60559 Floating-Point option is supported, a domain error
shall occur;   otherwise, a domain error or range error may
occur.
ERRORS
These functions shall fail if:
Domain Error
[XSI|MX]  The correct value is not representable as an integer.
The x argument is zero, NaN, or ±Inf.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If
the integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall
be raised.
These functions may fail if:
Domain Error
The x argument is zero, NaN, or ±Inf.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If
the integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall
be raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are
independent of each other, but at least one of them must be non-zero.
RATIONALE
The errors come from taking the expected floating-point value and converting it to int, which is an invalid operation in
IEEE Std 754-1985 (since overflow, infinity, and NaN are not representable in a type int), so should be a domain
error.
There are no known implementations that overflow. For overflow to happen, {INT_MAX} must be less than
LDBL_MAX_EXP*log2(FLT_RADIX) or {INT_MIN} must be greater than LDBL_MIN_EXP*log2(FLT_RADIX) if subnormals are not
supported, or {INT_MIN} must be greater than (LDBL_MIN_EXP-LDBL_MANT_DIG)*log2(FLT_RADIX) if subnormals are supported.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept, fetestexcept, logb, scalbln
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
The ilogb() function is no longer marked as an extension.
The ilogbf() and ilogbl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The RETURN VALUE section is revised for alignment with the ISO/IEC 9899:1999 standard.
Functionality relating to the XSI option is marked.
Issue 7
ISO/IEC 9899:1999 standard, Technical Corrigendum 2 #48 (SD5-XSH-ERN-71), #49, and #79 (SD5-XSH-ERN-72) are applied.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/puts.html =====
puts
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
puts — put a string on standard output
SYNOPSIS
#include
int puts(const char *s);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The puts() function shall write the string pointed to by s, followed by a , to the standard output
stream stdout. The terminating null byte shall not be written.
[CX]  The
last data modification and last file status change timestamps of the file shall be marked for update between the successful
execution of puts() and the next successful completion of a call to fflush()
or fclose() on the same stream or a call to exit() or abort().
RETURN VALUE
Upon successful completion, puts() shall return a non-negative number. Otherwise, it shall return EOF, shall set an error
indicator for the stream, [CX]   and errno shall be set to indicate the error.
ERRORS
Refer to fputc().
The following sections are informative.
EXAMPLES
Printing to Standard Output
The following example gets the current time, converts it to a string using localtime() and asctime(), and prints it to
standard output using puts(). It then prints the number of minutes to an event for which it is waiting.
#include
#include
...
time_t now;
int minutes_to_event;
...
time(&now);
printf("The time is ");
puts(asctime(localtime(&now)));
printf("There are %d minutes to the event.\n",
minutes_to_event);
...
APPLICATION USAGE
The puts() function appends a , while fputs() does not.
This volume of POSIX.1-2024 requires that successful completion simply return a non-negative integer. There are at least three
known different implementation conventions for this requirement:
Return a constant value.
Return the last character written.
Return the number of bytes written. Note that this implementation convention cannot be adhered to for strings longer than
{INT_MAX} bytes as the value would not be representable in the return type of the function. For backwards compatibility,
implementations can return the number of bytes for strings of up to {INT_MAX} bytes, and return {INT_MAX} for all longer
strings.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, fopen(), fputs(), putc()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
Extensions beyond the ISO C standard are marked.
Issue 7
Changes are made related to support for finegrained timestamps.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0476 [174,412] and XSH/TC1-2008/0477 [14] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/tfind.html =====
tdelete
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
tdelete, tfind, tsearch, twalk — manage a binary search tree
SYNOPSIS
[XSI]  #include
void *tdelete(const void *restrict key,
posix_tnode **restrict rootp,
int(*compar)(const void *, const void *));
posix_tnode *tfind(const void *key,
posix_tnode *const *rootp,
int(*compar)(const void *, const void *));
posix_tnode *tsearch(const void *key,
posix_tnode **rootp,
int (*compar)(const void *, const void *));
void twalk(const posix_tnode *root,
void (*action)(const posix_tnode *, VISIT, int));
DESCRIPTION
The tdelete(), tfind(), tsearch(), and twalk() functions manipulate binary search trees. Comparisons
are made with a user-supplied routine, the address of which is passed as the compar argument. This routine is called with
two arguments, which are the pointers to the elements being compared. The application shall ensure that the user-supplied routine
returns an integer less than, equal to, or greater than 0, according to whether the first argument is to be considered less than,
equal to, or greater than the second argument. The comparison function need not compare every byte, so arbitrary data may be
contained in the elements in addition to the values being compared.
The tsearch() function shall build and access the tree. The key argument is a pointer to an element to be accessed
or stored. If there is a node in the tree whose element is equal to the value pointed to by key, a pointer to this found
node shall be returned. Otherwise, the value pointed to by key shall be inserted (that is, a new node is created and the
value of key is copied to this node), and a pointer to this node returned. Only pointers are copied, so the application
shall ensure that the calling routine stores the data. The rootp argument points to a variable that points to the root node
of the tree. A null pointer value for the variable pointed to by rootp denotes an empty tree; in this case, the variable
shall be set to point to the node which shall be at the root of the new tree.
Like tsearch(), tfind() shall search for a node in the tree, returning a pointer to it if found. However, if it is
not found, tfind() shall return a null pointer. The arguments for tfind() are the same as for tsearch().
The tdelete() function shall delete a node from a binary search tree. The arguments are the same as for tsearch().
The variable pointed to by rootp shall be set to a pointer to the new root of the tree if the root of the tree was changed.
If the deleted node was the root of the tree and had no children, the variable pointed to by rootp shall be set to a null
pointer. The tdelete() function shall return a pointer to the parent of the deleted node, or an unspecified non-null pointer
if the deleted node was the root node, or a null pointer if the node is not found.
If tsearch() adds an element to a tree, or tdelete() successfully deletes an element from a tree, the concurrent
use of that tree in another thread, or use of pointers produced by a previous call to tfind() or tsearch(), produces
undefined results.
The twalk() function shall traverse a binary search tree. The root argument is a pointer to the root node of the
tree to be traversed. (Any node in a tree may be used as the root for a walk below that node.) The argument action is the
name of a routine to be invoked at each node. This routine is, in turn, called with three arguments. The first argument shall be
the address of the node being visited. The structure pointed to by this argument is unspecified and shall not be modified by the
application, but it shall be possible to cast a pointer-to-node into a pointer-to-pointer-to-element to access the element stored
in the node. The second argument shall be a value from an enumeration data type:
typedef enum { preorder, postorder, endorder, leaf } VISIT;
(defined in ), depending on whether this is the first, second, or
third time that the node is visited (during a depth-first, left-to-right traversal of the tree), or whether the node is a leaf. The
third argument shall be the level of the node in the tree, with the root being level 0.
If the calling function alters the pointer to the root, the result is undefined.
If the functions pointed to by action or compar (for any of these binary search functions) change the tree, the
results are undefined.
These functions are thread-safe only as long as multiple threads do not access the same tree.
RETURN VALUE
If the node is found, both tsearch() and tfind() shall return a pointer to it. If not, tfind() shall return
a null pointer, and tsearch() shall return a pointer to the inserted item.
A null pointer shall be returned by tsearch() if there is not enough space available to create a new node.
A null pointer shall be returned by tdelete(), tfind(), and tsearch() if rootp is a null pointer on
entry.
The tdelete() function shall return a pointer to the parent of the deleted node, or an unspecified non-null pointer if
the deleted node was the root node, or a null pointer if the node is not found.
The twalk() function shall not return a value.
In all cases where a pointer to a node is returned, the structure pointed to by the return value is unspecified and shall not be
modified by the application, but it shall be possible to cast a pointer-to-node into a pointer-to-pointer-to-element to access the
element stored in the node.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
The following code reads in strings and stores structures containing a pointer to each string and a count of its length. It then
walks the tree, printing out the stored strings and their lengths in alphabetical order.
#include
#include
#include
#include
#include
struct element {      /* Pointers to these are stored in the tree. */
int     count;
char    string[];
};
posix_tnode  *root = NULL;          /* This points to the root. */
int main(void)
{
char   str[_POSIX2_LINE_MAX+1];
int    length = 0;
struct element *elementptr;
posix_tnode *node;
void   print_node(const posix_tnode *, VISIT, int);
int    node_compare(const void *, const void *);
while (fgets(str, sizeof(str), stdin))  {
/* Set element. */
length = strlen(str);
if (str[length-1] == '\n')
str[--length] = '\0';
elementptr = malloc(sizeof(struct element) + length + 1);
strcpy(elementptr->string, str);
elementptr->count = 1;
/* Put element into the tree. */
node = tsearch((void *)elementptr, &root, node_compare);
if (node == NULL) {
fprintf(stderr,
"tsearch: Not enough space available\n");
exit(EXIT_FAILURE);
}
else if (*(struct element **)node != elementptr) {
/* A node containing the element already exists */
(*(struct element **)node)->count++;
free(elementptr);
}
}
twalk(root, print_node);
/* Delete all nodes in the tree */
while (root != NULL) {
elementptr = *(struct element **)root;
printf("deleting node: string = %s,  count = %d\n",
elementptr->string,
elementptr->count);
tdelete((void *)elementptr, &root, node_compare);
free(elementptr);
}
return 0;
}
/*
*  This routine compares two nodes, based on an
*  alphabetical ordering of the string field.
*/
int
node_compare(const void *node1, const void *node2)
{
return strcmp(((const struct element *) node1)->string,
((const struct element *) node2)->string);
}
/*
*  This routine prints out a node, the second time
*  twalk encounters it or if it is a leaf.
*/
void
print_node(const posix_tnode *ptr, VISIT order, int level)
{
const struct element *p = *(const struct element **) ptr;
if (order == postorder || order == leaf)  {
(void) printf("string = %s,  count = %d\n",
p->string, p->count);
}
}
APPLICATION USAGE
The root argument to twalk() is one level of indirection less than the rootp arguments to tdelete()
and tsearch().
There are two nomenclatures used to refer to the order in which tree nodes are visited. The twalk() function uses
preorder, postorder, and endorder to refer respectively to visiting a node before any of its children, after
its left child and before its right, and after both its children. The alternative nomenclature uses preorder,
inorder, and postorder to refer to the same visits, which could result in some confusion over the meaning of
postorder.
Since the return value of tdelete() is an unspecified non-null pointer in the case that the root of the tree has been
deleted, applications should only use the return value of tdelete() as indication of success or failure in this case and
should not assume it can be dereferenced. However, the only way that applications can tell if this case may have occurred is by
checking whether the variable pointed to by rootp changed. Since this variable can change for other reasons (for example,
tree balancing), using the return value of tdelete() as anything other than a boolean indicator is unreliable at best and is
discouraged. Some implementations in this case will return a pointer to the new root of the tree (or to an empty tree if the
deleted root node was the only node in the tree); other implementations return arbitrary non-null pointers.
RATIONALE
Implementations are encouraged to use balanced trees to reduce the depth of the trees that are created and improve tree search
times.
FUTURE DIRECTIONS
None.
SEE ALSO
hcreate(), lsearch()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The last paragraph of the DESCRIPTION was included as an APPLICATION USAGE note in previous issues.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
The restrict keyword is added to the tdelete() prototype for alignment with the ISO/IEC 9899:1999
standard.
Issue 7
Austin Group Interpretation 1003.1-2001 #149 is applied, clarifying concurrent use of the tree in another thread.
Austin Group Interpretation 1003.1-2001 #151 is applied, clarifying behavior for tdelete() when the deleted node is the
root node.
Austin Group Interpretation 1003.1-2001 #153 is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0366 [551] is applied.
Issue 8
Austin Group Defect 1011 is applied, changing some prototypes to use posix_tnode instead of void, and changing the
required behavior for tdelete() when the root of the tree changes.
Austin Group Defect 1470 is applied, changing the EXAMPLES section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/setprotoent.html =====
endprotoent
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
endprotoent, getprotobyname, getprotobynumber, getprotoent, setprotoent — network protocol database
functions
SYNOPSIS
#include
void endprotoent(void);
struct protoent *getprotobyname(const char *name);
struct protoent *getprotobynumber(int proto);
struct protoent *getprotoent(void);
void setprotoent(int stayopen);
DESCRIPTION
These functions shall retrieve information about protocols. This information is considered to be stored in a database that can
be accessed sequentially or randomly. The implementation of this database is unspecified.
The setprotoent() function shall open a connection to the database, and set the next entry to the first entry. If the
stayopen argument is non-zero, the connection to the network protocol database shall not be closed after each call to
getprotoent() (either directly, or indirectly through one of the other getproto*() functions), and the implementation
may maintain an open file descriptor for the database. If a file descriptor is used, the FD_CLOEXEC flag shall be set; see .
The getprotobyname() function shall search the database from the beginning and find the first entry for which the
protocol name specified by name matches the p_name member, opening and closing a connection to the database as
necessary.
The getprotobynumber() function shall search the database from the beginning and find the first entry for which the
protocol number specified by proto matches the p_proto member, opening and closing a connection to the database as
necessary.
The getprotoent() function shall read the next entry of the database, opening and closing a connection to the database as
necessary.
The getprotobyname(), getprotobynumber(), and getprotoent() functions shall each return a pointer to a
protoent structure, the members of which shall contain the fields of an entry in the network protocol database.
The endprotoent() function shall close the connection to the database, releasing any open file descriptor.
These functions need not be thread-safe.
RETURN VALUE
Upon successful completion, getprotobyname(), getprotobynumber(), and getprotoent() return a pointer to a
protoent structure if the requested entry was found, and a null pointer if the end of the database was reached or the
requested entry was not found. Otherwise, a null pointer is returned.
The application shall not modify the structure to which the return value points, nor any storage areas pointed to by pointers
within the structure. The returned pointer, and pointers within the structure, might be invalidated or the structure or the storage
areas might be overwritten by a subsequent call to getprotobyname(), getprotobynumber(), or getprotoent(). The
returned pointer, and pointers within the structure, might also be invalidated if the calling thread is terminated.
ERRORS
The getprotobyname(), getprotobynumber(), getprotoent(), and setprotoent() functions may fail
if:
[EMFILE]
All file descriptors available to the process are currently open.
[ENFILE]
The maximum allowable number of files is currently open in the system.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD ,
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0085 [75] and XSH/TC1-2008/0086 [75] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0091 [656] is applied.
Issue 8
Austin Group Defect 368 is applied, adding a requirement for FD_CLOEXEC to be set if a file descriptor is used, and adding the
[EMFILE] and [ENFILE] errors.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/dgettext.html =====
gettext
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
dgettext, dgettext_l, dcgettext, dcgettext_l, gettext, gettext_l, ngettext, ngettext_l, dngettext, dngettext_l,
dcngettext, dcngettext_l — message handling functions
SYNOPSIS
#include
char *dgettext(const char *domainname, const char *msgid);
char *dgettext_l(const char *domainname, const char *msgid,
locale_t locale);
char *dcgettext(const char *domainname, const char *msgid,
int category);
char *dcgettext_l(const char *domainname, const char *msgid,
int category, locale_t locale);
char *dngettext(const char *domainname, const char *msgid,
const char *msgid_plural, unsigned long int n);
char *dngettext_l(const char *domainname, const char *msgid,
const char *msgid_plural, unsigned long int n,
locale_t locale);
char *dcngettext(const char *domainname, const char *msgid,
const char *msgid_plural, unsigned long int n,
int category);
char *dcngettext_l(const char *domainname, const char *msgid,
const char *msgid_plural, unsigned long int n,
int category, locale_t locale);
char *gettext(const char *msgid);
char *gettext_l(const char *msgid, locale_t locale);
char *ngettext(const char *msgid, const char *msgid_plural,
unsigned long int n);
char *ngettext_l(const char *msgid, const char *msgid_plural,
unsigned long int n, locale_t locale);
DESCRIPTION
The gettext() function shall:
attempt to locate a suitable messages object (described in detail below) for the LC_MESSAGES category in the current
locale, and for the current text domain (see bindtextdomain()), containing
the string identified by msgid,
retrieve the string identified by msgid from the messages object,
convert the string to the output codeset if necessary (described in detail below), and
return the result.
If the locale name in effect is "POSIX" or "C" (i.e. the name associated with the LC_MESSAGES locale
category in the current locale), or if no suitable messages object exists, or if no string identified by msgid exists in the
messages object, or if an error occurs, msgid shall be returned.
The dgettext() function shall be equivalent to gettext(), except domainname shall be used instead of the
current text domain to locate the messages object.
The dcgettext() function shall be equivalent to dgettext(), except the locale category identified by
category shall be used instead of LC_MESSAGES .
The ngettext() function shall be equivalent to gettext(), except:
The string to retrieve shall be identified by a combination of msgid and n (see msgfmt).
If the locale name in effect is "POSIX" or "C", or if no suitable messages object exists, or if no string
identified by the combination of msgid and n exists in the messages object, or if an error occurs, the return value
shall be msgid if n is 1, otherwise msgid_plural.
The dngettext() function shall be equivalent to ngettext(), except domainname shall be used instead of the
current text domain to locate the messages object.
The dcngettext() function shall be equivalent to dngettext(), except the locale category identified by
category shall be used instead of LC_MESSAGES .
The *_l() functions shall be equivalent to their counterparts without the _l suffix, except locale shall be
used instead of the current locale. If locale is the special locale object LC_GLOBAL_LOCALE or is not a valid locale object
handle, the behavior is undefined.
The application shall ensure that the msgid and msgid_plural arguments are strings. If either msgid or
msgid_plural is an empty string, or contains characters not in the portable character set, the results are unspecified. If
the category argument is LC_ALL , the results are unspecified.
The location of the messages object shall be determined according to the following criteria, stopping when the first messages
object is found:
[XSI]
If the NLSPATH environment variable is set to a non-empty string, an NLSPATH search shall be performed as described
in XBD 8.2 Internationalization Variables. If NLSPATH identifies
more than one template to use, each template in turn shall be used until a valid messages object is found.
If the LANGUAGE environment variable is set to a non-empty string, a LANGUAGE search shall be performed as
described below. If LANGUAGE identifies more than one directory to search, each directory shall be searched until a valid
messages object is found.
A single-locale search shall be performed as described below.
For [XSI]   the NLSPATH search and   the single-locale search,
the single locale name used to locate the messages object shall be the locale name associated with the selected locale category
from the current locale, or the provided locale object if calling one of the *_l() functions; additional searches of locale
names without .codeset (if present), without _territory (if present), and without @modifier (if present) may
be performed.
For the LANGUAGE search, the value of the LANGUAGE environment variable shall be a list of one or more locale
names separated by a  (':') character. Each locale name shall be tried in the specified order. If a messages
object for the locale does not exist, or cannot be opened, or is unsuitable for implementation-defined reasons (such as security),
the next locale name (if any) shall be tried. If:
a messages object for the locale can be opened but cannot be processed without error, or
the messages object does not contain a string identified by msgid, or msgid and n for the ngettext
functions,
it is unspecified whether the next locale name (if any) is tried. In all other cases, the messages object for the locale shall
be used.
For each locale name in LANGUAGE , or if LANGUAGE is not set or is empty, or no suitable messages object is found
in processing LANGUAGE , the pathname used to locate the messages object shall be
dirname/localename/categoryname/textdomainname.mo, where:
The dirname part is the dirname argument of the most recent successful call to bindtextdomain() that had textdomainname as the domainname argument;
any trailing  characters in dirname shall be discarded. If a successful call to bindtextdomain() has not been made for textdomainname, an
implementation-defined default directory shall be used.
For the LANGUAGE search, the localename part is each locale name from LANGUAGE in turn; if a locale name
has the format language[_territory][.codeset][@modifier], additional
searches of locale names without .codeset (if present), without _territory (if present), and without @modifier
(if present) may be performed; if .codeset is not present, additional searches of locale names with an added .codeset
may be performed. For the single-locale search, the localename part is the name of the current locale, or the locale
specified in an *_l() function call, for the category named by categoryname. Spellings of codeset names are not
standardized, and implementations may attempt to use different commonly known spellings, for example "utf8" and
"UTF-8".
The categoryname part is the string "LC_MESSAGES" if gettext(), dgettext(), ngettext(), or
dngettext() is called, or the locale category name corresponding to the category argument to dcgettext() or
dcngettext(). Likewise for the *_l() variants of all these functions.
For gettext(), gettext_l(), ngettext(), and ngettext_l(), the textdomainname part is the text
domain set by the last successful call to textdomain(). For dgettext(),
dcgettext(), dngettext(), dcngettext(), and the *_l() variants of these functions,
textdomainname is the text domain specified by the domainname argument. The domainname argument shall be
equivalent in syntax and meaning to the domainname argument to textdomain(), except that the selection of the text domain shall affect only the
dgettext(), dcgettext(), dngettext(), and dcngettext() function calls and their *_l() variants.
If the domainname argument is a null pointer, the text domain set by the last successful call to textdomain() shall be used. For all of these functions, if a successful call to textdomain() has not been made the default text domain "messages" shall be
used.
Resolution of the messages object pathname shall be performed the first time one of the gettext family of functions is
called for a given combination of dirname, localename, categoryname, and textdomainname. It is
unspecified whether the pathname is re-resolved if the combination has been used before in a call to one of the gettext
family of functions. If bindtextdomain() performs pathname resolution of its
dirname argument, only the part of the messages object pathname after dirname shall be resolved by the gettext
family of functions.
When one of the gettext family of functions returns a message string that was found in a messages object, it shall
convert the codeset of the message string to the output codeset if a codeset is specified in the messages object (see msgfmt) and the output codeset is not the same as that codeset. If a successful call to
bind_textdomain_codeset() has been made with the text domain of the
messages object as the domainname argument and a non-null codeset argument, the output codeset shall be the
codeset argument from the most recent such call. Otherwise, the output codeset shall be the codeset of characters in the
current locale, or the provided locale object if calling one of the *_l() functions, as specified by the LC_CTYPE
category of the locale. The conversion shall be performed as if by a call to iconv()
using a conversion descriptor returned by iconv_open(, ),
except that if the return value of iconv() would be greater than zero, the
non-identical conversions performed by the gettext family of functions need not be the same as those that such an iconv() call would perform. If an error prevents the codeset conversion from being performed,
the gettext family of functions shall behave as if no message string was found in the messages object. If at least one
non-identical conversion is performed that results in a fallback character (one that does not provide any information about the
character it was converted from, for example, a  or "replacement-character"), the gettext family of
functions may behave as if no message string was found in the messages object.
RETURN VALUE
The gettext(), gettext_l(), dgettext(), dgettext_l(), dcgettext(), and dcgettext_l()
functions shall return the message string described in DESCRIPTION if successful. Otherwise, they shall return msgid.
The ngettext(), ngettext_l(), dngettext(), dngettext_l(), dcngettext(), and
dcngettext_l() functions shall return the message string described in DESCRIPTION if successful. Otherwise, msgid
shall be returned if n is equal to 1, or msgid_plural if n is not equal to 1.
The application shall ensure that it does not modify the returned string. A subsequent call to a gettext family function
shall not overwrite or invalidate the returned string. The returned string may be invalidated by a subsequent call to bind_textdomain_codeset(), bindtextdomain(), setlocale(), or
textdomain() in the same process, except for calls that only query values. The
returned string shall not be invalidated by a subsequent call to uselocale().
ERRORS
The gettext family of functions shall not modify errno. If an error occurs these functions shall return a string
as described in RETURN VALUE.
The following sections are informative.
EXAMPLES
The example code below assumes the following:
The implementation-defined default directory is /system/gettextlib.
The following locales are available on the target system: en_US, en_GB, de_DE. The codeset used for all of these locales is
UTF-8.
The en_AU locale is not available on the target system.
The target system supports conversion from ISO/IEC 8859-1 to UTF-8.
The codeset used for the POSIX locale is ASCII.
The target system does not support conversion from ISO/IEC 8859-1 to ASCII.
Furthermore, the following .mo files (and only the following .mo files) are installed:
/system/gettextlib/en_US/LC_MESSAGES/mail.mo
/messagecatalogs/example/en_US/LC_MESSAGES/mail.mo
These are compiled from a portable messages object source file (dot-po file) with the following ISO/IEC 8859-1 encoded contents
(see the EXTENDED DESCRIPTION of the msgfmt utility for a description of the dot-po
file format):
msgid ""
msgstr ""
"Content-Type: text/plain; charset=ISO_8859-1\n"
"Plural-Forms: nplurals=4; plural= n==1?0: (n>1&&n1&&n1&&n,
XCU gettext, msgfmt,
xgettext
CHANGE HISTORY
First released in Issue 8.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/stdout.html =====
stdin
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
stderr, stdin, stdout — standard I/O streams
SYNOPSIS
#include
extern FILE *stderr, *stdin, *stdout;
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
A file with associated buffering is called a stream and is declared to be a pointer to a defined type FILE. The
fopen() function shall create certain descriptive data for a stream and return a
pointer to designate the stream in all further transactions. Normally, there are three open streams with constant pointers declared
in the  header and associated with the standard open files.
At program start-up, three streams shall be predefined and already open: stdin (standard input, for conventional input)
for reading, stdout (standard output, for conventional output) for writing, and stderr (standard error, for
diagnostic output) for writing. When opened, stderr shall not be fully buffered; stdin and stdout shall be
fully buffered if and only if [CX]   the file descriptor associated with the stream is determined not to be associated with an
interactive device.
[CX]  The
following symbolic values in  define the file descriptors that shall
be associated with the C-language stdin, stdout, and stderr when the application is started:
STDIN_FILENO
Standard input value, stdin. Its value is 0.
STDOUT_FILENO
Standard output value, stdout. Its value is 1.
STDERR_FILENO
Standard error value, stderr. Its value is 2.
These file descriptors are often all associated with a single open file description which has access mode O_RDWR (e.g., in the
case of a terminal device for a login shell). However, the stderr, stdin, and stdout streams need not be
opened for both reading and writing at program start-up in this case.
RETURN VALUE
None.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
fclose(), feof(), ferror(), fileno(), fopen(), fprintf(), fread(), fscanf(), fseek(), getc(), isatty(), popen(), putc(), puts(), read(), setbuf(), setvbuf(), tmpfile(), ungetc(), vfprintf()
XBD ,
CHANGE HISTORY
First released in Issue 1.
Issue 6
Extensions beyond the ISO C standard are marked.
A note that stderr is expected to be open for reading and writing is added to the DESCRIPTION.
Issue 8
Austin Group Defect 1347 is applied, clarifying the requirements for how stderr, stdin, and stdout are
opened at program start-up.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/ttyname_r.html =====
ttyname
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ttyname, ttyname_r — find the pathname of a terminal
SYNOPSIS
#include
char *ttyname(int fildes);
int ttyname_r(int fildes, char *name, size_t namesize);
DESCRIPTION
The ttyname() function shall return a pointer to a string containing a null-terminated pathname of the terminal
associated with file descriptor fildes. The application shall not modify the string returned. The returned pointer might be
invalidated or the string content might be overwritten by a subsequent call to ttyname(). The returned pointer and the
string content might also be invalidated if the calling thread is terminated.
The ttyname() function need not be thread-safe.
The ttyname_r() function shall store the null-terminated pathname of the terminal associated with the file descriptor
fildes in the character array referenced by name. The array is namesize characters long and should have space
for the name and the terminating null character. The maximum length of the terminal name shall be {TTY_NAME_MAX}.
RETURN VALUE
Upon successful completion, ttyname() shall return a pointer to a string. Otherwise, a null pointer shall be returned and
errno set to indicate the error.
If successful, the ttyname_r() function shall return zero. Otherwise, an error number shall be returned to indicate the
error.
ERRORS
These functions may fail if:
[EBADF]
The fildes argument is not a valid file descriptor.
[ENOTTY]
The file associated with the fildes argument is not a terminal.
The ttyname_r() function shall fail if:
[ERANGE]
The value of namesize is smaller than the length of the string to be returned including the terminating null
character.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
The term "terminal" is used instead of the historical term "terminal device" in order to avoid a reference to an undefined
term.
The thread-safe version places the terminal name in a user-supplied buffer and returns a non-zero value if it fails. The
non-thread-safe version may return the name in a static data area that may be overwritten by each call.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The ttyname_r() function is included for alignment with the POSIX Threads Extension.
A note indicating that the ttyname() function need not be reentrant is added to the DESCRIPTION.
Issue 6
The ttyname_r() function is marked as part of the Thread-Safe Functions option.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The statement that errno is set on error is added.
The [EBADF] and [ENOTTY] optional error conditions are added.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
SD5-XSH-ERN-100 is applied, correcting the definition of the [ENOTTY] error condition.
The ttyname_r() function is moved from the Thread-Safe Functions option to the Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0686 [75] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0376 [656] is applied.
Issue 8
Austin Group Defect 398 is applied, combining the duplicated [EBADF] and [ENOTTY] errors and changing the [ERANGE] error from
"may fail" to "shall fail".
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/cfsetispeed.html =====
cfsetispeed
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
cfsetispeed — set input baud rate
SYNOPSIS
#include
int cfsetispeed(struct termios *termios_p, speed_t speed);
DESCRIPTION
The cfsetispeed() function shall set the input baud rate stored in the structure pointed to by termios_p to
speed.
There shall be no effect on the baud rates set in the hardware until a subsequent successful call to tcsetattr() with the same termios structure. Similarly, errors resulting from
attempts to set baud rates not supported by the terminal device need not be detected until the tcsetattr() function is called.
RETURN VALUE
Upon successful completion, cfsetispeed() shall return 0; otherwise, -1 shall be returned, and errno may be set to
indicate the error.
ERRORS
The cfsetispeed() function may fail if:
[EINVAL]
The speed value is not a valid baud rate.
[EINVAL]
The value of speed is outside the range of possible speed values as specified in .
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
Refer to cfgetispeed().
FUTURE DIRECTIONS
None.
SEE ALSO
cfgetispeed(), cfgetospeed(), cfsetospeed(),
tcsetattr()
XBD 11. General Terminal Interface,
CHANGE HISTORY
First released in Issue 3. Included for alignment with the POSIX.1-1988 standard.
Issue 6
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The optional setting of errno and the [EINVAL] error conditions are added.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/va_copy.html =====
va_arg
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
va_arg, va_copy, va_end, va_start — handle variable argument list
SYNOPSIS
#include
type va_arg(va_list ap, type);
void va_copy(va_list dest, va_list src);
void va_end(va_list ap);
void va_start(va_list ap, argN);
DESCRIPTION
Refer to XBD
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/roundl.html =====
round
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
round, roundf, roundl — round to the nearest integer value in a floating-point format
SYNOPSIS
#include
double round(double x);
float roundf(float x);
long double roundl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall round their argument to the nearest integer value in floating-point format, rounding halfway cases away
from zero, regardless of the current rounding direction.
[MX]
These functions may raise the inexact floating-point exception for finite non-integer arguments.
RETURN VALUE
Upon successful completion, these functions shall return the rounded integer value. [MX]   The result
shall have the same sign as x.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0 or ±Inf, x shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The integral value returned by these functions need not be expressible as an intmax_t. The return value should be tested
before assigning it to an integer type to avoid the undefined results of an integer overflow.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0520 [346] is applied.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/opendir.html =====
fdopendir
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fdopendir, opendir — open directory associated with file descriptor
SYNOPSIS
#include
DIR *fdopendir(int fd);
DIR *opendir(const char *dirname);
DESCRIPTION
The fdopendir() function shall be equivalent to the opendir() function except that the directory is specified by a
file descriptor rather than by a name. The file offset associated with the file descriptor at the time of the call determines which
entries are returned.
Upon successful return from fdopendir(), the file descriptor is under the control of the system, and if any attempt is
made to close the file descriptor, or to modify the state of the associated description, other than by means of closedir(), readdir(), readdir_r(), rewinddir(), or
[XSI]
seekdir(),  the
behavior is undefined. Upon calling closedir() the file descriptor shall be
closed.
It is unspecified whether the FD_CLOEXEC flag will be set on the file descriptor by a successful call to fdopendir() if
it was not previously set. However, the flag shall not be cleared if it was previously set.
The opendir() function shall open a directory stream corresponding to the directory named by the dirname argument.
The directory stream shall be positioned at the first entry. If opendir() opens a file descriptor for dirname to
associate with the returned stream:
The descriptor shall be allocated as if the O_DIRECTORY and O_CLOEXEC flags were passed to open().
The descriptor shall be subject to the limit of {OPEN_MAX} file descriptors available to the process.
RETURN VALUE
Upon successful completion, these functions shall return a pointer to an object of type DIR. Otherwise, these functions
shall return a null pointer and set errno to indicate the error.
ERRORS
The fdopendir() function shall fail if:
[EBADF]
The fd argument is not a valid file descriptor open for reading.
[ENOTDIR]
The descriptor fd is not associated with a directory.
The opendir() function shall fail if:
[EACCES]
Search permission is denied for the component of the path prefix of dirname or read permission is denied for
dirname.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the dirname argument.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOENT]
A component of dirname does not name an existing directory or dirname is an empty string.
[ENOTDIR]
A component of dirname names an existing file that is neither a directory nor a symbolic link to a directory.
The opendir() function may fail if:
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the dirname argument.
[EMFILE]
All file descriptors available to the process are currently open.
[ENAMETOOLONG]
The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a
length that exceeds {PATH_MAX}.
[ENFILE]
Too many files are currently open in the system.
The following sections are informative.
EXAMPLES
Open a Directory Stream
The following program fragment demonstrates how the opendir() function is used.
#include
...
DIR *dir;
struct dirent *dp;
...
if ((dir = opendir (".")) == NULL) {
perror ("Cannot open .");
exit (1);
}
while ((dp = readdir (dir)) != NULL) {
...
Find And Open a File
The following program searches through a given directory looking for files whose name does not begin with a dot and whose size
is larger than 1 MiB.
#include
#include
#include
#include
#include
#include
#include
int
main(int argc, char *argv[])
{
struct stat statbuf;
DIR *d;
struct dirent *dp;
int dfd, ffd;
if ((d = fdopendir((dfd = open("./tmp", O_RDONLY)))) == NULL) {
fprintf(stderr, "Cannot open ./tmp directory\n");
exit(1);
}
while ((dp = readdir(d)) != NULL) {
if (dp->d_name[0] == '.')
continue;
/* there is a possible race condition here as the file
* could be renamed between the readdir and the open */
if ((ffd = openat(dfd, dp->d_name, O_RDONLY)) == -1) {
perror(dp->d_name);
continue;
}
if (fstat(ffd, &statbuf) == 0 && statbuf.st_size > (1024*1024)) {
/* found it ... */
printf("%s: %jdK\n", dp->d_name,
(intmax_t)(statbuf.st_size / 1024));
}
close(ffd);
}
closedir(d); // note this implicitly closes dfd
return 0;
}
APPLICATION USAGE
The opendir() function should be used in conjunction with readdir(),
closedir(), and rewinddir() to
examine the contents of the directory (see the EXAMPLES section in readdir()).
This method is recommended for portability.
RATIONALE
The purpose of the fdopendir() function is to enable opening files in directories other than the current working
directory without exposure to race conditions. Any part of the path of a file could be changed in parallel to a call to
opendir(), resulting in unspecified behavior.
Based on historical implementations, the rules about file descriptors apply to directory streams as well. However, this volume
of POSIX.1-2024 does not mandate that opendir() opens a file descriptor to associate with the stream; this may instead be
done by the first call to dirfd(), thus avoiding the need to allocate a file
descriptor if dirfd() is never called. Once a file descriptor has been associated with
the stream, it is mandatory that closedir() deallocate the file descriptor. If
opendir() opens a file descriptor to associate with the stream, it behaves as if the O_CLOEXEC flag for open() had been used, so that the FD_CLOEXEC flag is set for the file descriptor. If
fdopendir() is used to create a directory stream, it is unspecified whether the FD_CLOEXEC flag on the file descriptor
specified by the fd argument is set or left unchanged.
The directory entries for dot and dot-dot are optional. This volume of POSIX.1-2024 does not provide a way to test a
priori for their existence because an application that is portable must be written to look for (and usually ignore) those
entries. Writing code that presumes that they are the first two entries does not always work, as many implementations permit them
to be other than the first two entries, with a "normal" entry preceding them. There is negligible value in providing a way to
determine what the implementation does because the code to deal with dot and dot-dot must be written in any case and because such a
flag would add to the list of those flags (which has proven in itself to be objectionable) and might be abused.
Since the structure and buffer allocation, if any, for directory operations are defined by the implementation, this volume of
POSIX.1-2024 imposes no portability requirements for erroneous program constructs, erroneous data, or the use of unspecified values
such as the use or referencing of a dirp value or a dirent structure value after a directory stream has been closed
or after a fork() or one of the exec
function calls.
FUTURE DIRECTIONS
None.
SEE ALSO
closedir(), dirfd(), fstatat(), open(), posix_getdents(), readdir(),
rewinddir(), symlink()
XBD , ,
CHANGE HISTORY
First released in Issue 2.
Issue 6
In the SYNOPSIS, the optional include of the  header is
removed.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The requirement to include  has been removed. Although
was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.
The [ELOOP] mandatory error condition is added.
A second [ENAMETOOLONG] is added as an optional error condition.
The following changes were made to align with the IEEE P1003.1a draft standard:
The [ELOOP] optional error condition is added.
Issue 7
Austin Group Interpretation 1003.1-2001 #143 is applied.
SD5-XBD-ERN-4 is applied, changing the definition of the [EMFILE] error.
The fdopendir() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 2.
An additional example is added.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0122 [422] and XSH/TC1-2008/0123 [324] are applied.
Issue 8
Austin Group Defect 368 is applied, adding a requirement for FD_CLOEXEC to be set by opendir() if it associates a file
descriptor with the returned stream.
Austin Group Defect 411 is applied, clarifying that FD_CLOEXEC is not cleared by fdopendir() if it was previously
set.
Austin Group Defect 697 is applied, adding posix_getdents() to the SEE
ALSO section.
Austin Group Defect 1360 is applied, clarifying that type DIR always has the ability to store a file descriptor; what is
optional is whether one is opened by opendir().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/cimag.html =====
cimag
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
cimag, cimagf, cimagl — complex imaginary functions
SYNOPSIS
#include
double cimag(double complex z);
float cimagf(float complex z);
long double cimagl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the imaginary part of z.
RETURN VALUE
These functions shall return the imaginary part value (as a real).
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
For a variable z of complex type:
z == creal(z) + cimag(z)*I
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
carg(), conj(), cproj(), creal()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/strtoul.html =====
strtoul
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
strtoul, strtoull — convert a string to an unsigned long
SYNOPSIS
#include
unsigned long strtoul(const char *restrict str,
char **restrict endptr, int base);
unsigned long long strtoull(const char *restrict str,
char **restrict endptr, int base);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall convert the initial portion of the string pointed to by str to a type unsigned long and
unsigned long long representation, respectively. First, they decompose the input string into three parts:
An initial, possibly empty, sequence of white-space bytes
A subject sequence interpreted as an integer represented in some radix determined by the value of base
A final string of one or more unrecognized characters, including the terminating NUL character of the input string
Then they shall attempt to convert the subject sequence to an unsigned integer, and return the result.
If the value of base is 0, the expected form of the subject sequence is that of a decimal constant, octal constant, or
hexadecimal constant, any of which may be preceded by a '+' or '-' sign. A decimal constant begins with a
non-zero digit, and consists of a sequence of decimal digits. An octal constant consists of the prefix '0' optionally
followed by a sequence of the digits '0' to '7' only. A hexadecimal constant consists of the prefix 0x or 0X
followed by a sequence of the decimal digits and letters 'a' (or 'A') to 'f' (or 'F') with
values 10 to 15 respectively.
If the value of base is between 2 and 36, the expected form of the subject sequence is a sequence of letters and digits
representing an integer with the radix specified by base, optionally preceded by a '+' or '-' sign. The
letters from 'a' (or 'A') to 'z' (or 'Z') inclusive are ascribed the values 10 to 35; only
letters whose ascribed values are less than that of base are permitted. If the value of base is 16, the characters 0x
or 0X may optionally precede the sequence of letters and digits, following the sign if present.
The subject sequence is defined as the longest initial subsequence of the input string, starting with the first non-white-space
byte, that is of the expected form. The subject sequence shall contain no characters if the input string is empty or consists
entirely of white-space bytes, or if the first non-white-space byte is other than a sign or a permissible letter or digit.
If the subject sequence has the expected form and the value of base is 0, the sequence of characters starting with the
first digit shall be interpreted as an integer constant. If the subject sequence has the expected form and the value of base
is between 2 and 36, it shall be used as the base for conversion, ascribing to each letter its value as given above. If the subject
sequence begins with a , the resulting value shall be the negative of the converted value; this action shall be
performed in the return type. A pointer to the final string shall be stored in the object pointed to by endptr, provided
that endptr is not a null pointer.
In other than the C [CX]   or POSIX  locale, additional
locale-specific subject sequence forms may be accepted.
If the subject sequence is empty or does not have the expected form, no conversion shall be performed; the value of str
shall be stored in the object pointed to by endptr, provided that endptr is not a null pointer.
These functions shall not change the setting of errno if successful.
Since 0, {ULONG_MAX}, and {ULLONG_MAX} are returned on error and are also valid returns on success, an application wishing to
check for error situations should set errno to 0, then call strtoul() or strtoull(), then check
errno.
RETURN VALUE
Upon successful completion, these functions shall return the converted value, if any. If no conversion could be performed, 0
shall be returned [CX]   and errno may be set to [EINVAL].
[CX]  If
the value of base is not supported, 0 shall be returned and errno shall be set to [EINVAL].
If the correct value is outside the range of representable values, {ULONG_MAX} or {ULLONG_MAX} shall be returned and
errno set to [ERANGE].
ERRORS
These functions shall fail if:
[EINVAL]
[CX]
The value of base is not supported.
[ERANGE]
The value to be returned is not representable.
These functions may fail if:
[EINVAL]
[CX]  No
conversion could be performed.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Since the value of *endptr is unspecified if the value of base is not supported, applications should either ensure
that base has a supported value (0 or between 2 and 36) before the call, or check for an [EINVAL] error before examining
*endptr.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
fscanf(), isalpha(), strtod(), strtol()
XBD
CHANGE HISTORY
First released in Issue 4. Derived from the ANSI C standard.
Issue 5
The DESCRIPTION is updated to indicate that errno is not changed if the function is successful.
Issue 6
Extensions beyond the ISO C standard are marked.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The [EINVAL] error condition is added for when the value of base is not supported.
In the RETURN VALUE and ERRORS sections, the [EINVAL] optional error condition is added if no conversion could be performed.
The following changes are made for alignment with the ISO/IEC 9899:1999 standard:
The strtoul() prototype is updated.
The strtoull() function is added.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0621 [105], XSH/TC1-2008/0622 [453], and XSH/TC1-2008/0623 [453] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0355 [584] and XSH/TC2-2008/0356 [796] are applied.
Issue 8
Austin Group Defect 700 is applied, clarifying how a subject sequence beginning with  is converted.
Austin Group Defect 1163 is applied, clarifying the handling of white space in the input string.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/hsearch.html =====
hcreate
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
hcreate, hdestroy, hsearch — manage hash search table
SYNOPSIS
[XSI]  #include
int hcreate(size_t nel);
void hdestroy(void);
ENTRY *hsearch(ENTRY item, ACTION action);
DESCRIPTION
The hcreate(), hdestroy(), and hsearch() functions shall manage hash search tables.
The hcreate() function shall allocate sufficient space for the table, and the application shall ensure it is called
before hsearch() is used. The nel argument is an estimate of the maximum number of entries that the table shall
contain. This number may be adjusted upward by the algorithm in order to obtain certain mathematically favorable circumstances.
The hdestroy() function shall dispose of the search table, and may be followed by another call to hcreate(). After
the call to hdestroy(), the data can no longer be considered accessible.
The hsearch() function is a hash-table search routine. It shall return a pointer into a hash table indicating the
location at which an entry can be found. The item argument is a structure of type ENTRY (defined in the  header) containing two pointers: item.key points to the comparison
key (a char *), and item.data (a void *) points to any other data to be associated with that key. The
comparison function used by hsearch() is strcmp(). The action argument
is a member of an enumeration type ACTION indicating the disposition of the entry if it cannot be found in the table. ENTER
indicates that the item should be inserted in the table at an appropriate point. FIND indicates that no entry should be made.
Unsuccessful resolution is indicated by the return of a null pointer.
These functions need not be thread-safe.
RETURN VALUE
The hcreate() function shall return 0 if it cannot allocate sufficient space for the table; otherwise, it shall return
non-zero.
The hdestroy() function shall not return a value.
The hsearch() function shall return a null pointer if either the action is FIND and the item could not be found or the
action is ENTER and the table is full.
ERRORS
The hcreate() and hsearch() functions may fail if:
[ENOMEM]
Insufficient storage space is available.
The following sections are informative.
EXAMPLES
The following example reads in strings followed by two numbers and stores them in a hash table, discarding duplicates. It then
reads in strings and finds the matching entry in the hash table and prints it out.
#include
#include
#include
struct info {        /* This is the info stored in the table */
int age, room;   /* other than the key. */
};
#define NUM_EMPL    5000    /* # of elements in search table. */
int main(void)
{
char string_space[NUM_EMPL*20];   /* Space to store strings. */
struct info info_space[NUM_EMPL]; /* Space to store employee info. */
char *str_ptr = string_space;     /* Next space in string_space. */
struct info *info_ptr = info_space;
/* Next space in info_space. */
ENTRY item;
ENTRY *found_item; /* Name to look for in table. */
char name_to_find[30];
int i = 0;
/* Create table; no error checking is performed. */
(void) hcreate(NUM_EMPL);
while (scanf("%s%d%d", str_ptr, &info_ptr->age,
&info_ptr->room) != EOF && i++ key,
((struct info *)found_item->data)->age,
((struct info *)found_item->data)->room);
} else
(void)printf("no such employee %s\n", name_to_find);
}
return 0;
}
APPLICATION USAGE
The hcreate() and hsearch() functions may use malloc() to allocate
space.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
bsearch(), lsearch(), malloc(), strcmp(), tdelete()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
A note indicating that this function need not be reentrant is added to the DESCRIPTION.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/dirname.html =====
dirname
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
dirname — report the parent directory name of a file pathname
SYNOPSIS
[XSI]  #include
char *dirname(char *path);
DESCRIPTION
The dirname() function shall take a pointer to a character string that contains a pathname, and return a pointer to a
string that is a pathname of the directory containing the entry of the final pathname component. The dirname() function
shall not perform pathname resolution; the result shall not be affected by whether or not path exists or by its file type.
Trailing '/' characters in the pathname that are not also leading '/' characters shall not be counted as part of
the pathname.
If the pathname does not contain a '/', then dirname() shall return a pointer to the string ".". If
path is a null pointer or points to an empty string, dirname() shall return a pointer to the string ".".
It is unspecified whether redundant '/' characters and '.' pathname components in path are removed
after determining the pathname to output. However, ".." pathname components occurring prior to the final component shall
not be removed.
The dirname() function may modify the string pointed to by path, and may return a pointer into the input string.
The returned pointer might be invalidated if the input string is subsequently modified or freed. If path does not contain a
'/', is a null pointer, or points to an empty string the returned pointer may point to constant data that cannot be
modified.
RETURN VALUE
The dirname() function shall return a pointer to a string as described above.
The dirname() function shall always be successful and no return value is reserved to indicate an error.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
The following code fragment reads a pathname, changes the current working directory to the parent directory, and opens the
file.
char *path = NULL, *pathcopy;
size_t buflen = 0;
ssize_t linelen = 0;
int fd;
linelen = getline(&path, &buflen, stdin);
path[linelen-1] = 0;
pathcopy = strdup(path);
if (chdir(dirname(pathcopy)) = 0) {
...
close (fd);
}
...
free (pathcopy);
free (path);
The EXAMPLES section of the basename() function (see basename()) includes a table showing examples of the results of processing
several sample pathnames by the basename() and dirname() functions and by
the basename and dirname
utilities.
APPLICATION USAGE
The dirname() and basename() functions together yield a complete
pathname. The expression dirname(path) obtains the pathname of the directory where basename(path) is
found.
Since the meaning of the leading "//" is implementation-defined, dirname("//foo") may return either
"//" or "/" (but nothing else).
Note that in some circumstances, the returned pointer might point into constant data. Therefore, if the application needs to
modify the returned data, it should be copied first.
RATIONALE
An implementation should prefer the shortest output possible; however, this is not required, in part because earlier versions of
the standard did not mention whether elision of redundant  characters or dot (".") components was permitted.
Removal of the dot-dot ("..") pathname component is not permitted, because eliding it correctly would require performing
pathname resolution to ensure the resulting string would still point to the correct pathname if the original string resolved as a
pathname. On implementations where pathname "//" has an implementation-defined meaning distinct from the pathname
"/", the dirname of "//" will be "//".
Earlier versions of this standard seemed to allow thread-safe and non-thread-safe implementations of basename() and dirname(), but did not allow implementations to return a null pointer
and require that errno be set when that happened. The standard now requires thread-safe behavior for both of these functions
and clearly states that they are always successful.
FUTURE DIRECTIONS
None.
SEE ALSO
basename()
XBD
XCU basename, dirname
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Normative text previously in the APPLICATION USAGE section is moved to the DESCRIPTION.
A note indicating that this function need not be reentrant is added to the DESCRIPTION.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
The EXAMPLES section is revised.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0068 [75] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0077 [830], XSH/TC2-2008/0078 [612], XSH/TC2-2008/0079 [830],
XSH/TC2-2008/0080 [656], and XSH/TC2-2008/0081 [612] are applied.
Issue 8
Austin Group Defect 1064 is applied, requiring dirname() to be thread-safe and allowing it to return a pointer to
constant data under certain conditions.
Austin Group Defect 1073 is applied, changing "parent directory of that file" to "directory containing the entry of the final
pathname component" and clarifying that redundant '/' characters and '.' pathname components may be removed
after determining the pathname to output.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_attr_getschedparam.html =====
pthread_attr_getschedparam
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_attr_getschedparam, pthread_attr_setschedparam — get and set the schedparam attribute
SYNOPSIS
#include
int pthread_attr_getschedparam(const pthread_attr_t *restrict attr,
struct sched_param *restrict param);
int pthread_attr_setschedparam(pthread_attr_t *restrict attr,
const struct sched_param *restrict param);
DESCRIPTION
The pthread_attr_getschedparam() and pthread_attr_setschedparam() functions, respectively, shall get and set the
scheduling parameter attributes in the attr argument. The contents of the param structure are defined in the  header. For the SCHED_FIFO and SCHED_RR policies, the only required member of
param is sched_priority.
[TSP]
For the SCHED_SPORADIC policy, the required members of the param structure are sched_priority,
sched_ss_low_priority, sched_ss_repl_period, sched_ss_init_budget, and sched_ss_max_repl. The specified
sched_ss_repl_period needs to be greater than or equal to the specified sched_ss_init_budget for the function to
succeed; if it is not, then the function shall fail. The value of sched_ss_max_repl shall be within the inclusive range
[1,{SS_REPL_MAX}] for the function to succeed; if not, the function shall fail. It is unspecified whether the
sched_ss_repl_period and sched_ss_init_budget values are stored as provided by this function or are rounded to align
with the resolution of the clock being used.
The behavior is undefined if the value specified by the attr argument to pthread_attr_getschedparam() or
pthread_attr_setschedparam() does not refer to an initialized thread attributes object.
RETURN VALUE
If successful, the pthread_attr_getschedparam() and pthread_attr_setschedparam() functions shall return zero;
otherwise, an error number shall be returned to indicate the error.
ERRORS
The pthread_attr_setschedparam() function shall fail if:
[ENOTSUP]
An attempt was made to set the attribute to an unsupported value.
The pthread_attr_setschedparam() function may fail if:
[EINVAL]
The value of param is not valid.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
After these attributes have been set, a thread can be created with the specified attributes using pthread_create(). Using these routines does not affect the current running
thread.
RATIONALE
If an implementation detects that the value specified by the attr argument to pthread_attr_getschedparam() or
pthread_attr_setschedparam() does not refer to an initialized thread attributes object, it is recommended that the function
should fail and report an [EINVAL] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_attr_destroy(), pthread_attr_getscope(), pthread_attr_getinheritsched(), pthread_attr_getschedpolicy(), pthread_create()
XBD ,
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
The pthread_attr_getschedparam() and pthread_attr_setschedparam() functions are marked as part of the Threads
option.
The SCHED_SPORADIC scheduling policy is added for alignment with IEEE Std 1003.1d-1999.
The restrict keyword is added to the pthread_attr_getschedparam() and pthread_attr_setschedparam()
prototypes for alignment with the ISO/IEC 9899:1999 standard.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/78 is applied, updating the ERRORS section to include optional
errors for the case when attr refers to an uninitialized thread attribute object.
Issue 7
The pthread_attr_getschedparam() and pthread_attr_setschedparam() functions are moved from the Threads option to
the Base.
Austin Group Interpretation 1003.1-2001 #119 is applied, clarifying the accuracy requirements for the
sched_ss_repl_period and sched_ss_init_budget values.
The [EINVAL] error for an uninitialized thread attributes object is removed; this condition results in undefined behavior.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0451 [314] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/inet_addr.html =====
inet_addr
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
inet_addr, inet_ntoa — IPv4 address manipulation
SYNOPSIS
[OB]  #include
in_addr_t inet_addr(const char *cp);
char *inet_ntoa(struct in_addr in);
DESCRIPTION
The inet_addr() function shall convert the string pointed to by cp, in the standard IPv4 dotted decimal notation,
to an integer value suitable for use as an Internet address.
The inet_ntoa() function shall convert the Internet host address specified by in to a string in the Internet
standard dot notation.
The inet_ntoa() function need not be thread-safe.
All Internet addresses shall be returned in network order (bytes ordered from left to right).
Values specified using IPv4 dotted decimal notation take one of the following forms:
a.b.c.d
When four parts are specified, each shall be interpreted as a byte of data and assigned, from left to right, to the four bytes
of an Internet address.
a.b.c
When a three-part address is specified, the last part shall be interpreted as a 16-bit quantity and placed in the rightmost two
bytes of the network address. This makes the three-part address format convenient for specifying Class B network addresses as
"128.net.host".
a.b
When a two-part address is supplied, the last part shall be interpreted as a 24-bit quantity and placed in the rightmost three
bytes of the network address. This makes the two-part address format convenient for specifying Class A network addresses as
"net.host".
a
When only one part is given, the value shall be stored directly in the network address without any byte rearrangement.
All numbers supplied as parts in IPv4 dotted decimal notation may be decimal, octal, or hexadecimal, as specified in the
ISO C standard (that is, a leading 0x or 0X implies hexadecimal; otherwise, a leading '0' implies octal; otherwise,
the number is interpreted as decimal).
RETURN VALUE
Upon successful completion, inet_addr() shall return the Internet address. Otherwise, it shall return
(in_addr_t)(-1).
The inet_ntoa() function shall return a pointer to the network address in Internet standard dot notation.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The return value of inet_ntoa() may point to static data that may be overwritten by subsequent calls to
inet_ntoa().
Applications should prefer inet_pton() over inet_addr() for the
following reasons:
The return value from inet_addr() when converting 255.255.255.255 is indistinguishable from an error.
The inet_pton() function supports multiple address families.
The alternative textual representations supported by inet_addr() (but not by inet_pton()) are often used maliciously to confuse or mislead users (e.g., for
phishing).
Applications should prefer inet_ntop() over inet_ntoa() as it supports
multiple address families and is thread-safe.
RATIONALE
None.
FUTURE DIRECTIONS
These functions are included only for compatibility with older implementations and may be removed in a future version.
SEE ALSO
endhostent(), endnetent()
, inet_ntop()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
Issue 8
Austin Group Defects 1101 and 1102 are applied, marking inet_addr() and inet_ntoa() as obsolescent.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/catan.html =====
catan
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
catan, catanf, catanl — complex arc tangent functions
SYNOPSIS
#include
double complex catan(double complex z);
float complex catanf(float complex z);
long double complex catanl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex arc tangent of z, with branch cuts outside the interval
[-i, +i] along the imaginary axis.
RETURN VALUE
These functions shall return the complex arc tangent value, in the range of a strip mathematically unbounded along the imaginary
axis and in the interval [-ℼ/2, +ℼ/2] along the real axis.
[MXC]
catan(conj(iz)), catanf(conjf(iz)), and catanl(conjl(iz)) shall
return exactly the same value as conj(catan(iz)), conjf(catanf(iz)), and
conjl(catanl(iz)), respectively, and catan(-iz), catanf(-iz), and
catanl(-iz) shall return exactly the same value as -catan(iz), -catanf(iz), and
-catanl(iz), respectively, including for the special values of iz below.
If iz is +0 + i0, -i (+0 + i0) shall be returned.
If iz is +0 + iNaN, -i (+0 + iNaN) shall be returned.
If iz is +1 + i0, -i (+Inf + i0) shall be returned and the divide-by-zero floating-point exception
shall be raised.
If iz is x + iInf where x is positive-signed and finite, -i (+0 + iℼ/2) shall be
returned.
If iz is x + iNaN where x is non-zero and finite, -i (NaN + iNaN) shall be returned
and the invalid floating-point exception may be raised.
If iz is +Inf + iy where y is positive-signed and finite, -i (+0 + iℼ/2) shall be
returned.
If iz is +Inf + iInf, -i (+0 + iℼ/2) shall be returned.
If iz is +Inf + iNaN, -i (+0 + iNaN) shall be returned.
If iz is NaN + iy where y is finite, -i (NaN + iNaN) shall be returned and the invalid
floating-point exception may be raised.
If iz is NaN + iInf, -i (±0 + iℼ/2) shall be returned; the sign of the imaginary part of the result
is unspecified.
If iz is NaN + iNaN, -i (NaN + iNaN) shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
The MXC special cases for catan() are derived from those for catanh() by
applying the formula catan(z) = -i catanh(iz).
FUTURE DIRECTIONS
None.
SEE ALSO
catanh(), ctan()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/atanhl.html =====
atanh
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
atanh, atanhf, atanhl — inverse hyperbolic tangent functions
SYNOPSIS
#include
double atanh(double x);
float atanhf(float x);
long double atanhl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the inverse hyperbolic tangent of their argument x.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the inverse hyperbolic tangent of their argument.
If x is ±1, a pole error shall occur, and atanh(), atanhf(), and atanhl() shall return the value of
the macro HUGE_VAL, HUGE_VALF, and HUGE_VALL, respectively, with the same sign as the correct value of the function.
For finite |x|>1, a domain error shall occur, and [MX]   either a NaN (if supported), or   an implementation-defined value shall be returned.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0, x shall be returned.
If x is ±Inf, a domain error shall occur, and a NaN shall be returned.
[MXX]
If x is subnormal, x should be returned.
[MX]  If x is subnormal, a range error may occur and, if x is
not returned, atanh(), atanhf(), and atanhl() shall return an implementation-defined value no greater in
magnitude than DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
ERRORS
These functions shall fail if:
Domain Error
The x argument is finite and not in the range [-1,1], [MX]   or is ±Inf.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
Pole Error
The x argument is ±1.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the divide-by-zero floating-point exception shall
be raised.
These functions may fail if:
Range Error
[MX]
The value of x is subnormal.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), tanh()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
The atanh() function is no longer marked as an extension.
The atanhf() and atanhl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0039 [320] and XSH/TC1-2008/0040 [680] are applied.
Issue 8
Austin Group Defect 1382 is applied, rearranging the text describing the behavior when x is subnormal to avoid the need
for two shading changes.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_kill.html =====
pthread_kill
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_kill — send a signal to a thread
SYNOPSIS
[CX]  #include
int pthread_kill(pthread_t thread, int sig);
DESCRIPTION
The pthread_kill() function shall request that a signal be delivered to the specified thread. It shall not be an error if
thread is a zombie thread.
RETURN VALUE
Upon successful completion, the function shall return a value of zero. Otherwise, the function shall return an error number. If
the pthread_kill() function fails, no signal shall be sent.
ERRORS
The pthread_kill() function may fail if:
[EINVAL]
The value of the sig argument is zero.
The pthread_kill() function shall fail if:
[EINVAL]
The value of the sig argument is non-zero and is an invalid or unsupported signal number.
The pthread_kill() function shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The pthread_kill() function provides a mechanism for asynchronously directing a signal at a thread in the calling
process. This could be used, for example, by one thread to affect broadcast delivery of a signal to a set of threads.
Note that pthread_kill() only causes the signal to be handled in the context of the given thread; the signal action
(termination or stopping) affects the process as a whole.
RATIONALE
If an implementation detects use of a thread ID after the end of its lifetime, it is recommended that the function should fail
and report an [ESRCH] error.
Historical implementations varied on the result of a pthread_kill() with a thread ID indicating a zombie thread. Some
indicated success on such a call, while others gave an error of [ESRCH]. Since the definition of thread lifetime in this volume of
POSIX.1-2024 covers zombie threads, the [ESRCH] error as described is inappropriate in this case and implementations that give this
error do not conform. In particular, this means that an application cannot have one thread check for termination of another by
calling pthread_kill() with a sig argument of zero, and implementations may indicate that it is not possible by
returning [EINVAL] when sig is zero.
FUTURE DIRECTIONS
None.
SEE ALSO
kill(), pthread_self(), raise()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
The pthread_kill() function is marked as part of the Threads option.
The APPLICATION USAGE section is added.
Issue 7
The pthread_kill() function is moved from the Threads option to the Base.
Austin Group Interpretation 1003.1-2001 #142 is applied, removing the [ESRCH] error condition.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0277 [765] is applied.
Issue 8
Austin Group Defect 792 is applied, adding a requirement that passing the thread ID of a zombie thread to pthread_kill()
is not treated as an error.
Austin Group Defect 1214 is applied, allowing pthread_kill() to fail with [EINVAL] when the sig argument is
zero.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sem_close.html =====
sem_close
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sem_close — close a named semaphore
SYNOPSIS
#include
int sem_close(sem_t *sem);
DESCRIPTION
The sem_close() function shall indicate that the calling process is finished using the named semaphore indicated by
sem. The effects of calling sem_close() for an unnamed semaphore (one created by sem_init()) are undefined. The sem_close() function shall deallocate (that is, make
available for reuse by a subsequent sem_open() by this process) any system
resources allocated by the system for use by this process for this semaphore. If the semaphore indicated by sem is
implemented using a file descriptor, the file descriptor shall be closed. The effect of subsequent use of the semaphore indicated
by sem by this process is undefined. If any threads in the calling process are currently blocked on the semaphore, the
behavior is undefined. If the semaphore has not been removed with a successful call to sem_unlink(), then sem_close() has no effect on the state of the semaphore. If the
sem_unlink() function has been successfully invoked for name after the
most recent call to sem_open() with O_CREAT for this semaphore, then when all
processes that have opened the semaphore close all semaphore handles to it, the semaphore is no longer accessible.
RETURN VALUE
Upon successful completion, a value of zero shall be returned. Otherwise, a value of -1 shall be returned and errno set
to indicate the error.
ERRORS
The sem_close() function may fail if:
[EINVAL]
The sem argument is not a valid semaphore descriptor.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
semctl(), semget(), semop(), sem_init(), sem_open(), sem_unlink()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Issue 6
The sem_close() function is marked as part of the Semaphores option.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Semaphores
option.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/113 is applied, updating the ERRORS section so that the [EINVAL]
error becomes optional.
Issue 7
The sem_close() function is moved from the Semaphores option to the Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0523 [37] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0317 [870] is applied.
Issue 8
Austin Group Defect 368 is applied, adding a requirement that if sem is implemented using a file descriptor,
sem_close() closes the file descriptor.
Austin Group Defect 1324 is applied, clarifying the circumstances under which an unlinked semaphore is no longer accessible.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/malloc.html =====
malloc
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
malloc — a memory allocator
SYNOPSIS
#include
void *malloc(size_t size);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The malloc() function shall allocate unused space for an object whose size in bytes is specified by size and whose
value is unspecified.
The order and contiguity of storage allocated by successive calls to malloc() is unspecified. The pointer returned if the
allocation succeeds shall be suitably aligned so that it may be assigned to a pointer to any type of object with a fundamental
alignment requirement and then used to access such an object in the space allocated (until the space is explicitly freed or
reallocated). Each such allocation shall yield a pointer to an object disjoint from any other object. The pointer returned points
to the start (lowest byte address) of the allocated space. If the space cannot be allocated, a null pointer shall be returned. If
the size of the space requested is 0, the behavior is implementation-defined: either a null pointer shall be returned, or the
behavior shall be as if the size were some non-zero value, except that the behavior is undefined if the returned pointer is used to
access an object.
For purposes of determining the existence of a data race, malloc() shall behave as though it accessed only memory
locations accessible through its argument and not other static duration storage. The function may, however, visibly modify the
storage that it allocates. Calls to aligned_alloc(), calloc(), free(), malloc(), [ADV]   posix_memalign(),
[CX]
reallocarray(),
and realloc() that allocate or deallocate a particular region of memory shall
occur in a single total order (see 4.15.1 Memory Ordering), and each
such deallocation call shall synchronize with the next allocation (if any) in this order.
RETURN VALUE
Upon successful completion, malloc() shall return a pointer to the allocated space; if size is 0, the application
shall ensure that the pointer is not used to access an object.
Otherwise, it shall return a null pointer [CX]   and set errno to indicate the error.
ERRORS
The malloc() function shall fail if:
[ENOMEM]
[CX]
Insufficient storage space is available.
The malloc() function may fail if:
[EINVAL]
[CX]
size is 0 and the implementation does not support 0 sized allocations.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
Some implementations set errno to [EAGAIN] to signal memory allocation failures that might succeed if retried and
[ENOMEM] for failures that are unlikely to ever succeed, for example due to configured limits. 2.3 Error Numbers permits this behavior; when multiple error conditions are
simultaneously true there is no precedence between them.
FUTURE DIRECTIONS
None.
SEE ALSO
aligned_alloc(), calloc()
, free(), getrlimit(), posix_memalign(), realloc()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
Extensions beyond the ISO C standard are marked.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
In the RETURN VALUE section, the requirement to set errno to indicate an error is added.
The [ENOMEM] error condition is added.
Issue 7
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0203 [526] is applied.
Issue 8
Austin Group Defect 374 is applied, changing the RETURN VALUE and ERRORS sections in relation to 0 sized allocations.
Austin Group Defect 1302 is applied, aligning this function with the ISO/IEC 9899:2018 standard.
Austin Group Defects 1387 and 1489 are applied, changing the RATIONALE section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/logbl.html =====
logb
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
logb, logbf, logbl — radix-independent exponent
SYNOPSIS
#include
double logb(double x);
float logbf(float x);
long double logbl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the exponent of x, which is the integral part of logr
|x|, as a signed floating-point value, for non-zero x, where r is the radix of the machine's floating-point
arithmetic, which is the value of FLT_RADIX defined in the
header.
If x is subnormal it is treated as though it were normalized; thus for finite positive x:
1 ,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
The logb() function is no longer marked as an extension.
The logbf() and logbl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
ISO/IEC 9899:1999 standard, Technical Corrigendum 2 #50 (SD5-XSH-ERN-76) is applied.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/tzname.html =====
tzset
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
daylight, timezone, tzname, tzset — set timezone conversion information
SYNOPSIS
#include
[XSI]  extern int daylight;
extern long timezone;
[CX]  extern char *tzname[2];
void tzset(void);
DESCRIPTION
The tzset() function shall use the value of the environment variable TZ to set time conversion information used by
ctime(), localtime(), mktime(), and strftime(). If TZ is
absent from the environment, implementation-defined default timezone information shall be used.
The tzset() function shall set the external variable tzname as follows:
tzname[0] = "std";
tzname[1] = "dst";
where std and dst are as described in XBD 8. Environment
Variables.
[XSI]
The tzset() function also shall set the external variable daylight to 0 if Daylight Saving Time conversions should
never be applied for the timezone in use; otherwise, non-zero. The external variable timezone shall be set to the
difference, in seconds, between Coordinated Universal Time (UTC) and local standard time.
If a thread accesses tzname, [XSI]  daylight, or timezone   directly while another thread is in a call to tzset(), or to any function that is
required or allowed to set timezone information as if by calling tzset(), the behavior is undefined.
RETURN VALUE
The tzset() function shall not return a value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
Example TZ variables and their timezone differences are given in the table below:
TZ
timezone
EST5EDT
5*60*60
GMT0
0*60*60
JST-9
-9*60*60
MET-1MEST
-1*60*60
MST7MDT
7*60*60
PST8PDT
8*60*60
APPLICATION USAGE
Since the ctime(), localtime(),
mktime(), strftime(), and strftime_l() functions are required to set timezone information as if by calling
tzset(), there is no need for an explicit tzset() call before using these functions. However, portable applications
should call tzset() explicitly before using localtime_r() because setting
timezone information is optional for that function.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
ctime(), localtime(), mktime(), strftime()
XBD 8. Environment Variables,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The example is corrected.
Issue 7
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0377 [880] is applied.
Issue 8
Austin Group Defect 1253 is applied, changing "Daylight Savings" to "Daylight Saving".
Austin Group Defect 1410 is applied, removing the ctime_r() function.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/atomic_flag_clear.html =====
atomic_flag_clear
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
atomic_flag_clear, atomic_flag_clear_explicit — clear an atomic flag
SYNOPSIS
#include
void atomic_flag_clear(volatile atomic_flag *object);
void atomic_flag_clear_explicit(volatile atomic_flag *object,
memory_order order);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
Implementations that define the macro __STDC_NO_ATOMICS__ need not provide the  header nor support these generic functions.
The atomic_flag_clear_explicit() function shall atomically place the atomic flag pointed to by object into the
clear state. Memory shall be affected according to the value of order, which the application shall ensure is not
memory_order_acquire nor memory_order_acq_rel.
The atomic_flag_clear() function shall be equivalent to atomic_flag_clear_explicit() called with order set
to memory_order_seq_cst.
RETURN VALUE
These functions shall not return a value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD 4.15.1 Memory Ordering,
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getc_unlocked.html =====
getc_unlocked
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getc_unlocked, getchar_unlocked, putc_unlocked, putchar_unlocked — stdio with explicit client locking
SYNOPSIS
[CX]  #include
int getc_unlocked(FILE *stream);
int getchar_unlocked(void);
int putc_unlocked(int c, FILE *stream);
int putchar_unlocked(int c);
DESCRIPTION
Versions of the functions getc(), getchar(), putc(), and putchar() respectively named getc_unlocked(), getchar_unlocked(),
putc_unlocked(), and putchar_unlocked() shall be provided which are functionally equivalent to the original versions,
with the exception that they are not required to be implemented in a fully thread-safe manner. They shall be thread-safe when used
within a scope protected by flockfile() (or ftrylockfile()) and funlockfile().
These functions can safely be used in a multi-threaded program if and only if they are called while the invoking thread owns the
(FILE *) object, as is the case after a successful call to the flockfile()
or ftrylockfile() functions.
If getc_unlocked() or putc_unlocked() are implemented as macros they may evaluate stream more than once, so
the stream argument should never be an expression with side-effects.
RETURN VALUE
See getc(), getchar(), putc(), and putchar().
ERRORS
See getc(), getchar(), putc(), and putchar().
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Since they may be implemented as macros, getc_unlocked() and putc_unlocked() may treat incorrectly a stream
argument with side-effects. In particular, getc_unlocked(*f++) and putc_unlocked(c,*f++) do not necessarily work as
expected. Therefore, use of these functions in such situations should be preceded by the following statement as appropriate:
#undef getc_unlocked
#undef putc_unlocked
RATIONALE
Some I/O functions are typically implemented as macros for performance reasons (for example, putc() and getc()). For safety, they need to be
synchronized, but it is often too expensive to synchronize on every character. Nevertheless, it was felt that the safety concerns
were more important; consequently, the getc(), getchar(), putc(), and putchar() functions are required to be thread-safe. However, unlocked versions are also
provided with names that clearly indicate the unsafe nature of their operation but can be used to exploit their higher performance.
These unlocked versions can be safely used only within explicitly locked program regions, using exported locking primitives. In
particular, a sequence such as:
flockfile(fileptr);
putc_unlocked('1', fileptr);
putc_unlocked('\n', fileptr);
fprintf(fileptr, "Line 2\n");
funlockfile(fileptr);
is permissible, and results in the text sequence:
1
Line 2
being printed without being interspersed with output from other threads.
It would be wrong to have the standard names such as getc(), putc(), and so on, map to the "faster, but unsafe" rather than the "slower, but safe"
versions. In either case, you would still want to inspect all uses of getc(), putc(), and so on, by hand when converting existing code. Choosing the safe bindings as the
default, at least, results in correct code and maintains the "atomicity at the function" invariant. To do otherwise would
introduce gratuitous synchronization errors into converted code. Other routines that modify the stdio (FILE *)
structures or buffers are also safely synchronized.
Note that there is no need for functions of the form getc_locked(), putc_locked(), and so on, since this is the
functionality of getc(), putc(), et
al. It would be inappropriate to use a feature test macro to switch a macro definition of getc() between getc_locked() and getc_unlocked(), since the ISO C standard
requires an actual function to exist, a function whose behavior could not be changed by the feature test macro. Also, providing
both the xxx_locked() and xxx_unlocked() forms leads to the confusion of whether the suffix describes the behavior of
the function or the circumstances under which it should be used.
Three additional routines, flockfile(), ftrylockfile(), and funlockfile()
(which may be macros), are provided to allow the user to delineate a sequence of I/O statements that are executed
synchronously.
The ungetc() function is infrequently called relative to the other
functions/macros so no unlocked variation is needed.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, flockfile(), getc(), getchar(), putc(), putchar()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
These functions are marked as part of the Thread-Safe Functions option.
The Open Group Corrigendum U030/2 is applied, adding APPLICATION USAGE describing how applications should be written to avoid
the case when the functions are implemented as macros.
Issue 7
The getc_unlocked(), getchar_unlocked(), putc_unlocked(), and putchar_unlocked() functions are moved
from the Thread-Safe Functions option to the Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0232 [395], XSH/TC1-2008/0233 [395], XSH/TC1-2008/0234 [395], and
XSH/TC1-2008/0235 [14] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0151 [826] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/difftime.html =====
difftime
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
difftime — compute the difference between two calendar time values
SYNOPSIS
#include
double difftime(time_t time1, time_t time0);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The difftime() function shall compute the difference between two calendar times (as returned by time()): time1- time0.
RETURN VALUE
The difftime() function shall return the difference expressed in seconds as a type double.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
asctime(), clock(), ctime(), futimens(), gmtime(), localtime(), mktime(), strftime(), strptime(), time()
XBD
CHANGE HISTORY
First released in Issue 4. Derived from the ISO C standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/crypt.html =====
crypt
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
crypt — password hashing function (CRYPT)
SYNOPSIS
[XSI]  #include
char *crypt(const char *key, const char *salt);
DESCRIPTION
The crypt() function hashes a password for storage in the user database. The algorithm is implementation-defined.
The key argument points to a password to be hashed. The salt argument shall be a string of at least two bytes in
length not including the null character chosen from the set:
a b c d e f g h i j k l m n o p q r s t u v w x y z
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
0 1 2 3 4 5 6 7 8 9 . /
The first two bytes of this string may be used to perturb the encoding algorithm.
The return value of crypt() points to static data that is overwritten by each call.
The crypt() function need not be thread-safe.
RETURN VALUE
Upon successful completion, crypt() shall return a pointer to the hashed password; the first two bytes of the returned
value shall be those of the salt argument. Otherwise, it shall return a null pointer and set errno to indicate the
error.
ERRORS
The crypt() function shall fail if:
[ENOSYS]
The functionality is not supported on this implementation.
The following sections are informative.
EXAMPLES
Encoding Passwords
The following example finds a user database entry matching a particular user name and changes the current password to a new
password. The crypt() function generates an encoded version of each password. The first call to crypt() produces an
encoded version of the old password; that encoded password is then compared to the password stored in the user database. The second
call to crypt() encodes the new password before it is stored.
The putpwent() function, used in the following example, is not part of POSIX.1-2024.
#include
#include
#include
#include
...
int valid_change;
int pfd;  /* Integer for file descriptor returned by open(). */
FILE *fpfd;  /* File pointer for use in putpwent(). */
struct passwd *p;
char user[100];
char oldpasswd[100];
char newpasswd[100];
char savepasswd[100];
...
valid_change = 0;
while ((p = getpwent()) != NULL) {
/* Change entry if found. */
if (strcmp(p->pw_name, user) == 0) {
if (strcmp(p->pw_passwd, crypt(oldpasswd, p->pw_passwd)) == 0) {
strcpy(savepasswd, crypt(newpasswd, user));
p->pw_passwd = savepasswd;
valid_change = 1;
}
else {
fprintf(stderr, "Old password is not valid\n");
}
}
/* Put passwd entry into ptmp. */
putpwent(p, fpfd);
}
APPLICATION USAGE
The values returned by this function need not be portable among XSI-conformant systems.
Several implementations offer extensions via characters outside of the set specified for the salt argument for specifying
alternative algorithms; while not portable, these extensions may offer better security. The use of crypt() for anything
other than password hashing is not recommended.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
encrypt(), setkey()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
Normative text previously in the APPLICATION USAGE section is moved to the DESCRIPTION.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
SD5-XSH-ERN-178 is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0073 [899] is applied.
Issue 8
Austin Group Defect 1192 is applied, clarifying that crypt() is intended for password hashing, not for general string
encoding.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/clog.html =====
clog
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
clog, clogf, clogl — complex natural logarithm functions
SYNOPSIS
#include
double complex clog(double complex z);
float complex clogf(float complex z);
long double complex clogl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex natural (base e) logarithm of z, with a branch cut along the negative
real axis.
RETURN VALUE
These functions shall return the complex natural logarithm value, in the range of a strip mathematically unbounded along the
real axis and in the interval [-iℼ, +iℼ] along the imaginary axis.
[MXC]
clog(conj(z)), clogf(conjf(z)), and clogl(conjl(z)) shall return
exactly the same value as conj(clog(z)), conjf(clogf(z)), and
conjl(clogl(z)), respectively, including for the special values of z below.
If z is -0 + i0, -Inf + iℼ shall be returned and the divide-by-zero floating-point exception shall be
raised.
If z is +0 + i0, -Inf + i0 shall be returned and the divide-by-zero floating-point exception shall be
raised.
If z is x + iInf where x is finite, +Inf + iℼ/2 shall be returned.
If z is x + iNaN where x is finite, NaN + iNaN shall be returned and the invalid
floating-point exception may be raised.
If z is -Inf + iy where y is positive-signed and finite, +Inf + iℼ shall be returned.
If z is +Inf + iy where y is positive-signed and finite, +Inf + i0 shall be returned.
If z is -Inf + iInf, +Inf + i3ℼ/4 shall be returned.
If z is +Inf + iInf, +Inf + iℼ/4 shall be returned.
If z is ±Inf + iNaN, +Inf + iNaN shall be returned.
If z is NaN + iy where y is finite, NaN + iNaN shall be returned and the invalid floating-point
exception may be raised.
If z is NaN + iInf, +Inf + iNaN shall be returned.
If z is NaN + iNaN, NaN + iNaN shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
cexp()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wctype.html =====
wctype
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wctype, wctype_l — define character class
SYNOPSIS
#include
wctype_t wctype(const char *property);
[CX]  wctype_t wctype_l(const char *property, locale_t locale);
DESCRIPTION
For wctype(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The wctype() [CX]   and wctype_l()
functions are defined for valid character class names as defined in the current locale [CX]   or in the
locale represented by locale,   respectively.
The property argument is a string identifying a generic character class for which codeset-specific type information is
required. The following character class names shall be defined in all locales:
alnum
alpha
blank
cntrl
digit
graph
lower
print
punct
space
upper
xdigit
Additional character class names defined in the locale definition file (category LC_CTYPE ) can also be
specified.
These functions shall return a value of type wctype_t, which can be used as the second argument to
subsequent calls of iswctype() [CX]   and iswctype_l().
The wctype() [CX]   and wctype_l()
functions shall determine values of wctype_t according to the rules of the coded character set defined by character
type information in the current locale [CX]   or in the locale represented by locale,   respectively (category LC_CTYPE ).
The values returned by wctype() shall be valid until a call to setlocale() that modifies the category LC_CTYPE .
[CX]  The values returned by wctype_l() shall be valid only in calls to iswctype_l() with a locale represented by locale with the same LC_CTYPE
category value.
The behavior is undefined if the locale argument to wctype_l() is the special locale object
LC_GLOBAL_LOCALE or is not a valid locale object handle.
RETURN VALUE
The wctype() [CX]   and wctype_l()
functions shall return 0 if the given character class name is not valid for the current locale (category LC_CTYPE );
otherwise, they shall return an object of type wctype_t that can be used in calls to iswctype() [CX]   and iswctype_l().
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
iswctype()
XBD
CHANGE HISTORY
First released in Issue 4.
Issue 5
The following change has been made in this version for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E):
The SYNOPSIS has been changed to indicate that this function and associated data types are now made visible by
inclusion of the  header rather than .
Issue 7
The wctype_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0736 [302], XSH/TC1-2008/0737 [283], and XSH/TC1-2008/0738
[283] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/setgrent.html =====
endgrent
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
endgrent, getgrent, setgrent — group database entry functions
SYNOPSIS
[XSI]  #include
void endgrent(void);
struct group *getgrent(void);
void setgrent(void);
DESCRIPTION
The getgrent() function shall return a pointer to a structure containing the broken-out fields of an entry in the group
database. If the group database is not already open, getgrent() shall open it and return a pointer to a group
structure containing the first entry in the database. Thereafter, it shall return a pointer to a group structure containing
the next group structure in the group database, so successive calls may be used to search the entire database.
An implementation that provides extended security controls may impose further implementation-defined restrictions on accessing
the group database. In particular, the system may deny the existence of some or all of the group database entries associated with
groups other than those groups associated with the caller and may omit users other than the caller from the list of members of
groups in database entries that are returned.
The setgrent() function shall rewind the group database so that the next getgrent() call returns the first entry,
allowing repeated searches.
The endgrent() function shall close the group database.
The setgrent() and endgrent() functions shall not change the setting of errno if successful.
On error, the setgrent() and endgrent() functions shall set errno to indicate the error.
Since no value is returned by the setgrent() and endgrent() functions, an application wishing to check for error
situations should set errno to 0, then call the function, then check errno.
These functions need not be thread-safe.
RETURN VALUE
On successful completion, getgrent() shall return a pointer to a group structure. On end-of-file,
getgrent() shall return a null pointer and shall not change the setting of errno. On error, getgrent() shall
return a null pointer and errno shall be set to indicate the error.
The application shall not modify the structure to which the return value points, nor any storage areas pointed to by pointers
within the structure. The returned pointer, and pointers within the structure, might be invalidated or the structure or the storage
areas might be overwritten by a subsequent call to getgrgid(), getgrnam(), or getgrent(). The returned pointer, and pointers within the structure,
might also be invalidated if the calling thread is terminated.
ERRORS
These functions may fail if:
[EINTR]
A signal was caught during the operation.
[EIO]
An I/O error has occurred.
In addition, the getgrent() and setgrent() functions may fail if:
[EMFILE]
All file descriptors available to the process are currently open.
[ENFILE]
The maximum allowable number of files is currently open in the system.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
These functions are provided due to their historical usage. Applications should avoid dependencies on fields in the group
database, whether the database is a single file, or where in the file system name space the database resides. Applications should
use getgrnam() and getgrgid()
whenever possible because it avoids these dependencies.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
endpwent(), getgrgid(),
getgrnam(), getlogin()
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Normative text previously in the APPLICATION USAGE section is moved to the RETURN VALUE section.
A note indicating that these functions need not be reentrant is added to the DESCRIPTION.
Issue 6
In the DESCRIPTION, the note about reentrancy is expanded to cover thread-safety.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
SD5-XBD-ERN-4 is applied, changing the definition of the [EMFILE] error.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0080 [75] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0086 [493], XSH/TC2-2008/0087 [656], and XSH/TC2-2008/0088 [493] are
applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getpwuid.html =====
getpwuid
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getpwuid, getpwuid_r — search user database for a user ID
SYNOPSIS
#include
struct passwd *getpwuid(uid_t uid);
int getpwuid_r(uid_t uid, struct passwd *pwd, char *buffer,
size_t bufsize, struct passwd **result);
DESCRIPTION
The getpwuid() function shall search the user database for an entry with a matching uid.
The getpwuid() function need not be thread-safe.
Applications wishing to check for error situations should set errno to 0 before calling getpwuid(). If
getpwuid() returns a null pointer and errno is set to non-zero, an error occurred.
The getpwuid_r() function shall update the passwd structure pointed to by pwd and store a pointer to that
structure at the location pointed to by result. The structure shall contain an entry from the user database with a matching
uid. Storage referenced by the structure is allocated from the memory provided with the buffer parameter, which is
bufsize bytes in size. A call to sysconf(_SC_GETPW_R_SIZE_MAX) returns either -1 without changing errno or an
initial value suggested for the size of this buffer. A null pointer shall be returned at the location pointed to by result
on error or if the requested entry is not found.
RETURN VALUE
The getpwuid() function shall return a pointer to a struct passwd with the structure as defined in  with a matching entry if found. A null pointer shall be returned if the requested
entry is not found, or an error occurs. If the requested entry was not found, errno shall not be changed. On error,
errno shall be set to indicate the error.
The application shall not modify the structure to which the return value points, nor any storage areas pointed to by pointers
within the structure. The returned pointer, and pointers within the structure, might be invalidated or the structure or the storage
areas might be overwritten by a subsequent call to getpwent(), getpwnam(), or getpwuid(). The returned pointer, and pointers within the structure,
might also be invalidated if the calling thread is terminated.
If successful, the getpwuid_r() function shall return zero; otherwise, an error number shall be returned to indicate the
error.
ERRORS
These functions may fail if:
[EIO]
An I/O error has occurred.
[EINTR]
A signal was caught during getpwuid().
[EMFILE]
All file descriptors available to the process are currently open.
[ENFILE]
The maximum allowable number of files is currently open in the system.
The getpwuid_r() function shall fail if:
[ERANGE]
Insufficient storage was supplied via buffer and bufsize to contain the data to be referenced by the resulting
passwd structure.
The following sections are informative.
EXAMPLES
Note that sysconf(_SC_GETPW_R_SIZE_MAX) may return -1 if there is no hard limit on the size of the buffer needed to store
all the groups returned. This example shows how an application can allocate a buffer of sufficient size to work with
getpwuid_r().
long int initlen = sysconf(_SC_GETPW_R_SIZE_MAX);
size_t len;
if (initlen == -1)
/* Default initial length. */
len = 1024;
else
len = (size_t) initlen;
struct passwd result;
struct passwd *resultp;
char *buffer = malloc(len);
if (buffer == NULL)
...handle error...
int e;
while ((e = getpwuid_r(42, &result, buffer, len, &resultp)) == ERANGE)
{
size_t newlen = 2 * len;
if (newlen
#include
...
uid_t id = 0;
struct passwd *pwd;
pwd = getpwuid(id);
Finding the Name for the Effective User ID
The following example defines pws as a pointer to a structure of type passwd, which is used to store the structure
pointer returned by the call to the getpwuid() function. The geteuid()
function shall return the effective user ID of the calling process; this is used as the search criteria for the getpwuid()
function. The call to getpwuid() shall return a pointer to the structure containing that user ID value.
#include
#include
#include
...
struct passwd *pws;
pws = getpwuid(geteuid());
Finding an Entry in the User Database
The following example uses getpwuid() to search the user database for a user ID that was previously stored in a
stat structure, then prints out the user name if it is found. If the user is not found, the program prints the numeric value
of the user ID for the entry.
#include
#include
#include
...
struct stat statbuf;
struct passwd *pwd;
...
if ((pwd = getpwuid(statbuf.st_uid)) != NULL)
printf(" %-8.8s", pwd->pw_name);
else
printf(" %-8d", statbuf.st_uid);
APPLICATION USAGE
Three names associated with the current process can be determined: getpwuid(geteuid()) returns the name associated with the effective user ID of the process; getlogin() returns the name associated with the current login activity; and
getpwuid(getuid()) returns the name associated with the real user ID of the
process.
The getpwuid_r() function is thread-safe and returns values in a user-supplied buffer instead of possibly using a static
data area that may be overwritten by each call.
Portable applications should take into account that it is usual for an implementation to return -1 from sysconf() indicating that there is no maximum for _SC_GETPW_R_SIZE_MAX.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
getpwnam(), geteuid(),
getuid(), getlogin(), sysconf()
XBD ,
CHANGE HISTORY
First released in Issue 1. Derived from System V Release 2.0.
Issue 5
Normative text previously in the APPLICATION USAGE section is moved to the RETURN VALUE section.
The getpwuid_r() function is included for alignment with the POSIX Threads Extension.
A note indicating that the getpwuid() function need not be reentrant is added to the DESCRIPTION.
Issue 6
The getpwuid_r() function is marked as part of the Thread-Safe Functions option.
The Open Group Corrigendum U028/3 is applied, correcting text in the DESCRIPTION describing matching the uid.
In the SYNOPSIS, the optional include of the  header is
removed.
In the DESCRIPTION, the note about reentrancy is expanded to cover thread-safety.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The requirement to include  has been removed. Although
was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.
In the RETURN VALUE section, the requirement to set errno on error is added.
The [EIO], [EINTR], [EMFILE], and [ENFILE] optional error conditions are added.
The APPLICATION USAGE section is updated to include a note on the thread-safe function and its avoidance of possibly using a
static data area.
IEEE PASC Interpretation 1003.1 #116 is applied, changing the description of the size of the buffer from bufsize
characters to bytes.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
SD5-XBD-ERN-4 is applied, changing the definition of the [EMFILE] error.
SD5-XSH-ERN-166 is applied.
The getpwuid_r() function is moved from the Thread-Safe Functions option to the Base.
A minor addition is made to the EXAMPLES section, reminding the application developer to free memory allocated as if by malloc().
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0256 [75] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0172 [808] and XSH/TC2-2008/0173 [656] are applied.
Issue 8
Austin Group Defect 398 is applied, changing the [ERANGE] error from "may fail" to "shall fail".
Austin Group Defect 1570 is applied, removing extra spacing in "==".
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/duplocale.html =====
duplocale
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
duplocale — duplicate a locale object
SYNOPSIS
[CX]  #include
locale_t duplocale(locale_t locobj);
DESCRIPTION
The duplocale() function shall create a duplicate copy of the locale object referenced by the locobj argument.
If the locobj argument is LC_GLOBAL_LOCALE, duplocale() shall create a new locale object containing a copy of the
global locale determined by the setlocale() function.
The behavior is undefined if the locobj argument is not a valid locale object handle.
RETURN VALUE
Upon successful completion, the duplocale() function shall return a handle for a new locale object. Otherwise,
duplocale() shall return (locale_t)0 and set errno to indicate the error.
ERRORS
The duplocale() function shall fail if:
[ENOMEM]
There is not enough memory available to create the locale object or load the locale data.
The following sections are informative.
EXAMPLES
Constructing an Altered Version of an Existing Locale Object
The following example shows a code fragment to create a slightly altered version of an existing locale object. The function
takes a locale object and a locale name and it replaces the LC_TIME category data in the locale object with that from the
named locale.
#include
...
locale_t
with_changed_lc_time (locale_t obj, const char *name)
{
locale_t retval = duplocale (obj);
if (retval != (locale_t) 0)
{
locale_t changed = newlocale (LC_TIME_MASK, name, retval);
if (changed == (locale_t) 0)
/* An error occurred. Free all allocated resources. */
freelocale (retval);
retval = changed;
}
return retval;
}
APPLICATION USAGE
The use of the duplocale() function is recommended for situations where a locale object is being used in multiple places,
and it is possible that the lifetime of the locale object might end before all uses are finished. Another reason to duplicate a
locale object is if a slightly modified form is needed. This can be achieved by a call to newlocale() following the duplocale() call.
As with the newlocale() function, handles for locale objects created by the
duplocale() function should be released by a corresponding call to freelocale().
The duplocale() function can also be used in conjunction with uselocale((locale_t)0). This returns the
locale in effect for the calling thread, but can have the value LC_GLOBAL_LOCALE. Passing LC_GLOBAL_LOCALE to functions such as
isalnum_l() results in undefined behavior, but applications can convert it into a
usable locale object by using duplocale().
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
freelocale(), newlocale()
, uselocale()
XBD
CHANGE HISTORY
First released in Issue 7.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0077 [283,301], XSH/TC1-2008/0078 [283], and XSH/TC1-2008/0079 [301] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0084 [753] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/asinhf.html =====
asinh
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
asinh, asinhf, asinhl — inverse hyperbolic sine functions
SYNOPSIS
#include
double asinh(double x);
float asinhf(float x);
long double asinhl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the inverse hyperbolic sine of their argument x.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the inverse hyperbolic sine of their argument.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0, or ±Inf, x shall be returned.
[MXX]
If x is subnormal, x should be returned.
[MX]  If x is subnormal, a range error may occur and, if x is
not returned, asinh(), asinhf(), and asinhl() shall return an implementation-defined value no greater in
magnitude than DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
ERRORS
These functions may fail if:
Range Error
[MX]
The value of x is subnormal.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), sinh()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
The asinh() function is no longer marked as an extension.
The asinhf() and asinhl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0036 [68] is applied.
Issue 8
Austin Group Defect 1382 is applied, rearranging the text describing the behavior when x is subnormal to avoid the need
for two shading changes.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_attr_setschedparam.html =====
pthread_attr_getschedparam
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_attr_getschedparam, pthread_attr_setschedparam — get and set the schedparam attribute
SYNOPSIS
#include
int pthread_attr_getschedparam(const pthread_attr_t *restrict attr,
struct sched_param *restrict param);
int pthread_attr_setschedparam(pthread_attr_t *restrict attr,
const struct sched_param *restrict param);
DESCRIPTION
The pthread_attr_getschedparam() and pthread_attr_setschedparam() functions, respectively, shall get and set the
scheduling parameter attributes in the attr argument. The contents of the param structure are defined in the  header. For the SCHED_FIFO and SCHED_RR policies, the only required member of
param is sched_priority.
[TSP]
For the SCHED_SPORADIC policy, the required members of the param structure are sched_priority,
sched_ss_low_priority, sched_ss_repl_period, sched_ss_init_budget, and sched_ss_max_repl. The specified
sched_ss_repl_period needs to be greater than or equal to the specified sched_ss_init_budget for the function to
succeed; if it is not, then the function shall fail. The value of sched_ss_max_repl shall be within the inclusive range
[1,{SS_REPL_MAX}] for the function to succeed; if not, the function shall fail. It is unspecified whether the
sched_ss_repl_period and sched_ss_init_budget values are stored as provided by this function or are rounded to align
with the resolution of the clock being used.
The behavior is undefined if the value specified by the attr argument to pthread_attr_getschedparam() or
pthread_attr_setschedparam() does not refer to an initialized thread attributes object.
RETURN VALUE
If successful, the pthread_attr_getschedparam() and pthread_attr_setschedparam() functions shall return zero;
otherwise, an error number shall be returned to indicate the error.
ERRORS
The pthread_attr_setschedparam() function shall fail if:
[ENOTSUP]
An attempt was made to set the attribute to an unsupported value.
The pthread_attr_setschedparam() function may fail if:
[EINVAL]
The value of param is not valid.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
After these attributes have been set, a thread can be created with the specified attributes using pthread_create(). Using these routines does not affect the current running
thread.
RATIONALE
If an implementation detects that the value specified by the attr argument to pthread_attr_getschedparam() or
pthread_attr_setschedparam() does not refer to an initialized thread attributes object, it is recommended that the function
should fail and report an [EINVAL] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_attr_destroy(), pthread_attr_getscope(), pthread_attr_getinheritsched(), pthread_attr_getschedpolicy(), pthread_create()
XBD ,
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
The pthread_attr_getschedparam() and pthread_attr_setschedparam() functions are marked as part of the Threads
option.
The SCHED_SPORADIC scheduling policy is added for alignment with IEEE Std 1003.1d-1999.
The restrict keyword is added to the pthread_attr_getschedparam() and pthread_attr_setschedparam()
prototypes for alignment with the ISO/IEC 9899:1999 standard.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/78 is applied, updating the ERRORS section to include optional
errors for the case when attr refers to an uninitialized thread attribute object.
Issue 7
The pthread_attr_getschedparam() and pthread_attr_setschedparam() functions are moved from the Threads option to
the Base.
Austin Group Interpretation 1003.1-2001 #119 is applied, clarifying the accuracy requirements for the
sched_ss_repl_period and sched_ss_init_budget values.
The [EINVAL] error for an uninitialized thread attributes object is removed; this condition results in undefined behavior.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0451 [314] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wcsdup.html =====
wcsdup
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wcsdup — duplicate a wide-character string
SYNOPSIS
[CX]  #include
wchar_t *wcsdup(const wchar_t *string);
DESCRIPTION
The wcsdup() function is the wide-character equivalent of the strdup()
function.
The wcsdup() function shall return a pointer to a new wide-character string, allocated as if by a call to malloc(), which is the duplicate of the wide-character string string. The returned
pointer can be passed to free(). A null pointer is returned if the new wide-character
string cannot be created.
RETURN VALUE
Upon successful completion, the wcsdup() function shall return a pointer to the newly allocated wide-character string.
Otherwise, it shall return a null pointer and set errno to indicate the error.
ERRORS
The wcsdup() function shall fail if:
[ENOMEM]
Memory large enough for the duplicate string could not be allocated.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
For functions that allocate memory as if by malloc(), the application should
release such memory when it is no longer required by a call to free(). For
wcsdup(), this is the return value.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
free(), strdup(), wcscpy()
XBD
CHANGE HISTORY
First released in Issue 7.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/csqrtl.html =====
csqrt
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
csqrt, csqrtf, csqrtl — complex square root functions
SYNOPSIS
#include
double complex csqrt(double complex z);
float complex csqrtf(float complex z);
long double complex csqrtl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex square root of z, with a branch cut along the negative real axis.
RETURN VALUE
These functions shall return the complex square root value, in the range of the right half-plane (including the imaginary
axis).
[MXC]
csqrt(conj(z)), csqrtf(conjf(z)), and csqrtl(conjl(z)) shall return
exactly the same value as conj(csqrt(z)), conjf(csqrtf(z)), and
conjl(csqrtl(z)), respectively, including for the special values of z below.
If z is ±0 + i0, +0 + i0 shall be returned.
If the imaginary part of z is Inf, +Inf + iInf, shall be returned.
If z is x + iNaN where x is finite, NaN + iNaN shall be returned and the invalid
floating-point exception may be raised.
If z is -Inf + iy where y is positive-signed and finite, +0 + iInf shall be returned.
If z is +Inf + iy where y is positive-signed and finite, +Inf + i0 shall be returned.
If z is -Inf + iNaN, NaN ± iInf shall be returned; the sign of the imaginary part of the result is
unspecified.
If z is +Inf + iNaN, +Inf + iNaN shall be returned.
If z is NaN + iy where y is finite, NaN + iNaN shall be returned and the invalid floating-point
exception may be raised.
If z is NaN + iNaN, NaN + iNaN shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
cabs(), cpow()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wcstod.html =====
wcstod
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wcstod, wcstof, wcstold — convert a wide-character string to a double-precision number
SYNOPSIS
#include
double wcstod(const wchar_t *restrict nptr, wchar_t **restrict endptr);
float wcstof(const wchar_t *restrict nptr, wchar_t **restrict endptr);
long double wcstold(const wchar_t *restrict nptr,
wchar_t **restrict endptr);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall convert the initial portion of the wide-character string pointed to by nptr to double,
float, and long double representation, respectively. First, they shall decompose the input wide-character string into
three parts:
An initial, possibly empty, sequence of white-space wide characters
A subject sequence interpreted as a floating-point constant or representing infinity or NaN
A final wide-character string of one or more unrecognized wide-character codes, including the terminating null wide-character
code of the input wide-character string
Then they shall attempt to convert the subject sequence to a floating-point number, and return the result.
The expected form of the subject sequence is an optional '+' or '-' sign, then one of the following:
A non-empty sequence of decimal digits optionally containing a radix character; then an optional exponent part consisting of the
wide character 'e' or the wide character 'E', optionally followed by a '+' or '-' wide
character, and then followed by one or more decimal digits
A 0x or 0X, then a non-empty sequence of hexadecimal digits optionally containing a radix character; then an optional binary
exponent part consisting of the wide character 'p' or the wide character 'P', optionally followed by a
'+' or '-' wide character, and then followed by one or more decimal digits
One of INF or INFINITY, or any other wide string equivalent except for case
One of NAN or NAN(n-wchar-sequenceopt), or any other wide string ignoring case in the NAN part,
where:
n-wchar-sequence:
digit
nondigit
n-wchar-sequence digit
n-wchar-sequence nondigit
The subject sequence is defined as the longest initial subsequence of the input wide string, starting with the first
non-white-space wide character, that is of the expected form. The subject sequence contains no wide characters if the input wide
string is not of the expected form.
If the subject sequence has the expected form for a floating-point number, the sequence of wide characters starting with the
first digit or the radix character (whichever occurs first) shall be interpreted as a floating constant according to the rules of
the C language, except that the radix character shall be used in place of a period, and that if neither an exponent part nor a
radix character appears in a decimal floating-point number, or if a binary exponent part does not appear in a hexadecimal
floating-point number, an exponent part of the appropriate type with value zero shall be assumed to follow the last digit in the
string. If the subject sequence begins with a , the sequence shall be interpreted as negated. A wide-character
sequence INF or INFINITY shall be interpreted as an infinity, if representable in the return type, else as if it were a floating
constant that is too large for the range of the return type. A wide-character sequence NAN or
NAN(n-wchar-sequenceopt) shall be interpreted as a quiet NaN, if supported in the return type,
else as if it were a subject sequence part that does not have the expected form; the meaning of the n-wchar sequences is
implementation-defined. A pointer to the final wide string shall be stored in the object pointed to by endptr, provided that
endptr is not a null pointer.
If the subject sequence has the hexadecimal form and FLT_RADIX is a power of 2, the conversion shall be rounded in an
implementation-defined manner.
[CX]  The
radix character shall be as defined in the current locale (category LC_NUMERIC ). In the POSIX locale, or in a locale where
the radix character is not defined, the radix character shall default to a  ('.').
In other than the C [CX]   or POSIX  locale, additional
locale-specific subject sequence forms may be accepted.
If the subject sequence is empty or does not have the expected form, no conversion shall be performed; the value of nptr
shall be stored in the object pointed to by endptr, provided that endptr is not a null pointer.
These functions shall not change the setting of errno if successful.
Since 0 is returned on error and is also a valid return on success, an application wishing to check for error situations should
set errno to 0, then call wcstod(), wcstof(), or wcstold(), then check errno.
RETURN VALUE
Upon successful completion, these functions shall return the converted value. If no conversion could be performed, 0 shall be
returned [CX]   and errno may be set to [EINVAL].
If the correct value would cause an overflow and default rounding is in effect, ±HUGE_VAL, ±HUGE_VALF, or ±HUGE_VALL shall be
returned (according to the sign of the value), and errno shall be set to [ERANGE].
If the correct value would cause underflow, a value whose magnitude is no greater than the smallest normalized positive number
in the return type shall be returned [CX]   and errno set to [ERANGE].
ERRORS
The wcstod() function shall fail if:
[ERANGE]
The value to be returned would cause overflow and default rounding is in effect [CX]   or the value
to be returned would cause underflow.
The wcstod() function may fail if:
[EINVAL]
[CX]  No
conversion could be performed.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
If the subject sequence has the hexadecimal form and FLT_RADIX is not a power of 2, and the result is not exactly representable,
the result should be one of the two numbers in the appropriate internal format that are adjacent to the hexadecimal floating source
value, with the extra stipulation that the error should have a correct sign for the current rounding direction.
If the subject sequence has the decimal form and at most DECIMAL_DIG (defined in ) significant digits, the result should be correctly rounded. If the subject
sequence D has the decimal form and more than DECIMAL_DIG significant digits, consider the two bounding, adjacent decimal
strings L and U, both having DECIMAL_DIG significant digits, such that the values of L, D, and U
satisfy "L ,
CHANGE HISTORY
First released in Issue 4. Derived from the MSE working draft.
Issue 5
The DESCRIPTION is updated to indicate that errno is not changed if the function is successful.
Issue 6
Extensions beyond the ISO C standard are marked.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
In the RETURN VALUE and ERRORS sections, the [EINVAL] optional error condition is added if no conversion could be performed.
The following changes are made for alignment with the ISO/IEC 9899:1999 standard:
The wcstod() prototype is updated.
The wcstof() and wcstold() functions are added.
If the correct value for wcstod() would cause underflow, the return value changed from 0 (as specified in Issue 5) to the
smallest normalized positive number.
The DESCRIPTION, RETURN VALUE, and APPLICATION USAGE sections are extensively updated.
ISO/IEC 9899:1999 standard, Technical Corrigendum 1 is incorporated.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/66 is applied, correcting the second paragraph in the RETURN
VALUE section.
Issue 7
Austin Group Interpretation 1003.1-2001 #015 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0723 [302] and XSH/TC1-2008/0724 [105] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0391 [584] and XSH/TC2-2008/0392 [796] are applied.
Issue 8
Austin Group Defect 1163 is applied, clarifying the handling of white space in the input string.
Austin Group Defect 1686 is applied, addressing some inconsistencies with strtod().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sigqueue.html =====
sigqueue
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sigqueue — queue a signal to a process
SYNOPSIS
[CX]  #include
int sigqueue(pid_t pid, int signo, union sigval value);
DESCRIPTION
The sigqueue() function shall cause the signal specified by signo to be sent with the value specified by
value to the process specified by pid. If signo is zero (the null signal), error checking is performed but no
signal is actually sent. The null signal can be used to check the validity of pid.
The conditions required for a process to have permission to queue a signal to another process are the same as for the kill() function.
The sigqueue() function shall return immediately. If SA_SIGINFO is set for signo and if the resources were
available to queue the signal, the signal shall be queued and sent to the receiving process. If SA_SIGINFO is not set for
signo, then signo shall be sent at least once to the receiving process; it is unspecified whether value shall
be sent to the receiving process as a result of this call.
If the value of pid causes signo to be generated for the sending process, and if signo is not blocked for
the calling thread and if no other thread has signo unblocked or is waiting in a sigwait() function for signo, either signo or at least the pending, unblocked
signal shall be delivered to the calling thread before the sigqueue() function returns. Should any multiple pending signals
in the range SIGRTMIN to SIGRTMAX be selected for delivery, it shall be the lowest numbered one. The selection order between
realtime and non-realtime signals, or between multiple pending non-realtime signals, is unspecified.
RETURN VALUE
Upon successful completion, the specified signal shall have been queued, and the sigqueue() function shall return a value
of zero. Otherwise, the function shall return a value of -1 and set errno to indicate the error.
ERRORS
The sigqueue() function shall fail if:
[EAGAIN]
No resources are available to queue the signal. The process has already queued {SIGQUEUE_MAX} signals that are still pending at
the receiver(s), or a system-wide resource limit has been exceeded.
[EINVAL]
The value of the signo argument is an invalid or unsupported signal number.
[EPERM]
The process does not have appropriate privileges to send the signal to the receiving process.
[ESRCH]
The process pid does not exist.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
The sigqueue() function allows an application to queue a realtime signal to itself or to another process, specifying the
application-defined value. This is common practice in realtime applications on existing realtime systems. It was felt that
specifying another function in the sig... name space already carved out for signals was preferable to extending the
interface to kill().
Such a function became necessary when the put/get event function of the message queues was removed. It should be noted that the
sigqueue() function implies reduced performance in a security-conscious implementation as the access permissions between the
sender and receiver have to be checked on each send when the pid is resolved into a target process. Such access checks were
necessary only at message queue open in the previous interface.
The standard developers required that sigqueue() have the same semantics with respect to the null signal as kill(), and that the same permission checking be used. But because of the difficulty of
implementing the "broadcast" semantic of kill() (for example, to process groups) and
the interaction with resource allocation, this semantic was not adopted. The sigqueue() function queues a signal to a single
process specified by the pid argument.
The sigqueue() function can fail if the system has insufficient resources to queue the signal. An explicit limit on the
number of queued signals that a process could send was introduced. While the limit is "per-sender", this volume of POSIX.1-2024
does not specify that the resources be part of the state of the sender. This would require either that the sender be maintained
after exit until all signals that it had sent to other processes were handled or that all such signals that had not yet been acted
upon be removed from the queue(s) of the receivers. This volume of POSIX.1-2024 does not preclude this behavior, but an
implementation that allocated queuing resources from a system-wide pool (with per-sender limits) and that leaves queued signals
pending after the sender exits is also permitted.
FUTURE DIRECTIONS
None.
SEE ALSO
2.8.1 Realtime Signals
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension and the POSIX Threads Extension.
Issue 6
The sigqueue() function is marked as part of the Realtime Signals Extension option.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Realtime
Signals Extension option.
Issue 7
The sigqueue() function is moved from the Realtime Signals Extension option to the Base.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0332 [844] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/basename.html =====
basename
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
basename — return the last component of a pathname
SYNOPSIS
[XSI]  #include
char *basename(char *path);
DESCRIPTION
The basename() function shall take the pathname pointed to by path and return a pointer to the final component of
the pathname, deleting any trailing '/' characters.
If the string pointed to by path consists entirely of the '/' character, basename() shall return a
pointer to the string "/", except that if the string pointed to by path is exactly "//", it is
implementation-defined whether "/" or "//" is returned.
If path is a null pointer or points to an empty string, basename() shall return a pointer to the string
".".
The basename() function may modify the string pointed to by path, and may return a pointer into the input string.
The returned pointer might be invalidated if the input string is subsequently modified or freed. If path is a null pointer
or points to an empty string, or if the string pointed to by path consists entirely of the '/' character, the
returned pointer may point to constant data that cannot be modified.
RETURN VALUE
The basename() function shall return a pointer to the final component of path.
The basename() function shall always be successful and no return value is reserved to indicate an error.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
Using basename()
The following program fragment returns a pointer to the value lib, which is the base name of /usr/lib.
#include
...
char name[] = "/usr/lib";
char *base;
base = basename(name);
...
Sample Input and Output Strings for the basename() and dirname() Functions
and the basename and dirname Utilities
basename() and dirname Functions path Argument
String Returned by basename()
String Returned by dirname()
basename and dirname Utilities string Operand
Output Written by basename Utility
Output Written by dirname Utility
"usr"
"usr"
"."
usr
usr
.
"usr/"
"usr"
"."
usr/
usr
.
""
"."
"."
empty string
. or empty string
.
"/"
"/"
"/"
/
/
/
"//"
"/" or "//" (see note 1)
"/" or "//" (see note 1)
//
/ or // (see note 1)
/ or // (see note 1)
"///"
"/"
"/" or "///"
///
/
/ or ///
"/usr/"
"usr"
"/"
/usr/
usr
/
"/usr/lib"
"lib"
"/usr"
/usr/lib
lib
/usr
"//usr//lib//"
"lib"
"//usr" or "/usr" (see note 1)
//usr//lib//
lib
//usr or /usr (see note 1)
"/home//dwc//test"
"test"
"/home//dwc" or "/home/dwc"
/home//dwc//test
test
/home//dwc or /home/dwc
"/home/.././test
"test"
"/home/../." or "/home/.."
/home/.././test
test
/home/../. or /home/..
"/home/dwc/."
"."
"/home/dwc"
/home/dwc/.
.
/home/dwc
Note
Whether leading // can be converted to / depends on the implementation-defined behavior of //
(see XBD 4.16 Pathname Resolution; although the basename() and
dirname() functions, and basename
and dirname utilities, do not themselves perform pathname resolution, their results
can be passed to a function or utility which does).
APPLICATION USAGE
Note that in some circumstances (in particular, when the returned string is required to be "/" or "." ), the
returned pointer might point into constant data. Therefore, if the application needs to modify the returned data, it should be
copied first.
RATIONALE
Earlier versions of this standard seemed to allow thread-safe and non-thread-safe implementations of basename() and
dirname(), but did not allow implementations to return a null pointer and require
that errno be set when that happened. The standard now requires thread-safe behavior for both of these functions and clearly
states that they are always successful.
FUTURE DIRECTIONS
None.
SEE ALSO
dirname()
XBD
XCU basename
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Normative text previously in the APPLICATION USAGE section is moved to the DESCRIPTION.
A note indicating that this function need not be reentrant is added to the DESCRIPTION.
Issue 6
In the DESCRIPTION, the note about reentrancy is expanded to cover thread-safety.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/20 is applied, changing the DESCRIPTION to make it
clear that the string referenced is the string pointed to by path.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0041 [75] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0047 [656], XSH/TC2-2008/0048 [928], and XSH/TC2-2008/0049
[612] are applied.
Issue 8
Austin Group Defects 1064 and 1358 are applied, requiring basename() to be thread-safe and allowing it to return a
pointer to constant data under certain conditions.
Austin Group Defect 1073 is applied, changing the EXAMPLES section.
Austin Group Defect 1396 is applied, changing the EXAMPLES section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/tzset.html =====
tzset
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
daylight, timezone, tzname, tzset — set timezone conversion information
SYNOPSIS
#include
[XSI]  extern int daylight;
extern long timezone;
[CX]  extern char *tzname[2];
void tzset(void);
DESCRIPTION
The tzset() function shall use the value of the environment variable TZ to set time conversion information used by
ctime(), localtime(), mktime(), and strftime(). If TZ is
absent from the environment, implementation-defined default timezone information shall be used.
The tzset() function shall set the external variable tzname as follows:
tzname[0] = "std";
tzname[1] = "dst";
where std and dst are as described in XBD 8. Environment
Variables.
[XSI]
The tzset() function also shall set the external variable daylight to 0 if Daylight Saving Time conversions should
never be applied for the timezone in use; otherwise, non-zero. The external variable timezone shall be set to the
difference, in seconds, between Coordinated Universal Time (UTC) and local standard time.
If a thread accesses tzname, [XSI]  daylight, or timezone   directly while another thread is in a call to tzset(), or to any function that is
required or allowed to set timezone information as if by calling tzset(), the behavior is undefined.
RETURN VALUE
The tzset() function shall not return a value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
Example TZ variables and their timezone differences are given in the table below:
TZ
timezone
EST5EDT
5*60*60
GMT0
0*60*60
JST-9
-9*60*60
MET-1MEST
-1*60*60
MST7MDT
7*60*60
PST8PDT
8*60*60
APPLICATION USAGE
Since the ctime(), localtime(),
mktime(), strftime(), and strftime_l() functions are required to set timezone information as if by calling
tzset(), there is no need for an explicit tzset() call before using these functions. However, portable applications
should call tzset() explicitly before using localtime_r() because setting
timezone information is optional for that function.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
ctime(), localtime(), mktime(), strftime()
XBD 8. Environment Variables,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The example is corrected.
Issue 7
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0377 [880] is applied.
Issue 8
Austin Group Defect 1253 is applied, changing "Daylight Savings" to "Daylight Saving".
Austin Group Defect 1410 is applied, removing the ctime_r() function.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/casin.html =====
casin
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
casin, casinf, casinl — complex arc sine functions
SYNOPSIS
#include
double complex casin(double complex z);
float complex casinf(float complex z);
long double complex casinl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex arc sine of z, with branch cuts outside the interval [-1, +1] along the
real axis.
RETURN VALUE
These functions shall return the complex arc sine value, in the range of a strip mathematically unbounded along the imaginary
axis and in the interval [-ℼ/2, +ℼ/2] along the real axis.
[MXC]
casin(conj(iz)), casinf(conjf(iz)), and casinl(conjl(iz)) shall
return exactly the same value as conj(casin(iz)), conjf(casinf(iz)), and
conjl(casinl(iz)), respectively, and casin(-iz), casinf(-iz), and
casinl(-iz) shall return exactly the same value as -casin(iz), -casinf(iz), and
-casinl(iz), respectively, including for the special values of iz below.
If iz is +0 + i0, -i (0 + i0) shall be returned.
If iz is x + iInf where x is positive-signed and finite, -i (+Inf + iℼ/2) shall be
returned.
If iz is x + iNaN where x is finite, -i (NaN + iNaN) shall be returned and the invalid
floating-point exception may be raised.
If iz is +Inf + iy where y is positive-signed and finite, -i (+Inf + i0) shall be
returned.
If iz is +Inf + iInf, -i (+Inf + iℼ/4) shall be returned.
If iz is +Inf + iNaN, -i (+Inf + iNaN) shall be returned.
If iz is NaN + i0, -i (NaN + i0) shall be returned.
If iz is NaN + iy where y is non-zero and finite, -i (NaN + iNaN) shall be returned and the
invalid floating-point exception may be raised.
If iz is NaN + iInf, -i (±Inf + iNaN) shall be returned; the sign of the imaginary part of the
result is unspecified.
If iz is NaN + iNaN, -i (NaN + iNaN) shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
The MXC special cases for casin() are derived from those for casinh() by
applying the formula casin(z) = -i casinh(iz).
FUTURE DIRECTIONS
None.
SEE ALSO
casinh(), csin()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/localtime_r.html =====
localtime
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
localtime, localtime_r — convert a time value to a broken-down local time
SYNOPSIS
#include
struct tm *localtime(const time_t *timer);
[CX]  struct tm *localtime_r(const time_t *restrict timer,
struct tm *restrict result);
DESCRIPTION
For localtime(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The localtime() function shall convert the time in seconds since the Epoch pointed to by timer into a broken-down
time, expressed as a local time. The function corrects for the timezone and any seasonal time adjustments. [CX]   Local timezone
information shall be set as though localtime() calls tzset().
The relationship between a time in seconds since the Epoch used as an argument to localtime() and the tm structure
(defined in the  header) is that the result shall be as specified in the
expression given in the definition of seconds since the Epoch (see XBD 4.19
Seconds Since the Epoch) corrected for timezone and any seasonal time adjustments, where the names in the structure and in
the expression correspond.
The same relationship shall apply for localtime_r().
The localtime() function need not be thread-safe; however, localtime() shall avoid data races with all functions
other than itself, asctime(), ctime(),
and gmtime().
The asctime(), ctime(), gmtime(), and localtime() functions shall return values in one of two static objects:
a broken-down time structure and an array of type char. Execution of any of the functions that return a pointer to one of
these object types may overwrite the information in any object of the same type pointed to by the value returned from any previous
call to any of them.
[CX]  The
localtime_r() function shall convert the time in seconds since the Epoch pointed to by timer into a broken-down time
stored in the structure to which result points. The localtime_r() function shall also return a pointer to that same
structure.
Unlike localtime(), the localtime_r() function is not required to set tzname. If localtime_r() sets
tzname, it shall also set daylight and timezone. If localtime_r() does not set tzname, it shall
not set daylight and shall not set timezone. If the tm structure member tm_zone is accessed after the
value of TZ is subsequently modified, the behaviour is undefined.
RETURN VALUE
Upon successful completion, the localtime() function shall return a pointer to the broken-down time structure. If an
error is detected, localtime() shall return a null pointer [CX]
and set errno to indicate the error.
Upon successful completion, localtime_r() shall return a pointer to the structure pointed to by the argument
result. If an error is detected, localtime_r() shall return a null pointer and set errno to indicate the
error.
ERRORS
The localtime() [CX]   and localtime_r()
functions shall fail if:
[EOVERFLOW]
[CX]
The result cannot be represented.
The following sections are informative.
EXAMPLES
Getting the Local Date and Time
The following example uses the time() function to calculate the time elapsed, in
seconds, since January 1, 1970 0:00 UTC (the Epoch), localtime() to convert that value to a broken-down time, and asctime() to convert the broken-down time values into a printable string.
#include
#include
int main(void)
{
time_t result;
result = time(NULL);
printf("%s%ju secs since the Epoch\n",
asctime(localtime(&result)),
(uintmax_t)result);
return(0);
}
This example writes the current time to stdout in a form like this:
Wed Jun 26 10:32:15 1996
835810335 secs since the Epoch
Getting the Modification Time for a File
The following example prints the last data modification timestamp in the local timezone for a given file.
#include
#include
#include
int
print_file_time(const char *pathname)
{
struct stat statbuf;
struct tm *tm;
char timestr[BUFSIZ];
if(stat(pathname, &statbuf) == -1)
return -1;
if((tm = localtime(&statbuf.st_mtime)) == NULL)
return -1;
if(strftime(timestr, sizeof(timestr), "%Y-%m-%d %H:%M:%S", tm) == 0)
return -1;
printf("%s: %s.%09ld\n", pathname, timestr, statbuf.st_mtim.tv_nsec);
return 0;
}
Timing an Event
The following example gets the current time, converts it to a string using localtime() and asctime(), and prints it to standard output using fputs(). It then prints the number of minutes to an event being timed.
#include
#include
...
time_t now;
int minutes_to_event;
...
time(&now);
printf("The time is ");
fputs(asctime(localtime(&now)), stdout);
printf("There are still %d minutes to the event.\n",
minutes_to_event);
...
APPLICATION USAGE
The localtime_r() function is thread-safe and returns values in a user-supplied buffer instead of possibly using a static
data area that may be overwritten by each call.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
asctime(), clock(), ctime(), difftime(), futimens(), getdate(), gmtime(), mktime(), strftime(), strptime(), time(), tzset()
XBD 4.19 Seconds Since the Epoch,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
A note indicating that the localtime() function need not be reentrant is added to the DESCRIPTION.
The localtime_r() function is included for alignment with the POSIX Threads Extension.
Issue 6
The localtime_r() function is marked as part of the Thread-Safe Functions option.
Extensions beyond the ISO C standard are marked.
The APPLICATION USAGE section is updated to include a note on the thread-safe function and its avoidance of possibly using a
static data area.
The restrict keyword is added to the localtime_r() prototype for alignment with the ISO/IEC 9899:1999
standard.
Examples are added.
IEEE Std 1003.1-2001/Cor 1-2002, itemm XSH/TC1/D6/32 is applied, adding the [EOVERFLOW] error.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/55 is applied, updating the error handling for
localtime_r().
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/56 is applied, adding a requirement that if localtime_r()
does not set the tzname variable, it shall not set the daylight or timezone variables. On systems supporting
XSI, the daylight, timezone, and tzname variables should all be set to provide information for the same
timezone. This updates the description of localtime_r() to mention daylight and timezone as well as
tzname. The SEE ALSO section is updated.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
The localtime_r() function is moved from the Thread-Safe Functions option to the Base.
Changes are made to the EXAMPLES section related to support for finegrained timestamps.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0363 [291] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0201 [664] is applied.
Issue 8
Austin Group Defect 1125 is applied, changing "Local timezone information is used" to "Local timezone information shall be
set".
Austin Group Defect 1302 is applied, aligning the localtime() function with the ISO/IEC 9899:2018 standard.
Austin Group Defect 1376 is applied, removing CX shading from some text derived from the ISO C standard and updating it to
match the ISO C standard.
Austin Group Defect 1533 is applied, adding tm_gmtoff and tm_zone to the tm structure.
Austin Group Defect 1570 is applied, removing extra spacing in "==".
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/posix_spawnattr_setpgroup.html =====
posix_spawnattr_getpgroup
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
posix_spawnattr_getpgroup, posix_spawnattr_setpgroup — get and set the spawn-pgroup attribute of a spawn attributes
object (ADVANCED REALTIME)
SYNOPSIS
[SPN]  #include
int posix_spawnattr_getpgroup(const posix_spawnattr_t *restrict attr,
pid_t *restrict pgroup);
int posix_spawnattr_setpgroup(posix_spawnattr_t *attr, pid_t pgroup);
DESCRIPTION
The posix_spawnattr_getpgroup() function shall obtain the value of the spawn-pgroup attribute from the attributes
object referenced by attr.
The posix_spawnattr_setpgroup() function shall set the spawn-pgroup attribute in an initialized attributes object
referenced by attr.
The spawn-pgroup attribute represents the process group to be joined by the new process image in a spawn operation (if
POSIX_SPAWN_SETPGROUP is set in the spawn-flags attribute). The default value of this attribute shall be zero.
RETURN VALUE
Upon successful completion, posix_spawnattr_getpgroup() shall return zero and store the value of the spawn-pgroup
attribute of attr into the object referenced by the pgroup parameter; otherwise, an error number shall be returned to
indicate the error.
Upon successful completion, posix_spawnattr_setpgroup() shall return zero; otherwise, an error number shall be returned
to indicate the error.
ERRORS
These functions may fail if:
[EINVAL]
The value specified by attr is invalid.
The posix_spawnattr_setpgroup() function may fail if:
[EINVAL]
The value of the attribute being set is not valid.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
These functions are part of the Spawn option and need not be provided on all implementations.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
posix_spawn(), posix_spawnattr_destroy(), posix_spawnattr_getsigdefault(), posix_spawnattr_getflags(), posix_spawnattr_getschedparam(), posix_spawnattr_getschedpolicy(), posix_spawnattr_getsigmask()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1d-1999.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/ccosh.html =====
ccosh
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ccosh, ccoshf, ccoshl — complex hyperbolic cosine functions
SYNOPSIS
#include
double complex ccosh(double complex z);
float complex ccoshf(float complex z);
long double complex ccoshl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex hyperbolic cosine of z.
RETURN VALUE
These functions shall return the complex hyperbolic cosine value.
[MXC]
ccosh(conj(z)), ccoshf(conjf(z)), and ccoshl(conjl(z)) shall return
exactly the same value as conj(ccosh(z)), conjf(ccoshf(z)), and
conjl(ccoshl(z)), respectively, and ccosh(-z), ccoshf(-z), and
ccoshl(-z) shall return exactly the same value as ccosh(z), ccoshf(z), and
ccoshl(z), respectively, including for the special values of z below.
If z is +0 + i0, 1 + i0 shall be returned.
If z is +0 + iInf, NaN ± i0 shall be returned and the invalid floating-point exception shall be raised; the
sign of the imaginary part of the result is unspecified.
If z is +0 + iNaN, NaN ± i0 shall be returned; the sign of the imaginary part of the result is
unspecified.
If z is x + iInf where x is non-zero and finite, NaN + iNaN shall be returned and the invalid
floating-point exception shall be raised.
If z is x + iNaN where x is non-zero and finite, NaN + iNaN shall be returned and the invalid
floating-point exception may be raised.
If z is +Inf + i0, +Inf + i0 shall be returned.
If z is +Inf + iy where y is non-zero and finite, +Inf (cos(y) + isin(y)) shall
be returned.
If z is +Inf + iInf, ±Inf + iNaN shall be returned and the invalid floating-point exception shall be
raised; the sign of the real part of the result is unspecified.
If z is +Inf + iNaN, +Inf + iNaN shall be returned.
If z is NaN + i0, NaN ± i0 shall be returned; the sign of the imaginary part of the result is
unspecified.
If z is NaN + iy where y is any non-zero number, NaN + iNaN shall be returned and the invalid
floating-point exception may be raised.
If z is NaN + iNaN, NaN + iNaN shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
cacosh()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/dlopen.html =====
dlopen
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
dlopen — open a symbol table handle
SYNOPSIS
#include
void *dlopen(const char *file, int mode);
DESCRIPTION
The dlopen() function shall make the symbols (function identifiers and data object identifiers) in the executable object
file specified by file available to the calling program.
The class of executable object files eligible for this operation and the manner of their construction are
implementation-defined, though typically such files are shared libraries or programs.
Implementations may permit the construction of embedded dependencies in executable object files. In such cases, a
dlopen() operation shall load those dependencies in addition to the executable object file specified by file.
Implementations may also impose specific constraints on the construction of programs that can employ dlopen() and its
related services.
A successful dlopen() shall return a symbol table handle which the caller may use on subsequent calls to dlsym() and dlclose().
The value of this symbol table handle should not be interpreted in any way by the caller.
The file argument is used to construct a pathname to the executable object file. If file contains a
character, the file argument is used as the pathname for the file. Otherwise, file is used in an
implementation-defined manner to yield a pathname.
If file is a null pointer, dlopen() shall return a global symbol table handle for the currently running process
image. This symbol table handle shall provide access to the symbols from an ordered set of executable object files consisting of
the original program image file, any executable object files loaded at program start-up as specified by that process file (for
example, shared libraries), and the set of executable object files loaded using dlopen() operations with the RTLD_GLOBAL
flag. As the latter set of executable object files can change during execution, the set of symbols made available by this symbol
table handle can also change dynamically.
Only a single copy of an executable object file shall be brought into the address space, even if dlopen() is invoked
multiple times in reference to the executable object file, and even if different pathnames are used to reference the executable
object file.
The mode parameter describes how dlopen() shall operate upon file with respect to the processing of
relocations and the scope of visibility of the symbols provided within file. When an executable object file is brought into
the address space of a process, it may contain references to symbols whose addresses are not known until the executable object file
is loaded.
These references shall be relocated before the symbols can be accessed. The mode parameter governs when these relocations
take place and may have the following values:
RTLD_LAZY
Relocations shall be performed at an implementation-defined time, ranging from the time of the dlopen() call until the
first reference to a given symbol occurs. Specifying RTLD_LAZY should improve performance on implementations supporting dynamic
symbol binding since a process might not reference all of the symbols in an executable object file. And, for systems supporting
dynamic symbol resolution for normal process execution, this behavior mimics the normal handling of process execution.
RTLD_NOW
All necessary relocations shall be performed when the executable object file is first loaded. This may waste some processing if
relocations are performed for symbols that are never referenced. This behavior may be useful for applications that need to know
that all symbols referenced during execution will be available before dlopen() returns.
Any executable object file loaded by dlopen() that requires relocations against global symbols can reference the symbols
in the original process image file, any executable object files loaded at program start-up, from the initial process image itself,
from any other executable object file included in the same dlopen() invocation, and any executable object files that were
loaded in any dlopen() invocation and which specified the RTLD_GLOBAL flag. To determine the scope of visibility for the
symbols loaded with a dlopen() invocation, the mode parameter should be a bitwise-inclusive OR with one of the
following values:
RTLD_GLOBAL
The executable object file's symbols shall be made available for relocation processing of any other executable object file. In
addition, symbol lookup using dlopen(NULL,mode) and an associated dlsym() allows executable object files loaded with this mode to be searched.
RTLD_LOCAL
The executable object file's symbols shall not be made available for relocation processing of any other executable object
file.
If neither RTLD_GLOBAL nor RTLD_LOCAL is specified, the default behavior is unspecified.
If an executable object file is specified in multiple dlopen() invocations, mode is interpreted at each
invocation.
If RTLD_NOW has been specified, all relocations shall have been completed rendering further RTLD_NOW operations redundant and
any further RTLD_LAZY operations irrelevant.
If RTLD_GLOBAL has been specified, the executable object file shall maintain the RTLD_GLOBAL status regardless of any previous
or future specification of RTLD_LOCAL, as long as the executable object file remains in the address space (see dlclose()). If there was a previous specification of RTLD_LOCAL, it is unspecified whether
relocations after the new specification of RTLD_GLOBAL are made as if the previous specification had been RTLD_GLOBAL or as if the
executable object file had not previously been loaded.
Symbols introduced into the process image through calls to dlopen() may be used in relocation activities. Symbols so
introduced may duplicate symbols already defined by the program or previous dlopen() operations. To resolve the ambiguities
such a situation might present, the resolution of a symbol reference to symbol definition is based on a symbol resolution order.
Two such resolution orders are defined: load order and dependency order. Load order establishes an ordering among symbol
definitions, such that the first definition loaded (including definitions from the process image file and any dependent executable
object files loaded with it) has priority over executable object files added later (by dlopen()). Load ordering is used in
relocation processing. Dependency ordering uses a breadth-first order starting with a given executable object file, then all of its
dependencies, then any dependents of those, iterating until all dependencies are satisfied. With the exception of the global symbol
table handle obtained via a dlopen() operation with a null pointer as the file argument, dependency ordering is used
by the dlsym() function. Load ordering is used in dlsym() operations upon the global symbol table handle.
When an executable object file is first made accessible via dlopen(), it and its dependent executable object files are
added in dependency order. Once all the executable object files are added, relocations are performed using load order. Note that if
an executable object file or its dependencies had been previously loaded, the load and dependency orders may yield different
resolutions.
The symbols introduced by dlopen() operations and available through dlsym()
are at a minimum those which are exported as identifiers of global scope by the executable object file. Typically, such identifiers
shall be those that were specified in (for example) C source code as having extern linkage. The precise manner in which an
implementation constructs the set of exported symbols for an executable object file is implementation-defined.
RETURN VALUE
Upon successful completion, dlopen() shall return a symbol table handle. If file cannot be found, cannot be opened
for reading, is not of an appropriate executable object file format for processing by dlopen(), or if an error occurs during
the process of loading file or relocating its symbolic references, dlopen() shall return a null pointer. More
detailed diagnostic information shall be available through dlerror().
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
Refer to dlsym().
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
dladdr(), dlclose(), dlerror(), dlsym()
XBD
CHANGE HISTORY
First released in Issue 5.
Issue 6
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/21 is applied, changing the default behavior in the DESCRIPTION
when neither RTLD_GLOBAL nor RTLD_LOCAL are specified from implementation-defined to unspecified.
Issue 7
The dlopen() function is moved from the XSI option to the Base.
The EXAMPLES section is updated to refer to dlsym().
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0073 [74] is applied.
Issue 8
Austin Group Defect 982 is applied, clarifying the requirements when changing from RTLD_LOCAL to RTLD_GLOBAL.
Austin Group Defect 993 is applied, adding dladdr() to the SEE ALSO section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fclose.html =====
fclose
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fclose — close a stream
SYNOPSIS
#include
int fclose(FILE *stream);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The fclose() function shall cause the stream pointed to by stream to be flushed and the associated file to be
closed. Any unwritten buffered data for the stream shall be written to the file; any unread buffered data shall be discarded.
Whether or not the call succeeds, the stream shall be disassociated from the file and any buffer set by the setbuf() or setvbuf() function shall be
disassociated from the stream. If the associated buffer was automatically allocated, it shall be deallocated.
[CX]  If
the file is not already at EOF, and the file is one capable of seeking, the file offset of the underlying open file description
shall be set to the file position of the stream if the stream is the active handle to the underlying file description.
The fclose() function shall mark for update the last data modification and last file status change timestamps of the
underlying file, if the stream was writable, and if buffered data remains that has not yet been written to the file. The
fclose() function shall perform the equivalent of a close() on the file
descriptor that is associated with the stream pointed to by stream.
After the call to fclose(), any use of stream results in undefined behavior.
RETURN VALUE
Upon successful completion, fclose() shall return 0; otherwise, it shall return EOF [CX]   and set
errno to indicate the error.
ERRORS
The fclose() function shall fail if:
[EAGAIN]
[CX]
The O_NONBLOCK flag is set for the file descriptor underlying stream and the thread would be delayed in the write operation.
[EBADF]
[CX]
The file descriptor underlying stream is not valid.
[EFBIG]
[CX]  An
attempt was made to write a file that exceeds the maximum file size.
[EFBIG]
[CX]  An
attempt was made to write a file that exceeds the file size limit of the process.
[XSI]
A SIGXFSZ signal shall also be generated for the thread.
[EFBIG]
[CX]
The file is a regular file and an attempt was made to write at or beyond the offset maximum associated with the corresponding
stream.
[EINTR]
[CX]
The fclose() function was interrupted by a signal.
[EIO]
[CX]
The process is a member of a background process group attempting to write to its controlling terminal, TOSTOP is set, the calling
thread is not blocking SIGTTOU, the process is not ignoring SIGTTOU, and the process group of the process is orphaned. This error
may also be returned under implementation-defined conditions.
[ENOMEM]
[CX]
The underlying stream was created by open_memstream() or open_wmemstream() and insufficient memory is available.
[ENOSPC]
[CX]
There was no free space remaining on the device containing the file or in the buffer used by the fmemopen() function.
[EPIPE]
[CX]  An
attempt is made to write to a pipe or FIFO that is not open for reading by any process. A SIGPIPE signal shall also be sent to the
thread.
The fclose() function may fail if:
[ENXIO]
[CX]  A
request was made of a nonexistent device, or the request was outside the capabilities of the device.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Since after the call to fclose() any use of stream results in undefined behavior, fclose() should not be
used on stdin, stdout, or stderr except immediately before process termination (see XBD 3.287 Process Termination), so as to avoid triggering undefined behavior in
other standard interfaces that rely on these streams. If there are any atexit()
handlers registered by the application, such a call to fclose() should not occur until the last handler is finishing. Once
fclose() has been used to close stdin, stdout, or stderr, there is no standard way to reopen any of
these streams.
Use of freopen() to change stdin, stdout, or stderr instead
of closing them avoids the danger of a file unexpectedly being opened as one of the special file descriptors STDIN_FILENO,
STDOUT_FILENO, or STDERR_FILENO at a later time in the application.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, atexit(), close(), fmemopen(), fopen(), freopen(), getrlimit(), open_memstream()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
Large File Summit extensions are added.
Issue 6
Extensions beyond the ISO C standard are marked.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The [EFBIG] error is added as part of the large file support extensions.
The [ENXIO] optional error condition is added.
The DESCRIPTION is updated to note that the stream and any buffer are disassociated whether or not the call succeeds. This is
for alignment with the ISO/IEC 9899:1999 standard.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/28 is applied, updating the [EAGAIN] error in the ERRORS section
from "the process would be delayed" to "the thread would be delayed".
Issue 7
Austin Group Interpretation 1003.1-2001 #002 is applied, clarifying the interaction of file descriptors and streams.
The [ENOSPC] error condition is updated and the [ENOMEM] error is added from The Open Group Technical Standard, 2006, Extended
API Set Part 1.
Changes are made related to support for finegrained timestamps.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0113 [87], XSH/TC1-2008/0114 [79], and XSH/TC1-2008/0115 [14] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0104 [555] is applied.
Issue 8
Austin Group Defect 308 is applied, clarifying the handling of [EFBIG] errors.
Austin Group Defect 1669 is applied, removing XSI shading from part of the [EFBIG] error relating to the file size limit for the
process.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/ftruncate.html =====
ftruncate
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ftruncate — truncate a file to a specified length
SYNOPSIS
#include
int ftruncate(int fildes, off_t length);
DESCRIPTION
If fildes is not a valid file descriptor open for writing, the ftruncate() function shall fail.
If fildes refers to a regular file, the ftruncate() function shall cause the size of the file to be truncated to
length. If the size of the file previously exceeded length, the extra data shall no longer be available to reads on
the file. If the file previously was smaller than this size, ftruncate() shall increase the size of the file. If the file
size is increased, the extended area shall appear as if it were zero-filled. The value of the seek pointer shall not be modified by
a call to ftruncate().
Upon successful completion, if fildes refers to a regular file, ftruncate() shall mark for update the last data
modification and last file status change timestamps of the file and the S_ISUID and S_ISGID bits of the file mode may be cleared.
If the ftruncate() function is unsuccessful, the file is unaffected.
If the request would cause the file size to exceed the soft file size limit for the process, the request shall fail
[XSI]
and the implementation shall generate a SIGXFSZ signal for the thread.
If fildes is a file descriptor open for writing and refers to a file that is neither a regular file nor a shared memory
object, the result is unspecified.
[SHM]
If fildes refers to a shared memory object, ftruncate() shall set the size of the shared memory object to
length.
If the effect of ftruncate() is to decrease the size of a memory mapped file [SHM]   or a shared
memory object   and whole pages beyond the new end were
previously mapped, then the whole pages beyond the new end shall be discarded.
References to discarded pages shall result in the generation of a SIGBUS signal.
If the effect of ftruncate() is to increase the size of a memory object, it is unspecified whether the contents of any
mapped pages between the old end-of-file and the new are flushed to the underlying object.
RETURN VALUE
Upon successful completion, ftruncate() shall return 0; otherwise, -1 shall be returned and errno set to indicate
the error.
ERRORS
The ftruncate() function shall fail if:
[EBADF] or [EINVAL]
The fildes argument is not a file descriptor open for writing.
[EFBIG] or [EINVAL]
The length argument is greater than the maximum file size.
[EFBIG]
The length argument exceeds the file size limit of the process. [XSI]   A SIGXFSZ
signal shall also be generated for the thread.
[EFBIG]
The file is a regular file and length is greater than the offset maximum established in the open file description
associated with fildes.
[EINTR]
A signal was caught during execution.
[EINVAL]
The length argument is less than 0 or the fildes argument refers to a file on which this operation is not
possible (for example, a pipe, FIFO or socket).
[EIO]
An I/O error occurred while reading from or writing to a file system.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
open(), truncate()
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE and aligned with ftruncate() in the POSIX Realtime Extension. Specifically, the
DESCRIPTION is extensively reworded and [EROFS] is added to the list of mandatory errors that can be returned by
ftruncate().
Large File Summit extensions are added.
Issue 6
The truncate() function is split out into a separate reference page.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The DESCRIPTION is changed to indicate that if the file size is changed, and if the file is a regular file, the S_ISUID and
S_ISGID bits in the file mode may be cleared.
The following changes were made to align with the IEEE P1003.1a draft standard:
The DESCRIPTION text is updated.
XSI-conformant systems are required to increase the size of the file if the file was previously smaller than the size
requested.
Issue 7
Austin Group Interpretation 1003.1-2001 #056 is applied, revising the ERRORS section (although the [EINVAL] "may fail" error
was subsequently removed during review of the XSI option).
Functionality relating to the Memory Protection and Memory Mapped Files options is moved to the Base.
The DESCRIPTION is updated so that a call to ftruncate() when the file is smaller than the size requested will increase
the size of the file. Previously, non-XSI-conforming implementations were allowed to increase the size of the file or fail.
Changes are made related to support for finegrained timestamps.
Issue 8
Austin Group Defect 308 is applied, clarifying the handling of [EFBIG] errors.
Austin Group Defect 1169 is applied, removing a redundant statement that ftruncate() fails if fildes refers to a
directory.
Austin Group Defect 1381 is applied, adding a second condition to the [EINVAL] error and rearranging the ERRORS section into
alphabetical order.
Austin Group Defect 1669 is applied, removing XSI shading from part of the [EFBIG] error relating to the file size limit for the
process.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/cabs.html =====
cabs
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
cabs, cabsf, cabsl — return a complex absolute value
SYNOPSIS
#include
double cabs(double complex z);
float cabsf(float complex z);
long double cabsl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex absolute value (also called norm, modulus, or magnitude) of z.
RETURN VALUE
These functions shall return the complex absolute value.
[MXC]
cabs(x + iy), cabs(y + ix), and cabs(x - iy) shall return exactly
the same value.
If z is ±0 ± i0, +0 shall be returned.
If the real or imaginary part of z is ±Inf, +Inf shall be returned, even if the other part is NaN.
If the real or imaginary part of z is NaN and the other part is not ±Inf, NaN shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/htobe32.html =====
be16toh
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
be16toh, be32toh, be64toh, htobe16, htobe32, htobe64, htole16, htole32, htole64, le16toh, le32toh, le64toh — convert
values between host and specified byte order
SYNOPSIS
#include
uint16_t be16toh(uint16_t big_endian_16bits);
uint32_t be32toh(uint32_t big_endian_32bits);
uint64_t be64toh(uint64_t big_endian_64bits);
uint16_t htobe16(uint16_t host_16bits);
uint32_t htobe32(uint32_t host_32bits);
uint64_t htobe64(uint64_t host_64bits);
uint16_t htole16(uint16_t host_16bits);
uint32_t htole32(uint32_t host_32bits);
uint64_t htole64(uint64_t host_64bits);
uint16_t le16toh(uint16_t little_endian_16bits);
uint32_t le32toh(uint32_t little_endian_32bits);
uint64_t le64toh(uint64_t little_endian_64bits);
DESCRIPTION
These functions shall convert integer values of various sizes between host representations and representations in a specified
order.
On some implementations, these functions are defined as macros.
A little-endian representation of an integer has the least significant byte stored as the first byte, with the significance of
the bytes increasing as the byte address increases. A big-endian representation has the most significant byte as the first byte,
with the significance of the bytes reducing as the byte address increases.
Note:
Network byte order is big-endian.
For example, the uint32_t value 0x01020304 is represented as the four bytes 0x04, 0x03, 0x02, 0x01 on a little-endian
host, and as 0x01, 0x02, 0x03, 0x04 on a big-endian host.
For each of the sizes 16, 32 and 64, the htobeSIZE() function shall convert from whatever order the host uses to
big-endian representation, htoleSIZE() shall convert to little-endian representation, beSIZEtoh() shall convert from
big-endian to host order, and leSIZEtoh() shall convert from little-endian to host order.
RETURN VALUE
These functions shall return an unsigned integer of the appropriate size and representation.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
#include
#include
#include
int main(int argc, char *argv[])
{
uint32_t val;
if (argc > 1) {
val = (uint32_t)strtoul(argv[1], NULL, 0);
printf("Value: %08x\n", val);
printf("As bytes:\n");
union {
uint32_t asint;
unsigned char asbytes[sizeof(uint32_t)];
} u;
printf("Little endian: ");
u.asint = htole32(val);
for (int i = 0; i  is included:
htobe32
htonl
htobe16
htons
be32toh
ntohl
be16toh
ntohs
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
htonl()
XBD ,
CHANGE HISTORY
First released in Issue 8.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/mlock.html =====
mlock
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
mlock, munlock — lock or unlock a range of process address space (REALTIME)
SYNOPSIS
[MLR]  #include
int mlock(const void *addr, size_t len);
int munlock(const void *addr, size_t len);
DESCRIPTION
The mlock() function shall cause those whole pages containing any part of the address space of the process starting at
address addr and continuing for len bytes to be memory-resident until unlocked or until the process exits or
execs another process image. The implementation may require that addr be a
multiple of {PAGESIZE}.
The munlock() function shall unlock those whole pages containing any part of the address space of the process starting at
address addr and continuing for len bytes, regardless of how many times mlock() has been called by the process
for any of the pages in the specified range. The implementation may require that addr be a multiple of {PAGESIZE}.
If any of the pages in the range specified to a call to munlock() are also mapped into the address spaces of other
processes, any locks established on those pages by another process are unaffected by the call of this process to munlock().
If any of the pages in the range specified by a call to munlock() are also mapped into other portions of the address space
of the calling process outside the range specified, any locks established on those pages via the other mappings are also unaffected
by this call.
Upon successful return from mlock(), pages in the specified range shall be locked and memory-resident. Upon successful
return from munlock(), pages in the specified range shall be unlocked with respect to the address space of the process.
Memory residency of unlocked pages is unspecified.
Appropriate privileges are required to lock process memory with mlock().
RETURN VALUE
Upon successful completion, the mlock() and munlock() functions shall return a value of zero. Otherwise, no change
is made to any locks in the address space of the process, and the function shall return a value of -1 and set errno to
indicate the error.
ERRORS
The mlock() and munlock() functions shall fail if:
[ENOMEM]
Some or all of the address range specified by the addr and len arguments does not correspond to valid mapped
pages in the address space of the process.
The mlock() function shall fail if:
[EAGAIN]
Some or all of the memory identified by the operation could not be locked when the call was made.
The mlock() and munlock() functions may fail if:
[EINVAL]
The addr argument is not a multiple of {PAGESIZE}.
The mlock() function may fail if:
[ENOMEM]
Locking the pages mapped by the specified range would exceed an implementation-defined limit on the amount of memory that the
process may lock.
[EPERM]
The calling process does not have appropriate privileges to perform the requested operation.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
exec, exit(), fork(), mlockall(), munmap()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Issue 6
The mlock() and munlock() functions are marked as part of the Range Memory Locking option.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Range
Memory Locking option.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/posix_close.html =====
close
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
close, posix_close — close a file descriptor
SYNOPSIS
#include
int close(int fildes);
int posix_close(int fildes, int flag);
DESCRIPTION
The close() function shall deallocate the file descriptor indicated by fildes. To deallocate means to make the
file descriptor available for return by subsequent calls to open() or other functions
that allocate file descriptors. All process-owned file locks that the calling process owns on the file associated with the file
descriptor shall be unlocked.
If close() is interrupted by a signal that is to be caught, then it is unspecified whether it returns -1 with
errno set to [EINTR] and fildes remaining open, or returns -1 with errno set to [EINPROGRESS] and
fildes being closed, or returns 0 to indicate successful completion; except that if POSIX_CLOSE_RESTART is defined as 0,
then the option of returning -1 with errno set to [EINTR] and fildes remaining open shall not occur. If
close() returns -1 with errno set to [EINTR], it is unspecified whether fildes can subsequently be passed to
any function except close() or posix_close() without error. For all other error situations (except for [EBADF] where
fildes was invalid), fildes shall be closed. If fildes was closed even though the close operation is
incomplete, the close operation shall continue asynchronously and the process shall have no further ability to track the completion
or final status of the close operation.
When all file descriptors associated with a pipe or FIFO special file are closed, any data remaining in the pipe or FIFO shall
be discarded.
When all file descriptors associated with an open file description have been closed, the open file description shall be
freed.
If the link count of the file is 0, when all file descriptors associated with the file are closed, the space occupied by the
file shall be freed and the file shall no longer be accessible.
[XSI]
If fildes refers to the manager side of a pseudo-terminal, and this is the last close, a SIGHUP signal shall be sent to the
controlling process, if any, for which the subsidiary side of the pseudo-terminal is the controlling terminal. It is unspecified
whether closing the manager side of the pseudo-terminal flushes all queued input and output.
When there is an outstanding cancelable asynchronous I/O operation against fildes when close() is called, that I/O
operation may be canceled. An I/O operation that is not canceled completes as if the close() operation had not yet occurred.
All operations that are not canceled shall complete as if the close() blocked until the operations completed. The
close() operation itself need not block awaiting such I/O completion. Whether any I/O operation is canceled, and which I/O
operation may be canceled upon close(), is implementation-defined.
If a memory mapped file [SHM]   or a shared memory object
remains referenced at the last close (that is, a process has it mapped), then the entire contents of the memory object shall
persist until the memory object becomes unreferenced. If this is the last close of a memory mapped file [SHM]   or a shared
memory object   and the close results in the memory object
becoming unreferenced, and the memory object has been unlinked, then the memory object shall be removed.
When all file descriptors associated with a socket have been closed, the socket shall be destroyed. If the socket is in
connection-mode, and the SO_LINGER option is set for the socket with non-zero linger time, and the socket has untransmitted data,
then close() shall block for up to the current linger interval until all data is transmitted.
The posix_close() function shall be equivalent to the close() function, except with the modifications based on the
flag argument as described below. If flag is 0, then posix_close() shall not return -1 with errno set
to [EINTR], which implies that fildes will always be closed (except for [EBADF], where fildes was invalid). If
flag includes POSIX_CLOSE_RESTART and POSIX_CLOSE_RESTART is defined as a non-zero value, and posix_close() is
interrupted by a signal that is to be caught, then posix_close() may return -1 with errno set to [EINTR], in which
case fildes shall be left open; however, it is unspecified whether fildes can subsequently be passed to any function
except close() or posix_close() without error. If flag is invalid, posix_close() may fail with errno
set to [EINVAL], but shall otherwise behave as if flag had been 0 and close fildes.
RETURN VALUE
Upon successful completion, 0 shall be returned; otherwise, -1 shall be returned and errno set to indicate the error.
ERRORS
The close() and posix_close() functions shall fail if:
[EBADF]
The fildes argument is not a open file descriptor.
[EINPROGRESS]
The function was interrupted by a signal and fildes was closed but the close operation is continuing
asynchronously.
The close() and posix_close() functions may fail if:
[EINTR]
The function was interrupted by a signal, POSIX_CLOSE_RESTART is defined as non-zero, and (in the case of posix_close())
the flag argument included POSIX_CLOSE_RESTART, in which case fildes is still open.
[EIO]
An I/O error occurred while reading from or writing to the file system.
The posix_close() function may fail if:
[EINVAL]
The value of the flag argument is invalid.
The close() and posix_close() functions shall not return an [EAGAIN] or [EWOULDBLOCK] error. If
POSIX_CLOSE_RESTART is zero, the close() function shall not return an [EINTR] error. The posix_close() function shall
not return an [EINTR] error unless flag includes a non-zero POSIX_CLOSE_RESTART.
The following sections are informative.
EXAMPLES
Reassigning a File Descriptor
The following example closes the file descriptor associated with standard output for the current process, re-assigns standard
output to a new file descriptor, and closes the original file descriptor to clean up. This example assumes that the file descriptor
0 (which is the descriptor for standard input) is not closed.
#include
...
int pfd;
...
close(1);
dup(pfd);
close(pfd);
...
Incidentally, this is exactly what could be achieved using:
dup2(pfd, 1);
close(pfd);
Closing a File Descriptor
In the following example, close() is used to close a file descriptor after an unsuccessful attempt is made to associate
that file descriptor with a stream.
#include
#include
#include
#define LOCKFILE "/etc/ptmp"
...
int pfd;
FILE *fpfd;
...
if ((fpfd = fdopen (pfd, "w")) == NULL) {
close(pfd);
unlink(LOCKFILE);
exit(1);
}
...
APPLICATION USAGE
An application that had used the stdio routine fopen() to open a file should
use the corresponding fclose() routine rather than close(). Once a file is
closed, the file descriptor no longer exists, since the integer corresponding to it no longer refers to a file.
Implementations may use file descriptors that must be inherited into child processes for the child process to remain conforming,
such as for message catalog or tracing purposes. Therefore, an application that calls close() on an arbitrary integer risks
non-conforming behavior, and close() can only portably be used on file descriptor values that the application has obtained
through explicit actions, as well as the three file descriptors corresponding to the standard file streams. In multi-threaded
parent applications, the practice of calling close() in a loop after fork() and
before an exec call in order to avoid a race condition of leaking an unintended file
descriptor into a child process, is therefore unsafe, and the race should instead be combatted by opening all file descriptors with
the FD_CLOEXEC bit set unless the file descriptor is intended to be inherited across exec.
Usage of close() on file descriptors STDIN_FILENO, STDOUT_FILENO, or STDERR_FILENO should immediately be followed by an
operation to reopen these file descriptors. Unexpected behavior will result if any of these file descriptors is left in a closed
state (for example, an [EBADF] error from perror()) or if an unrelated open() or similar call later in the application accidentally allocates a file to one of these
well-known file descriptors. Furthermore, a close() followed by a reopen operation (e.g., open(), dup(), etc.) is not atomic; dup2() should be used to change standard file descriptors.
RATIONALE
The use of interruptible device close routines should be discouraged to avoid problems with the implicit closes of file
descriptors, such as by exec, process termination, or dup2(). This volume of POSIX.1-2024 only intends to permit such behavior by specifying the
[EINTR] error condition for close() and posix_close() with non-zero POSIX_CLOSE_RESTART, to allow applications a
portable way to resume waiting for an event associated with the close operation (for example, a tape drive rewinding) after
receiving an interrupt. This standard also permits implementations to define POSIX_CLOSE_RESTART to 0 if they do not choose to
provide a way to restart an interrupted close action. Although the file descriptor is left open on [EINTR], it might no longer be
usable; that is, passing it to any function except close() or posix_close() might result in an error such as [EIO].
If an application must guarantee that data will not be lost, it is recommended that the application use fsync() or fdatasync() prior to the close
operation, rather than leaving the close operation to deal with pending I/O and risk an interrupt.
Earlier versions of this standard left the state of fildes unspecified after errors such as [EINTR] and [EIO]; and
implementations differed on whether close() left fildes open after [EINTR]. This was unsatisfactory once threads were
introduced, since multi-threaded applications need to know whether fildes has been closed. Applications cannot blindly call
close() again, because if fildes was closed by the first call another thread could have been allocated a file
descriptor with the same value as fildes, which must not be closed by the first thread. On the other hand, the alternative
of never retrying close() would lead to a file descriptor leak in implementations where close() did not close
fildes, although such a leak may be harmless if the process is about to exit or the file descriptor is marked FD_CLOEXEC and
the process is about to be replaced by exec. This standard introduced
posix_close() with a flag argument that allows a choice between the two possible error behaviors, and leaves it
unspecified which of the two behaviors is implemented by close() (although it is guaranteed to be one of the two behaviors
of posix_close(), rather than leaving things completely unspecified as in earlier versions of the standard).
Note that the standard requires that close() and posix_close() must leave fildes open after [EINTR] (in the
cases where [EINTR] is permitted) and must close the file descriptor regardless of all other errors (except [EBADF], where
fildes is already invalid). In general, portable applications should only retry a close() after checking for [EINTR]
(and on implementations where POSIX_CLOSE_RESTART is defined to be zero, this retry loop will be dead code), and risk a file
descriptor leak if a retry loop is not attempted. It should also be noted that [EINTR] is only possible if close() can be
interrupted; if no signal handlers are installed, then close() will not be interrupted. Conversely, if a single-threaded
application can guarantee that no file descriptors are opened or closed in signal handlers, then a retry loop without checking for
[EINTR] will be harmless (since the retry will fail with [EBADF]), but guaranteeing that no external libraries introduce the use of
threading can be difficult. There are additional guarantees for applications which will only ever be used on systems where
POSIX_CLOSE_RESTART is defined as 0. These observations should help in determining whether an application needs to have its
close() calls audited for replacement with posix_close().
It should also be noted that the requirement for posix_close() with a flag of 0 to always close fildes,
even if an error is reported, is similar to the requirements on fclose() to always
release the stream, even if an error is encountered while flushing data.
Implementations that previously always closed fildes can meet the new requirements by translating [EINTR] to
[EINPROGRESS] in close(); and may define POSIX_CLOSE_RESTART to 0 rather than having to add restart semantics. On the other
hand, implementations that previously left fildes open on [EINTR] can map that to posix_close() with
POSIX_CLOSE_RESTART, and must add the semantics of posix_close() when flag is 0; one possibility is by calling the
original close() implementation, checking for failure, and on [EINTR], using actions similar to dup2() to replace the incomplete close operation with another file descriptor that can be
closed immediately by another call to the original close(), all before returning to the application. Either way,
close() should always map to one of the two behaviors of posix_close(), and implementations are encouraged to keep
the behavior of close() unchanged so as not to break implementation-specific expectations of older applications that were
relying on behavior not specified by older versions of this standard.
The standard developers considered introducing a thread-local variable that close() would set to indicate whether it had
closed fildes when returning -1. However, this was rejected in favor of the simpler solution of tightening close() to
guarantee that fildes is closed except for [EINTR], and exposing a choice of whether to expect [EINTR] by adding
posix_close(). Additionally, while the name posix_close() is new to this standard, it is reminiscent of at least one
implementation that introduced an alternate system call named close_nocancel() in order to allow an application to choose
whether restart semantics were desired.
Another consideration was whether implementations might return [EAGAIN] as an extension and whether close() should be
required to leave the file descriptor open in this case, since [EAGAIN] normally implies an operation should be retried. It seemed
very unlikely that any implementation would have a legitimate reason to return [EAGAIN] or [EWOULDBLOCK], and therefore this
requirement would mean applications have to include code for an error case that will never be used. Therefore close() is now
forbidden from returning [EAGAIN] and [EWOULDBLOCK] errors.
Note that the requirement for close() on a socket to block for up to the current linger interval is not conditional on
the O_NONBLOCK setting.
The standard developers rejected a proposal to add closefrom() to the standard. Because the standard permits
implementations to use inherited file descriptors as a means of providing a conforming environment for the child process, it is not
possible to standardize an interface that closes arbitrary file descriptors above a certain value while still guaranteeing a
conforming environment.
FUTURE DIRECTIONS
None.
SEE ALSO
dup(), exec, exit(), fclose(), fopen(), fork(), open(), perror(), unlink()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Realtime Extension.
Issue 6
The DESCRIPTION related to a STREAMS-based file or pseudo-terminal is marked as part of the XSI STREAMS Option Group.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The [EIO] error condition is added as an optional error.
The DESCRIPTION is updated to describe the state of the fildes file descriptor as unspecified if an I/O error occurs and
an [EIO] error condition is returned.
Text referring to sockets is added to the DESCRIPTION.
The DESCRIPTION is updated for alignment with IEEE Std 1003.1j-2000 by specifying that shared memory objects and
memory mapped files (and not typed memory objects) are the types of memory objects to which the paragraph on last closes
applies.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/12 is applied, correcting the XSH shaded text relating to the
manager side of a pseudo-terminal. The reason for the change is that the behavior of pseudo-terminals and regular terminals should
be as much alike as possible in this case; the change achieves that and matches historical behavior.
Issue 7
Functionality relating to the XSI STREAMS option is marked obsolescent.
Functionality relating to the Asynchronous Input and Output and Memory Mapped Files options is moved to the Base.
Austin Group Interpretation 1003.1-2001 #139 is applied, clarifying that the requirement for close() on a socket to block
for up to the current linger interval is not conditional on the O_NONBLOCK setting.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0059 [419], XSH/TC1-2008/0060 [149], and XSH/TC1-2008/0061 [149] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0069 [555] is applied.
Issue 8
Austin Group Defect 529 is applied, adding the posix_close() function and changing requirements for the close()
function relating to [EINTR].
Austin Group Defect 768 is applied, adding OFD-owned file locks.
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
Austin Group Defect 1466 is applied, changing the terminology used for pseudo-terminal devices.
Austin Group Defect 1525 is applied, clarifying that a socket is not destroyed until all file descriptors associated with it
have been closed.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_attr_getinheritsched.html =====
pthread_attr_getinheritsched
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_attr_getinheritsched, pthread_attr_setinheritsched — get and set the inheritsched attribute (REALTIME
THREADS)
SYNOPSIS
[TPS]  #include
int pthread_attr_getinheritsched(const pthread_attr_t *restrict attr,
int *restrict inheritsched);
int pthread_attr_setinheritsched(pthread_attr_t *attr,
int inheritsched);
DESCRIPTION
The pthread_attr_getinheritsched() and pthread_attr_setinheritsched() functions, respectively, shall get and set
the inheritsched attribute in the attr argument.
When the attributes objects are used by pthread_create(), the
inheritsched attribute determines how the other scheduling attributes of the created thread shall be set.
The supported values of inheritsched shall be:
PTHREAD_INHERIT_SCHED
Specifies that the thread scheduling attributes shall be inherited from the creating thread, and the scheduling attributes in this
attr argument shall be ignored.
PTHREAD_EXPLICIT_SCHED
Specifies that the thread scheduling attributes shall be set to the corresponding values from this attributes object.
The symbols PTHREAD_INHERIT_SCHED and PTHREAD_EXPLICIT_SCHED are defined in the  header.
The following thread scheduling attributes defined by POSIX.1-2024 are affected by the inheritsched attribute: scheduling
policy (schedpolicy), scheduling parameters (schedparam), and scheduling contention scope
(contentionscope).
The behavior is undefined if the value specified by the attr argument to pthread_attr_getinheritsched() or
pthread_attr_setinheritsched() does not refer to an initialized thread attributes object.
RETURN VALUE
If successful, the pthread_attr_getinheritsched() and pthread_attr_setinheritsched() functions shall return zero;
otherwise, an error number shall be returned to indicate the error.
ERRORS
The pthread_attr_setinheritsched() function shall fail if:
[ENOTSUP]
An attempt was made to set the attribute to an unsupported value.
The pthread_attr_setinheritsched() function may fail if:
[EINVAL]
The value of inheritsched is not valid.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
After these attributes have been set, a thread can be created with the specified attributes using pthread_create(). Using these routines does not affect the current running
thread.
See 2.9.4 Thread Scheduling for further details on thread
scheduling attributes and their default settings.
RATIONALE
If an implementation detects that the value specified by the attr argument to pthread_attr_getinheritsched() or
pthread_attr_setinheritsched() does not refer to an initialized thread attributes object, it is recommended that the
function should fail and report an [EINVAL] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_attr_destroy(), pthread_attr_getscope(), pthread_attr_getschedpolicy(), pthread_attr_getschedparam(), pthread_create()
XBD ,
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Marked as part of the Realtime Threads Feature Group.
Issue 6
The pthread_attr_getinheritsched() and pthread_attr_setinheritsched() functions are marked as part of the Threads
and Thread Execution Scheduling options.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Thread
Execution Scheduling option.
The restrict keyword is added to the pthread_attr_getinheritsched() prototype for alignment with the
ISO/IEC 9899:1999 standard.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/75 is applied, clarifying the values of inheritsched in
the DESCRIPTION and adding two optional [EINVAL] errors to the ERRORS section for checking when attr refers to an
uninitialized thread attribute object.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/77 is applied, adding a reference to 2.9.4 Thread Scheduling in the APPLICATION USAGE section.
Issue 7
The pthread_attr_getinheritsched() and pthread_attr_setinheritsched() functions are marked only as part of the
Thread Execution Scheduling option as the Threads option is now part of the Base.
The [EINVAL] error for an uninitialized thread attributes object is removed; this condition results in undefined behavior.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0450 [314] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0262 [757] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/execlp.html =====
exec
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
environ, execl, execle, execlp, execv, execve, execvp, fexecve — execute a file
SYNOPSIS
#include
extern char **environ;
int execl(const char *path, const char *arg0, ... /*, (char *)0 */);
int execle(const char *path, const char *arg0, ... /*,
(char *)0, char *const envp[]*/);
int execlp(const char *file, const char *arg0, ... /*, (char *)0 */);
int execv(const char *path, char *const argv[]);
int execve(const char *path, char *const argv[], char *const envp[]);
int execvp(const char *file, char *const argv[]);
int fexecve(int fd, char *const argv[], char *const envp[]);
DESCRIPTION
The exec family of functions shall replace the current process image with a new process image. The new image shall be
constructed from a regular, executable file called the new process image file. There shall be no return from a successful
exec, because the calling process image is overlaid by the new process image.
The fexecve() function shall be equivalent to the execve() function except that the file to be executed is
determined by the file descriptor fd instead of a pathname. The file offset of fd is ignored.
When a C-language program is executed as a result of a call to one of the exec family of functions, it shall be entered
as a C-language function call as follows:
int main (int argc, char *argv[]);
where argc is the argument count and argv is an array of character pointers to the arguments themselves. In
addition, the following variable, which needs to be declared by the user if it is to be used directly:
extern char **environ;
is initialized as a pointer to an array of character pointers to the environment strings. The argv and environ
arrays are each terminated by a null pointer. The null pointer terminating the argv array is not counted in argc.
Applications can change the entire environment in a single operation by assigning the environ variable to point to an
array of character pointers to the new environment strings. After assigning a new value to environ, applications should not
rely on the new environment strings remaining part of the environment, as a call to getenv(), secure_getenv(),
[XSI]
putenv(),  setenv(), unsetenv(), or any function that is
dependent on an environment variable may, on noticing that environ has changed, copy the environment strings to a new array
and assign environ to point to it.
Any application that directly modifies the pointers to which the environ variable points has undefined behavior.
Conforming multi-threaded applications shall not use the environ variable to access or modify any environment variable
while any other thread is concurrently modifying any environment variable. A call to any function dependent on any environment
variable shall be considered a use of the environ variable to access that environment variable.
The arguments specified by a program with one of the exec functions shall be passed on to the new process image in the
corresponding main() arguments.
For the execl(), execle(), execv(), and execve() functions, the argument path points to a
pathname that identifies the new process image file.
For the execlp() and execvp() functions, the argument file is used to construct a pathname that identifies
the new process image file. If the file argument contains a  character, the file argument shall be used
as the pathname for this file. Otherwise, the path prefix for this file is obtained by a search of the directories passed as the
environment variable PATH (see XBD 8. Environment Variables). If
this environment variable is not present, the results of the search are implementation-defined.
There are two distinct ways in which the contents of the process image file may cause the execution to fail, distinguished by
the setting of errno to either [ENOEXEC] or [EINVAL] (see the ERRORS section). In the cases where the other members of the
exec family of functions would fail and set errno to [ENOEXEC], the execlp() and execvp() functions
shall execute a command interpreter and the environment of the executed command shall be as if the process invoked the sh utility using execl() as follows:
execl(, , file, , (char *)0);
where  is an unspecified pathname for the sh utility,
is an unspecified string, file is the process image file, and where  is zero or more
parameters corresponding to any initial non-null arguments passed after arg0 for execlp() or to any initial non-null
members of argv starting at argv[1] for execvp().
The arguments represented by arg0,... are pointers to null-terminated character strings. These strings shall constitute
the argument list available to the new process image. The list is terminated by a null pointer. The argument arg0 should
point to a filename string that is associated with the process being started by one of the exec functions.
The argument argv is an array of character pointers to null-terminated strings. The application shall ensure that the
last member of this array is a null pointer. These strings shall constitute the argument list available to the new process image.
The value in argv[0] should point to a filename string that is associated with the process being started by one of the
exec functions.
The argument envp is an array of character pointers to null-terminated strings. These strings shall constitute the
environment for the new process image. The envp array is terminated by a null pointer.
For those forms not containing an envp pointer (execl(), execv(),
execlp(), and execvp()), the environment for the new process image shall be taken from the external variable
environ in the calling process.
The number of bytes available for the new process' combined argument and environment lists is {ARG_MAX}. It is
implementation-defined whether null terminators, pointers, and/or any alignment bytes are included in this total.
File descriptors open in the calling process image shall remain open in the new process image, except for those whose
close-on-exec flag FD_CLOEXEC is set. For those file descriptors that remain open, all attributes of the open file
description shall remain unchanged and the FD_CLOFORK file descriptor flag, if set, shall remain set. For any file descriptor that
is closed for this reason, process-owned file locks that the calling process owns on the file associated with the file descriptor
shall be unlocked as a result of the close, as described in close(). File locks that
are not unlocked by closing of file descriptors remain unchanged.
If file descriptor 0, 1, or 2 would otherwise be closed after a successful call to one of the exec family of functions,
implementations may open an unspecified file for the file descriptor in the new process image. If a standard utility or a
conforming application is executed with file descriptor 0 not open for reading or with file descriptor 1 or 2 not open for writing,
the environment in which the utility or application is executed shall be deemed non-conforming, and consequently the utility or
application might not behave as described in this standard.
Directory streams open in the calling process image shall be closed in the new process image.
The state of the floating-point environment in the initial thread of the new process image shall be set to the default.
The state of conversion descriptors and message catalog descriptors in the new process image is undefined.
For the new process image, the equivalent of:
setlocale(LC_ALL, "C")
shall be executed at start-up.
Signals set to the default action (SIG_DFL) in the calling process image shall be set to the default action in the new process
image. Except for SIGCHLD, signals set to be ignored (SIG_IGN) by the calling process image shall be set to be ignored by the new
process image. Signals set to be caught by the calling process image shall be set to the default action in the new process image
(see ).
If the SIGCHLD signal is set to be ignored by the calling process image, it is unspecified whether the SIGCHLD signal is set to
be ignored or to the default action in the new process image.
[XSI]
After a successful call to any of the exec functions, alternate signal stacks are not preserved and the SA_ONSTACK flag
shall be cleared for all signals.
After a successful call to any of the exec functions, any functions previously registered by the atexit(), at_quick_exit(), or pthread_atfork() functions are no longer registered.
[XSI]
If the ST_NOSUID bit is set for the file system containing the new process image file, then the effective user ID, effective group
ID, saved set-user-ID, and saved set-group-ID are unchanged in the new process image. Otherwise,  if the set-user-ID mode bit of the new process image file is set, the effective user ID of the new
process image shall be set to the user ID of the new process image file. Similarly, if the set-group-ID mode bit of the new process
image file is set, the effective group ID of the new process image shall be set to the group ID of the new process image file. The
real user ID, real group ID, and supplementary group IDs of the new process image shall remain the same as those of the calling
process image. The effective user ID and effective group ID of the new process image shall be saved (as the saved set-user-ID and
the saved set-group-ID) for use by setuid().
[XSI]
Any shared memory segments attached to the calling process image shall not be attached to the new process image.
Any named semaphores open in the calling process shall be closed as if by appropriate calls to sem_close(). Any unnamed semaphores open in the calling process shall be destroyed as if
by calls to sem_destroy().
[TYM]
Any blocks of typed memory that were mapped in the calling process are unmapped, as if munmap() was implicitly called to unmap them.
[ML]
Memory locks established by the calling process via calls to mlockall() or mlock() shall be removed. If locked pages in the address space of the calling process are also
mapped into the address spaces of other processes and are locked by those processes, the locks established by the other processes
shall be unaffected by the call by this process to the exec function. If the exec function fails, the effect on
memory locks is unspecified.
Memory mappings created in the process are unmapped before the address space is rebuilt for the new process image.
When the calling process image does not use the SCHED_FIFO, SCHED_RR, [SS]
or SCHED_SPORADIC   scheduling policies, the scheduling policy and parameters of the new process image and the initial
thread in that new process image are implementation-defined.
[PS]
When the calling process image uses the SCHED_FIFO, SCHED_RR, or SCHED_SPORADIC scheduling policies, the process policy and
scheduling parameter settings shall not be changed by a call to an exec function.  [TPS]   The initial thread in the new process image shall inherit the process scheduling policy and
parameters. It shall have the default system contention scope, but shall inherit its allocation domain from the calling process
image.
Per-process timers created by the calling process shall be deleted before replacing the current process image with the new
process image.
[MSG]
All open message queue descriptors in the calling process shall be closed, as described in mq_close().
Any outstanding asynchronous I/O operations may be canceled. Those asynchronous I/O operations that are not canceled shall
complete as if the exec function had not yet occurred, but any associated signal notifications shall be suppressed. It is
unspecified whether the exec function itself blocks awaiting such I/O completion. In no event, however, shall the new
process image created by the exec function be affected by the presence of outstanding asynchronous I/O operations at the
time the exec function is called. Whether any I/O is canceled, and which I/O may be canceled upon exec, is
implementation-defined.
[CPT]
The new process image shall inherit the CPU-time clock of the calling process image. This inheritance means that the process
CPU-time clock of the process being exec-ed shall not be reinitialized or altered as a result of the exec function
other than to reflect the time spent by the process executing the exec function itself.
[TCT]
The initial value of the CPU-time clock of the initial thread of the new process image shall be set to zero.
The thread ID of the initial thread in the new process image is unspecified.
The size and location of the stack on which the initial thread in the new process image runs is unspecified.
The initial thread in the new process image shall have its cancellation type set to PTHREAD_CANCEL_DEFERRED and its cancellation
state set to PTHREAD_CANCEL_ENABLED.
The initial thread in the new process image shall have all thread-specific data values set to NULL and all thread-specific data
keys shall be removed by the call to exec without running destructors.
The initial thread in the new process image shall be joinable, as if created with the detachstate attribute set to
PTHREAD_CREATE_JOINABLE.
The new process shall inherit at least the following attributes from the calling process image:
[XSI]
Nice value (see nice())
[XSI]
semadj values (see semop())
Process ID
Parent process ID
Process group ID
Session membership
Real user ID
Real group ID
Supplementary group IDs
Time left until an alarm clock signal (see alarm())
Current working directory
Root directory
File mode creation mask (see umask())
File size limit (see getrlimit() and setrlimit())
Process signal mask (see pthread_sigmask())
Pending signal (see sigpending())
tms_utime, tms_stime, tms_cutime, and tms_cstime (see times())
Resource limits
Controlling terminal
The initial thread of the new process shall inherit at least the following attributes from the calling thread:
Signal mask (see sigprocmask() and pthread_sigmask())
Pending signals (see sigpending())
All other process attributes defined in this volume of POSIX.1-2024 shall be inherited in the new process image from the old
process image. All other thread attributes defined in this volume of POSIX.1-2024 shall be inherited in the initial thread in the
new process image from the calling thread in the old process image. The inheritance of process or thread attributes not defined by
this volume of POSIX.1-2024 is implementation-defined.
A call to any exec function from a process with more than one thread shall result in all threads being terminated and the
new executable image being loaded and executed. No destructor functions or cleanup handlers shall be called.
Upon successful completion, the exec functions shall mark for update the last data access timestamp of the file. If an
exec function failed but was able to locate the process image file, whether the last data access timestamp is marked for
update is unspecified. Should the exec function succeed, the process image file shall be considered to have been opened with
open(). The corresponding close() shall be
considered to occur at a time after this open, but before process termination or successful completion of a subsequent call to one
of the exec functions, posix_spawn(), or posix_spawnp(). The argv[] and envp[] arrays of pointers and the strings
to which those arrays point shall not be modified by a call to one of the exec functions, except as a consequence of
replacing the process image.
The saved resource limits in the new process image are set to be a copy of the process' corresponding hard and soft limits.
RETURN VALUE
If one of the exec functions returns to the calling process image, an error has occurred; the return value shall be -1,
and errno shall be set to indicate the error.
ERRORS
The exec functions shall fail if:
[E2BIG]
The number of bytes used by the new process image's argument list and environment list is greater than the system-imposed limit
of {ARG_MAX} bytes.
[EACCES]
The new process image file is not a regular file and the implementation does not support execution of files of its type.
[EINVAL]
The new process image file has appropriate privileges and has a recognized executable binary format, but the system does not
support execution of a file with this format.
The exec functions, except for fexecve(), shall fail if:
[EACCES]
Search permission is denied for a directory listed in the new process image file's path prefix, or the new process image file
denies execution permission.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the path or file argument.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOENT]
A component of path or file does not name an existing file or path or file is an empty string.
[ENOTDIR]
A component of the new process image file's path prefix names an existing file that is neither a directory nor a symbolic link
to a directory, or the new process image file's pathname contains at least one non- character and ends with one or
more trailing  characters and the last pathname component names an existing file that is neither a directory nor a
symbolic link to a directory.
The exec functions, except for execlp() and execvp(), shall fail if:
[ENOEXEC]
The new process image file has the appropriate access permission but has an unrecognized format.
The fexecve() function shall fail if:
[EBADF]
The fd argument is not a valid file descriptor open for executing.
The exec functions may fail if:
[ENOMEM]
The new process image requires more memory than is allowed by the hardware or system-imposed memory management
constraints.
The exec functions, except for fexecve(), may fail if:
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the path or file argument.
[ENAMETOOLONG]
The length of the path argument or the length of the pathname constructed from the file argument exceeds {PATH_MAX},
or pathname resolution of a symbolic link produced an intermediate result with a length that exceeds {PATH_MAX}.
[ETXTBSY]
The new process image file is a pure procedure (shared text) file that is currently open for writing by some process.
The following sections are informative.
EXAMPLES
Using execl()
The following example executes the ls command, specifying the pathname of the
executable (/bin/ls) and using arguments supplied directly to the command to produce single-column output.
#include
int ret;
...
ret = execl ("/bin/ls", "ls", "-1", (char *)0);
Using execle()
The following example is similar to Using execl(). In addition, it specifies the environment
for the new process image using the env argument.
#include
int ret;
char *env[] = { "HOME=/usr/home", "LOGNAME=home", (char *)0 };
...
ret = execle ("/bin/ls", "ls", "-l", (char *)0, env);
Using execlp()
The following example searches for the location of the ls command among the
directories specified by the PATH environment variable.
#include
int ret;
...
ret = execlp ("ls", "ls", "-l", (char *)0);
Using execv()
The following example passes arguments to the ls command in the cmd array.
#include
int ret;
char *cmd[] = { "ls", "-l", (char *)0 };
...
ret = execv ("/bin/ls", cmd);
Using execve()
The following example passes arguments to the ls command in the cmd array, and
specifies the environment for the new process image using the env argument.
#include
int ret;
char *cmd[] = { "ls", "-l", (char *)0 };
char *env[] = { "HOME=/usr/home", "LOGNAME=home", (char *)0 };
...
ret = execve ("/bin/ls", cmd, env);
Using execvp()
The following example searches for the location of the ls command among the
directories specified by the PATH environment variable, and passes arguments to the ls command in the cmd array.
#include
int ret;
char *cmd[] = { "ls", "-l", (char *)0 };
...
ret = execvp ("ls", cmd);
APPLICATION USAGE
As the state of conversion descriptors and message catalog descriptors in the new process image is undefined, conforming
applications should not rely on their use and should close them prior to calling one of the exec functions.
Applications that require other than the default POSIX locale as the global locale in the new process image should call setlocale() with the appropriate parameters.
When assigning a new value to the environ variable, applications should ensure that the environment to which it will
point contains at least the following:
Any implementation-defined variables required by the implementation to provide a conforming environment. See the _CS_V8_ENV
entry in  and confstr() for details.
A value for PATH which finds conforming versions of all standard utilities before any other versions.
The same constraint applies to the envp array passed to execle() or execve(), in order to ensure that the
new process image is invoked in a conforming environment.
Applications should not execute programs with file descriptor 0 not open for reading or with file descriptor 1 or 2 not open for
writing, as this might cause the executed program to misbehave. In order not to pass on these file descriptors to an executed
program, applications should not just close them but should reopen them on, for example, /dev/null. Some implementations may
reopen them automatically, but applications should not rely on this being done.
If an application wants to perform an integrity test of the file being executed before executing it, the file will need to be
opened with read permission to perform the integrity test.
Since execute permission is checked by fexecve(), the file description fd need not have been opened with the
O_EXEC flag. However, if the file to be executed denies read and write permission for the process preparing to do the exec,
the only way to provide the fd to fexecve() will be to use the O_EXEC flag when opening fd. In this case, the
application will not be able to perform an integrity test since it will not be able to read the contents of the file.
Note that when a file descriptor is opened with O_RDONLY, O_RDWR, or O_WRONLY mode, the file descriptor can be used to read,
read and write, or write the file, respectively, even if the mode of the file changes after the file was opened. Using the O_EXEC
open mode is different; fexecve() will ignore the mode that was used when the file descriptor was opened and the exec
will fail if the mode of the file associated with fd does not grant execute permission to the calling process at the time
fexecve() is called.
RATIONALE
Early proposals required that the value of argc passed to main() be "one or greater". This was driven by the
same requirement in drafts of the ISO C standard. In fact, historical implementations have passed a value of zero when no
arguments are supplied to the caller of the exec functions. This requirement was removed from the ISO C standard and
subsequently removed from this volume of POSIX.1-2024 as well. The wording, in particular the use of the word should,
requires a Strictly Conforming POSIX Application to pass at least one argument to the exec function, thus guaranteeing that
argc be one or greater when invoked by such an application. In fact, this is good practice, since many existing applications
reference argv[0] without first checking the value of argc.
The requirement on a Strictly Conforming POSIX Application also states that the value passed as the first argument be a filename
string associated with the process being started. Although some existing applications pass a pathname rather than a filename string
in some circumstances, a filename string is more generally useful, since the common usage of argv[0] is in printing
diagnostics. In some cases the filename passed is not the actual filename of the file; for example, many implementations of the
login utility use a convention of prefixing a  ('-') to the actual filename, which indicates to
the command interpreter being invoked that it is a "login shell".
Also, note that the test and [ utilities require specific strings for the
argv[0] argument to have deterministic behavior across all implementations.
Historically, there have been two ways that implementations can exec shell scripts.
One common historical implementation is that the execl(), execv(), execle(), and execve() functions
return an [ENOEXEC] error for any file not recognizable as executable, including a shell script. When the execlp() and
execvp() functions encounter such a file, they assume the file to be a shell script and invoke a known command interpreter
to interpret such files. This is now required by POSIX.1-2024. These implementations of execvp() and execlp() only
give the [ENOEXEC] error in the rare case of a problem with the command interpreter's executable file. Because of these
implementations, the [ENOEXEC] error is not mentioned for execlp() or execvp(), although implementations can still
give it.
Another way that some historical implementations handle shell scripts is by recognizing the first two bytes of the file as the
character string "#!" and using the remainder of the first line of the file as the name of the command interpreter to
execute.
One potential source of confusion noted by the standard developers is over how the contents of a process image file affect the
behavior of the exec family of functions. The following is a description of the actions taken:
If the process image file is a valid executable (in a format that is executable and valid and having appropriate privileges) for
this system, then the system executes the file.
If the process image file has appropriate privileges and is in a format that is executable but not valid for this system (such
as a recognized binary for another architecture), then this is an error and errno is set to [EINVAL] (see later RATIONALE on
[EINVAL]).
If the process image file has appropriate privileges but is not otherwise recognized:
If this is a call to execlp() or execvp(), then they invoke a command interpreter assuming that the process image
file is a shell script.
If this is not a call to execlp() or execvp(), then an error occurs and errno is set to [ENOEXEC].
Applications that do not require to access their arguments may use the form:
main(void)
as specified in the ISO C standard. However, the implementation will always provide the two arguments argc and
argv, even if they are not used.
Some implementations provide a third argument to main() called envp. This is defined as a pointer to the
environment. The ISO C standard specifies invoking main() with two arguments, so implementations are required to
support applications written this way. Since this volume of POSIX.1-2024 defines the global variable environ, which is also
provided by historical implementations and can be used anywhere that envp could be used, there is no functional need for the
envp argument. Applications should use the getenv() function rather than
accessing the environment directly via either envp or environ. Implementations are required to support the
two-argument calling sequence, but this does not prohibit an implementation from supporting envp as an optional third
argument.
This volume of POSIX.1-2024 specifies that signals set to SIG_IGN remain set to SIG_IGN, and that the new process image inherits
the signal mask of the thread that called exec in the old process image. This is consistent with historical implementations,
and it permits some useful functionality, such as the nohup command. However, it
should be noted that many existing applications wrongly assume that they start with certain signals set to the default action
and/or unblocked. In particular, applications written with a simpler signal model that does not include blocking of signals, such
as the one in the ISO C standard, may not behave properly if invoked with some signals blocked. Therefore, it is best not to
block or ignore signals across execs without explicit reason to do so, and especially not to block signals across
execs of arbitrary (not closely cooperating) programs.
The exec functions always save the value of the effective user ID and effective group ID of the process at the completion
of the exec, whether or not the set-user-ID or the set-group-ID bit of the process image file is set.
The statement about argv[] and envp[] being constants is included to make explicit to future writers of language
bindings that these objects are completely constant. Due to a limitation of the ISO C standard, it is not possible to state
that idea in standard C. Specifying two levels of const-qualification for the argv[] and envp[]
parameters for the exec functions may seem to be the natural choice, given that these functions do not modify either the
array of pointers or the characters to which the function points, but this would disallow existing correct code. Instead, only the
array of pointers is noted as constant. The table of assignment compatibility for dst=src derived from the ISO C
standard summarizes the compatibility:
dst:
char *[]
const char *[]
char *const[]
const char *const[]
src:
char *[]
VALID
—
VALID
—
const char *[]
—
VALID
—
VALID
char * const []
—
—
VALID
—
const char *const[]
—
—
—
VALID
Since all existing code has a source type matching the first row, the column that gives the most valid combinations
is the third column. The only other possibility is the fourth column, but using it would require a cast on the argv or
envp arguments. It is unfortunate that the fourth column cannot be used, because the declaration a non-expert would
naturally use would be that in the second row.
The ISO C standard and this volume of POSIX.1-2024 do not conflict on the use of environ, but some
historical implementations of environ may cause a conflict. As long as environ is treated in the same way as an entry
point (for example, fork()), it conforms to both standards. A library can contain
fork(), but if there is a user-provided fork(), that fork() is given precedence and no
problem ensues. The situation is similar for environ: the definition in this volume of POSIX.1-2024 is to be used if there
is no user-provided environ to take precedence. At least three implementations are known to exist that solve this
problem.
[E2BIG]
The limit {ARG_MAX} applies not just to the size of the argument list, but to the sum of that and the size of the environment
list.
[EFAULT]
Some historical systems return [EFAULT] rather than [ENOEXEC] when the new process image file is corrupted. They are
non-conforming.
[EINVAL]
This error condition was added to POSIX.1-2024 to allow an implementation to detect executable files generated for different
architectures, and indicate this situation to the application. Historical implementations of shells, execvp(), and
execlp() that encounter an [ENOEXEC] error will execute a shell on the assumption that the file is a shell script. This will
not produce the desired effect when the file is a valid executable for a different architecture. An implementation may now choose
to avoid this problem by returning [EINVAL] when a valid executable for a different architecture is encountered. Some historical
implementations return [EINVAL] to indicate that the path argument contains a character with the high order bit set. The
standard developers chose to deviate from historical practice for the following reasons:
The new utilization of [EINVAL] will provide some measure of utility to the user community.
Historical use of [EINVAL] is not acceptable in an internationalized operating environment.
[ENAMETOOLONG]
Since the file pathname may be constructed by taking elements in the PATH variable and putting them together with the
filename, the [ENAMETOOLONG] error condition could also be reached this way.
[ETXTBSY]
System V returns this error when the executable file is currently open for writing by some process. This volume of POSIX.1-2024
neither requires nor prohibits this behavior.
Other systems (such as System V) may return [EINTR] from exec. This is not addressed by this volume of
POSIX.1-2024, but implementations may have a window between the call to exec and the time that a signal could cause one of
the exec calls to return with [EINTR].
An explicit statement regarding the floating-point environment (as defined in the  header) was added to make it clear that the floating-point environment is set
to its default when a call to one of the exec functions succeeds. The requirements for inheritance or setting to the default
for other process and thread start-up functions is covered by more generic statements in their descriptions and can be summarized
as follows:
posix_spawn()
Set to default.
fork()
Inherit.
pthread_create()
Inherit.
The purpose of the fexecve() function is to enable executing a file which has been verified to be the
intended file. It is possible to actively check the file by reading from the file descriptor and be sure that the file is not
exchanged for another between the reading and the execution. Alternatively, a function like openat() can be used to open a file which has been found by reading the content of a
directory using readdir().
When execlp() or execvp() fall back to invoking sh because
of an [ENOEXEC] condition, the standard leaves the process name (what becomes argv[0] in the resulting sh process) unspecified. Existing implementations vary on whether they pass a variation of
"sh", or preserve the original arg0. There are existing implementations of sh that behave differently depending on the contents of argv[0], such that blindly passing
the original arg0 on to the fallback execution can fail to invoke a compliant shell environment. Because of the requirements
on how sh handles its command line arguments, the shell script will see $0
containing the pathname of the script being executed, regardless of the value of argv[0].
FUTURE DIRECTIONS
None.
SEE ALSO
alarm(), atexit(), chmod(), close(), confstr(), exit(), fcntl(), fork(), fstatvfs(), getenv(), getrlimit(), mknod(), mmap(), nice(), open(), posix_spawn(), pthread_atfork(), pthread_sigmask(), putenv(),
readdir(), semop(), setlocale(), shmat(), sigaction(), sigaltstack(),
sigpending(), system(),
times(), umask()
XBD 8. Environment Variables,
XCU test
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Realtime Extension and the POSIX Threads Extension.
Large File Summit extensions are added.
Issue 6
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
In the DESCRIPTION, behavior is defined for when the process image file is not a valid executable.
In this version, _POSIX_SAVED_IDS is mandated, thus the effective user ID and effective group ID of the new
process image shall be saved (as the saved set-user-ID and the saved set-group-ID) for use by the setuid() function.
The [ELOOP] mandatory error condition is added.
A second [ENAMETOOLONG] is added as an optional error condition.
The [ETXTBSY] optional error condition is added.
The following changes were made to align with the IEEE P1003.1a draft standard:
The [EINVAL] mandatory error condition is added.
The [ELOOP] optional error condition is added.
The description of CPU-time clock semantics is added for alignment with IEEE Std 1003.1d-1999.
The DESCRIPTION is updated for alignment with IEEE Std 1003.1j-2000 by adding semantics for typed
memory.
The normative text is updated to avoid use of the term "must" for application requirements.
The description of tracing semantics is added for alignment with IEEE Std 1003.1q-2000.
IEEE PASC Interpretation 1003.1 #132 is applied.
The DESCRIPTION is updated to make it explicit that the floating-point environment in the new process image is set
to the default.
The DESCRIPTION and RATIONALE are updated to include clarifications of how the contents of a process image file
affect the behavior of the exec functions.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/15 is applied, adding a new paragraph to the
DESCRIPTION and text to the end of the APPLICATION USAGE section. This change addresses a security concern, where implementations
may want to reopen file descriptors 0, 1, and 2 for programs with the set-user-id or set-group-id file mode bits calling the
exec family of functions.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/24 is applied, applying changes to the DESCRIPTION,
addressing which attributes are inherited by threads, and behavioral requirements for threads attributes.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/25 is applied, updating text in the RATIONALE from
"the process signal mask be unchanged across an exec" to "the new process image inherits the signal mask of the thread
that called exec in the old process image".
Issue 7
Austin Group Interpretation 1003.1-2001 #047 is applied, adding the description of _CS_V7_ENV to the APPLICATION USAGE.
Austin Group Interpretation 1003.1-2001 #143 is applied.
The fexecve() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 2.
Functionality relating to the Asynchronous Input and Output, Memory Mapped Files, Threads, and Timers options is
moved to the Base.
Changes are made related to support for finegrained timestamps.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0095 [386], XSH/TC1-2008/0096 [167], XSH/TC1-2008/0097 [291],
XSH/TC1-2008/0098 [173], XSH/TC1-2008/0099 [296], XSH/TC1-2008/00100 [324], XSH/TC1-2008/00101 [296], XSH/TC1-2008/00102 [302],
XSH/TC1-2008/00103 [167], XSH/TC1-2008/00104 [173], and XSH/TC1-2008/00105 [291,429] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0097 [584], XSH/TC2-2008/0098 [898], and XSH/TC2-2008/0099
[734] are applied.
Issue 8
Austin Group Defects 51 and 1669 are applied, moving the getrlimit() and
setrlimit() functions from the XSI option to the Base.
Austin Group Defect 368 is applied, adding a requirement for unnamed semaphores to be destroyed.
Austin Group Defect 768 is applied, adding OFD-owned file locks.
Austin Group Defect 922 is applied, adding the secure_getenv()
function.
Austin Group Defect 1284 is applied, changing "checksum test" to "integrity test" in the APPLICATION USAGE
section.
Austin Group Defect 1318 is applied, adding FD_CLOFORK.
Austin Group Defect 1330 is applied, removing obsolescent interfaces and changing "_V7_" to "_V8_".
Austin Group Defect 1435 is applied, adding function lists to the descriptions of the path and file
arguments.
Austin Group Defect 1645 is applied, making it unspecified what string is passed to the shell in argv[0]
when executed by execlp() or execvp().
Austin Group Defect 1646 is applied, adding at_quick_exit() to
the list of registration functions whose registrations are not inherited across exec.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/iswblank_l.html =====
iswblank
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
iswblank, iswblank_l — test for a blank wide-character code
SYNOPSIS
#include
int iswblank(wint_t wc);
[CX]  int iswblank_l(wint_t wc, locale_t locale);
DESCRIPTION
For iswblank(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The iswblank() [CX]   and iswblank_l()
functions shall test whether wc is a wide-character code representing a character of class blank in the current
locale, [CX]   or in the locale represented by locale,
respectively; see XBD 7. Locale.
The wc argument is a wint_t, the value of which the application shall ensure is a wide-character code
corresponding to a valid character in the locale used by the function, or equal to the value of the macro WEOF. If the argument has
any other value, the behavior is undefined.
[CX]  The
behavior is undefined if the locale argument to iswblank_l() is the special locale object LC_GLOBAL_LOCALE or is not
a valid locale object handle.
RETURN VALUE
The iswblank() [CX]   and iswblank_l()
functions shall return non-zero if wc is a blank wide-character code; otherwise, they shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
To ensure applications portability, especially across natural languages, only these functions and the functions in the reference
pages listed in the SEE ALSO section should be used for character classification.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
iswalnum(), iswalpha(),
iswcntrl(), iswctype(),
iswdigit(), iswgraph(),
iswlower(), iswprint(),
iswpunct(), iswspace(),
iswupper(), iswxdigit(),
setlocale(), uselocale()
XBD 7. Locale, ,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
The iswblank_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0315 [302], XSH/TC1-2008/0316 [283], and XSH/TC1-2008/0317 [283] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0182 [685] is applied.
Issue 8
Austin Group Defect 1770 is applied, changing "iswblank() and iswblank()
functions" to "iswblank() and iswblank_l() functions".
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wcscpy.html =====
wcscpy
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wcpcpy, wcscpy — copy a wide-character string, returning a pointer to its end
SYNOPSIS
#include
[CX]  wchar_t *wcpcpy(wchar_t *restrict ws1, const wchar_t *restrict ws2);
wchar_t *wcscpy(wchar_t *restrict ws1, const wchar_t *restrict ws2);
DESCRIPTION
For wcscpy(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The [CX]
wcpcpy()   and wcscpy() functions shall copy the
wide-character string pointed to by ws2 (including the terminating null wide-character code) into the array pointed to by
ws1.
The application shall ensure that there is room for at least wcslen(ws2)+1 wide characters in the ws1
array, and that the ws2 and ws1 arrays do not overlap.
If copying takes place between objects that overlap, the behavior is undefined.
[CX]  The
wcscpy() and wcpcpy() functions shall not change the setting of errno on valid input.
RETURN VALUE
[CX]  The
wcpcpy() function shall return a pointer to the terminating null wide-character code copied into the ws1 buffer.
The wcscpy() function shall return ws1.
No return values are reserved to indicate an error.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
strcpy(), wcsdup(), wcsncpy()
XBD
CHANGE HISTORY
First released in Issue 4. Derived from the MSE working draft.
Issue 6
The wcscpy() prototype is updated for alignment with the ISO/IEC 9899:1999 standard.
Issue 7
The wcpcpy() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 1.
Issue 8
Austin Group Defect 448 is applied, adding a requirement that wcscpy() and wcpcpy() do not change the setting of
errno on valid input.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sigprocmask.html =====
pthread_sigmask
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_sigmask, sigprocmask — examine and change blocked signals
SYNOPSIS
[CX]  #include
int pthread_sigmask(int how, const sigset_t *restrict set,
sigset_t *restrict oset);
int sigprocmask(int how, const sigset_t *restrict set,
sigset_t *restrict oset);
DESCRIPTION
The pthread_sigmask() function shall examine or change (or both) the calling thread's signal mask.
If the argument set is not a null pointer, it points to a set of signals to be used to change the currently blocked
set.
The argument how indicates the way in which the set is changed, and the application shall ensure it consists of one of
the following values:
SIG_BLOCK
The resulting set shall be the union of the current set and the signal set pointed to by set.
SIG_SETMASK
The resulting set shall be the signal set pointed to by set.
SIG_UNBLOCK
The resulting set shall be the intersection of the current set and the complement of the signal set pointed to by
set.
If the argument oset is not a null pointer, the previous mask shall be stored in the location pointed to by oset.
If set is a null pointer, the value of the argument how is not significant and the thread's signal mask shall be
unchanged; thus the call can be used to enquire about currently blocked signals.
If the argument set is not a null pointer, after pthread_sigmask() changes the currently blocked set of signals it
shall determine whether there are any pending unblocked signals; if there are any, then at least one of those signals shall be
delivered before the call to pthread_sigmask() returns.
It is not possible to block those signals which cannot be ignored. This shall be enforced by the system without causing an error
to be indicated.
If any of the SIGFPE, SIGILL, SIGSEGV, or SIGBUS signals are generated while they are blocked, the result is undefined, unless
the signal was generated by the action of another process, or by one of the functions kill(), pthread_kill(), raise(), or sigqueue().
If pthread_sigmask() fails, the thread's signal mask shall not be changed.
The sigprocmask() function shall be equivalent to pthread_sigmask(), except that its behavior is unspecified if
called from a multi-threaded process, and on error it returns -1 and sets errno to the error number instead of returning the
error number directly.
RETURN VALUE
Upon successful completion, pthread_sigmask() shall return 0; otherwise, it shall return the corresponding error
number.
Upon successful completion, sigprocmask() shall return 0; otherwise, -1 shall be returned and errno shall be set
to indicate the error.
ERRORS
These functions shall fail if:
[EINVAL]
The set argument is not a null pointer and the value of the how argument is not equal to one of the defined
values.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
Signaling in a Multi-Threaded Process
This example shows the use of pthread_sigmask() in order to deal with signals in a multi-threaded process. It provides a
fairly general framework that could be easily adapted/extended.
#include
#include
#include
#include
#include
#include
...
static sigset_t   signal_mask;  /* signals to block         */
int main (int argc, char *argv[])
{
pthread_t  sig_thr_id;      /* signal handler thread ID */
int        rc;              /* return code              */
sigemptyset (&signal_mask);
sigaddset (&signal_mask, SIGINT);
sigaddset (&signal_mask, SIGTERM);
rc = pthread_sigmask (SIG_BLOCK, &signal_mask, NULL);
if (rc != 0) {
/* handle error */
...
}
/* any newly created threads inherit the signal mask */
rc = pthread_create (&sig_thr_id, NULL, signal_thread, NULL);
if (rc != 0) {
/* handle error */
...
}
/* APPLICATION CODE */
...
}
void *signal_thread (void *arg)
{
int       sig_caught;    /* signal caught       */
int       rc;            /* returned code       */
rc = sigwait (&signal_mask, &sig_caught);
if (rc != 0) {
/* handle error */
}
switch (sig_caught)
{
case SIGINT:     /* process SIGINT  */
...
break;
case SIGTERM:    /* process SIGTERM */
...
break;
default:         /* should normally not happen */
fprintf (stderr, "\nUnexpected signal %d\n", sig_caught);
break;
}
}
APPLICATION USAGE
Although pthread_sigmask() has to deliver at least one of any pending unblocked signals that exist after it has changed
the currently blocked set of signals, there is no requirement that the delivered signal(s) include any that were unblocked by the
change. If one or more signals that were already unblocked become pending (see 2.4.1 Signal Generation and Delivery) during the period the
pthread_sigmask() call is executing, the signal(s) delivered before the call returns might include only those signals.
RATIONALE
When a thread's signal mask is changed in a signal-catching function that is installed by sigaction(), the restoration of the signal mask on return from the signal-catching
function overrides that change (see sigaction()). If the signal-catching function
was installed with signal(), it is unspecified whether this occurs.
See kill() for a discussion of the requirement on delivery of signals.
FUTURE DIRECTIONS
None.
SEE ALSO
exec, kill(), sigaction(), sigaddset(), sigdelset(), sigemptyset(), sigfillset(),
sigismember(), sigpending()
, sigqueue(), sigsuspend()
XBD
CHANGE HISTORY
First released in Issue 3. Included for alignment with the POSIX.1-1988 standard.
Issue 5
The DESCRIPTION is updated for alignment with the POSIX Threads Extension.
The pthread_sigmask() function is added for alignment with the POSIX Threads Extension.
Issue 6
The pthread_sigmask() function is marked as part of the Threads option.
The SYNOPSIS for sigprocmask() is marked as a CX extension to note that the presence of this function in the  header is an extension to the ISO C standard.
The following changes are made for alignment with the ISO POSIX-1:1996 standard:
The DESCRIPTION is updated to explicitly state the functions which may generate the signal.
The normative text is updated to avoid use of the term "must" for application requirements.
The restrict keyword is added to the pthread_sigmask() and sigprocmask() prototypes for alignment with the
ISO/IEC 9899:1999 standard.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/105 is applied, updating "process' signal mask" to "thread's
signal mask" in the DESCRIPTION and RATIONALE sections.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/106 is applied, adding the example to the EXAMPLES section.
Issue 7
The pthread_sigmask() function is moved from the Threads option to the Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0467 [319] is applied.
Issue 8
Austin Group Defect 1132 is applied, clarifying the [EINVAL] error.
Austin Group Defect 1636 is applied, clarifying the exceptions to the equivalence of pthread_sigmask() and
sigprocmask().
Austin Group Defect 1731 is applied, clarifying that although pthread_sigmask() has to deliver at least one of any
pending unblocked signals that exist after it has changed the currently blocked set of signals, there is no requirement that the
delivered signal(s) include any that were unblocked by the change.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_spin_unlock.html =====
pthread_spin_unlock
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_spin_unlock — unlock a spin lock object
SYNOPSIS
#include
int pthread_spin_unlock(pthread_spinlock_t *lock);
DESCRIPTION
The pthread_spin_unlock() function shall release the spin lock referenced by lock which was locked via the
pthread_spin_lock() or pthread_spin_trylock() functions.
The results are undefined if the lock is not held by the calling thread.
If there are threads spinning on the lock when pthread_spin_unlock() is called, the lock becomes available and an
unspecified spinning thread shall acquire the lock.
The results are undefined if this function is called with an uninitialized thread spin lock.
RETURN VALUE
Upon successful completion, the pthread_spin_unlock() function shall return zero; otherwise, an error number shall be
returned to indicate the error.
ERRORS
This function shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
If an implementation detects that the value specified by the lock argument to pthread_spin_unlock() does not refer
to an initialized spin lock object, it is recommended that the function should fail and report an [EINVAL] error.
If an implementation detects that the value specified by the lock argument to pthread_spin_unlock() refers to a
spin lock object for which the current thread does not hold the lock, it is recommended that the function should fail and report an
[EPERM] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_spin_destroy(), pthread_spin_lock()
XBD 4.15.2 Memory Synchronization,
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1j-2000.
In the SYNOPSIS, the inclusion of  is no longer
required.
Issue 7
The pthread_spin_unlock() function is moved from the Spin Locks option to the Base.
The [EINVAL] error for an uninitialized spin lock object is removed; this condition results in undefined behavior.
The [EPERM] error for a spin lock object for which the current thread does not hold the lock is removed; this condition results
in undefined behavior.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_barrierattr_destroy.html =====
pthread_barrierattr_destroy
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_barrierattr_destroy, pthread_barrierattr_init — destroy and initialize the barrier attributes
object
SYNOPSIS
#include
int pthread_barrierattr_destroy(pthread_barrierattr_t *attr);
int pthread_barrierattr_init(pthread_barrierattr_t *attr);
DESCRIPTION
The pthread_barrierattr_destroy() function shall destroy a barrier attributes object. A destroyed attr attributes
object can be reinitialized using pthread_barrierattr_init(); the results of otherwise referencing the object after it has
been destroyed are undefined. An implementation may cause pthread_barrierattr_destroy() to set the object referenced by
attr to an invalid value.
The pthread_barrierattr_init() function shall initialize a barrier attributes object attr with the default value
for all of the attributes defined by the implementation.
If pthread_barrierattr_init() is called specifying an already initialized attr attributes object, the results are
undefined.
After a barrier attributes object has been used to initialize one or more barriers, any function affecting the attributes object
(including destruction) shall not affect any previously initialized barrier.
The behavior is undefined if the value specified by the attr argument to pthread_barrierattr_destroy() does not
refer to an initialized barrier attributes object.
RETURN VALUE
If successful, the pthread_barrierattr_destroy() and pthread_barrierattr_init() functions shall return zero;
otherwise, an error number shall be returned to indicate the error.
ERRORS
The pthread_barrierattr_init() function shall fail if:
[ENOMEM]
Insufficient memory exists to initialize the barrier attributes object.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
If an implementation detects that the value specified by the attr argument to pthread_barrierattr_destroy() does
not refer to an initialized barrier attributes object, it is recommended that the function should fail and report an [EINVAL]
error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_barrierattr_getpshared()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1j-2000.
In the SYNOPSIS, the inclusion of  is no longer
required.
Issue 7
The pthread_barrierattr_destroy() and pthread_barrierattr_init() functions are moved from the Barriers option to
the Base.
The [EINVAL] error for an uninitialized barrier attributes object is removed; this condition results in undefined behavior.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/nice.html =====
nice
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
nice — change the nice value of a process
SYNOPSIS
[XSI]  #include
int nice(int incr);
DESCRIPTION
The nice() function shall add the value of incr to the nice value of the calling process. A nice value of a
process is a non-negative number for which a more positive value shall result in less favorable scheduling.
A maximum nice value of 2*{NZERO}-1 and a minimum nice value of 0 shall be imposed by the system. Requests for values above or
below these limits shall result in the nice value being set to the corresponding limit. Only a process with appropriate privileges
can lower the nice value.
[PS|TPS]
Calling the nice() function has no effect on the priority of processes or threads with policy SCHED_FIFO or SCHED_RR. The
effect on processes or threads with other scheduling policies is implementation-defined.
The nice value set with nice() shall be applied to the process. If the process is multi-threaded, the nice value shall
affect all system scope threads in the process.
As -1 is a permissible return value in a successful situation, an application wishing to check for error situations should set
errno to 0, then call nice(), and if it returns -1, check to see whether errno is non-zero.
RETURN VALUE
Upon successful completion, nice() shall return the new nice value -{NZERO}. Otherwise, -1 shall be returned, the nice
value of the process shall not be changed, and errno shall be set to indicate the error.
ERRORS
The nice() function shall fail if:
[EPERM]
The incr argument is negative and the calling process does not have appropriate privileges.
The following sections are informative.
EXAMPLES
Changing the Nice Value
The following example adds the value of the incr argument, -20, to the nice value of the calling process.
#include
...
int incr = -20;
int ret;
ret = nice(incr);
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
exec, getpriority()
XBD ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
A statement is added to the description indicating the effects of this function on the different scheduling policies and
multi-threaded processes.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/atomic_fetch_xor_explicit.html =====
atomic_fetch_add
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
atomic_fetch_add, atomic_fetch_add_explicit, atomic_fetch_and, atomic_fetch_and_explicit, atomic_fetch_or,
atomic_fetch_or_explicit, atomic_fetch_sub, atomic_fetch_sub_explicit, atomic_fetch_xor, atomic_fetch_xor_explicit — atomically
replace the value of an object with the result of a computation
SYNOPSIS
#include
C atomic_fetch_add(volatile A *object, M operand); C
atomic_fetch_add_explicit(volatile A *object, M operand,
memory_order order); C atomic_fetch_and(volatile A
*object, M operand); C atomic_fetch_and_explicit(volatile A
*object, M operand,
memory_order order); C atomic_fetch_or(volatile A
*object, M operand); C atomic_fetch_or_explicit(volatile A
*object, M operand,
memory_order order); C atomic_fetch_sub(volatile A
*object, M operand); C atomic_fetch_sub_explicit(volatile A
*object, M operand,
memory_order order); C atomic_fetch_xor(volatile A
*object, M operand); C atomic_fetch_xor_explicit(volatile A
*object, M operand,
memory_order order);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
Implementations that define the macro __STDC_NO_ATOMICS__ need not provide the  header nor support these generic functions.
The atomic_fetch_add_explicit() generic function shall atomically replace the value pointed to by object with the
result of adding operand to this value. This operation shall be an atomic read-modify-write operation (see XBD 4.15.1 Memory Ordering). Memory shall be affected according to the value of
order.
The atomic_fetch_add() generic function shall be equivalent to atomic_fetch_add_explicit() called with
order set to memory_order_seq_cst.
The other atomic_fetch_*() generic functions shall be equivalent to atomic_fetch_add_explicit() if their name ends
with explicit, or to atomic_fetch_add() if it does not, respectively, except that they perform the computation
indicated in their name, instead of addition:
sub
subtraction
or
bitwise inclusive OR
xor
bitwise exclusive OR
and
bitwise AND
For addition and subtraction, the application shall ensure that A is an atomic integer type or an atomic pointer type and is not
atomic_bool. For the other operations, the application shall ensure that A is an atomic integer type and is not
atomic_bool.
For signed integer types, the computation shall silently wrap around on overflow; there are no undefined results. For pointer
types, the result can be an undefined address, but the computations otherwise have no undefined behavior.
RETURN VALUE
These generic functions shall return the value pointed to by object immediately before the effects.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The operation of these generic functions is nearly equivalent to the operation of the corresponding compound assignment
operators +=, -=, etc. The only differences are that the compound assignment operators are not guaranteed to
operate atomically, and the value yielded by a compound assignment operator is the updated value of the object, whereas the value
returned by these generic functions is the previous value of the atomic object.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD 4.15.1 Memory Ordering,
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/round.html =====
round
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
round, roundf, roundl — round to the nearest integer value in a floating-point format
SYNOPSIS
#include
double round(double x);
float roundf(float x);
long double roundl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall round their argument to the nearest integer value in floating-point format, rounding halfway cases away
from zero, regardless of the current rounding direction.
[MX]
These functions may raise the inexact floating-point exception for finite non-integer arguments.
RETURN VALUE
Upon successful completion, these functions shall return the rounded integer value. [MX]   The result
shall have the same sign as x.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0 or ±Inf, x shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The integral value returned by these functions need not be expressible as an intmax_t. The return value should be tested
before assigning it to an integer type to avoid the undefined results of an integer overflow.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0520 [346] is applied.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/posix_mem_offset.html =====
posix_mem_offset
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
posix_mem_offset — find offset and length of a mapped typed memory block (ADVANCED REALTIME)
SYNOPSIS
[TYM]  #include
int posix_mem_offset(const void *restrict addr, size_t len,
off_t *restrict off, size_t *restrict contig_len,
int *restrict fildes);
DESCRIPTION
The posix_mem_offset() function shall return in the variable pointed to by off a value that identifies the offset
(or location), within a memory object, of the memory block currently mapped at addr. The function shall return in the
variable pointed to by fildes, the descriptor used (via mmap()) to establish the
mapping which contains addr. If that descriptor was closed since the mapping was established, the returned value of
fildes shall be -1. The len argument specifies the length of the block of the memory object the user wishes the
offset for; upon return, the value pointed to by contig_len shall equal either len, or the length of the largest
contiguous block of the memory object that is currently mapped to the calling process starting at addr, whichever is
smaller.
If the memory object mapped at addr is a typed memory object, then if the off and contig_len values
obtained by calling posix_mem_offset() are used in a call to mmap() with a file
descriptor that refers to the same memory pool as fildes (either through the same port or through a different port), and
that was opened with neither the POSIX_TYPED_MEM_ALLOCATE nor the POSIX_TYPED_MEM_ALLOCATE_CONTIG flag, the typed memory area that
is mapped shall be exactly the same area that was mapped at addr in the address space of the process that called
posix_mem_offset().
If the memory object specified by fildes is not a typed memory object, then the behavior of this function is
implementation-defined.
RETURN VALUE
Upon successful completion, the posix_mem_offset() function shall return zero; otherwise, the corresponding error status
value shall be returned.
ERRORS
The posix_mem_offset() function shall fail if:
[EACCES]
The process has not mapped a memory object supported by this function at the given address addr.
This function shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
mmap(), posix_typed_mem_open()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1j-2000.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/cacosf.html =====
cacos
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
cacos, cacosf, cacosl — complex arc cosine functions
SYNOPSIS
#include
double complex cacos(double complex z);
float complex cacosf(float complex z);
long double complex cacosl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex arc cosine of z, with branch cuts outside the interval [-1, +1] along the
real axis.
RETURN VALUE
These functions shall return the complex arc cosine value, in the range of a strip mathematically unbounded along the imaginary
axis and in the interval [0, ℼ] along the real axis.
[MXC]
cacos(conj(z)), cacosf(conjf(z)), and cacosl(conjl(z)) shall return
exactly the same value as conj(cacos(z)), conjf(cacosf(z)), and
conjl(cacosl(z)), respectively, including for the special values of z below.
If z is ±0 + i0, ℼ/2 - i0 shall be returned.
If z is ±0 + iNaN, ℼ/2 + iNaN shall be returned.
If z is x + iInf where x is finite, ℼ/2 - iInf shall be returned.
If z is x + iNaN where x is non-zero and finite, NaN + iNaN shall be returned and the invalid
floating-point exception may be raised.
If z is -Inf + iy where y is positive-signed and finite, ℼ - iInf shall be returned.
If z is +Inf + iy where y is positive-signed and finite, +0 - iInf shall be returned.
If z is -Inf + iInf, 3ℼ/4 - iInf shall be returned.
If z is +Inf + iInf, ℼ/4 - iInf shall be returned.
If z is ±Inf + iNaN, NaN ± iInf shall be returned; the sign of the imaginary part of the result is
unspecified.
If z is NaN + iy where y is finite, NaN + iNaN shall be returned and the invalid floating-point
exception may be raised.
If z is NaN + iInf, NaN - iInf shall be returned.
If z is NaN + iNaN, NaN - iNaN shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
ccos()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/strtoumax.html =====
strtoimax
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
strtoimax, strtoumax — convert string to integer type
SYNOPSIS
#include
intmax_t strtoimax(const char *restrict nptr, char **restrict endptr,
int base);
uintmax_t strtoumax(const char *restrict nptr, char **restrict endptr,
int base);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall be equivalent to the strtol(), strtoll(), strtoul(), and strtoull() functions, except that the initial portion of the string shall be converted to
intmax_t and uintmax_t representation, respectively.
RETURN VALUE
These functions shall return the converted value, if any.
If no conversion could be performed, zero shall be returned [CX]   and errno may be set to [EINVAL].
[CX]  If
the value of base is not supported, 0 shall be returned and errno shall be set to [EINVAL].
If the correct value is outside the range of representable values, {INTMAX_MAX}, {INTMAX_MIN}, or {UINTMAX_MAX} shall be
returned (according to the return type and sign of the value, if any), and errno shall be set to [ERANGE].
ERRORS
These functions shall fail if:
[EINVAL]
[CX]
The value of base is not supported.
[ERANGE]
The value to be returned is not representable.
These functions may fail if:
[EINVAL]
No conversion could be performed.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Since the value of *endptr is unspecified if the value of base is not supported, applications should either ensure
that base has a supported value (0 or between 2 and 36) before the call, or check for an [EINVAL] error before examining
*endptr.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
strtol(), strtoul()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0613 [453] and XSH/TC1-2008/0614 [453] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fchmodat.html =====
chmod
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
chmod, fchmodat — change mode of a file
SYNOPSIS
#include
int chmod(const char *path, mode_t mode);
[OH] #include
int fchmodat(int fd, const char *path, mode_t mode, int
flag);
DESCRIPTION
The chmod() function shall change S_ISUID, S_ISGID, [XSI]   S_ISVTX,  and the file permission bits of the file named by the pathname pointed to by the path argument to the
corresponding bits in the mode argument. If any bits that can be set in the st_mode value returned by lstat() or stat() but cannot be changed using
chmod(), such as the bits that are used to encode the file type, are set in the mode argument, these read-only
st_mode bits shall be ignored.
If the effective user ID of the process does not match the owner of the file and the process does not have appropriate
privileges, the chmod() function shall fail.
S_ISUID, S_ISGID, [XSI]   S_ISVTX,  and the file permission
bits are described in .
If the calling process does not have appropriate privileges, and if the group ID of the file does not match the effective group
ID or one of the supplementary group IDs and if the file is a regular file, bit S_ISGID (set-group-ID on execution) in the file's
mode shall be cleared upon successful return from chmod().
Additional implementation-defined restrictions may cause the S_ISUID and S_ISGID bits in mode to be ignored,
[XSI]
and may cause the S_ISVTX bit in mode to be ignored for non-directory files.
Upon successful completion, chmod() shall mark for update the last file status change timestamp of the file.
The fchmodat() function shall be equivalent to the chmod() function except in the case where path specifies
a relative path. In this case the file to be changed is determined relative to the directory associated with the file descriptor
fd instead of the current working directory. If the access mode of the open file description associated with the file
descriptor is not O_SEARCH, the function shall check whether directory searches are permitted using the current permissions of the
directory underlying the file descriptor. If the access mode is O_SEARCH, the function shall not perform the check.
Values for flag are constructed by a bitwise-inclusive OR of flags from the following list, defined in :
AT_SYMLINK_NOFOLLOW
If path names a symbolic link, then the mode of the symbolic link is changed.
If fchmodat() is passed the special value AT_FDCWD in the fd parameter, the current working directory shall be
used. If also flag is zero, the behavior shall be identical to a call to chmod().
RETURN VALUE
Upon successful completion, these functions shall return 0. Otherwise, these functions shall return -1 and set errno to
indicate the error. If -1 is returned, no change to the file mode occurs.
ERRORS
These functions shall fail if:
[EACCES]
Search permission is denied on a component of the path prefix.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOENT]
A component of path does not name an existing file or path is an empty string.
[ENOTDIR]
A component of the path prefix names an existing file that is neither a directory nor a symbolic link to a directory, or the
path argument contains at least one non- character and ends with one or more trailing  characters
and the last pathname component names an existing file that is neither a directory nor a symbolic link to a directory.
[EPERM]
The effective user ID does not match the owner of the file and the process does not have appropriate privileges.
[EROFS]
The named file resides on a read-only file system.
The fchmodat() function shall fail if:
[EACCES]
The access mode of the open file description associated with fd is not O_SEARCH and the permissions of the directory
underlying fd do not permit directory searches.
[EBADF]
The path argument does not specify an absolute path and the fd argument is neither AT_FDCWD nor a valid file
descriptor open for reading or searching.
[ENOTDIR]
The path argument is not an absolute path and fd is a file descriptor associated with a non-directory file.
These functions may fail if:
[EINTR]
A signal was caught during execution of the function.
[EINVAL]
The value of the mode argument, ignoring read-only st_mode bits (see the DESCRIPTION), is invalid.
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a
length that exceeds {PATH_MAX}.
The fchmodat() function may fail if:
[EINVAL]
The value of the flag argument is invalid.
[EOPNOTSUPP]
The AT_SYMLINK_NOFOLLOW bit is set in the flag argument, path names a symbolic link, and the system does not
support changing the mode of a symbolic link.
The following sections are informative.
EXAMPLES
Setting Read Permissions for User, Group, and Others
The following example sets read permissions for the owner, group, and others.
#include
const char *path;
...
chmod(path, S_IRUSR|S_IRGRP|S_IROTH);
Setting Read, Write, and Execute Permissions for the Owner Only
The following example sets read, write, and execute permissions for the owner, and no permissions for group and others.
#include
const char *path;
...
chmod(path, S_IRWXU);
Setting Different Permissions for Owner, Group, and Other
The following example sets owner permissions for CHANGEFILE to read, write, and execute, group permissions to read and execute,
and other permissions to read.
#include
#define CHANGEFILE "/etc/myfile"
...
chmod(CHANGEFILE, S_IRWXU|S_IRGRP|S_IXGRP|S_IROTH);
Modifying File Permissions
The following example adds group write permission to the existing permission bits for a file if that bit is not already set.
#include
struct stat sbuf;
...
if (stat(path, &sbuf) == 0 && (sbuf.st_mode & S_IWGRP) == 0)
chmod(path, sbuf.st_mode | S_IWGRP);
Setting and Checking File Permissions
The following example sets the file permission bits for a file named /home/cnd/mod1, then calls the stat() function to verify the permissions.
#include
#include
int status;
struct stat buffer
...
chmod("/home/cnd/mod1", S_IRWXU|S_IRWXG|S_IROTH|S_IWOTH);
status = stat("/home/cnd/mod1", &buffer);
APPLICATION USAGE
In order to ensure that the S_ISUID and S_ISGID bits are set, an application requiring this should use stat() after a successful chmod() to verify this.
Any file descriptors currently open by any process on the file could possibly become invalid if the mode of the file is changed
to a value which would deny access to that process. One situation where this could occur is on a stateless file system. This
behavior will not occur in a conforming environment.
RATIONALE
This volume of POSIX.1-2024 specifies that the S_ISGID bit is cleared by chmod() on a regular file under certain
conditions. This is specified on the assumption that regular files may be executed, and the system should prevent users from making
executable setgid() files perform with privileges that the caller does not have. On
implementations that support execution of other file types, the S_ISGID bit should be cleared for those file types under the same
circumstances.
Implementations that use the S_ISUID bit to indicate some other function (for example, mandatory record locking) on
non-executable files need not clear this bit on writing. They should clear the bit for executable files and any other cases where
the bit grants special powers to processes that change the file contents. Similar comments apply to the S_ISGID bit.
The purpose of the fchmodat() function is to enable changing the mode of files in directories other than the current
working directory without exposure to race conditions. Any part of the path of a file could be changed in parallel to a call to
chmod(), resulting in unspecified behavior. By opening a file descriptor for the target directory and using the
fchmodat() function it can be guaranteed that the changed file is located relative to the desired directory. Some
implementations might allow changing the mode of symbolic links. This is not supported by the interfaces in the POSIX
specification. Systems with such support provide an interface named lchmod(). To support such implementations
fchmodat() has a flag parameter.
FUTURE DIRECTIONS
None.
SEE ALSO
access(), chown(),
exec, fstatat(), fstatvfs(), mkdir(), mkfifo(),
mknod(), open()
XBD , ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The requirement to include  has been removed. Although
was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.
The [EINVAL] and [EINTR] optional error conditions are added.
A second [ENAMETOOLONG] is added as an optional error condition.
The following changes were made to align with the IEEE P1003.1a draft standard:
The [ELOOP] optional error condition is added.
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
Austin Group Interpretation 1003.1-2001 #143 is applied.
The fchmodat() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 2.
Changes are made related to support for finegrained timestamps.
Changes are made to allow a directory to be opened for searching.
The [ENOTDIR] error condition is clarified to cover the condition where the last component of a pathname exists but is not a
directory or a symbolic link to a directory.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0048 [300], XSH/TC1-2008/0049 [461], XSH/TC1-2008/0050 [324],
XSH/TC1-2008/0051 [278], and XSH/TC1-2008/0052 [278] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0057 [873], XSH/TC2-2008/0058 [591], XSH/TC2-2008/0059 [817],
XSH/TC2-2008/0060 [817], and XSH/TC2-2008/0061 [893] are applied.
Issue 8
Austin Group Defect 1024 is applied, allowing the S_ISVTX bit to be ignored for non-directory files.
Austin Group Defect 1283 is applied, clarifying that chmod() ignores read-only st_mode bits in the mode
argument.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/csinl.html =====
csin
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
csin, csinf, csinl — complex sine functions
SYNOPSIS
#include
double complex csin(double complex z);
float complex csinf(float complex z);
long double complex csinl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex sine of z.
RETURN VALUE
These functions shall return the complex sine value.
[MXC]
csin(conj(iz)), csinf(conjf(iz)), and csinl(conjl(iz)) shall return
exactly the same value as conj(csin(iz)), conjf(csinf(iz)), and
conjl(csinl(iz)), respectively, and csin(-iz), csinf(-iz), and
csinl(-iz) shall return exactly the same value as -csin(iz), -csinf(iz), and
-csinl(iz), respectively, including for the special values of iz below.
If iz is +0 + i0, -i (+0 + i0) shall be returned.
If iz is +0 + iInf, -i (±0 + iNaN) shall be returned and the invalid floating-point exception shall
be raised; the sign of the imaginary part of the result is unspecified.
If iz is +0 + iNaN, -i (±0 + iNaN) shall be returned; the sign of the imaginary part of the result
is unspecified.
If iz is x + iInf where x is positive and finite, -i (NaN + iNaN) shall be returned and the
invalid floating-point exception shall be raised.
If iz is x + iNaN where x is non-zero and finite, -i (NaN + iNaN) shall be returned and the
invalid floating-point exception may be raised.
If iz is +Inf + i0, -i (+Inf + i0) shall be returned.
If iz is +Inf + iy where y is positive and finite, -iInf (cos(y) +
isin(y)) shall be returned.
If iz is +Inf + iInf, -i (±Inf + iNaN) shall be returned and the invalid floating-point exception
shall be raised; the sign of the imaginary part of the result is unspecified.
If iz is +Inf + iNaN, -i (±Inf + iNaN) shall be returned; the sign of the imaginary part of the
result is unspecified.
If iz is NaN + i0, -i (NaN + i0) shall be returned.
If iz is NaN + iy where y is any non-zero number, -i (NaN + iNaN) shall be returned and the
invalid floating-point exception may be raised.
If iz is NaN + iNaN, -i (NaN + iNaN) shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
The MXC special cases for csin() are derived from those for csinh() by
applying the formula csin(z) = -icsinh(iz).
FUTURE DIRECTIONS
None.
SEE ALSO
casin(), csinh()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/cos.html =====
cos
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
cos, cosf, cosl — cosine function
SYNOPSIS
#include
double cos(double x);
float cosf(float x);
long double cosl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the cosine of their argument x, measured in radians.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the cosine of x.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0, the value 1.0 shall be returned.
If x is ±Inf, a domain error shall occur, and a NaN shall be returned.
ERRORS
These functions shall fail if:
Domain Error
[MX]
The x argument is ±Inf.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
Taking the Cosine of a 45-Degree Angle
#include
...
double radians = 45 * M_PI / 180;
double result;
...
result = cos(radians);
APPLICATION USAGE
These functions may lose accuracy when their argument is near an odd multiple of ℼ/2 or is far from 0.
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
acos(), feclearexcept(),
fetestexcept(), isnan(),
sin(), tan()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The cosf() and cosl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0063 [320] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/errno.html =====
errno
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
errno — error return value
SYNOPSIS
#include
DESCRIPTION
The lvalue to which the macro errno expands is used by many functions to return error values.
Many functions provide an error number in errno, which has type int and is defined in . The value of errno in the initial thread shall be zero at program
startup (the initial value of errno in other threads is an indeterminate value) and shall otherwise be defined only after a
call to a function for which it is explicitly stated to be set and until it is changed by the next function call or if the
application assigns it a value. The value of errno should only be examined when it is indicated to be valid by a function's
return value. Applications shall obtain the definition of errno by the inclusion of . No function in this volume of POSIX.1-2024 shall set errno to 0. The
setting of errno after a successful call to a function is unspecified unless the description of that function specifies that
errno shall not be modified.
If the macro definition is suppressed in order to access an actual object, or a program defines an identifier with the name
errno, the behavior is undefined.
The symbolic values stored in errno are documented in the ERRORS sections on all relevant pages.
RETURN VALUE
None.
ERRORS
None.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
to be defined as an external variable, whereas the ISO C standard required only that errno be defined as a modifiable
lvalue with type int.
An application that needs to examine the value of errno to determine the error should set it to 0 before a function call,
then inspect it before a subsequent function call.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.3 Error Numbers
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The following sentence is deleted from the DESCRIPTION: "The value of errno is 0 at program start-up, but is never set
to 0 by any XSI function".
The DESCRIPTION also no longer states that conforming implementations may support the declaration:
extern int errno;
Issue 6
Obsolescent text regarding defining errno as:
extern int errno
is removed.
Text regarding no function setting errno to zero to indicate an error is changed to no function shall set errno to
zero. This is for alignment with the ISO/IEC 9899:1999 standard.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/23 is applied, adding text to the DESCRIPTION stating that the
setting of errno after a successful call to a function is unspecified unless the description of the function requires that
it will not be modified.
Issue 8
Austin Group Defect 1302 is applied, aligning this macro with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/recvfrom.html =====
recvfrom
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
recvfrom — receive a message from a socket
SYNOPSIS
#include
ssize_t recvfrom(int socket, void *restrict buffer, size_t length,
int flags, struct sockaddr *restrict address,
socklen_t *restrict address_len);
DESCRIPTION
The recvfrom() function shall receive a message from a connection-mode or connectionless-mode socket. It is normally used
with connectionless-mode sockets because it permits the application to retrieve the source address of received data.
The recvfrom() function takes the following arguments:
socket
Specifies the socket file descriptor.
buffer
Points to the buffer where the message should be stored.
length
Specifies the length in bytes of the buffer pointed to by the buffer argument.
flags
Specifies the type of message reception. Values of this argument are formed by logically OR'ing zero or more of the following
values:
MSG_PEEK
Peeks at an incoming message. The data is treated as unread and the next recvfrom() or similar function shall still
return this data.
MSG_OOB
Requests out-of-band data. The significance and semantics of out-of-band data are protocol-specific.
MSG_WAITALL
On SOCK_STREAM sockets this requests that the function block until the full amount of data can be returned. The function may
return the smaller amount of data if the socket is a message-based socket, if a signal is caught, if the connection is terminated,
if MSG_PEEK was specified, or if an error is pending for the socket.
address
A null pointer, or points to a sockaddr structure in which the sending address is to be stored. The length and format of
the address depend on the address family of the socket.
address_len
Either a null pointer, if address is a null pointer, or a pointer to a socklen_t object which on input specifies
the length of the supplied sockaddr structure, and on output specifies the length of the sending address.
The recvfrom() function shall return the length of the message written to the buffer pointed to by the buffer
argument. For message-based sockets, such as [RS]   SOCK_RAW,  SOCK_DGRAM, and SOCK_SEQPACKET, the entire message shall be read in a single operation. If a message is too long to fit
in the supplied buffer, and MSG_PEEK is not set in the flags argument, the excess bytes shall be discarded. For stream-based
sockets, such as SOCK_STREAM, message boundaries shall be ignored. In this case, data shall be returned to the user as soon as it
becomes available, and no data shall be discarded.
If the MSG_WAITALL flag is not set, data shall be returned only up to the end of the first message.
Not all protocols provide the source address for messages. If the address argument is not a null pointer and the protocol
provides the source address of messages, the source address of the received message shall be stored in the sockaddr
structure pointed to by the address argument, and the length of this address shall be stored in the object pointed to by the
address_len argument.
If the actual length of the address is greater than the length of the supplied sockaddr structure, the stored address
shall be truncated.
If the address argument is not a null pointer and the protocol does not provide the source address of messages, the value
stored in the object pointed to by address is unspecified.
If no messages are available at the socket and O_NONBLOCK is not set on the socket's file descriptor, recvfrom() shall
block until a message arrives or a timeout occurs (see SO_RCVTIMEO in 2.10.16
Use of Options). If no messages are available at the socket and O_NONBLOCK is set on the socket's file descriptor,
recvfrom() shall fail and set errno to [EAGAIN] or [EWOULDBLOCK].
RETURN VALUE
Upon successful completion, recvfrom() shall return the length of the message in bytes. If no messages are available to
be received and the peer has performed an orderly shutdown, recvfrom() shall return 0. Otherwise, the function shall return
-1 and set errno to indicate the error.
ERRORS
The recvfrom() function shall fail if:
[EAGAIN] or [EWOULDBLOCK]
The socket's file descriptor is marked O_NONBLOCK and no data is waiting to be received; or MSG_OOB is set and no out-of-band data
is available and either the socket's file descriptor is marked O_NONBLOCK or the socket does not support blocking to await
out-of-band data. See also SO_RCVTIMEO in 2.10.16 Use of Options
.
[EBADF]
The socket argument is not a valid file descriptor.
[ECONNRESET]
A connection was forcibly closed by a peer.
[EINTR]
A signal interrupted recvfrom() before any data was available.
[EINVAL]
The MSG_OOB flag is set and no out-of-band data is available.
[ENOTCONN]
A receive is attempted on a connection-mode socket that is not connected.
[ENOTSOCK]
The socket argument does not refer to a socket.
[EOPNOTSUPP]
The specified flags are not supported for this socket type.
[ETIMEDOUT]
The connection timed out during connection establishment, or due to a transmission timeout on active connection.
The recvfrom() function may fail if:
[EIO]
An I/O error occurred while reading from or writing to the file system.
[ENOBUFS]
Insufficient resources were available in the system to perform the operation.
[ENOMEM]
Insufficient memory was available to fulfill the request.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The select() and poll() functions can
be used to determine when data is available to be received.
For AF_UNIX sockets, it is recommended that address points to a buffer of length greater than sizeof(struct
sockaddr_un) which has been initialized with null bytes. That way, even if the implementation supports the use of all bytes of
sun_path without a terminating null byte, the larger buffer guarantees that the sun_path member can then be passed to
other interfaces that expect a null-terminated string. If no truncation occurred based on the input value of address_len, it
is unspecified whether the returned address_len will be sizeof(struct sockaddr_un), or merely a value at least as
large as offsetof(struct sockaddr_un, sun_path) plus the number of non-null bytes stored in sun_path.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
poll(), pselect(), read(), recv(), recvmsg(), send(), sendmsg(), sendto(), setsockopt(), shutdown(), socket(), write()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0503 [464] is applied.
Issue 8
Austin Group Defect 561 is applied, adding a paragraph about sun_path to APPLICATION USAGE.
Austin Group Defect 1429 is applied, clarifying the behavior on timeout by adding references to 2.10.16 Use of Options.
Austin Group Defect 1565 is applied, changing the description of address_len.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/chown.html =====
chown
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
chown, fchownat — change owner and group of a file
SYNOPSIS
#include
int chown(const char *path, uid_t owner, gid_t group);
[OH] #include
int fchownat(int fd, const char *path, uid_t owner, gid_t
group,
int flag);
DESCRIPTION
The chown() function shall change the user and group ownership of a file.
The path argument points to a pathname naming a file. The user ID and group ID of the named file shall be set to the
numeric values contained in owner and group, respectively.
Only processes with an effective user ID equal to the user ID of the file or with appropriate privileges may change the
ownership of a file. If _POSIX_CHOWN_RESTRICTED is in effect for path:
Changing the user ID is restricted to processes with appropriate privileges.
Changing the group ID is permitted to a process with an effective user ID equal to the user ID of the file, but without
appropriate privileges, if and only if owner is equal to the file's user ID or (uid_t)-1 and group is equal
either to the calling process' effective group ID or to one of its supplementary group IDs.
If the specified file is a regular file, one or more of the S_IXUSR, S_IXGRP, or S_IXOTH bits of the file mode are set, and the
process does not have appropriate privileges, the set-user-ID (S_ISUID) and set-group-ID (S_ISGID) bits of the file mode shall be
cleared upon successful return from chown(). If the specified file is a regular file, one or more of the S_IXUSR, S_IXGRP,
or S_IXOTH bits of the file mode are set, and the process has appropriate privileges, it is implementation-defined whether the
set-user-ID and set-group-ID bits are altered. If the chown() function is successfully invoked on a file that is not a
regular file and one or more of the S_IXUSR, S_IXGRP, or S_IXOTH bits of the file mode are set, the set-user-ID and set-group-ID
bits may be cleared.
If owner or group is specified as (uid_t)-1 or (gid_t)-1, respectively, the corresponding ID of the
file shall not be changed.
Upon successful completion, chown() shall mark for update the last file status change timestamp of the file, except that
if owner is (uid_t)-1 and group is (gid_t)-1, the file status change timestamp need not be marked for
update.
The fchownat() function shall be equivalent to the chown() and lchown() functions except in the case where path specifies a relative path. In this
case the file to be changed is determined relative to the directory associated with the file descriptor fd instead of the
current working directory. If the access mode of the open file description associated with the file descriptor is not O_SEARCH, the
function shall check whether directory searches are permitted using the current permissions of the directory underlying the file
descriptor. If the access mode is O_SEARCH, the function shall not perform the check.
Values for flag are constructed by a bitwise-inclusive OR of flags from the following list, defined in :
AT_SYMLINK_NOFOLLOW
If path names a symbolic link, ownership of the symbolic link is changed.
If fchownat() is passed the special value AT_FDCWD in the fd parameter, the current working directory shall be
used and the behavior shall be identical to a call to chown() or lchown()
respectively, depending on whether or not the AT_SYMLINK_NOFOLLOW bit is set in the flag argument.
RETURN VALUE
Upon successful completion, these functions shall return 0. Otherwise, these functions shall return -1 and set errno to
indicate the error. If -1 is returned, no changes are made in the user ID and group ID of the file.
ERRORS
These functions shall fail if:
[EACCES]
Search permission is denied on a component of the path prefix.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOENT]
A component of path does not name an existing file or path is an empty string.
[ENOTDIR]
A component of the path prefix names an existing file that is neither a directory nor a symbolic link to a directory, or the
path argument contains at least one non- character and ends with one or more trailing  characters
and the last pathname component names an existing file that is neither a directory nor a symbolic link to a directory.
[EPERM]
The effective user ID does not match the owner of the file, or the calling process does not have appropriate privileges and
_POSIX_CHOWN_RESTRICTED indicates that such privilege is required.
[EROFS]
The named file resides on a read-only file system.
The fchownat() function shall fail if:
[EACCES]
The access mode of the open file description associated with fd is not O_SEARCH and the permissions of the directory
underlying fd do not permit directory searches.
[EBADF]
The path argument does not specify an absolute path and the fd argument is neither AT_FDCWD nor a valid file
descriptor open for reading or searching.
[ENOTDIR]
The path argument is not an absolute path and fd is a file descriptor associated with a non-directory file.
These functions may fail if:
[EIO]
An I/O error occurred while reading or writing to the file system.
[EINTR]
The chown() function was interrupted by a signal which was caught.
[EINVAL]
The owner or group ID supplied is not a value supported by the implementation.
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a
length that exceeds {PATH_MAX}.
The fchownat() function may fail if:
[EINVAL]
The value of the flag argument is not valid.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Although chown() can be used on some implementations by the file owner to change the owner and group to any desired
values, the only portable use of this function is to change the group of a file to the effective GID of the calling process or to a
member of its group set.
RATIONALE
System III and System V allow a user to give away files; that is, the owner of a file may change its user ID to anything. This
is a serious problem for implementations that are intended to meet government security regulations. Version 7 and 4.3 BSD permit
only the superuser to change the user ID of a file. Some government agencies (usually not ones concerned directly with security)
find this limitation too confining. This volume of POSIX.1-2024 uses may to permit secure implementations while not
disallowing System V.
System III and System V allow the owner of a file to change the group ID to anything. Version 7 permits only the superuser to
change the group ID of a file. 4.3 BSD permits the owner to change the group ID of a file to its effective group ID or to any of
the groups in the list of supplementary group IDs, but to no others.
The POSIX.1-1990 standard requires that the chown() function invoked by a non-appropriate privileged process clear the
S_ISGID and the S_ISUID bits for regular files, and permits them to be cleared for other types of files. This is so that changes in
accessibility do not accidentally cause files to become security holes. Unfortunately, requiring these bits to be cleared on
non-executable data files also clears the mandatory file locking bit (shared with S_ISGID), which is an extension on many
implementations (it first appeared in System V). These bits should only be required to be cleared on regular files that have one or
more of their execute bits set.
The purpose of the fchownat() function is to enable changing ownership of files in directories other than the current
working directory without exposure to race conditions. Any part of the path of a file could be changed in parallel to a call to
chown() or lchown(), resulting in unspecified behavior. By opening a file
descriptor for the target directory and using the fchownat() function it can be guaranteed that the changed file is located
relative to the desired directory.
FUTURE DIRECTIONS
None.
SEE ALSO
chmod(), fpathconf(),
lchown()
XBD , ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The following changes are made for alignment with the ISO POSIX-1:1996 standard:
The wording describing the optional dependency on _POSIX_CHOWN_RESTRICTED is restored.
The [EPERM] error is restored as an error dependent on _POSIX_CHOWN_RESTRICTED. This is since its operand is a pathname and
applications should be aware that the error may not occur for that pathname if the file system does not support
_POSIX_CHOWN_RESTRICTED.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The requirement to include  has been removed. Although
was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.
The value for owner of (uid_t)-1 allows the use of -1 by the owner of a file to change the group ID only. A
corresponding change is made for group.
The [ELOOP] mandatory error condition is added.
The [EIO] and [EINTR] optional error conditions are added.
A second [ENAMETOOLONG] is added as an optional error condition.
The following changes were made to align with the IEEE P1003.1a draft standard:
Clarification is added that the S_ISUID and S_ISGID bits do not need to be cleared when the process has appropriate
privileges.
The [ELOOP] optional error condition is added.
Issue 7
Austin Group Interpretation 1003.1-2001 #143 is applied.
The fchownat() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 2.
Changes are made related to support for finegrained timestamps.
Changes are made to allow a directory to be opened for searching.
The [ENOTDIR] error condition is clarified to cover the condition where the last component of a pathname exists but is not a
directory or a symbolic link to a directory.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0053 [461], XSH/TC1-2008/0054 [324], XSH/TC1-2008/0055 [278], and
XSH/TC1-2008/0056 [278] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0062 [873], XSH/TC2-2008/0063 [591], XSH/TC2-2008/0064 [485],
XSH/TC2-2008/0065 [817], and XSH/TC2-2008/0066 [817] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/atanf.html =====
atan
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
atan, atanf, atanl — arc tangent function
SYNOPSIS
#include
double atan(double x);
float atanf(float x);
long double atanl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the principal value of the arc tangent of their argument x.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the arc tangent of x in the range [-ℼ/2,ℼ/2] radians.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0, x shall be returned.
If x is ±Inf, ±ℼ/2 shall be returned.
[MXX]
If x is subnormal, x should be returned.
[MX]  If x is subnormal, a range error may occur and, if x is
not returned, atan(), atanf(), and atanl() shall return an implementation-defined value no greater in
magnitude than DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
ERRORS
These functions may fail if:
Range Error
[MX]
The value of x is subnormal.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
atan2(), feclearexcept(),
fetestexcept(), isnan(),
tan()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The atanf() and atanl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0037 [68] is applied.
Issue 8
Austin Group Defect 1382 is applied, rearranging the text describing the behavior when x is subnormal to avoid the need
for two shading changes.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_cond_wait.html =====
pthread_cond_clockwait
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_cond_clockwait, pthread_cond_timedwait, pthread_cond_wait — wait on a condition
SYNOPSIS
#include
int pthread_cond_clockwait(pthread_cond_t *restrict cond,
pthread_mutex_t *restrict mutex, clockid_t clock_id,
const struct timespec *restrict abstime);
int pthread_cond_timedwait(pthread_cond_t *restrict cond,
pthread_mutex_t *restrict mutex,
const struct timespec *restrict abstime);
int pthread_cond_wait(pthread_cond_t *restrict cond,
pthread_mutex_t *restrict mutex);
DESCRIPTION
The pthread_cond_clockwait(), pthread_cond_timedwait(), and pthread_cond_wait() functions shall block on a
condition variable. The application shall ensure that these functions are called with mutex locked by the calling thread;
otherwise, an error (for PTHREAD_MUTEX_ERRORCHECK and robust mutexes) or undefined behavior (for other mutexes) results.
These functions atomically release mutex and cause the calling thread to block on the condition variable cond;
atomically here means "atomically with respect to access by another thread to the mutex and then the condition variable". That
is, if another thread is able to acquire the mutex after the about-to-block thread has released it, then a subsequent call to
pthread_cond_broadcast() or pthread_cond_signal() in that thread shall behave as if it were issued after the
about-to-block thread has blocked.
Upon successful return, the mutex shall have been locked and shall be owned by the calling thread.
If mutex is a robust mutex where an owner terminated while holding the lock and the state is recoverable, the mutex shall
be acquired even though the function returns [EOWNERDEAD].
When using condition variables there is always a Boolean predicate involving shared variables associated with each condition
wait that is true if the thread should proceed. Spurious wakeups from the pthread_cond_clockwait(),
pthread_cond_timedwait(), or pthread_cond_wait() functions may occur. Since the return from
pthread_cond_clockwait(), pthread_cond_timedwait(), or pthread_cond_wait() does not imply anything about the
value of this predicate, the predicate should be re-evaluated upon such return.
When a thread waits on a condition variable, having specified a particular mutex to the pthread_cond_clockwait(),
pthread_cond_timedwait(), or pthread_cond_wait() operation, a dynamic binding is formed between that mutex and
condition variable that remains in effect as long as at least one thread is blocked on the condition variable. During this time,
the effect of an attempt by any thread to wait on that condition variable using a different mutex is undefined. Once all waiting
threads have been unblocked (as by the pthread_cond_broadcast()
operation), the next wait operation on that condition variable shall form a new dynamic binding with the mutex specified by that
wait operation. Even though the dynamic binding between condition variable and mutex may be removed or replaced between the time a
thread is unblocked from a wait on the condition variable and the time that it returns to the caller or begins cancellation
cleanup, the unblocked thread shall always re-acquire the mutex specified in the condition wait operation call from which it is
returning.
A condition wait (whether timed or not) is a cancellation point. When the cancelability type of a thread is set to
PTHREAD_CANCEL_DEFERRED, a side-effect of acting upon a cancellation request while in a condition wait is that the mutex is (in
effect) re-acquired before calling the first cancellation cleanup handler. The effect is as if the thread were unblocked, allowed
to execute up to the point of returning from the call to pthread_cond_clockwait(), pthread_cond_timedwait(), or
pthread_cond_wait(), but at that point notices the cancellation request and, instead of returning to the caller, starts the
thread cancellation activities, which includes calling cancellation cleanup handlers.
A thread that has been unblocked because it has been canceled while blocked in a call to pthread_cond_clockwait(),
pthread_cond_timedwait(), or pthread_cond_wait() shall not consume any condition signal that may be directed
concurrently at the condition variable if there are other threads blocked on the condition variable.
The pthread_cond_clockwait() function shall be equivalent to pthread_cond_wait(), except that an error is returned
if the absolute time specified by abstime as measured against the clock indicated by clock_id passes (that is, the
current time measured by that clock equals or exceeds abstime) before the condition cond is signaled or broadcasted,
or if the absolute time specified by abstime has already been passed at the time of the call. Implementations shall support
passing CLOCK_REALTIME and CLOCK_MONOTONIC to pthread_cond_clockwait() as the clock_id argument. When such timeouts
occur, pthread_cond_clockwait() shall nonetheless release and re-acquire the mutex referenced by mutex, and may
consume a condition signal directed concurrently at the condition variable.
The pthread_cond_timedwait() function shall be equivalent to pthread_cond_clockwait(), except that it lacks the
clock_id argument. The clock to measure abstime against shall instead come from the condition variable's clock
attribute which can be set by pthread_condattr_setclock() prior to
the condition variable's creation. If no clock attribute has been set, the default shall be CLOCK_REALTIME.
If a signal is delivered to a thread waiting for a condition variable, upon return from the signal handler the thread resumes
waiting for the condition variable as if it was not interrupted, or it shall return zero due to spurious wakeup.
The behavior is undefined if the value specified by the cond or mutex argument to these functions does not refer
to an initialized condition variable or an initialized mutex object, respectively.
RETURN VALUE
Except for [ETIMEDOUT], [ENOTRECOVERABLE], and [EOWNERDEAD], all these error checks shall act as if they were performed
immediately at the beginning of processing for the function and shall cause an error return, in effect, prior to modifying the
state of the mutex specified by mutex or the condition variable specified by cond.
Upon successful completion, a value of zero shall be returned; otherwise, an error number shall be returned to indicate the
error.
ERRORS
These functions shall fail if:
[EAGAIN]
The mutex is a robust mutex and the system resources available for robust mutexes owned would be exceeded.
[ENOTRECOVERABLE]
The state protected by the mutex is not recoverable.
[EOWNERDEAD]
The mutex is a robust mutex and the process containing the previous owning thread terminated while holding the mutex lock. The
mutex lock shall be acquired by the calling thread and it is up to the new owner to make the state consistent.
[EPERM]
The mutex type is PTHREAD_MUTEX_ERRORCHECK or the mutex is a robust mutex, and the current thread does not own the mutex.
The pthread_cond_clockwait() and pthread_cond_timedwait() functions shall fail if:
[ETIMEDOUT]
The time specified by abstime has passed.
[EINVAL]
The abstime argument specified a nanosecond value less than zero or greater than or equal to 1000 million, or the
clock_id argument passed to pthread_cond_clockwait() is invalid or not supported.
These functions may fail if:
[EOWNERDEAD]
The mutex is a robust mutex and the previous owning thread terminated while holding the mutex lock. The mutex lock shall be
acquired by the calling thread and it is up to the new owner to make the state consistent.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Applications that have assumed that non-zero return values are errors will need updating for use with robust mutexes, since a
valid return for a thread acquiring a mutex which is protecting a currently inconsistent state is [EOWNERDEAD]. Applications that
do not check the error returns, due to ruling out the possibility of such errors arising, should not use robust mutexes. If an
application is supposed to work with normal and robust mutexes, it should check all return values for error conditions and if
necessary take appropriate action.
RATIONALE
If an implementation detects that the value specified by the cond argument to pthread_cond_clockwait(),
pthread_cond_timedwait(), or pthread_cond_wait() does not refer to an initialized condition variable, or detects that
the value specified by the mutex argument does not refer to an initialized mutex object, it is recommended that the function
should fail and report an [EINVAL] error.
Condition Wait Semantics
It is important to note that when pthread_cond_clockwait(), pthread_cond_timedwait(), and
pthread_cond_wait() return without error, the associated predicate may still be false. Similarly, when
pthread_cond_clockwait() or pthread_cond_timedwait() returns with the timeout error, the associated predicate may be
true due to an unavoidable race between the expiration of the timeout and the predicate state change.
The application needs to recheck the predicate on any return because it cannot be sure there is another thread waiting on the
thread to handle the signal, and if there is not then the signal is lost. The burden is on the application to check the
predicate.
Some implementations, particularly on a multi-processor, may sometimes cause multiple threads to wake up when the condition
variable is signaled simultaneously on different processors.
In general, whenever a condition wait returns, the thread has to re-evaluate the predicate associated with the condition wait to
determine whether it can safely proceed, should wait again, or should declare a timeout. A return from the wait does not imply that
the associated predicate is either true or false.
It is thus recommended that a condition wait be enclosed in the equivalent of a "while loop" that checks the predicate.
Timed Wait Semantics
An absolute time measure was chosen for specifying the timeout parameter for two reasons. First, a relative time measure can be
easily implemented on top of a function that specifies absolute time, but there is a race condition associated with specifying an
absolute timeout on top of a function that specifies relative timeouts. For example, assume that clock_gettime() returns the current time and cond_relative_timed_wait() uses
relative timeouts:
clock_gettime(CLOCK_REALTIME, &now)
reltime = sleep_til_this_absolute_time -now;
cond_relative_timed_wait(c, m, &reltime);
If the thread is preempted between the first statement and the last statement, the thread blocks for too long. Blocking,
however, is irrelevant if an absolute timeout is used. An absolute timeout also need not be recomputed if it is used multiple times
in a loop, such as that enclosing a condition wait.
For cases when the system clock is advanced discontinuously by an operator, it is expected that implementations process any
timed wait expiring at an intervening time as if that time had actually occurred.
Choice of Clock
Care should be taken to decide which clock is most appropriate when waiting with a timeout. The system clock CLOCK_REALTIME, as
used by default with pthread_cond_timedwait(), may be subject to jumps forwards and backwards in order to correct it against
actual time. CLOCK_MONOTONIC is guaranteed not to jump backwards and must also advance in real time, so using it via
pthread_cond_clockwait() or pthread_condattr_setclock() may
be more appropriate.
Cancellation and Condition Wait
A condition wait, whether timed or not, is a cancellation point. That is, the functions pthread_cond_clockwait(),
pthread_cond_timedwait(), and pthread_cond_wait() are points where a pending (or concurrent) cancellation request is
noticed. The reason for this is that an indefinite wait is possible at these points—whatever event is being waited for, even if the
program is totally correct, might never occur; for example, some input data being awaited might never be sent. By making condition
wait a cancellation point, the thread can be canceled and perform its cancellation cleanup handler even though it may be stuck in
some indefinite wait.
A side-effect of acting on a cancellation request while a thread is blocked on a condition variable is to re-acquire the mutex
before calling any of the cancellation cleanup handlers. This is done in order to ensure that the cancellation cleanup handler is
executed in the same state as the critical code that lies both before and after the call to the condition wait function. This rule
is also required when interfacing to POSIX threads from languages, such as Ada or C++, which may choose to map cancellation onto a
language exception; this rule ensures that each exception handler guarding a critical section can always safely depend upon the
fact that the associated mutex has already been locked regardless of exactly where within the critical section the exception was
raised. Without this rule, there would not be a uniform rule that exception handlers could follow regarding the lock, and so coding
would become very cumbersome.
Therefore, since some statement has to be made regarding the state of the lock when a cancellation is delivered during a
wait, a definition has been chosen that makes application coding most convenient and error free.
When acting on a cancellation request while a thread is blocked on a condition variable, the implementation is required to
ensure that the thread does not consume any condition signals directed at that condition variable if there are any other threads
waiting on that condition variable. This rule is specified in order to avoid deadlock conditions that could occur if these two
independent requests (one acting on a thread and the other acting on the condition variable) were not processed independently.
Performance of Mutexes and Condition Variables
Mutexes are expected to be locked only for a few instructions. This practice is almost automatically enforced by the desire of
programmers to avoid long serial regions of execution (which would reduce total effective parallelism).
When using mutexes and condition variables, one tries to ensure that the usual case is to lock the mutex, access shared data,
and unlock the mutex. Waiting on a condition variable should be a relatively rare situation. For example, when implementing a
read-write lock, code that acquires a read-lock typically needs only to increment the count of readers (under mutual-exclusion) and
return. The calling thread would actually wait on the condition variable only when there is already an active writer. So the
efficiency of a synchronization operation is bounded by the cost of mutex lock/unlock and not by condition wait. Note that in the
usual case there is no context switch.
This is not to say that the efficiency of condition waiting is unimportant. Since there needs to be at least one context switch
per Ada rendezvous, the efficiency of waiting on a condition variable is important. The cost of waiting on a condition variable
should be little more than the minimal cost for a context switch plus the time to unlock and lock the mutex.
Features of Mutexes and Condition Variables
It had been suggested that the mutex acquisition and release be decoupled from condition wait. This was rejected because it is
the combined nature of the operation that, in fact, facilitates realtime implementations. Those implementations can atomically move
a high-priority thread between the condition variable and the mutex in a manner that is transparent to the caller. This can prevent
extra context switches and provide more deterministic acquisition of a mutex when the waiting thread is signaled. Thus, fairness
and priority issues can be dealt with directly by the scheduling discipline. Furthermore, the current condition wait operation
matches existing practice.
Scheduling Behavior of Mutexes and Condition Variables
Synchronization primitives that attempt to interfere with scheduling policy by specifying an ordering rule are considered
undesirable. Threads waiting on mutexes and condition variables are selected to proceed in an order dependent upon the scheduling
policy rather than in some fixed order (for example, FIFO or priority). Thus, the scheduling policy determines which thread(s) are
awakened and allowed to proceed.
Timed Condition Wait
The pthread_cond_clockwait() and pthread_cond_timedwait() functions allow an application to give up waiting for a
particular condition after a given amount of time. An example follows:
(void) pthread_mutex_lock(&t.mn);
t.waiters++;
clock_gettime(CLOCK_MONOTONIC, &ts);
ts.tv_sec += 5;
rc = 0;
while (! mypredicate(&t) && rc == 0)
rc = pthread_cond_clockwait(&t.cond, &t.mn,
CLOCK_MONOTONIC, &ts);
t.waiters--;
if (rc == 0 || mypredicate(&t))
setmystate(&t);
(void) pthread_mutex_unlock(&t.mn);
By making the timeout parameter absolute, it does not need to be recomputed each time the program checks its blocking predicate.
If the timeout was relative, it would have to be recomputed before each call. This would be especially difficult since such code
would need to take into account the possibility of extra wakeups that result from extra broadcasts or signals on the condition
variable that occur before either the predicate is true or the timeout is due. Using CLOCK_MONOTONIC rather than CLOCK_REALTIME
means that the timeout is not influenced by the system clock being changed.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_cond_broadcast()
XBD 4.15.2 Memory Synchronization,
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
The pthread_cond_timedwait() and pthread_cond_wait() functions are marked as part of the Threads option.
The Open Group Corrigendum U021/9 is applied, correcting the prototype for the pthread_cond_wait() function.
The DESCRIPTION is updated for alignment with IEEE Std 1003.1j-2000 by adding semantics for the Clock Selection
option.
The ERRORS section has an additional case for [EPERM] in response to IEEE PASC Interpretation 1003.1c #28.
The restrict keyword is added to the pthread_cond_timedwait() and pthread_cond_wait() prototypes for
alignment with the ISO/IEC 9899:1999 standard.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/89 is applied, updating the DESCRIPTION for consistency with the
pthread_cond_destroy() function that states it is safe to destroy an
initialized condition variable upon which no threads are currently blocked.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/90 is applied, updating words in the DESCRIPTION from "the
cancelability enable state" to "the cancelability type".
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/91 is applied, updating the ERRORS section to remove the error
case related to abstime from the pthread_cond_wait() function, and to make the error case related to abstime
mandatory for pthread_cond_timedwait() for consistency with other functions.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/92 is applied, adding a new paragraph to the RATIONALE section
stating that an application should check the predicate on any return from this function.
Issue 7
SD5-XSH-ERN-44 is applied, changing the definition of the "shall fail" case of the [EINVAL] error.
Changes are made from The Open Group Technical Standard, 2006, Extended API Set Part 3.
The pthread_cond_timedwait() and pthread_cond_wait() functions are moved from the Threads option to the Base.
The [EINVAL] error for an uninitialized condition variable or uninitialized mutex object is removed; this condition results in
undefined behavior"
The [EPERM] error is revised and moved to the "shall fail" list of error conditions for the pthread_cond_timedwait()
function.
The DESCRIPTION is updated to clarify the behavior when mutex is a robust mutex.
The ERRORS section is updated to include "shall fail" cases for PTHREAD_MUTEX_ERRORCHECK mutexes.
The DESCRIPTION is rewritten to clarify that undefined behavior occurs only for mutexes where the [EPERM] error is not
mandated.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0456 [91,286,437] and XSH/TC1-2008/0457 [239] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0271 [749] is applied.
Issue 8
Austin Group Defect 354 is applied, adding the [EAGAIN] error.
Austin Group Defect 1162 is applied, changing "an error code" to "[EOWNERDEAD]".
Austin Group Defects 1216 and 1485 are applied, adding pthread_cond_clockwait().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/drand48.html =====
drand48
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
drand48, erand48, jrand48, lcong48, lrand48, mrand48, nrand48, seed48, srand48 — generate uniformly distributed
pseudo-random numbers
SYNOPSIS
[XSI]  #include
double drand48(void);
double erand48(unsigned short xsubi[3]);
long jrand48(unsigned short xsubi[3]);
void lcong48(unsigned short param[7]);
long lrand48(void);
long mrand48(void);
long nrand48(unsigned short xsubi[3]);
unsigned short *seed48(unsigned short seed16v[3]);
void srand48(long seedval);
DESCRIPTION
This family of functions shall generate pseudo-random numbers using a linear congruential algorithm and 48-bit integer
arithmetic.
The drand48() and erand48() functions shall return non-negative, double-precision, floating-point values,
uniformly distributed over the interval [0.0,1.0).
The lrand48() and nrand48() functions shall return non-negative, long integers, uniformly distributed over the
interval [0,231).
The mrand48() and jrand48() functions shall return signed long integers uniformly distributed over the interval
[-231,231).
The srand48(), seed48(), and lcong48() functions are initialization entry points, one of which should be
invoked before either drand48(), lrand48(), or mrand48() is called. (Although it is not recommended practice,
constant default initializer values shall be supplied automatically if drand48(), lrand48(), or mrand48() is
called without a prior call to an initialization entry point.) The erand48(), nrand48(), and jrand48()
functions do not require an initialization entry point to be called first.
All the routines work by generating a sequence of 48-bit integer values,
\(X_{i}\),
according to the linear congruential formula:
\(X_{n+1}=\left(a X_n+c\right)_{\bmod m} \quad n \geq 0\)
The parameter m=248; hence 48-bit integer arithmetic is performed. Unless lcong48() is invoked, the multiplier
value a and the addend value c are given by:
\(
\begin{aligned}
& a= \text { 5DEECE66D }_{16}=273673163155_8 \\
& c=\mathrm{B}_{16}=13_8
\end{aligned}
\)
The value returned by any of the drand48(), erand48(), jrand48(), lrand48(), mrand48(), or
nrand48() functions is computed by first generating the next 48-bit \(X_{i}\) in the sequence. \(X_{i}\) is then converted
to the return value as follows:
For drand48() and erand48() the value shall be 2-48 times \(X_{i}\).
For jrand48() and mrand48() the value shall be the largest integer not greater than 2-16 times \(X_{i}\).
For lrand48() and nrand48() the value shall be the largest integer not greater than 2-17 times \(X_{i}\).
The drand48(), lrand48(), and mrand48() functions store the last 48-bit \(X_{i}\) generated in an internal
buffer; that is why the application shall ensure that these are initialized prior to being invoked. The erand48(),
nrand48(), and jrand48() functions require the calling program to provide storage for the successive \(X_{i}\) values
in the array specified as an argument when the functions are invoked. That is why these routines do not have to be initialized; the
calling program merely has to place the desired initial value of \(X_{i}\) into the array and pass it as an argument. By using
different arguments, erand48(), nrand48(), and jrand48() allow separate modules of a large program to generate
several independent streams of pseudo-random numbers; that is, the sequence of numbers in each stream shall not
depend upon how many times the routines are called to generate numbers for the other streams.
The initializer function srand48() sets the high-order 32 bits of \(X_{i}\) to the low-order 32 bits contained in its
argument. The low-order 16 bits of \(X_{i}\) are set to the arbitrary value 330E16.
The initializer function seed48() sets the value of \(X_{i}\) to the 48-bit value specified in the argument array. The
low-order 16 bits of \(X_{i}\) are set to the low-order 16 bits of seed16v[0]. The mid-order 16 bits of \(X_{i}\) are
set to the low-order 16 bits of seed16v[1]. The high-order 16 bits of \(X_{i}\) are set to the low-order 16 bits of
seed16v[2]. In addition, the previous value of \(X_{i}\) is copied into a 48-bit internal buffer, used only by
seed48(), and a pointer to this buffer is the value returned by seed48(). This returned pointer, which can just be
ignored if not needed, is useful if a program is to be restarted from a given point at some future time—use the pointer to get at
and store the last \(X_{i}\) value, and then use this value to reinitialize via seed48() when the program is restarted.
The initializer function lcong48() allows the user to specify the initial \(X_{i}\), the multiplier value a, and the
addend value c. Argument array elements param[0-2] specify \(X_{i}\), param[3-5] specify the
multiplier a, and param[6] specifies the 16-bit addend c. After lcong48() is called, a subsequent call to
either srand48() or seed48() shall restore the standard multiplier and addend values, a and c,
specified above.
The drand48(), lrand48(), and mrand48() functions need not be thread-safe.
RETURN VALUE
As described in the DESCRIPTION above.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
The following program tests that the required pseudo-random number generator is used by these functions.
#include
#include
int main() {
{
unsigned short xsubi[3] = {37174, 64810, 11603};
double d = erand48(xsubi);
assert(d >= 0.896);
assert(d = 0.337);
assert(d = 0.647);
assert(d = 0.500);
assert(d = 0.506);
assert(d
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
A note indicating that the drand48(), lrand48(), and mrand48() functions need not be reentrant is added to
the DESCRIPTION.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0083 [743] is applied.
Issue 8
Austin Group Defect 1107 is applied, clarifying how the return value is calculated from  \(X_{i}\) for each function.
Austin Group Defect 1134 is applied, adding getentropy().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fwscanf.html =====
fwscanf
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fwscanf, swscanf, wscanf — convert formatted wide-character input
SYNOPSIS
#include
#include
int fwscanf(FILE *restrict stream, const wchar_t *restrict format, ...);
int swscanf(const wchar_t *restrict ws,
const wchar_t *restrict format, ...);
int wscanf(const wchar_t *restrict format, ...);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The fwscanf() function shall read from the named input stream. The wscanf() function shall read from the
standard input stream stdin. The swscanf() function shall read from the wide-character string ws. Each
function reads wide characters, interprets them according to a format, and stores the results in its arguments. Each expects, as
arguments, a control wide-character string format described below, and a set of pointer arguments indicating where
the converted input should be stored. The result is undefined if there are insufficient arguments for the format. If the
format is exhausted while arguments remain, the excess arguments are evaluated but are otherwise ignored.
[CX]
Conversions can be applied to the nth argument after the format in the argument list, rather than to the next unused
argument. In this case, the conversion specifier wide character % (see below) is replaced by the sequence "%n$",
where n is a decimal integer in the range [1,{NL_ARGMAX}]. This feature provides for the definition of format
wide-character strings that select arguments in an order appropriate to specific languages. In format wide-character strings
containing the "%n$" form of conversion specifications, it is unspecified whether numbered arguments in
the argument list can be referenced from the format wide-character string more than once.
The format can contain either form of a conversion specification—that is, % or "%n$"—
but the two forms cannot normally be mixed within a single format wide-character string. The only exception to this is that
%% or %* can be mixed with the "%n$" form. When numbered argument specifications are
used, specifying the Nth argument requires that all the leading arguments, from the first to the (N-1)th, are
pointers.
The fwscanf() function in all its forms allows for detection of a language-dependent radix character in the input string,
encoded as a wide-character value. The radix character is defined in the current locale (category LC_NUMERIC ). In the POSIX
locale, or in a locale where the radix character is not defined, the radix character shall default to a
('.').
The format is a wide-character string composed of zero or more directives. Each directive is composed of one of the
following: one or more white-space wide characters; an ordinary wide character (neither '%' nor a white-space wide
character); or a conversion specification. It is unspecified whether an encoding error occurs if the format string contains
wchar_t values that do not correspond to members of the character set of the current locale and the specified semantics do
not require that value to be processed by wcrtomb().
Each conversion specification is introduced by the '%' [CX]
or by the character sequence
"%n$",   after which the following
appear in sequence:
An optional assignment-suppressing character '*'.
An optional non-zero decimal integer that specifies the maximum field width.
[CX]  An
optional assignment-allocation character 'm'.
An optional length modifier that specifies the size of the receiving object.
A conversion specifier wide character that specifies the type of conversion to be applied. The valid conversion specifiers are
described below.
The fwscanf() functions shall execute each directive of the format in turn. When all directives have been executed, or if
a directive fails (as detailed below), the function shall return. Failures are described as input failures (due to the
unavailability of input bytes) or matching failures (due to inappropriate input).
A directive composed of one or more white-space wide characters shall be executed by reading input up to the first wide
character that is not a white-space wide character, which shall remain unread, or until no more wide characters can be read. The
directive shall never fail.
A directive that is an ordinary wide character shall be executed as follows. The next wide character is read from the input and
compared with the wide character that comprises the directive; if the comparison shows that they are not equivalent, the directive
shall fail, and the differing and subsequent wide characters remain unread. Similarly, if end-of-file, an encoding error, or a read
error prevents a wide character from being read, the directive shall fail.
A directive that is a conversion specification defines a set of matching input sequences, as described below for each conversion
wide character. A conversion specification is executed in the following steps.
Input white-space wide characters shall be skipped, unless the conversion specification includes a [, c, or
n conversion specifier.
An item shall be read from the input, unless the conversion specification includes an n conversion specifier wide
character. An input item is defined as the longest sequence of input wide characters, not exceeding any specified field width,
which is an initial subsequence of a matching sequence. The first wide character, if any, after the input item shall remain unread.
If the length of the input item is zero, the execution of the conversion specification shall fail; this condition is a matching
failure, unless end-of-file, an encoding error, or a read error prevented input from the stream, in which case it is an input
failure.
Except in the case of a % conversion specifier, the input item (or, in the case of a %n conversion
specification, the count of input wide characters) shall be converted to a type appropriate to the conversion wide character. If
the input item is not a matching sequence, the execution of the conversion specification shall fail; this condition is a matching
failure. Unless assignment suppression was indicated by a '*', the result of the conversion shall be placed in the object
pointed to by the first argument following the format argument that has not already received a conversion result if the
conversion specification is introduced by %, [CX]   or in the nth argument if introduced by the wide-character
sequence "%n$".   If this object does
not have an appropriate type, or if the result of the conversion cannot be represented in the space provided, the behavior is
undefined.
[CX]  The
c, s, and [ conversion specifiers shall accept an optional assignment-allocation character 'm',
which shall cause a memory buffer to be allocated to hold the conversion results. If the conversion specifier is s or
[, the allocated buffer shall include space for a terminating null character (or wide character). In such a case, the
argument corresponding to the conversion specifier should be a reference to a pointer value that will receive a pointer to the
allocated buffer. The system shall allocate a buffer as if malloc() had been called.
The application shall be responsible for freeing the memory after usage. If there is insufficient memory to allocate a buffer, the
function shall set errno to [ENOMEM] and a conversion error shall result. If the function returns EOF, any memory
successfully allocated for parameters using assignment-allocation character 'm' by this call shall be freed before the
function returns.
The length modifiers and their meanings are:
hh
Specifies that a following d, i, o, u, x, X, or n conversion
specifier applies to an argument with type pointer to signed char or unsigned char.
h
Specifies that a following d, i, o, u, x, X, or n conversion
specifier applies to an argument with type pointer to short or unsigned short.
l (ell)
Specifies that a following d, i, o, u, x, X, or n conversion
specifier applies to an argument with type pointer to long or unsigned long; that a following a, A,
e, E, f, F, g, or G conversion specifier applies to an argument with type
pointer to double; or that a following c, s, or [ conversion specifier applies to an argument
with type pointer to wchar_t. [CX]   If the 'm' assignment-allocation character is specified, the conversion applies to
an argument with the type pointer to a pointer to wchar_t.
ll (ell-ell)
Specifies that a following d, i, o, u, x, X, or n conversion
specifier applies to an argument with type pointer to long long or unsigned long long.
j
Specifies that a following d, i, o, u, x, X, or n conversion
specifier applies to an argument with type pointer to intmax_t or uintmax_t.
z
Specifies that a following d, i, o, u, x, X, or n conversion
specifier applies to an argument with type pointer to size_t or the corresponding signed integer type.
t
Specifies that a following d, i, o, u, x, X, or n conversion
specifier applies to an argument with type pointer to ptrdiff_t or the corresponding unsigned type.
L
Specifies that a following a, A, e, E, f, F, g, or G
conversion specifier applies to an argument with type pointer to long double.
If a length modifier appears with any conversion specifier other than as specified above, the behavior is undefined.
The following conversion specifier wide characters are valid:
d
Matches an optionally signed decimal integer, whose format is the same as expected for the subject sequence of wcstol() with the value 10 for the base argument. In the absence of a size modifier,
the application shall ensure that the corresponding argument is a pointer to int.
i
Matches an optionally signed integer, whose format is the same as expected for the subject sequence of wcstol() with 0 for the base argument. In the absence of a size modifier, the
application shall ensure that the corresponding argument is a pointer to int.
o
Matches an optionally signed octal integer, whose format is the same as expected for the subject sequence of wcstoul() with the value 8 for the base argument. In the absence of a size modifier,
the application shall ensure that the corresponding argument is a pointer to unsigned.
u
Matches an optionally signed decimal integer, whose format is the same as expected for the subject sequence of wcstoul() with the value 10 for the base argument. In the absence of a size modifier,
the application shall ensure that the corresponding argument is a pointer to unsigned.
x
Matches an optionally signed hexadecimal integer, whose format is the same as expected for the subject sequence of wcstoul() with the value 16 for the base argument. In the absence of a size modifier,
the application shall ensure that the corresponding argument is a pointer to unsigned.
a, e, f, g
Matches an optionally signed floating-point number, infinity, or NaN whose format is the same as expected for the subject sequence
of wcstod(). In the absence of a size modifier, the application shall ensure that the
corresponding argument is a pointer to float.
If the fwprintf() family of functions generates character string representations
for infinity and NaN (a symbolic entity encoded in floating-point format) to support IEEE Std 754-1985, the
fwscanf() family of functions shall recognize them as input.
s
Matches a sequence of non-white-space wide characters. If no l (ell) qualifier is present, characters from the input
field shall be converted as if by repeated calls to the wcrtomb() function, with the
conversion state described by an mbstate_t object initialized to zero before the first wide character is converted. If the
'm' assignment-allocation character is not specified, the application shall ensure that the corresponding argument is a
pointer to a character array large enough to accept the sequence and the terminating null character, which shall be added
automatically. [CX]   Otherwise, the application shall ensure that the corresponding argument is a pointer to a pointer to a
char.
If the l (ell) qualifier is present and the 'm' assignment-allocation character is not specified, the
application shall ensure that the corresponding argument is a pointer to an array of wchar_t large enough to accept the
sequence and the terminating null wide character, which shall be added automatically. [CX]   If the
l (ell) qualifier is present and the 'm' assignment-allocation character is present, the application shall ensure
that the corresponding argument is a pointer to a pointer to a wchar_t.
[
Matches a non-empty sequence of wide characters from a set of expected wide characters (the scanset). If no l
(ell) qualifier is present, wide characters from the input field shall be converted as if by repeated calls to the wcrtomb() function, with the conversion state described by an mbstate_t object
initialized to zero before the first wide character is converted. If the 'm' assignment-allocation character is not
specified, the application shall ensure that the corresponding argument is a pointer to a character array large enough to accept
the sequence and the terminating null character, which shall be added automatically. [CX]   Otherwise, the
application shall ensure that the corresponding argument is a pointer to a pointer to a char.
If an l (ell) qualifier is present and the 'm' assignment-allocation character is not specified, the
application shall ensure that the corresponding argument is a pointer to an array of wchar_t large enough to accept the
sequence and the terminating null wide character. [CX]   If an l (ell) qualifier is present and the 'm'
assignment-allocation character is specified, the application shall ensure that the corresponding argument is a pointer to a
pointer to a wchar_t.
The conversion specification includes all subsequent wide characters in the format string up to and including the
matching  (']'). The wide characters between the square brackets (the scanlist)
comprise the scanset, unless the wide character after the  is a  ('^'), in
which case the scanset contains all wide characters that do not appear in the scanlist between the  and the
. If the conversion specification begins with "[]" or "[^]", the
is included in the scanlist and the next  is the matching
that ends the conversion specification; otherwise, the first  is the one
that ends the conversion specification. If a '-' is in the scanlist and is not the first wide character, nor the second
where the first wide character is a '^', nor the last wide character, the behavior is implementation-defined.
c
Matches a sequence of wide characters of exactly the number specified by the field width (1 if no field width is present in the
conversion specification).
If no l (ell) length modifier is present, characters from the input field shall be converted as if by repeated calls to
the wcrtomb() function, with the conversion state described by an mbstate_t
object initialized to zero before the first wide character is converted. No null character is added. If the 'm'
assignment-allocation character is not specified, the application shall ensure that the corresponding argument is a pointer to the
initial element of a character array large enough to accept the sequence. [CX]
Otherwise, the application shall ensure that the
corresponding argument is a pointer to a pointer to a char.
No null wide character is added. If an l (ell) length modifier is present and the 'm' assignment-allocation
character is not specified, the application shall ensure that the corresponding argument shall be a pointer to the initial element
of an array of wchar_t large enough to accept the sequence. [CX]
If an l (ell) qualifier is present and the
'm' assignment-allocation character is specified, the application shall ensure that the corresponding argument is a
pointer to a pointer to a wchar_t.
p
Matches an implementation-defined set of sequences, which shall be the same as the set of sequences that is produced by the
%p conversion specification of the corresponding fwprintf() functions. The
application shall ensure that the corresponding argument is a pointer to a pointer to void. The interpretation of the input
item is implementation-defined. If the input item is a value converted earlier during the same program execution, the pointer that
results shall compare equal to that value; otherwise, the behavior of the %p conversion is undefined.
n
No input is consumed. The application shall ensure that the corresponding argument is a pointer to the integer into which is to
be written the number of wide characters read from the input so far by this call to the fwscanf() functions. Execution of a
%n conversion specification shall not increment the assignment count returned at the completion of execution of the
function. No argument shall be converted, but one shall be consumed. If the conversion specification includes an
assignment-suppressing wide character or a field width, the behavior is undefined.
C
[XSI]
Equivalent to lc.
S
[XSI]
Equivalent to ls.
%
Matches a single '%' wide character; no conversion or assignment shall occur. The complete conversion specification
shall be %%.
If a conversion specification is invalid, the behavior is undefined.
The conversion specifiers A, E, F, G, and X are also valid and shall be equivalent
to, respectively, a, e, f, g, and x.
If end-of-file is encountered during input, conversion is terminated. If end-of-file occurs before any wide characters matching
the current conversion specification (except for %n) have been read (other than leading white-space wide characters, where
permitted), execution of the current conversion specification shall terminate with an input failure. Otherwise, unless execution of
the current conversion specification is terminated with a matching failure, execution of the following conversion specification (if
any) shall be terminated with an input failure.
Reaching the end of the string in swscanf() shall be equivalent to encountering end-of-file for fwscanf().
If conversion terminates on a conflicting input, the offending input shall be left unread in the input. Any trailing white-space
wide characters (including ) shall be left unread unless matched by a conversion specification. The success of
literal matches and suppressed assignments is only directly determinable via the %n conversion specification.
[CX]  The
fwscanf() and wscanf() functions may mark the last data access timestamp of the file associated with stream
for update. The last data access timestamp shall be marked for update by the first successful execution of fgetwc(), fgetws(), fwscanf(), getwc(), getwchar(), vfwscanf(), vwscanf(), or wscanf()
using stream that returns data not supplied by a prior call to ungetwc().
RETURN VALUE
Upon successful completion, these functions shall return the number of successfully matched and assigned input items; this
number can be zero in the event of an early matching failure. If the input ends before the first conversion (if any) has completed,
and without a matching failure having occurred, EOF shall be returned. If an error occurs before the first conversion (if any) has
completed, and without a matching failure having occurred, EOF shall be returned [CX]   and
errno shall be set to indicate the error.   If a read
error occurs, the error indicator for the stream shall be set.
ERRORS
For the conditions under which the fwscanf() functions shall fail and may fail, refer to fgetwc().
In addition, the fwscanf() function shall fail if:
[EILSEQ]
[CX]
Input byte sequence does not form a valid character.
[ENOMEM]
Insufficient storage space is available.
In addition, the fwscanf() function may fail if:
[EINVAL]
[CX]
There are insufficient arguments.
The following sections are informative.
EXAMPLES
The call:
int i, n; float x; char name[50];
n = wscanf(L"%d%f%s", &i, &x, name);
with the input line:
25 54.32E-1 Hamster
assigns to n the value 3, to i the value 25, to x the value 5.432, and name contains the string
"Hamster".
The call:
int i; float x; char name[50];
(void) wscanf(L"%2d%f%*d %[0123456789]", &i, &x, name);
with input:
56789 0123 56a72
assigns 56 to i, 789.0 to x, skips 0123, and places the string "56\0" in name. The next call to
getchar() shall return the character 'a'.
APPLICATION USAGE
In format strings containing the '%' form of conversion specifications, each argument in the argument list is used
exactly once.
For functions that allocate memory as if by malloc(), the application should
release such memory when it is no longer required by a call to free(). For
fwscanf(), this is memory allocated via use of the 'm' assignment-allocation character.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, getwc(), fwprintf(), setlocale(), wcstod(), wcstol(), wcstoul(), wcrtomb()
XBD 7. Locale, , ,
CHANGE HISTORY
First released in Issue 5. Included for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E).
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
The following changes are made for alignment with the ISO/IEC 9899:1999 standard:
The prototypes for fwscanf() and swscanf() are updated.
The DESCRIPTION is updated.
The hh, ll, j, t, and z length modifiers are added.
The a, A, and F conversion characters are added.
The DESCRIPTION is updated to use the terms "conversion specifier" and "conversion specification" consistently.
Issue 7
Austin Group Interpretation 1003.1-2001 #170 is applied.
SD5-XSH-ERN-132 is applied, adding the assignment-allocation character 'm'.
Functionality relating to the "%n$" form of conversion specification is moved from the XSI option to the Base.
Changes are made related to support for finegrained timestamps.
The APPLICATION USAGE section is updated to clarify that memory is allocated as if by malloc().
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0229 [302] and XSH/TC1-2008/0230 [14] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0148 [73], XSH/TC2-2008/0149 [823], and XSH/TC2-2008/0150 [936] are
applied.
Issue 8
Austin Group Defect 1163 is applied, clarifying the handling of white space in the format string.
Austin Group Defect 1173 is applied, clarifying the description of the assignment-allocation character 'm'.
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
Austin Group Defect 1375 is applied, changing "terminating null wide character" to "terminating null character (or wide
character)" and changing the first occurrence of wchar_t in the descriptions of the s and [ conversion
specifiers to char.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/llrintf.html =====
llrint
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
llrint, llrintf, llrintl — round to the nearest integer value using current rounding direction
SYNOPSIS
#include
long long llrint(double x);
long long llrintf(float x);
long long llrintl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall round their argument to the nearest integer value, rounding according to the current rounding
direction.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the rounded integer value.
[MX]  If
x is NaN, a domain error shall occur, and an unspecified value is returned.
If x is +Inf, a domain error shall occur and an unspecified value is returned.
If x is -Inf, a domain error shall occur and an unspecified value is returned.
If the correct value is positive and too large to represent as a long long, an unspecified value shall be returned.
[MX]
On systems that support the IEC 60559 Floating-Point option, a domain error shall occur;   otherwise, a [CX]   domain  error may occur.
If the correct value is negative and too large to represent as a long long, an unspecified value shall be returned.
[MX]
On systems that support the IEC 60559 Floating-Point option, a domain error shall occur;   otherwise, a [CX]   domain  error may occur.
ERRORS
These functions shall fail if:
Domain Error
[MX]
The x argument is NaN or ±Inf, or the correct value is not representable as an integer.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
These functions may fail if:
Domain Error
The correct value is not representable as an integer.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
These functions provide floating-to-integer conversions. They round according to the current rounding direction. If the rounded
value is outside the range of the return type, the numeric result is unspecified and the invalid floating-point exception is
raised. When they raise no other floating-point exception and the result differs from the argument, they raise the inexact
floating-point exception.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), lrint()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
ISO/IEC 9899:1999 standard, Technical Corrigendum 2 #53 is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/ttyname.html =====
ttyname
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ttyname, ttyname_r — find the pathname of a terminal
SYNOPSIS
#include
char *ttyname(int fildes);
int ttyname_r(int fildes, char *name, size_t namesize);
DESCRIPTION
The ttyname() function shall return a pointer to a string containing a null-terminated pathname of the terminal
associated with file descriptor fildes. The application shall not modify the string returned. The returned pointer might be
invalidated or the string content might be overwritten by a subsequent call to ttyname(). The returned pointer and the
string content might also be invalidated if the calling thread is terminated.
The ttyname() function need not be thread-safe.
The ttyname_r() function shall store the null-terminated pathname of the terminal associated with the file descriptor
fildes in the character array referenced by name. The array is namesize characters long and should have space
for the name and the terminating null character. The maximum length of the terminal name shall be {TTY_NAME_MAX}.
RETURN VALUE
Upon successful completion, ttyname() shall return a pointer to a string. Otherwise, a null pointer shall be returned and
errno set to indicate the error.
If successful, the ttyname_r() function shall return zero. Otherwise, an error number shall be returned to indicate the
error.
ERRORS
These functions may fail if:
[EBADF]
The fildes argument is not a valid file descriptor.
[ENOTTY]
The file associated with the fildes argument is not a terminal.
The ttyname_r() function shall fail if:
[ERANGE]
The value of namesize is smaller than the length of the string to be returned including the terminating null
character.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
The term "terminal" is used instead of the historical term "terminal device" in order to avoid a reference to an undefined
term.
The thread-safe version places the terminal name in a user-supplied buffer and returns a non-zero value if it fails. The
non-thread-safe version may return the name in a static data area that may be overwritten by each call.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The ttyname_r() function is included for alignment with the POSIX Threads Extension.
A note indicating that the ttyname() function need not be reentrant is added to the DESCRIPTION.
Issue 6
The ttyname_r() function is marked as part of the Thread-Safe Functions option.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The statement that errno is set on error is added.
The [EBADF] and [ENOTTY] optional error conditions are added.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
SD5-XSH-ERN-100 is applied, correcting the definition of the [ENOTTY] error condition.
The ttyname_r() function is moved from the Thread-Safe Functions option to the Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0686 [75] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0376 [656] is applied.
Issue 8
Austin Group Defect 398 is applied, combining the duplicated [EBADF] and [ENOTTY] errors and changing the [ERANGE] error from
"may fail" to "shall fail".
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/dbm_nextkey.html =====
dbm_clearerr
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
dbm_clearerr, dbm_close, dbm_delete, dbm_error, dbm_fetch, dbm_firstkey, dbm_nextkey, dbm_open, dbm_store — database
functions
SYNOPSIS
[XSI]  #include
int dbm_clearerr(DBM *db);
void dbm_close(DBM *db);
int dbm_delete(DBM *db, datum key);
int dbm_error(DBM *db);
datum dbm_fetch(DBM *db, datum key);
datum dbm_firstkey(DBM *db);
datum dbm_nextkey(DBM *db);
DBM *dbm_open(const char *file, int open_flags, mode_t file_mode);
int dbm_store(DBM *db, datum key, datum content, int
store_mode);
DESCRIPTION
These functions create, access, and modify a database.
A datum consists of at least two members, dptr and dsize. The dptr member points to an object that
is dsize bytes in length. Arbitrary binary data, as well as character strings, may be stored in the object pointed to by
dptr.
A database shall be stored in one or two files. When one file is used, the name of the database file shall be formed by
appending the suffix .db to the file argument given to dbm_open(). When two files are used, the names of the
database files shall be formed by appending the suffixes .dir and .pag respectively to the file argument.
The dbm_open() function shall open a database. The file argument to the function is the pathname of the database.
Values for the open_flags argument are constructed by a bitwise-inclusive OR of flags from the following list, defined in
. Applications shall specify exactly one of the first three values
(file access modes) below in the value of open_flags:
O_RDONLY
Open the database, and the underlying file(s) used to store the database, for reading only.
O_RDWR
Open the database, and the underlying file(s) used to store the database, for reading and writing.
O_WRONLY
Open the database for writing only. The underlying file(s) used to store the database shall be opened for reading and
writing.
Any combination of the following can be used:
O_CLOEXEC
If set, the FD_CLOEXEC flag for the new file descriptor(s) used to open the underlying file(s) shall be set.
O_CREAT
If the database exists, this flag has no effect except as noted under O_EXCL below. Otherwise, the database shall be created;
the user ID of the underlying file(s) shall be set to the effective user ID of the process; the group ID of the underlying file(s)
shall be set to the group ID of the file's parent directory or to the effective group ID of the process. Implementations shall
provide a way to initialize the group ID to the group ID of the parent directory. Implementations may, but need not, provide an
implementation-defined way to initialize the group ID to the effective group ID of the calling process.
O_DSYNC
[SIO]
Write I/O operations on the file(s) used to store the database shall complete as defined by synchronized I/O data integrity
completion.
O_EXCL
If O_CREAT and O_EXCL are set, dbm_open() shall fail if the database exists according to the following criteria. If the
database is stored in a file with a .db suffix, a check for the existence of the file and the creation of the file if it
does not exist shall be performed as a single atomic operation. If the database is stored in files with .pag and .dir
suffixes, this atomic existence check and creation operation shall be performed for each file, but it is unspecified which file is
first. If the first file is successfully created and the second file is found to exist, the first file should be removed before
dbm_open() returns.
If O_EXCL is set and O_CREAT is not set, the result is undefined.
O_RSYNC
[SIO]
Read I/O operations on the file(s) used to store the database shall complete at the same level of integrity as specified by the
O_DSYNC and O_SYNC flags. If both O_DSYNC and O_RSYNC are set in oflag, all I/O operations on the file(s) shall complete as defined
by synchronized I/O data integrity completion. If both O_SYNC and O_RSYNC are set in flags, all I/O operations on the file(s) shall
complete as defined by synchronized I/O file integrity completion.
O_SYNC
Write I/O operations on the file(s) used to store the database shall complete as defined by synchronized I/O file integrity
completion.
O_TRUNC
If the database exists and is successfully opened O_RDWR or O_WRONLY, it shall be emptied, and the mode and owner of the
underlying file(s) shall be unchanged. The result of using O_TRUNC without either O_RDWR or O_WRONLY is undefined.
The behaviour of other flags described for the flags argument of open() is
unspecified.
The file_mode argument has the same meaning as the third argument of open()
and shall apply to the underlying file(s) used to store the database.
The dbm_open() function need not accept pathnames longer than {PATH_MAX}-4 bytes (including the terminating null), or
pathnames with a last component longer than {NAME_MAX}-4 bytes (excluding the terminating null).
The dbm_close() function shall close a database. The application shall ensure that argument db is a pointer to a
dbm structure that has been returned from a call to dbm_open().
These database functions shall support an internal block size large enough to support key/content pairs of at least 1023
bytes.
The dbm_fetch() function shall read a record from a database. The argument db is a pointer to a database structure
that has been returned from a call to dbm_open(). The argument key is a datum that has been initialized by the
application to the value of the key that matches the key of the record the program is fetching.
The dbm_store() function shall write a record to a database. The argument db is a pointer to a database structure
that has been returned from a call to dbm_open(). The argument key is a datum that has been initialized by the
application to the value of the key that identifies (for subsequent reading, writing, or deleting) the record the application is
writing. The argument content is a datum that has been initialized by the application to the value of the record the
program is writing. The argument store_mode controls whether dbm_store() replaces any pre-existing record that has
the same key that is specified by the key argument. The application shall set store_mode to either DBM_INSERT or
DBM_REPLACE. If the database contains a record that matches the key argument and store_mode is DBM_REPLACE, the
existing record shall be replaced with the new record. If the database contains a record that matches the key argument and
store_mode is DBM_INSERT, the existing record shall be left unchanged and the new record ignored. If the database does not
contain a record that matches the key argument and store_mode is either DBM_INSERT or DBM_REPLACE, the new record
shall be inserted in the database.
If the sum of a key/content pair exceeds the internal block size, the result is unspecified. Moreover, the application shall
ensure that all key/content pairs that hash together fit on a single block. The dbm_store() function shall return an error
in the event that a disk block fills with inseparable data.
The dbm_delete() function shall delete a record and its key from the database. The argument db is a pointer to a
database structure that has been returned from a call to dbm_open(). The argument key is a datum that has been
initialized by the application to the value of the key that identifies the record the program is deleting.
The dbm_firstkey() function shall return the first key in the database. The argument db is a pointer to a database
structure that has been returned from a call to dbm_open().
The dbm_nextkey() function shall return the next key in the database. The argument db is a pointer to a database
structure that has been returned from a call to dbm_open(). The application shall ensure that the dbm_firstkey()
function is called before calling dbm_nextkey(). Subsequent calls to dbm_nextkey() return the next key until all of
the keys in the database have been returned.
The dbm_error() function shall return the error condition of the database. The argument db is a pointer to a
database structure that has been returned from a call to dbm_open().
The dbm_clearerr() function shall clear the error condition of the database. The argument db is a pointer to a
database structure that has been returned from a call to dbm_open().
The dptr pointers returned by these functions may point into static storage that may be changed by subsequent calls.
These functions need not be thread-safe.
RETURN VALUE
The dbm_store() and dbm_delete() functions shall return 0 when they succeed and a negative value when they
fail.
The dbm_store() function shall return 1 if it is called with a flags value of DBM_INSERT and the function finds an
existing record with the same key.
The dbm_error() function shall return 0 if the error condition is not set and return a non-zero value if the error
condition is set.
The return value of dbm_clearerr() is unspecified.
The dbm_firstkey() and dbm_nextkey() functions shall return a key datum. When the end of the database is
reached, the dptr member of the key is a null pointer. If an error is detected, the dptr member of the key shall be a
null pointer and the error condition of the database shall be set.
The dbm_fetch() function shall return a content datum. If no record in the database matches the key or if an error
condition has been detected in the database, the dptr member of the content shall be a null pointer.
The dbm_open() function shall return a pointer to a database structure. If an error is detected during the operation,
dbm_open() shall return a (DBM *)0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The following code can be used to traverse the database:
for(key = dbm_firstkey(db); key.dptr != NULL; key = dbm_nextkey(db))
The dbm_* functions provided in this library should not be confused in any way with those of a general-purpose database
management system. These functions do not provide for multiple search keys per entry, they do not protect against multi-user access
(in other words they do not lock records or files), and they do not provide the many other useful database functions that are found
in more robust database management systems. Creating and updating databases by use of these functions is relatively slow because of
data copies that occur upon hash collisions. These functions are useful for applications requiring fast lookup of relatively static
information that is to be indexed by a single key.
Note that a strictly conforming application is extremely limited by these functions: since there is no way to determine that the
keys in use do not all hash to the same value (although that would be rare), a strictly conforming application cannot be guaranteed
that it can store more than one block's worth of data in the database. As long as a key collision does not occur, additional data
may be stored, but because there is no way to determine whether an error is due to a key collision or some other error condition
(dbm_error() being effectively a Boolean), once an error is detected, the
application is effectively limited to guessing what the error might be if it wishes to continue using these functions.
The dbm_delete() function need not physically reclaim file space, although it does make it available for reuse by the
database.
After calling dbm_store() or dbm_delete() during a pass through the keys by dbm_firstkey() and
dbm_nextkey(), the application should reset the database by calling dbm_firstkey() before again calling
dbm_nextkey(). The contents of these files are unspecified and may not be portable.
Applications should take care that database pathname arguments specified to dbm_open() are not prefixes of unrelated
files. This might be done, for example, by placing databases in a separate directory.
Since some implementations use three characters for a suffix and others use four characters for a suffix, applications should
ensure that the maximum portable pathname length passed to dbm_open() is no greater than {PATH_MAX}-4 bytes, with the last
component of the pathname no greater than {NAME_MAX}-4 bytes.
RATIONALE
and having .dir as its suffix. The second file containing all data and having .pag as its suffix. This has been
changed not to specify the use of the files and to allow newer implementations of the Berkeley DB interface using a single file
that have evolved while remaining compatible with the application programming interface. The standard developers considered
removing the specific suffixes altogether but decided to retain them so as not to pollute the application file name space more than
necessary and to allow for portable backups of the database.
FUTURE DIRECTIONS
A future revision of this standard may mandate the file removal that is currently recommended (by the use of "should") in the
description of O_EXCL.
SEE ALSO
open()
XBD ,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Normative text previously in the APPLICATION USAGE section is moved to the DESCRIPTION.
A note indicating that these functions need not be reentrant is added to the DESCRIPTION.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
Austin Group Interpretation 1003.1-2001 #042 is applied so that the DESCRIPTION permits newer implementations of the Berkeley DB
interface.
Austin Group Interpretation 1003.1-2001 #156 is applied.
Issue 8
Austin Group Defect 1057 is applied, clarifying how the O_ flags defined for use with open() apply to dbm_open().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/mknod.html =====
mknod
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
mknod, mknodat — make directory, special file, or regular file
SYNOPSIS
[XSI]  #include
int mknod(const char *path, mode_t mode, dev_t dev);
[OH] #include
[XSI]  int mknodat(int fd, const char *path, mode_t mode,
dev_t dev);
DESCRIPTION
The mknod() function shall create a new file named by the pathname to which the argument path points.
The file type for path is OR'ed into the mode argument, and the application shall select one of the following
symbolic constants:
Name
Description
S_IFIFO
FIFO-special
S_IFCHR
Character-special (non-portable)
S_IFDIR
Directory (non-portable)
S_IFBLK
Block-special (non-portable)
S_IFREG
Regular (non-portable)
The only portable use of mknod() is to create a FIFO-special file. If mode is not S_IFIFO or
dev is not 0, the behavior of mknod() is unspecified.
The permissions for the new file are OR'ed into the mode argument, and may be selected from any combination
of the following symbolic constants:
Name
Description
S_ISUID
Set user ID on execution.
S_ISGID
Set group ID on execution.
S_IRWXU
Read, write, or execute (search) by owner.
S_IRUSR
Read by owner.
S_IWUSR
Write by owner.
S_IXUSR
Execute (search) by owner.
S_IRWXG
Read, write, or execute (search) by group.
S_IRGRP
Read by group.
S_IWGRP
Write by group.
S_IXGRP
Execute (search) by group.
S_IRWXO
Read, write, or execute (search) by others.
S_IROTH
Read by others.
S_IWOTH
Write by others.
S_IXOTH
Execute (search) by others.
S_ISVTX
On directories, restricted deletion flag.
The user ID of the file shall be initialized to the effective user ID of the process. The group ID of the file
shall be initialized to either the effective group ID of the process or the group ID of the parent directory. Implementations shall
provide a way to initialize the file's group ID to the group ID of the parent directory. Implementations may, but need not, provide
an implementation-defined way to initialize the file's group ID to the effective group ID of the calling process. The owner, group,
and other permission bits of mode shall be modified by the file mode creation mask of the process. The mknod()
function shall clear each bit whose corresponding bit in the file mode creation mask of the process is set.
If path names a symbolic link, mknod() shall fail and set errno to [EEXIST].
Upon successful completion, mknod() shall mark for update the last data access, last data modification, and
last file status change timestamps of the file. Also, the last data modification and last file status change timestamps of the
directory that contains the new entry shall be marked for update.
Only a process with appropriate privileges may invoke mknod() for file types other than FIFO-special.
The mknodat() function shall be equivalent to the mknod() function except in the case where
path specifies a relative path. In this case the newly created directory, special file, or regular file is located relative
to the directory associated with the file descriptor fd instead of the current working directory. If the access mode of the
open file description associated with the file descriptor is not O_SEARCH, the function shall check whether directory searches are
permitted using the current permissions of the directory underlying the file descriptor. If the access mode is O_SEARCH, the
function shall not perform the check.
If mknodat() is passed the special value AT_FDCWD in the fd parameter, the current working directory
shall be used and the behavior shall be identical to a call to mknod().
RETURN VALUE
Upon successful completion, these functions shall return 0. Otherwise, these functions shall return -1 and set errno to
indicate the error. If -1 is returned, the new file shall not be created.
ERRORS
These functions shall fail if:
[EACCES]
A component of the path prefix denies search permission, or write permission is denied on the parent directory.
[EEXIST]
The named file exists.
[EILSEQ]
The last pathname component of path is not a portable filename, and cannot be created in the target directory.
[EINVAL]
An invalid argument exists.
[EIO]
An I/O error occurred while accessing the file system.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOENT]
A component of the path prefix of path does not name an existing file or path is an empty string.
[ENOENT] or [ENOTDIR]
The path argument contains at least one non- character and ends with one or more trailing
characters. If path without the trailing  characters would name an existing file, an [ENOENT] error shall not
occur.
[ENOSPC]
The directory that would contain the new file cannot be extended or the file system is out of file allocation resources.
[ENOTDIR]
A component of the path prefix names an existing file that is neither a directory nor a symbolic link to a directory.
[EPERM]
The invoking process does not have appropriate privileges and the file type is not FIFO-special.
[EROFS]
The directory in which the file is to be created is located on a read-only file system.
The mknodat() function shall fail if:
[EACCES]
The access mode of the open file description associated with fd is not O_SEARCH and the permissions of the directory
underlying fd do not permit directory searches.
[EBADF]
The path argument does not specify an absolute path and the fd argument is neither AT_FDCWD nor a valid file
descriptor open for reading or searching.
[ENOTDIR]
The path argument is not an absolute path and fd is a file descriptor associated with a non-directory file.
These functions may fail if:
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the path argument.
[ENAMETOOLONG]
The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a
length that exceeds {PATH_MAX}.
The following sections are informative.
EXAMPLES
Creating a FIFO Special File
The following example shows how to create a FIFO special file named /home/cnd/mod_done, with read/write
permissions for owner, and with read permissions for group and others.
#include
#include
dev_t dev;
int   status;
...
status  = mknod("/home/cnd/mod_done", S_IFIFO | S_IWUSR |
S_IRUSR | S_IRGRP | S_IROTH, dev);
APPLICATION USAGE
The mkfifo() function is preferred over this function for making FIFO special
files.
RATIONALE
The POSIX.1-1990 standard required that the group ID of a newly created file be set to the group ID of its parent directory or
to the effective group ID of the creating process. FIPS 151-2 required that implementations provide a way to have the group ID be
set to the group ID of the containing directory, but did not prohibit implementations also supporting a way to set the group ID to
the effective group ID of the creating process. Conforming applications should not assume which group ID will be used. If it
matters, an application can use chown() to set the group ID after the file is created,
or determine under what conditions the implementation will set the desired group ID.
The purpose of the mknodat() function is to create directories, special files, or regular files in
directories other than the current working directory without exposure to race conditions. Any part of the path of a file could be
changed in parallel to a call to mknod(), resulting in unspecified behavior. By opening a file descriptor for the target
directory and using the mknodat() function it can be guaranteed that the newly created directory, special file, or regular
file is located relative to the desired directory.
Implementations are encouraged to have mknod() and mknodat() report an [EILSEQ] error if the last
component of path contains any bytes that have the encoded value of a  character.
FUTURE DIRECTIONS
None.
SEE ALSO
chmod(), creat(),
exec, fstatat(), mkdir(), mkfifo(), open(), umask()
XBD ,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
The wording of the mandatory [ELOOP] error condition is updated, and a second optional [ELOOP] error condition is
added.
Issue 7
Austin Group Interpretation 1003.1-2001 #143 is applied.
The mknodat() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 2.
Changes are made related to support for finegrained timestamps.
Changes are made to allow a directory to be opened for searching.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0388 [324], XSH/TC1-2008/0389 [461], XSH/TC1-2008/0390
[146,435], XSH/TC1-2008/0391 [278], and XSH/TC1-2008/0392 [278] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0222 [591], XSH/TC2-2008/0223 [817], XSH/TC2-2008/0224 [822],
XSH/TC2-2008/0225 [817], and XSH/TC2-2008/0226 [591] are applied.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to disallow the creation of filenames containing any bytes that
have the encoded value of a  character.
Austin Group Defect 293 is applied, adding the [EILSEQ] error.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getutxid.html =====
endutxent
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
endutxent, getutxent, getutxid, getutxline, pututxline, setutxent — user accounting database functions
SYNOPSIS
[XSI]  #include
void endutxent(void);
struct utmpx *getutxent(void);
struct utmpx *getutxid(const struct utmpx *id);
struct utmpx *getutxline(const struct utmpx *line);
struct utmpx *pututxline(const struct utmpx *utmpx);
void setutxent(void);
DESCRIPTION
These functions shall provide access to the user accounting database.
The getutxent() function shall read the next entry from the user accounting database. If the database is not already
open, it shall open it. If it reaches the end of the database, it shall fail.
The getutxid() function shall search forward from the current point in the database. If the ut_type value of the
utmpx structure pointed to by id is BOOT_TIME, OLD_TIME, or NEW_TIME, then it shall stop when it finds an entry with
a matching ut_type value. If the ut_type value is INIT_PROCESS, LOGIN_PROCESS, USER_PROCESS, or DEAD_PROCESS, then it
shall stop when it finds an entry whose type is one of these four and whose ut_id member matches the ut_id member of
the utmpx structure pointed to by id. If the end of the database is reached without a match, getutxid() shall
fail.
The getutxline() function shall search forward from the current point in the database until it finds an entry of the type
LOGIN_PROCESS or USER_PROCESS which also has a ut_line value matching that in the utmpx structure pointed to by
line. If the end of the database is reached without a match, getutxline() shall fail.
The getutxid() or getutxline() function may cache data. For this reason, to use getutxline() to search for
multiple occurrences, the application shall zero out the static data after each success, or getutxline() may return a
pointer to the same utmpx structure.
There is one exception to the rule about clearing the structure before further reads are done. The implicit read done by
pututxline() (if it finds that it is not already at the correct place in the user accounting database) shall not modify the
static structure returned by getutxent(), getutxid(), or getutxline(), if the application has modified this
structure and passed the pointer back to pututxline().
For all entries that match a request, the ut_type member indicates the type of the entry. Other members of the entry
shall contain meaningful data based on the value of the ut_type member as follows:
ut_type Member
Other Members with Meaningful Data
EMPTY
No others
BOOT_TIME
ut_tv
OLD_TIME
ut_tv
NEW_TIME
ut_tv
USER_PROCESS
ut_id, ut_user (login name of the user), ut_line, ut_pid, ut_tv
INIT_PROCESS
ut_id, ut_pid, ut_tv
LOGIN_PROCESS
ut_id, ut_user (implementation-defined name of the login process), ut_line, ut_pid,
ut_tv
DEAD_PROCESS
ut_id, ut_pid, ut_tv
An implementation that provides extended security controls may impose implementation-defined restrictions on
accessing the user accounting database. In particular, the system may deny the existence of some or all of the user accounting
database entries associated with users other than the caller.
If the process has appropriate privileges, the pututxline() function shall write out the structure into the
user accounting database. It shall search for a record as if by getutxid() that satisfies the request. If this search
succeeds, then the entry shall be replaced. Otherwise, a new entry shall be made at the end of the user accounting database.
The endutxent() function shall close the user accounting database.
The setutxent() function shall reset the input to the beginning of the database. This should be done before
each search for a new entry if it is desired that the entire database be examined.
These functions need not be thread-safe.
RETURN VALUE
Upon successful completion, getutxent(), getutxid(), and getutxline() shall return a pointer to a
utmpx structure containing a copy of the requested entry in the user accounting database. Otherwise, a null pointer shall be
returned.
The return value may point to a static area which is overwritten by a subsequent call to getutxid() or
getutxline().
Upon successful completion, pututxline() shall return a pointer to a utmpx structure containing a
copy of the entry added to the user accounting database. Otherwise, a null pointer shall be returned.
The endutxent() and setutxent() functions shall not return a value.
ERRORS
No errors are defined for the endutxent(), getutxent(), getutxid(), getutxline(), and
setutxent() functions.
The pututxline() function may fail if:
[EPERM]
The process does not have appropriate privileges.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The sizes of the arrays in the structure can be found using the sizeof operator.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Normative text previously in the APPLICATION USAGE section is moved to the DESCRIPTION.
A note indicating that these functions need not be reentrant is added to the DESCRIPTION.
Issue 6
In the DESCRIPTION, the note about reentrancy is expanded to cover thread-safety.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0090 [213,428] and XSH/TC1-2008/0091 [213] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/remainder.html =====
remainder
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
remainder, remainderf, remainderl — remainder function
SYNOPSIS
#include
double remainder(double x, double y);
float remainderf(float x, float y);
long double remainderl(long double x, long double y);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall return the floating-point remainder r=x-ny when y is non-zero. The value
n is the integral value nearest the exact value x/y. When |n-x/y|=½, the value n
is chosen to be even.
The behavior of remainder() shall be independent of the rounding mode.
RETURN VALUE
Upon successful completion, these functions shall return the floating-point remainder r=x-ny when y
is non-zero.
[MX]
When subnormal results are supported, the returned value shall be exact.
On systems that do not support the IEC 60559 Floating-Point option, if y is zero, it is implementation-defined whether a
domain error occurs or zero is returned.
[MX]  If
x or y is NaN, a NaN shall be returned.
If x is infinite or y is 0 and the other is non-NaN, a domain error shall occur, and a NaN shall be returned.
ERRORS
These functions shall fail if:
Domain Error
[MX]
The x argument is ±Inf, or the y argument is ±0 and the other argument is non-NaN.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
These functions may fail if:
Domain Error
The y argument is zero.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
abs(), div(), feclearexcept(), fetestexcept()
, ldiv()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
The remainder() function is no longer marked as an extension.
The remainderf() and remainderl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
ISO/IEC 9899:1999 standard, Technical Corrigendum 2 #55 (SD5-XSH-ERN-82) is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0506 [320] is applied.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/iswspace_l.html =====
iswspace
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
iswspace, iswspace_l — test for a white-space wide-character code
SYNOPSIS
#include
int iswspace(wint_t wc);
[CX]  int iswspace_l(wint_t wc, locale_t locale);
DESCRIPTION
For iswspace(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The iswspace() [CX]   and iswspace_l()
functions shall test whether wc is a wide-character code representing a character of class space in the current
locale, [CX]   or in the locale represented by locale,
respectively; see XBD 7. Locale.
The wc argument is a wint_t, the value of which the application shall ensure is a wide-character code
corresponding to a valid character in the locale used by the function, or equal to the value of the macro WEOF. If the argument has
any other value, the behavior is undefined.
[CX]  The
behavior is undefined if the locale argument to iswspace_l() is the special locale object LC_GLOBAL_LOCALE or is not
a valid locale object handle.
RETURN VALUE
The iswspace() [CX]   and iswspace_l()
functions shall return non-zero if wc is a white-space wide-character code; otherwise, they shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
To ensure applications portability, especially across natural languages, only these functions and the functions in the reference
pages listed in the SEE ALSO section should be used for character classification.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
iswalnum(), iswalpha(),
iswcntrl(), iswctype(),
iswdigit(), iswgraph(),
iswlower(), iswprint(),
iswpunct(), iswupper(),
iswxdigit(), setlocale(),
uselocale()
XBD 7. Locale, ,
CHANGE HISTORY
First released in Issue 4.
Issue 5
The following change has been made in this version for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E):
The SYNOPSIS has been changed to indicate that this function and associated data types are now made visible by inclusion of the
header rather than .
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
The iswspace_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0338 [302], XSH/TC1-2008/0339 [283], and XSH/TC1-2008/0340 [283] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0191 [685] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/ctime_r.html =====
ctime
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ctime — convert a time value to a date and time string
SYNOPSIS
[OB]  #include
char *ctime(const time_t *clock);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The ctime() function shall convert the time pointed to by clock, representing time in seconds since the Epoch, to
local time in the form of a string. It shall be equivalent to:
asctime(localtime(clock))
The asctime(), ctime(), gmtime(), and localtime() functions shall
return values in one of two static objects: a broken-down time structure and an array of char. Execution of any of the
functions that return a pointer to one of these object types may overwrite the information in any object of the same type pointed
to by the value returned from any previous call to any of them.
The ctime() function need not be thread-safe; however, ctime() shall avoid data races with all functions other
than itself, asctime(), gmtime(), and
localtime().
RETURN VALUE
The ctime() function shall return the pointer returned by asctime() with
that broken-down time as an argument.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
This function is included only for compatibility with older implementations. It has undefined behavior if the resulting string
would be too long, so the use of this function should be discouraged. On implementations that do not detect output string length
overflow, it is possible to overflow the output buffer in such a way as to cause applications to fail, or possible system security
violations. Also, this function does not support localized date and time formats. To avoid these problems, applications should use
strftime() to generate strings from broken-down times.
Values for the broken-down time structure can be obtained by calling gmtime() or
localtime().
Attempts to use ctime() for times before the Epoch or for times beyond the year 9999 produce undefined results. Refer to
asctime().
RATIONALE
The standard developers decided to mark the ctime() function obsolescent even though it is in the ISO C standard due
to the possibility of buffer overflow. The ISO C standard also provides the strftime() function which can be used to avoid these problems.
FUTURE DIRECTIONS
This function may be removed in a future version, but not until after it has been removed from the ISO C standard.
SEE ALSO
asctime(), clock(), difftime(), futimens(), gmtime(), localtime(), mktime(), strftime(), strptime(), time()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
Normative text previously in the APPLICATION USAGE section is moved to the DESCRIPTION.
The ctime_r() function is included for alignment with the POSIX Threads Extension.
A note indicating that the ctime() function need not be reentrant is added to the DESCRIPTION.
Issue 6
Extensions beyond the ISO C standard are marked.
In the DESCRIPTION, the note about reentrancy is expanded to cover thread-safety.
The APPLICATION USAGE section is updated to include a note on the thread-safe function and its avoidance of possibly using a
static data area.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
SD5-XSH-ERN-25 is applied, updating the APPLICATION USAGE.
Austin Group Interpretation 1003.1-2001 #053 is applied, marking these functions obsolescent.
The ctime_r() function is moved from the Thread-Safe Functions option to the Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0066 [321,428] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0075 [664] is applied.
Issue 8
Austin Group Defect 1302 is applied, aligning this function with the ISO/IEC 9899:2018 standard.
Austin Group Defect 1330 is applied, changing the FUTURE DIRECTIONS section.
Austin Group Defect 1376 is applied, removing CX shading from some text derived from the ISO C standard and updating it to
match the ISO C standard.
Austin Group Defect 1410 is applied, removing the ctime_r() function.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getaddrinfo.html =====
freeaddrinfo
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
freeaddrinfo, getaddrinfo — get address information
SYNOPSIS
#include
#include
void freeaddrinfo(struct addrinfo *ai);
int getaddrinfo(const char *restrict nodename,
const char *restrict servname,
const struct addrinfo *restrict hints,
struct addrinfo **restrict res);
DESCRIPTION
The freeaddrinfo() function shall free one or more addrinfo structures returned by getaddrinfo(), along
with any additional storage associated with those structures. If the ai_next field of the structure is not null, the entire
list of structures shall be freed. The freeaddrinfo() function shall support the freeing of arbitrary sublists of an
addrinfo list originally returned by getaddrinfo(). The freeaddrinfo() function shall not modify errno
if ai is a sublist previously returned by getaddrinfo() and not yet freed.
The getaddrinfo() function shall translate the name of a service location (for example, a host name) and/or a service
name and shall return a set of socket addresses and associated information to be used in creating a socket with which to address
the specified service.
Note:
In many cases it is implemented by the Domain Name System, as documented in RFC 1034, RFC 1035, and
RFC 3596.
The freeaddrinfo() and getaddrinfo() functions shall be thread-safe.
The nodename and servname arguments are either null pointers or pointers to null-terminated strings. One or both
of these two arguments shall be supplied by the application as a non-null pointer.
The format of a valid name depends on the address family or families. If a specific family is not given and the name could be
interpreted as valid within multiple supported families, the implementation shall attempt to resolve the name in all supported
families and, in absence of errors, one or more results shall be returned.
If the nodename argument is not null, it can be a descriptive name or can be an address string. If the specified address
family is AF_INET, [IP6]   AF_INET6,  or AF_UNSPEC, valid
descriptive names include host names. If the specified address family is AF_INET or AF_UNSPEC, address strings using Internet
standard dot notation as specified in inet_ntop() are valid.
[IP6]
If the specified address family is AF_INET6 or AF_UNSPEC, standard IPv6 text forms described in inet_ntop() are valid.
If nodename is not null, the requested service location is named by nodename; otherwise, the requested service
location is local to the caller.
If servname is null, the call shall return network-level addresses for the specified nodename. If servname
is not null, it is a null-terminated character string identifying the requested service. This can be either a descriptive name or a
numeric representation suitable for use with the address family or families. If the specified address family is AF_INET,
[IP6]
AF_INET6,  or AF_UNSPEC, the service can be specified as a
string specifying a decimal port number.
If the hints argument is not null, it refers to a structure containing input values that directs the operation by
providing options and by limiting the returned information to a specific socket type, address family, and/or protocol, as described
below. The application shall ensure that each of the ai_addrlen, ai_addr, ai_canonname, and ai_next
members, as well as each of the non-standard additional members, if any, of this hints structure is initialized. If any of
these members has a value other than the value that would result from default initialization, the behavior is
implementation-defined. A value of AF_UNSPEC for ai_family means that the caller shall accept any address family. A value of
zero for ai_socktype means that the caller shall accept any socket type. A value of zero for ai_protocol means that
the caller shall accept any protocol. If hints is a null pointer, the behavior shall be as if it referred to a structure
containing the value zero for the ai_flags, ai_socktype, and ai_protocol fields, and AF_UNSPEC for the
ai_family field.
The ai_flags field to which the hints parameter points shall be set to zero or be the bitwise-inclusive OR of one
or more of the values AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST, AI_NUMERICSERV, AI_V4MAPPED, AI_ALL, and AI_ADDRCONFIG.
If the AI_PASSIVE flag is specified, the returned address information shall be suitable for use in binding a socket for
accepting incoming connections for the specified service. In this case, if the nodename argument is null, then the IP
address portion of the socket address structure shall be set to INADDR_ANY for an IPv4 address or IN6ADDR_ANY_INIT for an IPv6
address. If the AI_PASSIVE flag is not specified, the returned address information shall be suitable for a call to connect() (for a connection-mode protocol) or for a call to connect(), sendto(), or sendmsg() (for a connectionless protocol). In this case, if the nodename argument is
null, then the IP address portion of the socket address structure shall be set to the loopback address. The AI_PASSIVE flag shall
be ignored if the nodename argument is not null.
If the AI_CANONNAME flag is specified and the nodename argument is not null, the function shall attempt to determine the
canonical name corresponding to nodename (for example, if nodename is an alias or shorthand notation for a complete
name).
Note:
Since different implementations use different conceptual models, the terms "canonical name" and "alias" cannot be precisely
defined for the general case. However, Domain Name System implementations are expected to interpret them as they are used in
RFC 1034.
A numeric host address string is not a "name", and thus does not have a "canonical name" form; no address to host name
translation is performed. See below for handling of the case where a canonical name cannot be obtained.
If the AI_NUMERICHOST flag is specified, then a non-null nodename string supplied shall be a numeric host address string.
Otherwise, an [EAI_NONAME] error is returned. This flag shall prevent any type of name resolution service (for example, the DNS)
from being invoked.
If the AI_NUMERICSERV flag is specified, then a non-null servname string supplied shall be a numeric port string.
Otherwise, an [EAI_NONAME] error shall be returned. This flag shall prevent any type of name resolution service (for example, NIS+)
from being invoked.
[IP6]
By default, with an ai_family of AF_INET6, getaddrinfo() shall return only IPv6 addresses. If the AI_V4MAPPED flag is
specified along with an ai_family of AF_INET6, then getaddrinfo() shall return IPv4-mapped IPv6 addresses on finding
no matching IPv6 addresses. The AI_V4MAPPED flag shall be ignored unless ai_family equals AF_INET6. If the AI_ALL flag is
used with the AI_V4MAPPED flag, then getaddrinfo() shall return all matching IPv6 and IPv4 addresses. The AI_ALL flag
without the AI_V4MAPPED flag shall be ignored.
If the AI_ADDRCONFIG flag is specified, IPv4 addresses shall be returned only if an IPv4 address is configured on the local
system, [IP6]   and IPv6 addresses shall be returned only if an IPv6 address is configured on the local system.
The ai_socktype field to which argument hints points specifies the socket type for the service, as defined in
2.10.6 Socket Types. If a specific socket type is not given (for
example, a value of zero) and the service name could be interpreted as valid with multiple supported socket types, the
implementation shall attempt to resolve the service name for all supported socket types and, in the absence of errors, all possible
results shall be returned. A non-zero socket type value shall limit the returned information to values with the specified socket
type.
If the ai_family field to which hints points has the value AF_UNSPEC, addresses shall be returned for use with any
address family that can be used with the specified nodename and/or servname. Otherwise, addresses shall be returned
for use only with the specified address family. If ai_family is not AF_UNSPEC and ai_protocol is not zero, then
addresses shall be returned for use only with the specified address family and protocol; the value of ai_protocol shall be
interpreted as in a call to the socket() function with the corresponding values of
ai_family and ai_protocol.
RETURN VALUE
A zero return value for getaddrinfo() indicates successful completion; a non-zero return value indicates failure. The
possible values for the failures are listed in the ERRORS section.
Upon successful return of getaddrinfo(), the location to which res points shall refer to a linked list of
addrinfo structures, each of which shall specify a socket address and information for use in creating a socket with which to
use that socket address. The list shall include at least one addrinfo structure. The ai_next field of each structure
contains a pointer to the next structure on the list, or a null pointer if it is the last structure on the list. Each structure on
the list shall include values for use with a call to the socket() function, and a
socket address for use with the connect() function or, if the AI_PASSIVE flag was
specified, for use with the bind() function. The fields ai_family,
ai_socktype, and ai_protocol shall be usable as the arguments to the socket() function to create a socket suitable for use with the returned address. The fields
ai_addr and ai_addrlen are usable as the arguments to the connect() or
bind() functions with such a socket, according to the AI_PASSIVE flag.
If nodename is not null, and if requested by the AI_CANONNAME flag, the ai_canonname field of the first returned
addrinfo structure shall point to a null-terminated string containing the canonical name corresponding to the input
nodename; if the canonical name is not available, then ai_canonname shall refer to the nodename argument or a
string with the same contents. The contents of the ai_flags field of the returned structures are undefined.
All fields in socket address structures returned by getaddrinfo() that are not filled in through an explicit argument
(for example, sin6_flowinfo) shall be set to zero.
Note:
This makes it easier to compare socket address structures.
ERRORS
The getaddrinfo() function shall fail and return the corresponding error value if:
[EAI_AGAIN]
The name could not be resolved at this time. Future attempts may succeed.
[EAI_BADFLAGS]
The flags parameter had an invalid value.
[EAI_FAIL]
A non-recoverable error occurred when attempting to resolve the name.
[EAI_FAMILY]
The address family was not recognized.
[EAI_MEMORY]
There was a memory allocation failure when trying to allocate storage for the return value.
[EAI_NONAME]
The name does not resolve for the supplied parameters.
Neither nodename nor servname were supplied. At least one of these shall be supplied.
[EAI_SERVICE]
The service passed was not recognized for the specified socket type.
[EAI_SOCKTYPE]
The intended socket type was not recognized.
[EAI_SYSTEM]
A system error occurred; the error code can be found in errno.
The following sections are informative.
EXAMPLES
The following (incomplete) program demonstrates the use of getaddrinfo() to obtain the socket address structure(s) for
the service named in the program's command-line argument. The program then loops through each of the address structures attempting
to create and bind a socket to the address, until it performs a successful bind().
#include
#include
#include
#include
#include
#include
int
main(int argc, char *argv[])
{
struct addrinfo *result, *rp;
int sfd, s;
if (argc != 2) {
fprintf(stderr, "Usage: %s port\n", argv[0]);
exit(EXIT_FAILURE);
}
struct addrinfo hints = {0};
hints.ai_family = AF_UNSPEC;
hints.ai_socktype = SOCK_DGRAM;
hints.ai_flags = AI_PASSIVE;
hints.ai_protocol = 0;
s = getaddrinfo(NULL, argv[1], &hints, &result);
if (s != 0) {
fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(s));
exit(EXIT_FAILURE);
}
/* getaddrinfo() returns a list of address structures.
Try each address until a successful bind().
If socket(2) (or bind(2)) fails, close the socket
and try the next address. */
for (rp = result; rp != NULL; rp = rp->ai_next) {
sfd = socket(rp->ai_family, rp->ai_socktype,
rp->ai_protocol);
if (sfd == -1)
continue;
if (bind(sfd, rp->ai_addr, rp->ai_addrlen) == 0)
break;            /* Success */
close(sfd);
}
if (rp == NULL) {         /* No address succeeded */
fprintf(stderr, "Could not bind\n");
exit(EXIT_FAILURE);
}
freeaddrinfo(result);     /* No longer needed */
/* ... use socket bound to sfd ... */
}
APPLICATION USAGE
If the caller handles only TCP and not UDP, for example, then the ai_protocol member of the hints structure should
be set to IPPROTO_TCP when getaddrinfo() is called.
If the caller handles only IPv4 and not IPv6, then the ai_family member of the hints structure should be set to
AF_INET when getaddrinfo() is called.
The hints structure can be initialized using memset(&hints, 0, sizeof hints) or by default initialization
(see the APPLICATION USAGE for XBD ).
The term "canonical name" is misleading; it is taken from the Domain Name System (RFC 2181). It should be noted that the
canonical name is a result of alias processing, and not necessarily a unique attribute of a host, address, or set of addresses. See
RFC 2181 for more discussion of this in the Domain Name System context.
The ai_socktype field pointed to by hints is just the socket type; not the socket type and flags that can be
specified when the socket is created. Passing in socket creation flags will cause a failure with [EAI_SOCKTYPE].
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
connect(), endservent(),
gai_strerror(), getnameinfo(), socket()
XBD ,
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
The restrict keyword is added to the getaddrinfo() prototype for alignment with the ISO/IEC 9899:1999
standard.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/19 is applied, adding three notes to the DESCRIPTION and adding
text to the APPLICATION USAGE related to the term "canonical name". A reference to RFC 2181 is also added to the Informative
References.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/20 is applied, making changes for alignment with IPv6. These
include the following:
Adding AI_V4MAPPED, AI_ALL, and AI_ADDRCONFIG to the allowed values for the ai_flags field
Adding a description of AI_ADDRCONFIG
Adding a description of the consequences of ignoring the AI_PASSIVE flag.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/39 is applied, changing "corresponding value" to
"corresponding error value" in the ERRORS section.
Issue 7
Austin Group Interpretation 1003.1-2001 #013 is applied.
Austin Group Interpretation 1003.1-2001 #146 is applied, updating the DESCRIPTION.
An example is added.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0130 [939], XSH/TC2-2008/0131 [979], XSH/TC2-2008/0132 [918], and
XSH/TC2-2008/0133 [934] are applied.
Issue 8
Austin Group Defect 385 is applied, adding a requirement that freeaddrinfo() does not modify errno when passed a
sublist that can be freed.
Austin Group Defect 411 is applied, changing the "socket type" reference and adding a paragraph about
hints->ai_socktype to the APPLICATION USAGE section.
Austin Group Defect 940 is applied, changing text in the APPLICATION USAGE section relating to initialization of the
hints structure.
Austin Group Defect 1102 is applied, replacing a reference to the inet_addr()
page with one to the inet_ntop() page.
Austin Group Defect 1685 is applied, updating RFC references.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/strtoll.html =====
strtol
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
strtol, strtoll — convert a string to a long integer
SYNOPSIS
#include
long strtol(const char *restrict nptr, char **restrict endptr, int base);
long long strtoll(const char *restrict nptr, char **restrict endptr,
int base)
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall convert the initial portion of the string pointed to by nptr to a type long and long
long representation, respectively. First, they decompose the input string into three parts:
An initial, possibly empty, sequence of white-space bytes
A subject sequence interpreted as an integer represented in some radix determined by the value of base
A final string of one or more unrecognized characters, including the terminating NUL character of the input string.
Then they shall attempt to convert the subject sequence to an integer, and return the result.
If the value of base is 0, the expected form of the subject sequence is that of a decimal constant, octal constant, or
hexadecimal constant, any of which may be preceded by a '+' or '-' sign. A decimal constant begins with a
non-zero digit, and consists of a sequence of decimal digits. An octal constant consists of the prefix '0' optionally
followed by a sequence of the digits '0' to '7' only. A hexadecimal constant consists of the prefix 0x or 0X
followed by a sequence of the decimal digits and letters 'a' (or 'A') to 'f' (or 'F') with
values 10 to 15 respectively.
If the value of base is between 2 and 36, the expected form of the subject sequence is a sequence of letters and digits
representing an integer with the radix specified by base, optionally preceded by a '+' or '-' sign. The
letters from 'a' (or 'A') to 'z' (or 'Z') inclusive are ascribed the values 10 to 35; only
letters whose ascribed values are less than that of base are permitted. If the value of base is 16, the characters 0x
or 0X may optionally precede the sequence of letters and digits, following the sign if present.
The subject sequence is defined as the longest initial subsequence of the input string, starting with the first non-white-space
byte, that is of the expected form. The subject sequence shall contain no characters if the input string is empty or consists
entirely of white-space bytes, or if the first non-white-space byte is other than a sign or a permissible letter or digit.
If the subject sequence has the expected form and the value of base is 0, the sequence of characters starting with the
first digit shall be interpreted as an integer constant. If the subject sequence has the expected form and the value of base
is between 2 and 36, it shall be used as the base for conversion, ascribing to each letter its value as given above. If the subject
sequence begins with a , the resulting value shall be the negative of the converted value. A pointer to the
final string shall be stored in the object pointed to by endptr, provided that endptr is not a null pointer.
In other than the C [CX]   or POSIX  locale, additional
locale-specific subject sequence forms may be accepted.
If the subject sequence is empty or does not have the expected form, no conversion is performed; the value of nptr shall
be stored in the object pointed to by endptr, provided that endptr is not a null pointer.
These functions shall not change the setting of errno if successful.
Since 0, {LONG_MIN} or {LLONG_MIN}, and {LONG_MAX} or {LLONG_MAX} are returned on error and are also valid returns on success,
an application wishing to check for error situations should set errno to 0, then call strtol() or strtoll(),
then check errno.
RETURN VALUE
Upon successful completion, these functions shall return the converted value, if any. If no conversion could be performed, 0
shall be returned [CX]   and errno may be set to [EINVAL].
[CX]  If
the value of base is not supported, 0 shall be returned and errno shall be set to [EINVAL].
If the correct value is outside the range of representable values, {LONG_MIN}, {LONG_MAX}, {LLONG_MIN}, or {LLONG_MAX} shall be
returned (according to the sign of the value), and errno set to [ERANGE].
ERRORS
These functions shall fail if:
[EINVAL]
[CX]
The value of base is not supported.
[ERANGE]
The value to be returned is not representable.
These functions may fail if:
[EINVAL]
No conversion could be performed.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Since the value of *endptr is unspecified if the value of base is not supported, applications should either ensure
that base has a supported value (0 or between 2 and 36) before the call, or check for an [EINVAL] error before examining
*endptr.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
fscanf(), isalpha(), strtod()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate that errno is not changed if the function is successful.
Issue 6
Extensions beyond the ISO C standard are marked.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
In the RETURN VALUE and ERRORS sections, the [EINVAL] optional error condition is added if no conversion could be performed.
The following changes are made for alignment with the ISO/IEC 9899:1999 standard:
The strtol() prototype is updated.
The strtoll() function is added.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0616 [453], XSH/TC1-2008/0617 [105], XSH/TC1-2008/0618 [453],
XSH/TC1-2008/0619 [453], and XSH/TC1-2008/0620 [453] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0351 [892], XSH/TC2-2008/0352 [584], XSH/TC2-2008/0353 [796], and
XSH/TC2-2008/0354 [892] are applied.
Issue 8
Austin Group Defect 700 is applied, clarifying how a subject sequence beginning with  is converted.
Austin Group Defect 1163 is applied, clarifying the handling of white space in the input string.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/swab.html =====
swab
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
swab — swap bytes
SYNOPSIS
[XSI]  #include
void swab(const void *restrict src, void *restrict dest,
ssize_t nbytes);
DESCRIPTION
The swab() function shall copy nbytes bytes, which are pointed to by src, to the object pointed to by
dest, exchanging adjacent bytes. The nbytes argument should be even. If nbytes is odd, swab() copies
and exchanges nbytes-1 bytes and the disposition of the last byte is unspecified. If copying takes place between objects
that overlap, the behavior is undefined. If nbytes is negative, swab() does nothing.
RETURN VALUE
None.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The restrict keyword is added to the swab() prototype for alignment with the ISO/IEC 9899:1999 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wcscasecmp_l.html =====
wcscasecmp
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wcscasecmp, wcscasecmp_l, wcsncasecmp, wcsncasecmp_l — case-insensitive wide-character string comparison
SYNOPSIS
[CX]  #include
int wcscasecmp(const wchar_t *ws1, const wchar_t *ws2);
int wcscasecmp_l(const wchar_t *ws1, const wchar_t *ws2,
locale_t locale);
int wcsncasecmp(const wchar_t *ws1, const wchar_t *ws2, size_t n);
int wcsncasecmp_l(const wchar_t *ws1, const wchar_t *ws2,
size_t n, locale_t locale);
DESCRIPTION
The wcscasecmp() and wcsncasecmp() functions are the wide-character equivalent of the strcasecmp() and strncasecmp()
functions, respectively.
The wcscasecmp() and wcscasecmp_l() functions shall compare, while ignoring differences in case, the
wide-character string pointed to by ws1 to the wide-character string pointed to by ws2.
The wcsncasecmp() and wcsncasecmp_l() functions shall compare, while ignoring differences in case, not more than
n wide-characters from the wide-character string pointed to by ws1 to the wide-character string pointed to by
ws2.
The wcscasecmp() and wcsncasecmp() functions use the current locale to determine the case of the wide
characters.
The wcscasecmp_l() and wcsncasecmp_l() functions use the locale represented by locale to determine the case
of the wide characters.
When the LC_CTYPE category of the locale being used is from the POSIX locale, these functions shall behave as if the
wide-character strings had been converted to lowercase and then a comparison of wide-character codes performed. Otherwise, the
results are unspecified.
The information for wcscasecmp_l() and wcsncasecmp_l() about the case of the characters comes from the locale
represented by locale.
The behavior is undefined if the locale argument to wcscasecmp_l() or wcsncasecmp_l() is the special locale
object LC_GLOBAL_LOCALE or is not a valid locale object handle.
RETURN VALUE
Upon completion, the wcscasecmp() and wcscasecmp_l() functions shall return an integer greater than, equal to, or
less than 0 if the wide-character string pointed to by ws1 is, ignoring case, greater than, equal to, or less than the
wide-character string pointed to by ws2, respectively.
Upon completion, the wcsncasecmp() and wcsncasecmp_l() functions shall return an integer greater than, equal to,
or less than 0 if the possibly null wide-character terminated string pointed to by ws1 is, ignoring case, greater than,
equal to, or less than the possibly null wide-character terminated string pointed to by ws2, respectively.
No return values are reserved to indicate an error.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
strcasecmp(), wcscmp(),
wcsncmp()
XBD
CHANGE HISTORY
First released in Issue 7.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0716 [294], XSH/TC1-2008/0717 [283], and XSH/TC1-2008/0718 [283] are
applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/isspace.html =====
isspace
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
isspace, isspace_l — test for a white-space character
SYNOPSIS
#include
int isspace(int c);
[CX]  int isspace_l(int c, locale_t locale);
DESCRIPTION
For isspace(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The isspace() [CX]   and isspace_l()
functions shall test whether c is a character of class space in the current locale, [CX]   or in the
locale represented by locale,  respectively; see XBD 7. Locale.
The c argument is an int, the value of which the application shall ensure is a character representable as an
unsigned char or equal to the value of the macro EOF. If the argument has any other value, the behavior is undefined.
[CX]  The
behavior is undefined if the locale argument to isspace_l() is the special locale object LC_GLOBAL_LOCALE or is not a
valid locale object handle.
RETURN VALUE
The isspace() [CX]   and isspace_l()
functions shall return non-zero if c is a white-space character; otherwise, they shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
To ensure applications portability, especially across natural languages, only these functions and the functions in the reference
pages listed in the SEE ALSO section should be used for character classification.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
isalnum(), isalpha(), iscntrl(), isdigit(), isgraph(), islower(), isprint(), ispunct(), isupper(), isxdigit(), setlocale(), uselocale()
XBD 7. Locale, ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
The isspace_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0303 [302], XSH/TC1-2008/0304 [283], and XSH/TC1-2008/0305 [283] are
applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sched_get_priority_max.html =====
sched_get_priority_max
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sched_get_priority_max, sched_get_priority_min — get priority limits (REALTIME)
SYNOPSIS
[PS|TPS]  #include
int sched_get_priority_max(int policy);
int sched_get_priority_min(int policy);
DESCRIPTION
The sched_get_priority_max() and sched_get_priority_min() functions shall return the appropriate maximum or
minimum, respectively, for the scheduling policy specified by policy.
The value of policy shall be one of the scheduling policy values defined in .
RETURN VALUE
If successful, the sched_get_priority_max() and sched_get_priority_min() functions shall return the appropriate
maximum or minimum values, respectively. If unsuccessful, they shall return a value of -1 and set errno to indicate the
error.
ERRORS
The sched_get_priority_max() and sched_get_priority_min() functions shall fail if:
[EINVAL]
The value of the policy parameter does not represent a defined scheduling policy.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
sched_getparam(), sched_setparam(), sched_getscheduler(), sched_rr_get_interval(), sched_setscheduler()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Issue 6
These functions are marked as part of the Process Scheduling option.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Process
Scheduling option.
The [ESRCH] error condition has been removed since these functions do not take a pid argument.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/52 is applied, changing the PS margin code in the SYNOPSIS to
PS|TPS.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_attr_getstack.html =====
pthread_attr_getstack
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_attr_getstack, pthread_attr_setstack — get and set stack attributes
SYNOPSIS
[TSA TSS]  #include
int pthread_attr_getstack(const pthread_attr_t *restrict attr,
void **restrict stackaddr, size_t *restrict stacksize);
int pthread_attr_setstack(pthread_attr_t *attr, void *stackaddr,
size_t stacksize);
DESCRIPTION
The pthread_attr_getstack() and pthread_attr_setstack() functions, respectively, shall get and set the thread
creation stack attributes stackaddr and stacksize in the attr object.
The stack attributes specify the area of storage to be used for the created thread's stack. The base (lowest addressable byte)
of the storage shall be stackaddr, and the size of the storage shall be stacksize bytes. The stacksize shall
be at least {PTHREAD_STACK_MIN}. The pthread_attr_setstack() function may fail with [EINVAL] if stackaddr does not
meet implementation-defined alignment requirements. All pages within the stack described by stackaddr and stacksize
shall be both readable and writable by the thread.
If the pthread_attr_getstack() function is called before the stackaddr attribute has been set, the behavior is
unspecified.
The behavior is undefined if the value specified by the attr argument to pthread_attr_getstack() or
pthread_attr_setstack() does not refer to an initialized thread attributes object.
RETURN VALUE
Upon successful completion, these functions shall return a value of 0; otherwise, an error number shall be returned to indicate
the error.
The pthread_attr_getstack() function shall store the stack attribute values in stackaddr and stacksize if
successful.
ERRORS
The pthread_attr_setstack() function shall fail if:
[EINVAL]
The value of stacksize is less than {PTHREAD_STACK_MIN} or exceeds an implementation-defined limit.
The pthread_attr_setstack() function may fail if:
[EINVAL]
The value of stackaddr does not have proper alignment to be used as a stack, or ((char *)stackaddr +
stacksize) lacks proper alignment.
[EACCES]
The stack page(s) described by stackaddr and stacksize are not both readable and writable by the thread.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
These functions are appropriate for use by applications in an environment where the stack for a thread must be placed in some
particular region of memory.
While it might seem that an application could detect stack overflow by providing a protected page outside the specified stack
region, this cannot be done portably. Implementations are free to place the thread's initial stack pointer anywhere within the
specified region to accommodate the machine's stack pointer behavior and allocation requirements. Furthermore, on some
architectures, such as the IA-64, "overflow" might mean that two separate stack pointers allocated within the region will overlap
somewhere in the middle of the region.
After a successful call to pthread_attr_setstack(), the storage area specified by the stackaddr parameter is under
the control of the implementation, as described in 2.9.8 Use of
Application-Managed Thread Stacks.
The specification of the stackaddr attribute presents several ambiguities that make portable use of these functions
impossible. For example, the standard allows implementations to impose arbitrary alignment requirements on stackaddr.
Applications cannot assume that a buffer obtained from malloc() is suitably aligned.
Note that although the stacksize value passed to pthread_attr_setstack() must satisfy alignment requirements, the
same is not true for pthread_attr_setstacksize() where the
implementation must increase the specified size if necessary to achieve the proper alignment.
RATIONALE
If an implementation detects that the value specified by the attr argument to pthread_attr_getstack() or
pthread_attr_setstack() does not refer to an initialized thread attributes object, it is recommended that the function
should fail and report an [EINVAL] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_attr_destroy(), pthread_attr_getdetachstate(), pthread_attr_getstacksize(), pthread_create()
XBD ,
CHANGE HISTORY
First released in Issue 6. Developed as part of the XSI option and brought into the BASE by IEEE PASC Interpretation 1003.1
#101.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/83 is applied, updating the APPLICATION USAGE section to refer
to 2.9.8 Use of Application-Managed Thread Stacks.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC/D6/84 is applied, updating the ERRORS section to include optional
errors for the case when attr refers to an uninitialized thread attribute object.
Issue 7
SD5-XSH-ERN-66 is applied, correcting the use of attr in the [EINVAL] error condition.
Austin Group Interpretation 1003.1-2001 #057 is applied, clarifying the behavior if the function is called before the
stackaddr attribute is set.
SD5-XSH-ERN-157 is applied, updating the APPLICATION USAGE section.
The description of the stackaddr attribute is updated in the DESCRIPTION and APPLICATION USAGE sections.
The [EINVAL] error for an uninitialized thread attributes object is removed; this condition results in undefined behavior.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/posix_spawnattr_setflags.html =====
posix_spawnattr_getflags
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
posix_spawnattr_getflags, posix_spawnattr_setflags — get and set the spawn-flags attribute of a spawn attributes object
(ADVANCED REALTIME)
SYNOPSIS
[SPN]  #include
int posix_spawnattr_getflags(const posix_spawnattr_t *restrict attr,
short *restrict flags);
int posix_spawnattr_setflags(posix_spawnattr_t *attr, short flags);
DESCRIPTION
The posix_spawnattr_getflags() function shall obtain the value of the spawn-flags attribute from the attributes
object referenced by attr.
The posix_spawnattr_setflags() function shall set the spawn-flags attribute in an initialized attributes object
referenced by attr.
The spawn-flags attribute is used to indicate which process attributes are to be changed in the new process image when
invoking posix_spawn() or posix_spawnp(). It is the bitwise-inclusive OR of zero or more of the following
flags:
POSIX_SPAWN_RESETIDS
POSIX_SPAWN_SETPGROUP
[PS]
POSIX_SPAWN_SETSCHEDPARAM
POSIX_SPAWN_SETSCHEDULER
POSIX_SPAWN_SETSID
POSIX_SPAWN_SETSIGDEF
POSIX_SPAWN_SETSIGMASK
These flags are defined in . The default value of this attribute
shall be as if no flags were set.
RETURN VALUE
Upon successful completion, posix_spawnattr_getflags() shall return zero and store the value of the spawn-flags
attribute of attr into the object referenced by the flags parameter; otherwise, an error number shall be returned to
indicate the error.
Upon successful completion, posix_spawnattr_setflags() shall return zero; otherwise, an error number shall be returned to
indicate the error.
ERRORS
These functions may fail if:
[EINVAL]
The value specified by attr is invalid.
The posix_spawnattr_setflags() function may fail if:
[EINVAL]
The value of the attribute being set is not valid.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
These functions are part of the Spawn option and need not be provided on all implementations.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
posix_spawn(), posix_spawnattr_destroy(), posix_spawnattr_getsigdefault(), posix_spawnattr_getpgroup(), posix_spawnattr_getschedparam(), posix_spawnattr_getschedpolicy(), posix_spawnattr_getsigmask()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1d-1999.
Issue 8
Austin Group Defect 1044 is applied, adding POSIX_SPAWN_SETSID.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/strsignal.html =====
strsignal
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
strsignal — get signal message string
SYNOPSIS
[CX]  #include
char *strsignal(int signum);
DESCRIPTION
The strsignal() function shall map the signal number in signum to an implementation-defined string and shall
return a pointer to it. It shall use the same set of messages as the psignal()
function.
The application shall not modify the string returned. The returned pointer might be invalidated or the string content might be
overwritten by a subsequent call to strsignal() or setlocale(). The
returned pointer might also be invalidated if the calling thread is terminated.
The contents of the message strings returned by strsignal() should be determined by the setting of the LC_MESSAGES
category in the current locale.
The implementation shall behave as if no function defined in this standard calls strsignal().
Since no return value is reserved to indicate an error, an application wishing to check for error situations should set
errno to 0, then call strsignal(), then check errno.
The strsignal() function need not be thread-safe.
RETURN VALUE
Upon successful completion, strsignal() shall return a pointer to a string. Otherwise, if signum is not a valid
signal number, the return value is unspecified.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
If signum is not a valid signal number, some implementations return NULL, while for others the strsignal()
function returns a pointer to a string containing an unspecified message denoting an unknown signal. POSIX.1-2024 leaves this
return value unspecified.
FUTURE DIRECTIONS
None.
SEE ALSO
psiginfo(), setlocale(),
sig2str()
XBD
CHANGE HISTORY
First released in Issue 7.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0609 [75] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0347 [656] is applied.
Issue 8
Austin Group Defect 1138 is applied, adding sig2str() to the SEE ALSO
section.
Austin Group Defect 1474 is applied, changing the NAME section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/le32toh.html =====
be16toh
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
be16toh, be32toh, be64toh, htobe16, htobe32, htobe64, htole16, htole32, htole64, le16toh, le32toh, le64toh — convert
values between host and specified byte order
SYNOPSIS
#include
uint16_t be16toh(uint16_t big_endian_16bits);
uint32_t be32toh(uint32_t big_endian_32bits);
uint64_t be64toh(uint64_t big_endian_64bits);
uint16_t htobe16(uint16_t host_16bits);
uint32_t htobe32(uint32_t host_32bits);
uint64_t htobe64(uint64_t host_64bits);
uint16_t htole16(uint16_t host_16bits);
uint32_t htole32(uint32_t host_32bits);
uint64_t htole64(uint64_t host_64bits);
uint16_t le16toh(uint16_t little_endian_16bits);
uint32_t le32toh(uint32_t little_endian_32bits);
uint64_t le64toh(uint64_t little_endian_64bits);
DESCRIPTION
These functions shall convert integer values of various sizes between host representations and representations in a specified
order.
On some implementations, these functions are defined as macros.
A little-endian representation of an integer has the least significant byte stored as the first byte, with the significance of
the bytes increasing as the byte address increases. A big-endian representation has the most significant byte as the first byte,
with the significance of the bytes reducing as the byte address increases.
Note:
Network byte order is big-endian.
For example, the uint32_t value 0x01020304 is represented as the four bytes 0x04, 0x03, 0x02, 0x01 on a little-endian
host, and as 0x01, 0x02, 0x03, 0x04 on a big-endian host.
For each of the sizes 16, 32 and 64, the htobeSIZE() function shall convert from whatever order the host uses to
big-endian representation, htoleSIZE() shall convert to little-endian representation, beSIZEtoh() shall convert from
big-endian to host order, and leSIZEtoh() shall convert from little-endian to host order.
RETURN VALUE
These functions shall return an unsigned integer of the appropriate size and representation.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
#include
#include
#include
int main(int argc, char *argv[])
{
uint32_t val;
if (argc > 1) {
val = (uint32_t)strtoul(argv[1], NULL, 0);
printf("Value: %08x\n", val);
printf("As bytes:\n");
union {
uint32_t asint;
unsigned char asbytes[sizeof(uint32_t)];
} u;
printf("Little endian: ");
u.asint = htole32(val);
for (int i = 0; i  is included:
htobe32
htonl
htobe16
htons
be32toh
ntohl
be16toh
ntohs
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
htonl()
XBD ,
CHANGE HISTORY
First released in Issue 8.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/rename.html =====
rename
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
rename, renameat — rename file
SYNOPSIS
#include
int rename(const char *old, const char *new);
[OH] #include
[CX]  int renameat(int oldfd, const char *old, int
newfd,
const char *new);
DESCRIPTION
For rename(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The rename() function shall change the name of a file. The old argument points to the pathname of the file to be
renamed. The new argument points to the new pathname of the file. [CX]
If the new argument does not resolve to an
existing directory entry for a file of type directory and the new argument contains at least one non- character
and ends with one or more trailing  characters after all symbolic links have been processed, rename() shall
fail.
If either the old or new argument names a symbolic link, rename() shall operate on the symbolic link
itself, and shall not resolve the last component of the argument. If the old argument and the new argument resolve to
either the same existing directory entry or different directory entries for the same existing file, rename() shall return
successfully and perform no other action.
If the old argument names a file that is not a directory and the new argument names a directory, or old
names a directory and new names a file that is not a directory, or new names a directory that is not empty,
rename() shall fail. Otherwise, if the directory entry named by new exists, it shall be removed and old
renamed to new. In this case, a directory entry named new shall remain visible to other threads throughout the
renaming operation and refer either to the file referred to by new or old before the operation began.
If either pathname argument refers to a path whose final component is either dot or dot-dot, rename() shall
fail.
If the old argument points to a pathname of a symbolic link, the symbolic link shall be renamed. If the new
argument points to a pathname of a symbolic link, the symbolic link shall be removed.
The old pathname shall not name an ancestor directory of the new pathname. Write access permission is required for
the directory containing old and the directory containing new. If the old argument points to the pathname of a
directory, write access permission may be required for the directory named by old, and, if it exists, the directory named by
new.
If the new argument names an existing file and the file's link count becomes 0 when it is removed and no process has the
file open, the space occupied by the file shall be freed and the file shall no longer be accessible. If one or more processes have
the file open when the last link is removed, the link shall be removed before rename() returns, but the removal of the file
contents shall be postponed until all references to the file are closed.
Upon successful completion, rename() shall mark for update the last data modification and last file status change
timestamps of the parent directory of each file.
If the rename() function fails for any reason other than [EIO], any file named by new shall be unaffected.
The renameat() function shall be equivalent to the rename() function except in the case where either old or
new specifies a relative path. If old is a relative path, the file to be renamed is located relative to the directory
associated with the file descriptor oldfd instead of the current working directory. If new is a relative path, the
same happens only relative to the directory associated with newfd. If the access mode of the open file description
associated with the file descriptor is not O_SEARCH, the function shall check whether directory searches are permitted using the
current permissions of the directory underlying the file descriptor. If the access mode is O_SEARCH, the function shall not perform
the check.
If renameat() is passed the special value AT_FDCWD in the oldfd or newfd parameter, the current working
directory shall be used in the determination of the file for the respective path parameter.
RETURN VALUE
Upon successful completion, the rename() function shall return 0. Otherwise, it shall return -1, [CX]  errno shall
be set to indicate the error,   and neither the file named by
old nor the file named by new shall be changed or created.
[CX]
Upon successful completion, the renameat() function shall return 0. Otherwise, it shall return -1 and set errno to
indicate the error.
ERRORS
The rename() [CX]   and renameat()
functions shall fail if:
[EACCES]
[CX]  A
component of either path prefix denies search permission; or one of the directories containing old or new denies
write permissions; or, write permission is required and is denied for a directory pointed to by the old or new
arguments.
[EBUSY]
[CX]
The directory named by old or new is currently in use by the system or another process, and the implementation
considers this an error.
[EEXIST] or [ENOTEMPTY]
[CX]
The new argument names a directory that is not empty.
[EILSEQ]
[CX]
The last pathname component of the new pathname is not a portable filename, and cannot be created in the target directory.
[EINVAL]
[CX]
The old pathname names an ancestor directory of the new pathname, or either pathname argument contains a final
component that is dot or dot-dot.
[EIO]
[CX]  A
physical I/O error has occurred.
[EISDIR]
[CX]
The new argument points to a directory and the old argument points to a file that is not a directory.
[ELOOP]
[CX]  A
loop exists in symbolic links encountered during resolution of the old or new argument.
[EMLINK]
[CX]
The file named by old is a directory, and the link count of the parent directory of new would exceed {LINK_MAX}.
[ENAMETOOLONG]
[CX]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOENT]
[CX]
The old argument does not name an existing file, a component of the path prefix of new does not exist, or either
old or new points to an empty string.
[ENOSPC]
[CX]
The directory that would contain new cannot be extended.
[ENOTDIR]
[CX]  A
component of either path prefix names an existing file that is neither a directory nor a symbolic link to a directory; or the
old argument names a directory and the new argument names a non-directory file; or the old argument contains
at least one non- character and ends with one or more trailing  characters and the last pathname
component names an existing file that is neither a directory nor a symbolic link to a directory; or the old argument names
an existing non-directory file and the new argument names a nonexistent file, contains at least one non-
character, and ends with one or more trailing  characters; or the new argument names an existing non-directory
file, contains at least one non- character, and ends with one or more trailing  characters.
[EPERM] or [EACCES]
[XSI]
The S_ISVTX flag is set on the directory containing the file referred to by old and the process does not satisfy the
criteria specified in XBD 4.5 Directory Protection with respect to
old; or new refers to an existing file, the S_ISVTX flag is set on the directory containing this file, and the
process does not satisfy the criteria specified in XBD 4.5 Directory
Protection with respect to this file.
[EROFS]
[CX]
The requested operation requires writing in a directory on a read-only file system.
[EXDEV]
[CX]
The file named by old and the directory in which the directory entry named by new is to be created or replaced are on
different file systems and the implementation does not support hard links between file systems.
[CX]  In
addition, the renameat() function shall fail if:
[EACCES]
The access mode of the open file description associated with oldfd or newfd is not O_SEARCH and the permissions
of the directory underlying oldfd or newfd, respectively, do not permit directory searches.
[EBADF]
The old argument does not specify an absolute path and the oldfd argument is neither AT_FDCWD nor a valid file
descriptor open for reading or searching, or the new argument does not specify an absolute path and the newfd
argument is neither AT_FDCWD nor a valid file descriptor open for reading or searching.
[ENOTDIR]
The old or new argument is not an absolute path and oldfd or newfd, respectively, is a file
descriptor associated with a non-directory file.
The rename() [CX]   and renameat()
functions may fail if:
[ELOOP]
[CX]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the old or new argument.
[ENAMETOOLONG]
[CX]
The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a
length that exceeds {PATH_MAX}.
[ETXTBSY]
[CX]
The file named by new exists and is the last directory entry to a pure procedure (shared text) file that is being executed.
The following sections are informative.
EXAMPLES
Renaming a File
The following example shows how to rename a file named /home/cnd/mod1 to /home/cnd/mod2.
#include
int status;
...
status = rename("/home/cnd/mod1", "/home/cnd/mod2");
APPLICATION USAGE
Some implementations mark for update the last file status change timestamp of renamed files and some do not. Applications which
make use of the last file status change timestamp may behave differently with respect to renamed files unless they are designed to
allow for either behavior.
RATIONALE
This rename() function is equivalent for regular files to that defined by the ISO C standard. Its inclusion here
expands that definition to include actions on directories and specifies behavior when the new parameter names a file that
already exists. That specification requires that the action of the function be atomic.
One of the reasons for introducing this function was to have a means of renaming directories while permitting implementations to
prohibit the use of link() and unlink()
with directories, thus constraining links to directories to those made by mkdir().
The specification that if old and new refer to the same file is intended to guarantee that:
rename("x", "x");
does not remove the file.
Renaming dot or dot-dot is prohibited in order to prevent cyclical file system paths.
See also the descriptions of [ENOTEMPTY] and [ENAMETOOLONG] in rmdir() and [EBUSY]
in unlink(). For a discussion of [EXDEV], see link().
The purpose of the renameat() function is to rename files in directories other than the current working directory without
exposure to race conditions. Any part of the path of a file could be changed in parallel to a call to rename(), resulting in
unspecified behavior. By opening file descriptors for the source and target directories and using the renameat() function it
can be guaranteed that that renamed file is located correctly and the resulting file is in the desired directory.
Implementations are encouraged to have rename() and renameat() report an [EILSEQ] error if the file named by
new does not already exist and the last component of that pathname contains any bytes that have the encoded value of a
character.
FUTURE DIRECTIONS
None.
SEE ALSO
link(), rmdir()
, symlink(), unlink()
XBD 4.5 Directory Protection, ,
CHANGE HISTORY
First released in Issue 3. Included for alignment with the POSIX.1-1988 standard.
Issue 5
The [EBUSY] error is added to the optional part of the ERRORS section.
Issue 6
Extensions beyond the ISO C standard are marked.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The [EIO] mandatory error condition is added.
The [ELOOP] mandatory error condition is added.
A second [ENAMETOOLONG] is added as an optional error condition.
The [ETXTBSY] optional error condition is added.
The following changes were made to align with the IEEE P1003.1a draft standard:
Details are added regarding the treatment of symbolic links.
The [ELOOP] optional error condition is added.
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
Austin Group Interpretation 1003.1-2001 #016 is applied, changing the definition of the [ENOTDIR] error.
Austin Group Interpretation 1003.1-2001 #076 is applied, clarifying the behavior if the final component of a path is either dot
or dot-dot, and adding the associated [EINVAL] error case.
Austin Group Interpretation 1003.1-2001 #143 is applied.
Austin Group Interpretation 1003.1-2001 #145 is applied, clarifying that the [ENOENT] error condition also applies to the case
in which a component of new does not exist.
Austin Group Interpretations 1003.1-2001 #174 and #181 are applied.
The renameat() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 2.
Changes are made related to support for finegrained timestamps.
Changes are made to allow a directory to be opened for searching.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0508 [324], XSH/TC1-2008/0509 [147], XSH/TC1-2008/0510 [379],
XSH/TC1-2008/0511 [278], and XSH/TC1-2008/0512 [278] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0311 [873], XSH/TC2-2008/0312 [591], XSH/TC2-2008/0313 [716],
XSH/TC2-2008/0314 [817], XSH/TC2-2008/0315 [817], and XSH/TC2-2008/0316 [591] are applied.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to disallow the creation of filenames containing any bytes that
have the encoded value of a  character.
Austin Group Defect 293 is applied, adding the [EILSEQ] error.
Austin Group Defect 1200 is applied, correcting the argument names in the [ELOOP] errors.
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
Austin Group Defect 1380 is applied, changing text using the term "link" in line with its updated definition.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/toc.html =====
System Interfaces: Table of contents
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
System Interfaces: Table of Contents
1. Introduction
1.1 Relationship to Other Formal Standards
1.2 Format of Entries
2. General Information
2.1 Use and Implementation of Interfaces
2.1.1 Use and Implementation of Functions
2.1.2 Use and Implementation of Macros
2.2 The Compilation Environment
2.2.1 POSIX.1 Symbols
2.2.1.1 The _POSIX_C_SOURCE Feature Test Macro
2.2.1.2 The _XOPEN_SOURCE Feature Test Macro
2.2.1.3 The __STDC_WANT_LIB_EXT1__ Feature Test Macro
2.2.2 The Name Space
2.3 Error Numbers
2.3.1 Additional Error Numbers
2.4 Signal Concepts
2.4.1 Signal Generation and Delivery
2.4.2 Realtime Signal Generation and Delivery
2.4.3 Signal Actions
SIG_DFL
SIG_IGN
Pointer to a Function
2.4.4 Signal Effects on Other Functions
2.5 Standard I/O Streams
2.5.1 Interaction of File Descriptors and Standard I/O Streams
2.5.2 Stream Orientation and Encoding Rules
2.6 File Descriptor Allocation
2.7 XSI Interprocess Communication
2.7.1 IPC General Description
2.8 Realtime
2.8.1 Realtime Signals
2.8.2 Asynchronous I/O
2.8.3 Memory Management
2.8.3.1 Memory Locking
2.8.3.2 Memory Mapped Files
2.8.3.3 Memory Protection
2.8.3.4 Typed Memory Objects
2.8.4 Process Scheduling
Scheduling Policies
SCHED_FIFO
SCHED_RR
SCHED_SPORADIC
SCHED_OTHER
2.8.5 Clocks and Timers
Time Value Specification Structures
Timer Event Notification Control Block
Manifest Constants
Execution Time Monitoring
2.9 Threads
2.9.1 Thread-Safety
2.9.2 Thread IDs
2.9.3 Thread Mutexes
2.9.4 Thread Scheduling
Thread Scheduling Attributes
Thread Scheduling Contention Scope
Scheduling Allocation Domain
Scheduling Documentation
2.9.5 Thread Cancellation
2.9.5.1 Cancelability States
2.9.5.2 Cancellation Points
2.9.5.3 Thread Cancellation Cleanup Handlers
2.9.5.4 Async-Cancel Safety
2.9.6 Thread Read-Write Locks
2.9.7 Thread Interactions with File Operations
2.9.8 Use of Application-Managed Thread Stacks
2.9.9 Synchronization Object Copies and Alternative Mappings
2.10 Sockets
2.10.1 Address Families
2.10.2 Addressing
2.10.3 Protocols
2.10.4 Routing
2.10.5 Interfaces
2.10.6 Socket Types
2.10.7 Socket I/O Mode
2.10.8 Socket Owner
2.10.9 Socket Queue Limits
2.10.10 Pending Error
2.10.11 Socket Receive Queue
2.10.12 Socket Out-of-Band Data State
2.10.13 Connection Indication Queue
2.10.14 Signals
2.10.15 Asynchronous Errors
2.10.16 Use of Options
2.10.17 Use of Sockets for Local UNIX Connections
2.10.17.1 Headers
2.10.18 Use of Sockets over Internet Protocols
2.10.19 Use of Sockets over Internet Protocols Based on IPv4
2.10.19.1 Headers
2.10.20 Use of Sockets over Internet Protocols Based on IPv6
2.10.20.1 Addressing
2.10.20.2 Compatibility with IPv4
2.10.20.3 Interface Identification
2.10.20.4 Options
2.10.20.5 Headers
2.11 Data Types
2.11.1 Defined Types
2.11.2 The char Type
2.12 Status Information
Footnotes
3. System Interfaces
CMPLX
_Exit
a64l
abort
abs
accept
access
acos
acosh
aio_cancel
aio_error
aio_fsync
aio_read
aio_return
aio_suspend
aio_write
alarm
aligned_alloc
alphasort
asctime
asin
asinh
assert
at_quick_exit
atan
atan2
atanh
atexit
atof
atoi
atol
atomic_compare_exchange_strong
atomic_exchange
atomic_fetch_add
atomic_flag_clear
atomic_flag_test_and_set
atomic_init
atomic_is_lock_free
atomic_load
atomic_signal_fence
atomic_store
basename
be16toh
bind
bindtextdomain
bsearch
btowc
c16rtomb
cabs
cacos
cacosh
call_once
calloc
carg
casin
casinh
catan
catanh
catclose
catgets
catopen
cbrt
ccos
ccosh
ceil
cexp
cfgetispeed
cfgetospeed
cfsetispeed
cfsetospeed
chdir
chmod
chown
cimag
clearerr
clock
clock_getcpuclockid
clock_getres
clock_nanosleep
clog
close
closedir
closelog
cnd_broadcast
cnd_destroy
cnd_timedwait
confstr
conj
connect
copysign
cos
cosh
cpow
cproj
creal
creat
crypt
csin
csinh
csqrt
ctan
ctanh
ctermid
ctime
dbm_clearerr
difftime
dirfd
dirname
div
dladdr
dlclose
dlerror
dlopen
dlsym
drand48
dup
duplocale
encrypt
endgrent
endhostent
endnetent
endprotoent
endpwent
endservent
endutxent
erf
erfc
errno
exec
exit
exp
exp2
expm1
fabs
fchdir
fchmod
fchown
fclose
fcntl
fdatasync
fdim
fdopen
fdopendir
feclearexcept
fegetenv
fegetexceptflag
fegetround
feholdexcept
feof
feraiseexcept
ferror
fetestexcept
feupdateenv
fflush
ffs
fgetc
fgetpos
fgets
fgetwc
fgetws
fileno
flockfile
floor
fma
fmax
fmemopen
fmin
fmod
fmtmsg
fnmatch
fopen
fork
fpathconf
fpclassify
fprintf
fputc
fputs
fputwc
fputws
fread
free
freeaddrinfo
freelocale
freopen
frexp
fscanf
fseek
fsetpos
fstat
fstatat
fstatvfs
fsync
ftell
ftok
ftruncate
futimens
fwide
fwprintf
fwrite
fwscanf
gai_strerror
getc
getc_unlocked
getchar
getcwd
getdate
getdelim
getegid
getentropy
getenv
geteuid
getgid
getgrgid
getgrnam
getgroups
gethostid
gethostname
getlocalename_l
getlogin
getnameinfo
getopt
getpeername
getpgid
getpgrp
getpid
getppid
getpriority
getpwnam
getpwuid
getresgid
getresuid
getrlimit
getrusage
getsid
getsockname
getsockopt
getsubopt
gettext
getuid
getwc
getwchar
glob
gmtime
grantpt
hcreate
htonl
hypot
iconv
iconv_close
iconv_open
if_freenameindex
if_indextoname
if_nameindex
if_nametoindex
ilogb
imaxabs
imaxdiv
in6addr_any
inet_addr
inet_ntop
initstate
insque
isalnum
isalpha
isatty
isblank
iscntrl
isdigit
isfinite
isgraph
isgreater
isinf
islower
isnan
isnormal
isprint
ispunct
isspace
isunordered
isupper
iswalnum
iswalpha
iswblank
iswcntrl
iswctype
iswdigit
iswgraph
iswlower
iswprint
iswpunct
iswspace
iswupper
iswxdigit
isxdigit
j0
kill
kill_dependency
killpg
labs
lchown
ldexp
ldiv
lgamma
link
lio_listio
listen
llrint
llround
localeconv
localtime
lockf
log
log10
log1p
log2
logb
longjmp
lrint
lround
lsearch
lseek
malloc
mblen
mbrlen
mbrtoc16
mbrtowc
mbsinit
mbsrtowcs
mbstowcs
mbtowc
memccpy
memchr
memcmp
memcpy
memmem
memmove
memset
mkdir
mkdtemp
mkfifo
mknod
mktime
mlock
mlockall
mmap
modf
mprotect
mq_close
mq_getattr
mq_notify
mq_open
mq_receive
mq_send
mq_setattr
mq_unlink
msgctl
msgget
msgrcv
msgsnd
msync
mtx_destroy
mtx_lock
munmap
nan
nanosleep
nearbyint
newlocale
nextafter
nftw
nice
nl_langinfo
open
open_memstream
pause
pclose
perror
pipe
poll
popen
posix_devctl
posix_fadvise
posix_fallocate
posix_getdents
posix_madvise
posix_mem_offset
posix_memalign
posix_openpt
posix_spawn
posix_spawn_file_actions_addchdir
posix_spawn_file_actions_addclose
posix_spawn_file_actions_adddup2
posix_spawn_file_actions_destroy
posix_spawnattr_destroy
posix_spawnattr_getflags
posix_spawnattr_getpgroup
posix_spawnattr_getschedparam
posix_spawnattr_getschedpolicy
posix_spawnattr_getsigdefault
posix_spawnattr_getsigmask
posix_typed_mem_get_info
posix_typed_mem_open
pow
pselect
psiginfo
pthread_atfork
pthread_attr_destroy
pthread_attr_getdetachstate
pthread_attr_getguardsize
pthread_attr_getinheritsched
pthread_attr_getschedparam
pthread_attr_getschedpolicy
pthread_attr_getscope
pthread_attr_getstack
pthread_attr_getstacksize
pthread_barrier_destroy
pthread_barrier_wait
pthread_barrierattr_destroy
pthread_barrierattr_getpshared
pthread_cancel
pthread_cleanup_pop
pthread_cond_broadcast
pthread_cond_clockwait
pthread_cond_destroy
pthread_condattr_destroy
pthread_condattr_getclock
pthread_condattr_getpshared
pthread_create
pthread_detach
pthread_equal
pthread_exit
pthread_getcpuclockid
pthread_getschedparam
pthread_getspecific
pthread_join
pthread_key_create
pthread_key_delete
pthread_kill
pthread_mutex_clocklock
pthread_mutex_consistent
pthread_mutex_destroy
pthread_mutex_getprioceiling
pthread_mutex_lock
pthread_mutexattr_destroy
pthread_mutexattr_getprioceiling
pthread_mutexattr_getprotocol
pthread_mutexattr_getpshared
pthread_mutexattr_getrobust
pthread_mutexattr_gettype
pthread_once
pthread_rwlock_clockrdlock
pthread_rwlock_clockwrlock
pthread_rwlock_destroy
pthread_rwlock_rdlock
pthread_rwlock_trywrlock
pthread_rwlock_unlock
pthread_rwlockattr_destroy
pthread_rwlockattr_getpshared
pthread_self
pthread_setcancelstate
pthread_setschedprio
pthread_sigmask
pthread_spin_destroy
pthread_spin_lock
pthread_spin_unlock
ptsname
putc
putchar
putenv
puts
putwc
putwchar
qsort
quick_exit
raise
rand
read
readdir
readlink
readv
realloc
realpath
recv
recvfrom
recvmsg
regcomp
remainder
remove
remquo
rename
rewind
rewinddir
rint
rmdir
round
scalbln
sched_get_priority_max
sched_getparam
sched_getscheduler
sched_rr_get_interval
sched_setparam
sched_setscheduler
sched_yield
seekdir
sem_clockwait
sem_close
sem_destroy
sem_getvalue
sem_init
sem_open
sem_post
sem_trywait
sem_unlink
semctl
semget
semop
send
sendmsg
sendto
setbuf
setegid
setenv
seteuid
setgid
setjmp
setkey
setlocale
setpgid
setregid
setresgid
setresuid
setreuid
setsid
setsockopt
setuid
setvbuf
shm_open
shm_unlink
shmat
shmctl
shmdt
shmget
shutdown
sig2str
sigaction
sigaddset
sigaltstack
sigdelset
sigemptyset
sigfillset
sigismember
siglongjmp
signal
signbit
sigpending
sigqueue
sigsetjmp
sigsuspend
sigtimedwait
sigwait
sin
sinh
sleep
sockatmark
socket
socketpair
sqrt
stdin
strcasecmp
strcat
strchr
strcmp
strcoll
strcpy
strcspn
strdup
strerror
strfmon
strftime
strlcat
strlen
strncat
strncmp
strncpy
strpbrk
strptime
strrchr
strsignal
strspn
strstr
strtod
strtoimax
strtok
strtol
strtoul
strxfrm
swab
symlink
sync
sysconf
system
tan
tanh
tcdrain
tcflow
tcflush
tcgetattr
tcgetpgrp
tcgetsid
tcgetwinsize
tcsendbreak
tcsetattr
tcsetpgrp
tcsetwinsize
tdelete
telldir
tgamma
thrd_create
thrd_current
thrd_detach
thrd_equal
thrd_exit
thrd_join
thrd_sleep
thrd_yield
time
timer_create
timer_delete
timer_getoverrun
times
timespec_get
tmpfile
tmpnam
tolower
toupper
towctrans
towlower
towupper
trunc
truncate
tss_create
tss_delete
tss_get
ttyname
tzset
umask
uname
ungetc
ungetwc
unlink
unlockpt
unsetenv
uselocale
vfprintf
vfscanf
vfwprintf
vfwscanf
wait
waitid
wcrtomb
wcscasecmp
wcscat
wcschr
wcscmp
wcscoll
wcscpy
wcscspn
wcsdup
wcsftime
wcslcat
wcslen
wcsncat
wcsncmp
wcsncpy
wcspbrk
wcsrchr
wcsrtombs
wcsspn
wcsstr
wcstod
wcstoimax
wcstok
wcstol
wcstombs
wcstoul
wcswidth
wcsxfrm
wctob
wctomb
wctrans
wctype
wcwidth
wmemchr
wmemcmp
wmemcpy
wmemmove
wmemset
wordexp
write
writev
y0
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index |
XBD |
XSH |
XCU |
XRAT ]
===== susv5-html/functions/pselect.html =====
pselect
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pselect, select — synchronous I/O multiplexing
SYNOPSIS
#include
int pselect(int nfds, fd_set *restrict readfds,
fd_set *restrict writefds, fd_set *restrict errorfds,
const struct timespec *restrict timeout,
const sigset_t *restrict sigmask);
int select(int nfds, fd_set *restrict readfds,
fd_set *restrict writefds, fd_set *restrict errorfds,
struct timeval *restrict timeout);
void FD_CLR(int fd, fd_set *fdset);
int FD_ISSET(int fd, const fd_set *fdset);
void FD_SET(int fd, fd_set *fdset);
void FD_ZERO(fd_set *fdset);
DESCRIPTION
The pselect() function shall examine the file descriptor sets whose addresses are passed in the readfds,
writefds, and errorfds parameters to see whether some of their descriptors are ready for reading, are ready for
writing, or have an exceptional condition pending, respectively.
The select() function shall be equivalent to the pselect() function, except as follows:
For the select() function, the timeout period is given in seconds and microseconds in an argument of type struct
timeval, whereas for the pselect() function the timeout period is given in seconds and nanoseconds in an argument of
type struct timespec.
The select() function has no sigmask argument; it shall behave as pselect() does when sigmask is a
null pointer.
Upon successful completion, the select() function may modify the object pointed to by the timeout argument.
The pselect() and select() functions shall support regular files, terminal and pseudo-terminal devices, FIFOs,
pipes, and sockets. The behavior of pselect() and select() on file descriptors that refer to other types of file is
unspecified.
The nfds argument specifies the range of descriptors to be tested. The first nfds descriptors shall be checked in
each set; that is, the descriptors from zero through nfds-1 in the descriptor sets shall be examined.
If the readfds argument is not a null pointer, it points to an object of type fd_set that on input specifies the
file descriptors to be checked for being ready to read, and on output indicates which file descriptors are ready to read.
If the writefds argument is not a null pointer, it points to an object of type fd_set that on input specifies the
file descriptors to be checked for being ready to write, and on output indicates which file descriptors are ready to write.
If the errorfds argument is not a null pointer, it points to an object of type fd_set that on input specifies the
file descriptors to be checked for error conditions pending, and on output indicates which file descriptors have error conditions
pending.
Upon successful completion, the pselect() or select() function shall modify the objects pointed to by the
readfds, writefds, and errorfds arguments to indicate which file descriptors are ready for reading, ready for
writing, or have an error condition pending, respectively, and shall return the total number of ready descriptors in all the output
sets. For each file descriptor less than nfds, the corresponding bit shall be set upon successful completion if it was set
on input and the associated condition is true for that file descriptor.
If none of the selected descriptors are ready for the requested operation, the pselect() or select() function
shall block until at least one of the requested operations becomes ready, until the timeout occurs, or until interrupted by
a signal. The timeout parameter controls how long the pselect() or select() function shall take before timing
out. If the timeout parameter is not a null pointer, it specifies a maximum interval to wait for the selection to complete.
If the specified time interval expires without any requested operation becoming ready, the function shall return. If the
timeout parameter is a null pointer, then the call to pselect() or select() shall block indefinitely until at
least one descriptor meets the specified criteria. To effect a poll, the timeout parameter should not be a null pointer, and
should point to a zero-valued timespec structure.
The use of a timeout does not affect any pending timers set up by alarm().
Implementations may place limitations on the maximum timeout interval supported. All implementations shall support a maximum
timeout interval of at least 31 days. If the timeout argument specifies a timeout interval greater than the
implementation-defined maximum value, the maximum value shall be used as the actual timeout value. Implementations may also place
limitations on the granularity of timeout intervals. If the requested timeout interval requires a finer granularity than the
implementation supports, the actual timeout interval shall be rounded up to the next supported value.
If sigmask is not a null pointer, then the pselect() function shall replace the signal mask of the caller by the
set of signals pointed to by sigmask before examining the descriptors, and shall restore the signal mask of the calling
thread before returning. If a signal is unmasked as a result of the signal mask being altered by pselect(), and a
signal-catching function is called for that signal during the execution of the pselect() function, and SA_RESTART is clear
for the interrupting signal, then
If none of the selected file descriptors are ready, pselect() shall immediately fail with the [EINTR] error after the
signal-catching function returns.
If one or more of the selected file descriptors are ready, it is unspecified whether pselect() behaves the same as if
none of the descriptors were ready (failing with [EINTR] as above) or behaves the same as if it was not interrupted (returning the
total number of ready descriptors).
A descriptor shall be considered ready for reading when a call to an input function with O_NONBLOCK clear would not block,
whether or not the function would transfer data successfully. (The function might return data, an end-of-file indication, or an
error other than one indicating that it is blocked, and in each of these cases the descriptor shall be considered ready for
reading.)
A descriptor shall be considered ready for writing when a call to an output function with O_NONBLOCK clear would not block,
whether or not the function would transfer data successfully.
If a socket has a pending error, it shall be considered to have an exceptional condition pending. Otherwise, what constitutes an
exceptional condition is file type-specific. For a file descriptor for use with a socket, it is protocol-specific except as noted
below. For other file types it is implementation-defined. If the operation is meaningless for a particular file type,
pselect() or select() shall indicate that the descriptor is ready for read or write operations, and shall indicate
that the descriptor has no exceptional condition pending.
If a descriptor refers to a socket, the implied input function is the recvmsg()
function with parameters requesting normal and ancillary data, such that the presence of either type shall cause the socket to be
marked as readable. The presence of out-of-band data shall be checked if the socket option SO_OOBINLINE has been enabled, as
out-of-band data is enqueued with normal data. If the socket is currently listening, then it shall be marked as readable if an
incoming connection request has been received, and a call to the accept() or accept4() function shall complete without blocking.
If a descriptor refers to a socket, the implied output function is the sendmsg()
function supplying an amount of normal data equal to the current value of the SO_SNDLOWAT option for the socket. If a non-blocking
call to the connect() function has been made for a socket, and the connection
attempt has either succeeded or failed leaving a pending error, the socket shall be marked as writable.
A socket shall be considered to have an exceptional condition pending if a receive operation with O_NONBLOCK clear for the open
file description and with the MSG_OOB flag set would return out-of-band data without blocking. (It is protocol-specific whether the
MSG_OOB flag would be used to read out-of-band data.) A socket shall also be considered to have an exceptional condition pending if
an out-of-band data mark is present in the receive queue. Other circumstances under which a socket may be considered to have an
exceptional condition pending are protocol-specific and implementation-defined.
If the readfds, writefds, and errorfds arguments are all null pointers and the timeout argument is
not a null pointer, the pselect() or select() function shall block for the time specified, or until interrupted by a
signal. If the readfds, writefds, and errorfds arguments are all null pointers and the timeout argument
is a null pointer, the pselect() or select() function shall block until interrupted by a signal.
File descriptors associated with regular files shall always select true for ready to read, ready to write, and error
conditions.
On failure, the objects pointed to by the readfds, writefds, and errorfds arguments shall not be modified.
If the timeout interval expires without the specified condition being true for any of the specified file descriptors, the objects
pointed to by the readfds, writefds, and errorfds arguments shall have all bits set to 0.
File descriptor masks of type fd_set can be initialized and tested with FD_CLR(), FD_ISSET(),
FD_SET(), and FD_ZERO(). It is unspecified whether each of these is a macro or a function. If a macro definition is
suppressed in order to access an actual function, or a program defines an external identifier with any of these names, the behavior
is undefined.
FD_CLR(fd, fdsetp) shall remove the file descriptor fd from the set pointed to by fdsetp. If
fd is not a member of this set, there shall be no effect on the set, and this shall not be treated as an error.
FD_ISSET(fd, fdsetp) shall evaluate to non-zero if the file descriptor fd is a member of the set
pointed to by fdsetp, and shall evaluate to zero otherwise.
FD_SET(fd, fdsetp) shall add the file descriptor fd to the set pointed to by fdsetp. If the
file descriptor fd is already in this set, there shall be no effect on the set, and this shall not be treated as an
error.
FD_ZERO(fdsetp) shall initialize the descriptor set pointed to by fdsetp to the null set. No error is
returned if the set is not empty at the time FD_ZERO() is invoked.
The behavior of these macros is undefined if the fd argument is less than 0 or greater than or equal to FD_SETSIZE, or if
fd is not a valid file descriptor, or if any of the arguments are expressions with side-effects.
If a thread gets canceled during a pselect() call, the signal mask in effect when executing the registered cleanup
functions is either the original signal mask or the signal mask installed as part of the pselect() call.
RETURN VALUE
Upon successful completion, the pselect() and select() functions shall return the total number of bits set in the
bit masks. Otherwise, -1 shall be returned, and errno shall be set to indicate the error.
FD_CLR(), FD_SET(), and FD_ZERO() do not return a value. FD_ISSET() shall return a non-zero value if
the bit for the file descriptor fd is set in the file descriptor set pointed to by fdset, and 0 otherwise.
ERRORS
Under the following conditions, pselect() and select() shall fail and set errno to:
[EBADF]
One or more of the file descriptor sets specified a file descriptor that is not a valid open file descriptor.
[EINTR]
The function was interrupted by a signal.
If SA_RESTART has been set for the interrupting signal, it is implementation-defined whether the function restarts or returns
with [EINTR].
[EINVAL]
An invalid timeout interval was specified.
[EINVAL]
The nfds argument is less than 0 or greater than FD_SETSIZE.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The use of select() and pselect() requires that the application construct the set of file descriptors to work on
each time through a polling loop, and is inherently limited from operating on file descriptors larger than FD_SETSIZE. Also, the
amount of work to perform scales as nfds increases, even if the number of file descriptors selected within the larger set
remains the same. Thus, applications may wish to consider using poll() and ppoll() instead, for better scaling.
When a pselect() or select() call indicates a file descriptor is ready for reading, this means that if an attempt
to read data had been made at the time that the status of the file descriptor was checked, it would have returned at least one byte
of data, an end-of-file indication, or an error, without blocking (even if O_NONBLOCK is clear). When a pselect() or
select() call indicates that a file descriptor is ready for writing, this means that if an attempt to write one byte of data
had been made at the time that the status of the file descriptor was checked, it would have written that byte or returned an error,
without blocking. However, if an attempt to write more than one byte had been made, it might have blocked (if O_NONBLOCK is clear).
In both cases, by the time the call returns and a subsequent I/O operation is attempted, the state of the file descriptor might
have changed (for example, because another thread read or wrote some data) and, if O_NONBLOCK is clear, there is no guarantee that
the operation will not block (unless it would not block for some other reason, such as setting MIN=0 and TIME=0 for a terminal in
non-canonical mode). Therefore it is recommended that applications always set O_NONBLOCK on file descriptors whose readiness for
I/O they query with pselect() or select().
RATIONALE
In earlier versions of the Single UNIX Specification, the select() function was defined in the  header. This is now changed to . The rationale for this change was as follows: the introduction of
the pselect() function included the  header and the
header defines all the related definitions for the
pselect() and select() functions. Backwards-compatibility to existing XSI implementations is handled by allowing
to include .
Code which wants to avoid the ambiguity of the signal mask for thread cancellation handlers can install an additional
cancellation handler which resets the signal mask to the expected value.
void cleanup(void *arg)
{
sigset_t *ss = (sigset_t *) arg;
pthread_sigmask(SIG_SETMASK, ss, NULL);
}
int call_pselect(int nfds, fd_set *readfds, fd_set *writefds,
fd_set errorfds, const struct timespec *timeout,
const sigset_t *sigmask)
{
sigset_t oldmask;
int result;
pthread_sigmask(SIG_SETMASK, NULL, &oldmask);
pthread_cleanup_push(cleanup, &oldmask);
result = pselect(nfds, readfds, writefds, errorfds, timeout, sigmask);
pthread_cleanup_pop(0);
return result;
}
FUTURE DIRECTIONS
None.
SEE ALSO
accept(), alarm(), connect(), fcntl(), poll(), read(), recvmsg(), sendmsg(), write()
XBD ,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
In the ERRORS section, the text has been changed to indicate that [EINVAL] is returned when nfds is less than 0 or
greater than FD_SETSIZE. It previously stated less than 0, or greater than or equal to FD_SETSIZE.
Text about timeout is moved from the APPLICATION USAGE section to the DESCRIPTION.
Issue 6
The Open Group Corrigendum U026/6 is applied, changing the occurrences of readfs and writefs in the
select() DESCRIPTION to be readfds and writefds.
Text referring to sockets is added to the DESCRIPTION.
The DESCRIPTION and ERRORS sections are updated so that references to STREAMS are marked as part of the XSI STREAMS Option
Group.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
These functions are now mandatory.
The pselect() function is added for alignment with IEEE Std 1003.1g-2000 and additional detail related to
sockets semantics is added to the DESCRIPTION.
The select() function now requires inclusion of .
The restrict keyword is added to the select() prototype for alignment with the ISO/IEC 9899:1999
standard.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/70 is applied, updating the DESCRIPTION to reference the signal
mask in terms of the calling thread rather than the process.
Issue 7
SD5-XSH-ERN-122 is applied, adding text to the DESCRIPTION for when a thread is canceled during a call to pselect(), and
adding example code to the RATIONALE.
Functionality relating to the XSI STREAMS option is marked obsolescent.
Functionality relating to the Threads option is moved to the Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0446 [372] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0259 [680] is applied.
Issue 8
Austin Group Defect 220 is applied, adding const to the second parameter of FD_ISSET().
Austin Group Defect 411 is applied, adding accept4().
Austin Group Defect 1186 is applied, clarifying the behavior when the pselect() function is interrupted by a signal.
Austin Group Defect 1263 is applied, changing the APPLICATION USAGE section.
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
Austin Group Defect 1448 is applied, changing the APPLICATION USAGE section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/ldexpf.html =====
ldexp
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ldexp, ldexpf, ldexpl — load exponent of a floating-point number
SYNOPSIS
#include
double ldexp(double x, int exp);
float ldexpf(float x, int exp);
long double ldexpl(long double x, int exp);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the quantity x * 2exp.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return x multiplied by 2, raised to the power exp.
If these functions would cause overflow, a range error shall occur and ldexp(), ldexpf(), and ldexpl()
shall return ±HUGE_VAL, ±HUGE_VALF, and ±HUGE_VALL (according to the sign of x), respectively.
If the correct value would cause underflow, [MXX]   and is not representable,   a range error may occur, and ldexp(), ldexpf(), and ldexpl() shall return
[MXX]
0.0, or   (if IEC 60559 Floating-Point is not supported)
an implementation-defined value no greater in magnitude than DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0 or ±Inf, x shall be returned.
If exp is 0, x shall be returned.
[MXX]
If the correct value would cause underflow, and is representable, a range error may occur and the correct value shall be returned.
ERRORS
These functions shall fail if:
Range Error
The result overflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall be
raised.
These functions may fail if:
Range Error
The result underflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), frexp(), isnan()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The ldexpf() and ldexpl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0352 [68] and XSH/TC1-2008/0353 [68] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wcstoul.html =====
wcstoul
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wcstoul, wcstoull — convert a wide-character string to an unsigned long
SYNOPSIS
#include
unsigned long wcstoul(const wchar_t *restrict nptr,
wchar_t **restrict endptr, int base);
unsigned long long wcstoull(const wchar_t *restrict nptr,
wchar_t **restrict endptr, int base);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The wcstoul() and wcstoull() functions shall convert the initial portion of the wide-character string pointed to
by nptr to unsigned long and unsigned long long representation, respectively. First, they shall decompose the
input wide-character string into three parts:
An initial, possibly empty, sequence of white-space wide characters
A subject sequence interpreted as an integer represented in some radix determined by the value of base
A final wide-character string of one or more unrecognized wide-character codes, including the terminating null wide-character
code of the input wide-character string
Then they shall attempt to convert the subject sequence to an unsigned integer, and return the result.
If base is 0, the expected form of the subject sequence is that of a decimal constant, octal constant, or hexadecimal
constant, any of which may be preceded by a '+' or '-' sign. A decimal constant begins with a non-zero digit, and
consists of a sequence of decimal digits. An octal constant consists of the prefix '0' optionally followed by a sequence
of the digits '0' to '7' only. A hexadecimal constant consists of the prefix 0x or 0X followed by a sequence of
the decimal digits and letters 'a' (or 'A') to 'f' (or 'F') with values 10 to 15
respectively.
If the value of base is between 2 and 36, the expected form of the subject sequence is a sequence of letters and digits
representing an integer with the radix specified by base, optionally preceded by a '+' or '-' sign, but
not including an integer suffix. The letters from 'a' (or 'A') to 'z' (or 'Z') inclusive are
ascribed the values 10 to 35; only letters whose ascribed values are less than that of base shall be permitted. If the value
of base is 16, the wide-character codes 0x or 0X may optionally precede the sequence of letters and digits, following the
sign if present.
The subject sequence is defined as the longest initial subsequence of the input wide-character string, starting with the first
non-white-space wide character, that is of the expected form. The subject sequence contains no wide-character codes if the input
wide-character string is empty or consists entirely of white-space wide characters, or if the first non-white-space wide character
is other than a sign or a permissible letter or digit.
If the subject sequence has the expected form and base is 0, the sequence of wide-character codes starting with the first
digit shall be interpreted as an integer constant. If the subject sequence has the expected form and the value of base is
between 2 and 36, it shall be used as the base for conversion, ascribing to each letter its value as given above. If the subject
sequence begins with a , the resulting value shall be the negative of the converted value; this action shall be
performed in the return type. A pointer to the final wide-character string shall be stored in the object pointed to by
endptr, provided that endptr is not a null pointer.
In other than the C [CX]   or POSIX  locale, additional
locale-specific subject sequence forms may be accepted.
If the subject sequence is empty or does not have the expected form, no conversion shall be performed; the value of nptr
shall be stored in the object pointed to by endptr, provided that endptr is not a null pointer.
These functions shall not change the setting of errno if successful.
Since 0, {ULONG_MAX}, and {ULLONG_MAX} are returned on error and 0 is also a valid return on success, an application wishing to
check for error situations should set errno to 0, then call wcstoul() or wcstoull(), then check
errno.
RETURN VALUE
Upon successful completion, the wcstoul() and wcstoull() functions shall return the converted value, if any. If no
conversion could be performed, 0 shall be returned [CX]   and errno may be set to indicate the error.  If the correct value is outside the range of representable values,
{ULONG_MAX} or {ULLONG_MAX} respectively shall be returned and errno set to [ERANGE].
ERRORS
These functions shall fail if:
[EINVAL]
[CX]
The value of base is not supported.
[ERANGE]
The value to be returned is not representable.
These functions may fail if:
[EINVAL]
[CX]  No
conversion could be performed.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
fscanf(), iswalpha(), wcstod(), wcstol()
XBD
CHANGE HISTORY
First released in Issue 4. Derived from the MSE working draft.
Issue 5
The DESCRIPTION is updated to indicate that errno is not changed if the function is successful.
Issue 6
Extensions beyond the ISO C standard are marked.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The [EINVAL] error condition is added for when the value of base is not supported.
In the RETURN VALUE and ERRORS sections, the [EINVAL] optional error condition is added if no conversion could be performed.
The following changes are made for alignment with the ISO/IEC 9899:1999 standard:
The wcstoul() prototype is updated.
The wcstoull() function is added.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0727 [105] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0395 [584] and XSH/TC2-2008/0396 [796] are applied.
Issue 8
Austin Group Defect 700 is applied, clarifying how a subject sequence beginning with  is converted.
Austin Group Defect 1163 is applied, clarifying the handling of white space in the input string.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/nearbyintl.html =====
nearbyint
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
nearbyint, nearbyintf, nearbyintl — floating-point rounding functions
SYNOPSIS
#include
double nearbyint(double x);
float nearbyintf(float x);
long double nearbyintl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall round their argument to an integer value in floating-point format, using the current rounding direction
and without raising the inexact floating-point exception.
RETURN VALUE
Upon successful completion, these functions shall return the rounded integer value. [MX]   The result
shall have the same sign as x.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0, ±0 shall be returned.
If x is ±Inf, x shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The integral value returned by these functions need not be expressible as an intmax_t. The return value should be tested
before assigning it to an integer type to avoid the undefined results of an integer overflow.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0402 [346,428] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_condattr_getclock.html =====
pthread_condattr_getclock
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_condattr_getclock, pthread_condattr_setclock — get and set the clock selection condition variable
attribute
SYNOPSIS
#include
int pthread_condattr_getclock(const pthread_condattr_t *restrict attr,
clockid_t *restrict clock_id);
int pthread_condattr_setclock(pthread_condattr_t *attr,
clockid_t clock_id);
DESCRIPTION
The pthread_condattr_getclock() function shall obtain the value of the clock attribute from the attributes object
referenced by attr.
The pthread_condattr_setclock() function shall set the clock attribute in an initialized attributes object
referenced by attr. If pthread_condattr_setclock() is called with a clock_id argument that refers to a
CPU-time clock, the call shall fail.
The clock attribute is the clock ID of the clock that shall be used to measure the timeout service of pthread_cond_timedwait(). The default value of the clock attribute
shall refer to the system clock. The clock attribute shall have no effect on the pthread_cond_clockwait() function.
The behavior is undefined if the value specified by the attr argument to pthread_condattr_getclock() or
pthread_condattr_setclock() does not refer to an initialized condition variable attributes object.
RETURN VALUE
If successful, the pthread_condattr_getclock() function shall return zero and store the value of the clock attribute of
attr into the object referenced by the clock_id argument. Otherwise, an error number shall be returned to indicate
the error.
If successful, the pthread_condattr_setclock() function shall return zero; otherwise, an error number shall be returned
to indicate the error.
ERRORS
The pthread_condattr_setclock() function may fail if:
[EINVAL]
The value specified by clock_id does not refer to a known clock, or is a CPU-time clock.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
If an implementation detects that the value specified by the attr argument to pthread_condattr_getclock() or
pthread_condattr_setclock() does not refer to an initialized condition variable attributes object, it is recommended that
the function should fail and report an [EINVAL] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_cond_clockwait(), pthread_cond_destroy(), pthread_condattr_destroy(), pthread_condattr_getpshared(), pthread_create(), pthread_mutex_destroy()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1j-2000.
Issue 7
The pthread_condattr_getclock() and pthread_condattr_setclock() functions are moved from the Clock Selection
option to the Base.
The [EINVAL] error for an uninitialized condition variable attributes object is removed; this condition results in undefined
behavior.
Issue 8
Austin Group Defect 1216 is applied, adding pthread_cond_clockwait().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/atomic_compare_exchange_strong_explicit.html =====
atomic_compare_exchange_strong
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
atomic_compare_exchange_strong, atomic_compare_exchange_strong_explicit, atomic_compare_exchange_weak,
atomic_compare_exchange_weak_explicit — atomically compare and exchange the values of two objects
SYNOPSIS
#include
_Bool atomic_compare_exchange_strong(volatile A *object,
C *expected, C desired);
_Bool atomic_compare_exchange_strong_explicit(volatile A *object,
C *expected, C desired, memory_order
success, memory_order failure);
_Bool atomic_compare_exchange_weak(volatile A *object,
C *expected, C desired);
_Bool atomic_compare_exchange_weak_explicit(volatile A *object,
C *expected, C desired, memory_order
success, memory_order failure);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
Implementations that define the macro __STDC_NO_ATOMICS__ need not provide the  header nor support these generic functions.
The atomic_compare_exchange_strong_explicit() generic function shall atomically compare the contents of the memory
pointed to by object for equality with that pointed to by expected, and if true, shall replace the contents of the
memory pointed to by object with desired, and if false, shall update the contents of the memory pointed to by
expected with that pointed to by object. This operation shall be an atomic read-modify-write operation (see XBD
4.15.1 Memory Ordering). If the comparison is true, memory
shall be affected according to the value of success, and if the comparison is false, memory shall be affected
according to the value of failure. The application shall ensure that failure is not memory_order_release nor
memory_order_acq_rel, and shall ensure that failure is no stronger than success.
The atomic_compare_exchange_strong() generic function shall be equivalent to
atomic_compare_exchange_strong_explicit() called with success and failure both set to
memory_order_seq_cst.
The atomic_compare_exchange_weak_explicit() generic function shall be equivalent to
atomic_compare_exchange_strong_explicit(), except that the compare-and-exchange operation may fail spuriously. That is, even
when the contents of memory referred to by expected and object are equal, it may return zero and store back to
expected the same memory contents that were originally there.
The atomic_compare_exchange_weak() generic function shall be equivalent to atomic_compare_exchange_weak_explicit()
called with success and failure both set to memory_order_seq_cst.
RETURN VALUE
These generic functions shall return the result of the comparison.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
A consequence of spurious failure is that nearly all uses of weak compare-and-exchange will be in a loop. For example:
exp = atomic_load(&cur);
do {
des = function(exp);
} while (!atomic_compare_exchange_weak(&cur, &exp, des));
When a compare-and-exchange is in a loop, the weak version will yield better performance on some platforms. When a weak
compare-and-exchange would require a loop and a strong one would not, the strong one is preferable.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD 4.15.1 Memory Ordering,
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/erfl.html =====
erf
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
erf, erff, erfl — error functions
SYNOPSIS
#include
double erf(double x);
float erff(float x);
long double erfl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the error function of their argument x, defined as:
\( \frac{2}{\sqrt{\pi}} \int_0^x e^{-t^2} d t\)
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the value of the error function.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0, ±0 shall be returned.
If x is ±Inf, ±1 shall be returned.
If the correct value would cause underflow, a range error may occur, and erf(), erff(), and erfl() shall
return an implementation-defined value no greater in magnitude than DBL_MIN, FLT_MIN, and LDBL_MIN, respectively. [MXX]   If the IEC
60559 Floating-Point option is supported, 2* x/ sqrt() should be returned.
ERRORS
These functions may fail if:
Range Error
[MX]
The result underflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If
the integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception
shall be raised.
The following sections are informative.
EXAMPLES
Computing the Probability for a Normal Variate
This example shows how to use erf() to compute the probability that a normal variate assumes a value in the range
[x1,x2] with x1
double
Phi(const double x1, const double x2)
{
return ( erf(x2*M_SQRT1_2) - erf(x1*M_SQRT1_2) ) / 2;
}
APPLICATION USAGE
Underflow occurs when |x|
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The erf() function is no longer marked as an extension.
The erfc() function is split out onto its own reference page.
The erff() and erfl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/22 is applied, adding the example to the EXAMPLES section.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0092 [68] is applied.
Issue 8
Austin Group Defect 1178 is applied, joining two paragraphs in the RETURN VALUE section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_attr_getstacksize.html =====
pthread_attr_getstacksize
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_attr_getstacksize, pthread_attr_setstacksize — get and set the stacksize attribute
SYNOPSIS
[TSS]  #include
int pthread_attr_getstacksize(const pthread_attr_t *restrict attr,
size_t *restrict stacksize);
int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);
DESCRIPTION
The pthread_attr_getstacksize() and pthread_attr_setstacksize() functions, respectively, shall get and set the
thread creation stacksize attribute in the attr object.
The stacksize attribute shall define the minimum stack size (in bytes) allocated for the created threads stack.
The behavior is undefined if the value specified by the attr argument to pthread_attr_getstacksize() or
pthread_attr_setstacksize() does not refer to an initialized thread attributes object.
RETURN VALUE
Upon successful completion, pthread_attr_getstacksize() and pthread_attr_setstacksize() shall return a value of 0;
otherwise, an error number shall be returned to indicate the error.
The pthread_attr_getstacksize() function stores the stacksize attribute value in stacksize if
successful.
ERRORS
The pthread_attr_setstacksize() function shall fail if:
[EINVAL]
The value of stacksize is less than {PTHREAD_STACK_MIN} or exceeds a system-imposed limit.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
If an implementation detects that the value specified by the attr argument to pthread_attr_getstacksize() or
pthread_attr_setstacksize() does not refer to an initialized thread attributes object, it is recommended that the function
should fail and report an [EINVAL] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_attr_destroy(), pthread_attr_getdetachstate(), pthread_create()
XBD ,
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
The pthread_attr_getstacksize() and pthread_attr_setstacksize() functions are marked as part of the Threads and
Thread Stack Size Attribute options.
The restrict keyword is added to the pthread_attr_getstacksize() prototype for alignment with the
ISO/IEC 9899:1999 standard.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/43 is applied, correcting the margin code in the SYNOPSIS from
TSA to TSS and updating the CHANGE HISTORY from "Thread Stack Address Attribute" option to "Thread Stack Size Attribute"
option.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/87 is applied, updating the ERRORS section to include optional
errors for the case when attr refers to an uninitialized thread attribute object.
Issue 7
The pthread_attr_getstacksize() and pthread_attr_setstacksize() functions are marked only as part of the Thread
Stack Size Attribute option as the Threads option is now part of the Base.
The [EINVAL] error for an uninitialized thread attributes object is removed; this condition results in undefined behavior.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0265 [757] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/timer_settime.html =====
timer_getoverrun
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
timer_getoverrun, timer_gettime, timer_settime — per-process timers
SYNOPSIS
[CX]  #include
int timer_getoverrun(timer_t timerid);
int timer_gettime(timer_t timerid, struct itimerspec *value);
int timer_settime(timer_t timerid, int flags,
const struct itimerspec *restrict value,
struct itimerspec *restrict ovalue);
DESCRIPTION
The timer_gettime() function shall store the amount of time until the specified timer, timerid, expires and the
reload value of the timer into the space pointed to by the value argument. The it_value member of this structure
shall contain the amount of time before the timer expires, or zero if the timer is disarmed. This value is returned as the interval
until timer expiration, even if the timer was armed with absolute time. The it_interval member of value shall contain
the reload value last set by timer_settime().
The timer_settime() function shall set the time until the next expiration of the timer specified by timerid from
the it_value member of the value argument and arm the timer if the it_value member of value is
non-zero. If the specified timer was already armed when timer_settime() is called, this call shall reset the time until next
expiration to the value specified. If the it_value member of value is zero, the timer shall be disarmed. The
effect of disarming or resetting a timer with pending expiration notifications is unspecified.
If the flag TIMER_ABSTIME is not set in the argument flags, timer_settime() shall behave as if the time until next
expiration is set to be equal to the interval specified by the it_value member of value. That is, the timer shall
expire in it_value nanoseconds from when the call is made. If the flag TIMER_ABSTIME is set in the argument flags,
timer_settime() shall behave as if the time until next expiration is set to be equal to the difference between the absolute
time specified by the it_value member of value and the current value of the clock associated with timerid.
That is, the timer shall expire when the clock reaches the value specified by the it_value member of value. If the
specified time has already passed, the function shall succeed and the expiration notification shall be made.
The reload value of the timer shall be set to the value specified by the it_interval member of value. When a timer
is armed with a non-zero it_interval, a periodic (or repetitive) timer is specified.
Time values that are between two consecutive non-negative integer multiples of the resolution of the specified timer shall be
rounded up to the larger multiple of the resolution. Quantization error shall not cause the timer to expire earlier than the
rounded time value.
If the argument ovalue is not NULL, the timer_settime() function shall store, in the location referenced by
ovalue, a value representing the previous amount of time before the timer would have expired, or zero if the timer was
disarmed, together with the previous timer reload value. Timers shall not expire before their scheduled time.
Only a single signal shall be queued to the process for a given timer at any point in time. When a timer for which a signal is
still pending expires, no signal shall be queued, and a timer overrun shall occur. When a timer expiration signal is delivered to
or accepted by a process, the timer_getoverrun() function shall return the timer expiration overrun count for the specified
timer. The overrun count returned contains the number of extra timer expirations that occurred between the time the signal was
generated (queued) and when it was delivered or accepted, up to but not including an implementation-defined maximum of
{DELAYTIMER_MAX}. If the number of such extra expirations is greater than or equal to {DELAYTIMER_MAX}, then the overrun count
shall be set to {DELAYTIMER_MAX}. The value returned by timer_getoverrun() shall apply to the most recent expiration signal
delivery or acceptance for the timer. If no expiration signal has been delivered for the timer, the return value of
timer_getoverrun() is unspecified.
The behavior is undefined if the value specified by the timerid argument to timer_getoverrun(),
timer_gettime(), or timer_settime() does not correspond to a timer ID returned by timer_create() but not yet deleted by timer_delete().
RETURN VALUE
If the timer_getoverrun() function succeeds, it shall return the timer expiration overrun count as explained above.
If the timer_gettime() or timer_settime() functions succeed, a value of 0 shall be returned.
If an error occurs for any of these functions, the value -1 shall be returned, and errno set to indicate the error.
ERRORS
The timer_settime() function shall fail if:
[EINVAL]
A value structure specified a nanosecond value less than zero or greater than or equal to 1000 million, and the
it_value member of that structure did not specify zero seconds and nanoseconds.
The timer_settime() function may fail if:
[EINVAL]
The it_interval member of value is not zero and the timer was created with notification by creation of a new
thread (sigev_sigev_notify was SIGEV_THREAD) and a fixed stack address has been set in the thread attribute pointed to by
sigev_notify_attributes.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Using fixed stack addresses is problematic when timer expiration is signaled by the creation of a new thread. Since it cannot be
assumed that the thread created for one expiration is finished before the next expiration of the timer, it could happen that two
threads use the same memory as a stack at the same time. This is invalid and produces undefined results.
RATIONALE
Practical clocks tick at a finite rate, with rates of 100 hertz and 1000 hertz being common. The inverse of this tick rate is
the clock resolution, also called the clock granularity, which in either case is expressed as a time duration, being 10
milliseconds and 1 millisecond respectively for these common rates. The granularity of practical clocks implies that if one reads a
given clock twice in rapid succession, one may get the same time value twice; and that timers must wait for the next clock tick
after the theoretical expiration time, to ensure that a timer never returns too soon. Note also that the granularity of the clock
may be significantly coarser than the resolution of the data format used to set and get time and interval values. Also note that
some implementations may choose to adjust time and/or interval values to exactly match the ticks of the underlying clock.
This volume of POSIX.1-2024 defines functions that allow an application to determine the implementation-supported resolution for
the clocks and requires an implementation to document the resolution supported for timers and nanosleep() if they differ from the supported clock resolution. This is more of a
procurement issue than a runtime application issue.
If an implementation detects that the value specified by the timerid argument to timer_getoverrun(),
timer_gettime(), or timer_settime() does not correspond to a timer ID returned by timer_create() but not yet deleted by timer_delete(), it is recommended that the function should fail and report an [EINVAL]
error.
FUTURE DIRECTIONS
None.
SEE ALSO
clock_getres(), timer_create()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension.
Issue 6
The timer_getoverrun(), timer_gettime(), and timer_settime() functions are marked as part of the Timers
option.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Timers
option.
The [EINVAL] error condition is updated to include the following: "and the it_value member of that structure did not
specify zero seconds and nanoseconds." This change is for IEEE PASC Interpretation 1003.1 #89.
The DESCRIPTION for timer_getoverrun() is updated to clarify that "If no expiration signal has been delivered for the
timer, or if the Realtime Signals Extension is not supported, the return value of timer_getoverrun() is unspecified".
The restrict keyword is added to the timer_settime() prototype for alignment with the ISO/IEC 9899:1999
standard.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/140 is applied, updating the ERRORS section so that the
mandatory [EINVAL] error ("The timerid argument does not correspond to an ID returned by timer_create() but not yet deleted by timer_delete()") becomes optional.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/141 is applied, updating the ERRORS section to include an
optional [EINVAL] error for the case when a timer is created with the notification method set to SIGEV_THREAD. APPLICATION USAGE
text is also added.
Issue 7
The timer_getoverrun(), timer_gettime(), and timer_settime() functions are moved from the Timers option to
the Base.
Functionality relating to the Realtime Signals Extension option is moved to the Base.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0370 [659] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getnetent.html =====
endnetent
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
endnetent, getnetbyaddr, getnetbyname, getnetent, setnetent — network database functions
SYNOPSIS
#include
void endnetent(void);
struct netent *getnetbyaddr(uint32_t net, int type);
struct netent *getnetbyname(const char *name);
struct netent *getnetent(void);
void setnetent(int stayopen);
DESCRIPTION
These functions shall retrieve information about networks. This information is considered to be stored in a database that can be
accessed sequentially or randomly. The implementation of this database is unspecified.
The setnetent() function shall open and rewind the database. If the stayopen argument is non-zero, the connection
to the net database shall not be closed after each call to getnetent() (either directly, or indirectly through one of
the other getnet*() functions), and the implementation may maintain an open file descriptor to the database. If a file
descriptor is used, the FD_CLOEXEC flag shall be set; see .
The getnetent() function shall read the next entry of the database, opening and closing a connection to the database as
necessary.
The getnetbyaddr() function shall search the database from the beginning, and find the first entry for which the address
family specified by type matches the n_addrtype member and the network number net matches the n_net
member, opening and closing a connection to the database as necessary. The net argument shall be the network number in host
byte order.
The getnetbyname() function shall search the database from the beginning and find the first entry for which the network
name specified by name matches the n_name member, opening and closing a connection to the database as necessary.
The getnetbyaddr(), getnetbyname(), and getnetent() functions shall each return a pointer to a
netent structure, the members of which shall contain the fields of an entry in the network database.
The endnetent() function shall close the database, releasing any open file descriptor.
These functions need not be thread-safe.
RETURN VALUE
Upon successful completion, getnetbyaddr(), getnetbyname(), and getnetent() shall return a pointer to a
netent structure if the requested entry was found, and a null pointer if the end of the database was reached or the
requested entry was not found. Otherwise, a null pointer shall be returned.
The application shall not modify the structure to which the return value points, nor any storage areas pointed to by pointers
within the structure. The returned pointer, and pointers within the structure, might be invalidated or the structure or the storage
areas might be overwritten by a subsequent call to getnetbyaddr(), getnetbyname(), or getnetent(). The
returned pointer, and pointers within the structure, might also be invalidated if the calling thread is terminated.
ERRORS
The getnetbyaddr(), getnetbyname(), getnetent(), and setnetent() functions may fail if:
[EMFILE]
All file descriptors available to the process are currently open.
[ENFILE]
The maximum allowable number of files is currently open in the system.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD ,
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0083 [75] and XSH/TC1-2008/0084 [75] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0090 [656] is applied.
Issue 8
Austin Group Defect 368 is applied, adding a requirement for FD_CLOEXEC to be set if a file descriptor is used, and adding the
[EMFILE] and [ENFILE] errors.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/ceilf.html =====
ceil
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ceil, ceilf, ceill — ceiling value function
SYNOPSIS
#include
double ceil(double x);
float ceilf(float x);
long double ceill(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the smallest integral value not less than x.
[MX]
These functions may raise the inexact floating-point exception for finite non-integer arguments.
RETURN VALUE
[MX]  The
returned value shall be independent of the current rounding direction mode and shall have the same sign as x.
Upon successful completion, ceil(), ceilf(), and ceill() shall return the smallest integral value not less
than x, expressed as a type double, float, or long double, respectively.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0 or ±Inf, x shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The integral value returned by these functions need not be expressible as an intmax_t. The return value should be tested
before assigning it to an integer type to avoid the undefined results of an integer overflow.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), floor(), isnan()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The ceilf() and ceill() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0046 [346] is applied.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/iswdigit_l.html =====
iswdigit
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
iswdigit, iswdigit_l — test for a decimal digit wide-character code
SYNOPSIS
#include
int iswdigit(wint_t wc);
[CX]  int iswdigit_l(wint_t wc, locale_t locale);
DESCRIPTION
For iswdigit(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The iswdigit() [CX]   and iswdigit_l()
functions shall test whether wc is a wide-character code representing a character of class digit in the current
locale, [CX]   or in the locale represented by locale,
respectively; see XBD 7. Locale.
The wc argument is a wint_t, the value of which the application shall ensure is a wide-character code
corresponding to a valid character in the locale used by the function, or equal to the value of the macro WEOF. If the argument has
any other value, the behavior is undefined.
[CX]  The
behavior is undefined if the locale argument to iswdigit_l() is the special locale object LC_GLOBAL_LOCALE or is not
a valid locale object handle.
RETURN VALUE
The iswdigit() [CX]   and iswdigit_l()
functions shall return non-zero if wc is a decimal digit wide-character code; otherwise, they shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
To ensure applications portability, especially across natural languages, only these functions and the functions in the reference
pages listed in the SEE ALSO section should be used for character classification.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
iswalnum(), iswalpha(),
iswcntrl(), iswctype(),
iswgraph(), iswlower(),
iswprint(), iswpunct(),
iswspace(), iswupper(),
iswxdigit(), setlocale(),
uselocale()
XBD 7. Locale, ,
CHANGE HISTORY
First released in Issue 4.
Issue 5
The following change has been made in this version for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E):
The SYNOPSIS has been changed to indicate that this function and associated data types are now made visible by inclusion of the
header rather than .
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
The iswdigit_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0323 [302], XSH/TC1-2008/0324 [283], and XSH/TC1-2008/0325 [283] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0186 [685] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/atol.html =====
atol
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
atol, atoll — convert a string to a long integer
SYNOPSIS
#include
long atol(const char *nptr);
long long atoll(const char *nptr);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
Except as noted below, the call atol(nptr) shall be equivalent to:
strtol(nptr, (char **)NULL, 10)
Except as noted below, the call to atoll(nptr) shall be equivalent to:
strtoll(nptr, (char **)NULL, 10)
The handling of errors may differ. If the value cannot be represented, the behavior is undefined.
RETURN VALUE
These functions shall return the converted value if the value can be represented.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
If the number is not known to be in range, strtol() or strtoll() should be used because atol() and atoll() are not required to
perform any error checking.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
strtol()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The atoll() function is added for alignment with the ISO/IEC 9899:1999 standard.
Issue 7
SD5-XSH-ERN-61 is applied, correcting the DESCRIPTION of atoll().
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0046 [892] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getservent.html =====
endservent
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
endservent, getservbyname, getservbyport, getservent, setservent — network services database functions
SYNOPSIS
#include
void endservent(void);
struct servent *getservbyname(const char *name, const char *proto);
struct servent *getservbyport(int port, const char *proto);
struct servent *getservent(void);
void setservent(int stayopen);
DESCRIPTION
These functions shall retrieve information about network services. This information is considered to be stored in a database
that can be accessed sequentially or randomly. The implementation of this database is unspecified.
The setservent() function shall open a connection to the database, and set the next entry to the first entry. If the
stayopen argument is non-zero, the net database shall not be closed after each call to the getservent()
function (either directly, or indirectly through one of the other getserv*() functions), and the implementation may maintain
an open file descriptor for the database. If a file descriptor is used, the FD_CLOEXEC flag shall be set; see .
The getservent() function shall read the next entry of the database, opening and closing a connection to the database as
necessary.
The getservbyname() function shall search the database from the beginning and find the first entry for which the service
name specified by name matches the s_name member and the protocol name specified by proto matches the
s_proto member, opening and closing a connection to the database as necessary. If proto is a null pointer, any value
of the s_proto member shall be matched.
The getservbyport() function shall search the database from the beginning and find the first entry for which the port
specified by port matches the s_port member and the protocol name specified by proto matches the
s_proto member, opening and closing a connection to the database as necessary. If proto is a null pointer, any value
of the s_proto member shall be matched. The port argument shall be a value obtained by converting a uint16_t
in network byte order to int.
The getservbyname(), getservbyport(), and getservent() functions shall each return a pointer to a
servent structure, the members of which shall contain the fields of an entry in the network services database.
The endservent() function shall close the database, releasing any open file descriptor.
These functions need not be thread-safe.
RETURN VALUE
Upon successful completion, getservbyname(), getservbyport(), and getservent() return a pointer to a
servent structure if the requested entry was found, and a null pointer if the end of the database was reached or the
requested entry was not found. Otherwise, a null pointer is returned.
The application shall not modify the structure to which the return value points, nor any storage areas pointed to by pointers
within the structure. The returned pointer, and pointers within the structure, might be invalidated or the structure or the storage
areas might be overwritten by a subsequent call to getservbyname(), getservbyport(), or getservent(). The
returned pointer, and pointers within the structure, might also be invalidated if the calling thread is terminated.
ERRORS
The getservbyname(), getservbyport(), getservent(), and setservent() functions may fail if:
[EMFILE]
All file descriptors available to the process are currently open.
[ENFILE]
The maximum allowable number of files is currently open in the system.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The port argument of getservbyport() need not be compatible with the port values of all address families.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
endhostent(), endprotoent(), htonl(), inet_addr()
XBD ,
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
SD5-XBD-ERN-14 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0088 [75] and XSH/TC1-2008/0089 [75] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0095 [656] is applied.
Issue 8
Austin Group Defect 368 is applied, adding a requirement for FD_CLOEXEC to be set if a file descriptor is used, and adding the
[EMFILE] and [ENFILE] errors.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wcsncasecmp.html =====
wcscasecmp
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wcscasecmp, wcscasecmp_l, wcsncasecmp, wcsncasecmp_l — case-insensitive wide-character string comparison
SYNOPSIS
[CX]  #include
int wcscasecmp(const wchar_t *ws1, const wchar_t *ws2);
int wcscasecmp_l(const wchar_t *ws1, const wchar_t *ws2,
locale_t locale);
int wcsncasecmp(const wchar_t *ws1, const wchar_t *ws2, size_t n);
int wcsncasecmp_l(const wchar_t *ws1, const wchar_t *ws2,
size_t n, locale_t locale);
DESCRIPTION
The wcscasecmp() and wcsncasecmp() functions are the wide-character equivalent of the strcasecmp() and strncasecmp()
functions, respectively.
The wcscasecmp() and wcscasecmp_l() functions shall compare, while ignoring differences in case, the
wide-character string pointed to by ws1 to the wide-character string pointed to by ws2.
The wcsncasecmp() and wcsncasecmp_l() functions shall compare, while ignoring differences in case, not more than
n wide-characters from the wide-character string pointed to by ws1 to the wide-character string pointed to by
ws2.
The wcscasecmp() and wcsncasecmp() functions use the current locale to determine the case of the wide
characters.
The wcscasecmp_l() and wcsncasecmp_l() functions use the locale represented by locale to determine the case
of the wide characters.
When the LC_CTYPE category of the locale being used is from the POSIX locale, these functions shall behave as if the
wide-character strings had been converted to lowercase and then a comparison of wide-character codes performed. Otherwise, the
results are unspecified.
The information for wcscasecmp_l() and wcsncasecmp_l() about the case of the characters comes from the locale
represented by locale.
The behavior is undefined if the locale argument to wcscasecmp_l() or wcsncasecmp_l() is the special locale
object LC_GLOBAL_LOCALE or is not a valid locale object handle.
RETURN VALUE
Upon completion, the wcscasecmp() and wcscasecmp_l() functions shall return an integer greater than, equal to, or
less than 0 if the wide-character string pointed to by ws1 is, ignoring case, greater than, equal to, or less than the
wide-character string pointed to by ws2, respectively.
Upon completion, the wcsncasecmp() and wcsncasecmp_l() functions shall return an integer greater than, equal to,
or less than 0 if the possibly null wide-character terminated string pointed to by ws1 is, ignoring case, greater than,
equal to, or less than the possibly null wide-character terminated string pointed to by ws2, respectively.
No return values are reserved to indicate an error.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
strcasecmp(), wcscmp(),
wcsncmp()
XBD
CHANGE HISTORY
First released in Issue 7.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0716 [294], XSH/TC1-2008/0717 [283], and XSH/TC1-2008/0718 [283] are
applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/endutxent.html =====
endutxent
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
endutxent, getutxent, getutxid, getutxline, pututxline, setutxent — user accounting database functions
SYNOPSIS
[XSI]  #include
void endutxent(void);
struct utmpx *getutxent(void);
struct utmpx *getutxid(const struct utmpx *id);
struct utmpx *getutxline(const struct utmpx *line);
struct utmpx *pututxline(const struct utmpx *utmpx);
void setutxent(void);
DESCRIPTION
These functions shall provide access to the user accounting database.
The getutxent() function shall read the next entry from the user accounting database. If the database is not already
open, it shall open it. If it reaches the end of the database, it shall fail.
The getutxid() function shall search forward from the current point in the database. If the ut_type value of the
utmpx structure pointed to by id is BOOT_TIME, OLD_TIME, or NEW_TIME, then it shall stop when it finds an entry with
a matching ut_type value. If the ut_type value is INIT_PROCESS, LOGIN_PROCESS, USER_PROCESS, or DEAD_PROCESS, then it
shall stop when it finds an entry whose type is one of these four and whose ut_id member matches the ut_id member of
the utmpx structure pointed to by id. If the end of the database is reached without a match, getutxid() shall
fail.
The getutxline() function shall search forward from the current point in the database until it finds an entry of the type
LOGIN_PROCESS or USER_PROCESS which also has a ut_line value matching that in the utmpx structure pointed to by
line. If the end of the database is reached without a match, getutxline() shall fail.
The getutxid() or getutxline() function may cache data. For this reason, to use getutxline() to search for
multiple occurrences, the application shall zero out the static data after each success, or getutxline() may return a
pointer to the same utmpx structure.
There is one exception to the rule about clearing the structure before further reads are done. The implicit read done by
pututxline() (if it finds that it is not already at the correct place in the user accounting database) shall not modify the
static structure returned by getutxent(), getutxid(), or getutxline(), if the application has modified this
structure and passed the pointer back to pututxline().
For all entries that match a request, the ut_type member indicates the type of the entry. Other members of the entry
shall contain meaningful data based on the value of the ut_type member as follows:
ut_type Member
Other Members with Meaningful Data
EMPTY
No others
BOOT_TIME
ut_tv
OLD_TIME
ut_tv
NEW_TIME
ut_tv
USER_PROCESS
ut_id, ut_user (login name of the user), ut_line, ut_pid, ut_tv
INIT_PROCESS
ut_id, ut_pid, ut_tv
LOGIN_PROCESS
ut_id, ut_user (implementation-defined name of the login process), ut_line, ut_pid,
ut_tv
DEAD_PROCESS
ut_id, ut_pid, ut_tv
An implementation that provides extended security controls may impose implementation-defined restrictions on
accessing the user accounting database. In particular, the system may deny the existence of some or all of the user accounting
database entries associated with users other than the caller.
If the process has appropriate privileges, the pututxline() function shall write out the structure into the
user accounting database. It shall search for a record as if by getutxid() that satisfies the request. If this search
succeeds, then the entry shall be replaced. Otherwise, a new entry shall be made at the end of the user accounting database.
The endutxent() function shall close the user accounting database.
The setutxent() function shall reset the input to the beginning of the database. This should be done before
each search for a new entry if it is desired that the entire database be examined.
These functions need not be thread-safe.
RETURN VALUE
Upon successful completion, getutxent(), getutxid(), and getutxline() shall return a pointer to a
utmpx structure containing a copy of the requested entry in the user accounting database. Otherwise, a null pointer shall be
returned.
The return value may point to a static area which is overwritten by a subsequent call to getutxid() or
getutxline().
Upon successful completion, pututxline() shall return a pointer to a utmpx structure containing a
copy of the entry added to the user accounting database. Otherwise, a null pointer shall be returned.
The endutxent() and setutxent() functions shall not return a value.
ERRORS
No errors are defined for the endutxent(), getutxent(), getutxid(), getutxline(), and
setutxent() functions.
The pututxline() function may fail if:
[EPERM]
The process does not have appropriate privileges.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The sizes of the arrays in the structure can be found using the sizeof operator.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Normative text previously in the APPLICATION USAGE section is moved to the DESCRIPTION.
A note indicating that these functions need not be reentrant is added to the DESCRIPTION.
Issue 6
In the DESCRIPTION, the note about reentrancy is expanded to cover thread-safety.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0090 [213,428] and XSH/TC1-2008/0091 [213] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/iswalnum.html =====
iswalnum
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
iswalnum, iswalnum_l — test for an alphanumeric wide-character code
SYNOPSIS
#include
int iswalnum(wint_t wc);
[CX]  int iswalnum_l(wint_t wc, locale_t locale);
DESCRIPTION
For iswalnum(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The iswalnum() [CX]   and iswalnum_l()
functions shall test whether wc is a wide-character code representing a character of class alpha or
digit in the current locale, [CX]   or in the locale represented by locale,  respectively; see XBD 7. Locale.
The wc argument is a wint_t, the value of which the application shall ensure is a wide-character code
corresponding to a valid character in the locale used by the function, or equal to the value of the macro WEOF. If the argument has
any other value, the behavior is undefined.
[CX]  The
behavior is undefined if the locale argument to iswalnum_l() is the special locale object LC_GLOBAL_LOCALE or is not
a valid locale object handle.
RETURN VALUE
The iswalnum() [CX]   and iswalnum_l()
functions shall return non-zero if wc is an alphanumeric wide-character code; otherwise, they shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
To ensure applications portability, especially across natural languages, only these functions and the functions in the reference
pages listed in the SEE ALSO section should be used for character classification.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
iswalpha(), iswcntrl(),
iswctype(), iswdigit(),
iswgraph(), iswlower(),
iswprint(), iswpunct(),
iswspace(), iswupper(),
iswxdigit(), setlocale(),
uselocale()
XBD 7. Locale, , ,
CHANGE HISTORY
First released as a World-wide Portability Interface in Issue 4.
Issue 5
The following change has been made in this version for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E):
The SYNOPSIS has been changed to indicate that this function and associated data types are now made visible by inclusion of the
header rather than .
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
The iswalnum_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0309 [302], XSH/TC1-2008/0310 [283], and XSH/TC1-2008/0311 [283] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0180 [685] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/coshl.html =====
cosh
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
cosh, coshf, coshl — hyperbolic cosine functions
SYNOPSIS
#include
double cosh(double x);
float coshf(float x);
long double coshl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the hyperbolic cosine of their argument x.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the hyperbolic cosine of x.
If the correct value would cause overflow, a range error shall occur and cosh(), coshf(), and coshl() shall
return the value of the macro HUGE_VAL, HUGE_VALF, and HUGE_VALL, respectively.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0, the value 1.0 shall be returned.
If x is ±Inf, +Inf shall be returned.
ERRORS
These functions shall fail if:
Range Error
The result would cause an overflow.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
acosh(), feclearexcept(),
fetestexcept(), isnan(),
sinh(), tanh()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The coshf() and coshl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0072 [630] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pututxline.html =====
endutxent
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
endutxent, getutxent, getutxid, getutxline, pututxline, setutxent — user accounting database functions
SYNOPSIS
[XSI]  #include
void endutxent(void);
struct utmpx *getutxent(void);
struct utmpx *getutxid(const struct utmpx *id);
struct utmpx *getutxline(const struct utmpx *line);
struct utmpx *pututxline(const struct utmpx *utmpx);
void setutxent(void);
DESCRIPTION
These functions shall provide access to the user accounting database.
The getutxent() function shall read the next entry from the user accounting database. If the database is not already
open, it shall open it. If it reaches the end of the database, it shall fail.
The getutxid() function shall search forward from the current point in the database. If the ut_type value of the
utmpx structure pointed to by id is BOOT_TIME, OLD_TIME, or NEW_TIME, then it shall stop when it finds an entry with
a matching ut_type value. If the ut_type value is INIT_PROCESS, LOGIN_PROCESS, USER_PROCESS, or DEAD_PROCESS, then it
shall stop when it finds an entry whose type is one of these four and whose ut_id member matches the ut_id member of
the utmpx structure pointed to by id. If the end of the database is reached without a match, getutxid() shall
fail.
The getutxline() function shall search forward from the current point in the database until it finds an entry of the type
LOGIN_PROCESS or USER_PROCESS which also has a ut_line value matching that in the utmpx structure pointed to by
line. If the end of the database is reached without a match, getutxline() shall fail.
The getutxid() or getutxline() function may cache data. For this reason, to use getutxline() to search for
multiple occurrences, the application shall zero out the static data after each success, or getutxline() may return a
pointer to the same utmpx structure.
There is one exception to the rule about clearing the structure before further reads are done. The implicit read done by
pututxline() (if it finds that it is not already at the correct place in the user accounting database) shall not modify the
static structure returned by getutxent(), getutxid(), or getutxline(), if the application has modified this
structure and passed the pointer back to pututxline().
For all entries that match a request, the ut_type member indicates the type of the entry. Other members of the entry
shall contain meaningful data based on the value of the ut_type member as follows:
ut_type Member
Other Members with Meaningful Data
EMPTY
No others
BOOT_TIME
ut_tv
OLD_TIME
ut_tv
NEW_TIME
ut_tv
USER_PROCESS
ut_id, ut_user (login name of the user), ut_line, ut_pid, ut_tv
INIT_PROCESS
ut_id, ut_pid, ut_tv
LOGIN_PROCESS
ut_id, ut_user (implementation-defined name of the login process), ut_line, ut_pid,
ut_tv
DEAD_PROCESS
ut_id, ut_pid, ut_tv
An implementation that provides extended security controls may impose implementation-defined restrictions on
accessing the user accounting database. In particular, the system may deny the existence of some or all of the user accounting
database entries associated with users other than the caller.
If the process has appropriate privileges, the pututxline() function shall write out the structure into the
user accounting database. It shall search for a record as if by getutxid() that satisfies the request. If this search
succeeds, then the entry shall be replaced. Otherwise, a new entry shall be made at the end of the user accounting database.
The endutxent() function shall close the user accounting database.
The setutxent() function shall reset the input to the beginning of the database. This should be done before
each search for a new entry if it is desired that the entire database be examined.
These functions need not be thread-safe.
RETURN VALUE
Upon successful completion, getutxent(), getutxid(), and getutxline() shall return a pointer to a
utmpx structure containing a copy of the requested entry in the user accounting database. Otherwise, a null pointer shall be
returned.
The return value may point to a static area which is overwritten by a subsequent call to getutxid() or
getutxline().
Upon successful completion, pututxline() shall return a pointer to a utmpx structure containing a
copy of the entry added to the user accounting database. Otherwise, a null pointer shall be returned.
The endutxent() and setutxent() functions shall not return a value.
ERRORS
No errors are defined for the endutxent(), getutxent(), getutxid(), getutxline(), and
setutxent() functions.
The pututxline() function may fail if:
[EPERM]
The process does not have appropriate privileges.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The sizes of the arrays in the structure can be found using the sizeof operator.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Normative text previously in the APPLICATION USAGE section is moved to the DESCRIPTION.
A note indicating that these functions need not be reentrant is added to the DESCRIPTION.
Issue 6
In the DESCRIPTION, the note about reentrancy is expanded to cover thread-safety.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0090 [213,428] and XSH/TC1-2008/0091 [213] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sched_yield.html =====
sched_yield
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sched_yield — yield the processor
SYNOPSIS
#include
int sched_yield(void);
DESCRIPTION
The sched_yield() function shall force the running thread to relinquish the processor until it again becomes the head of
its thread list. It takes no arguments.
RETURN VALUE
The sched_yield() function shall return 0 if it completes successfully; otherwise, it shall return a value of -1 and set
errno to indicate the error.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The conceptual model for scheduling semantics in POSIX.1-2024 defines a set of thread lists. This set of thread lists is always
present regardless of the scheduling options supported by the system. On a system where the Process Scheduling option is not
supported, portable applications should not make any assumptions regarding whether threads from other processes will be on the same
thread list.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Realtime Extension and the POSIX Threads Extension.
Issue 6
The sched_yield() function is now marked as part of the Process Scheduling and Threads options.
Issue 7
SD5-XSH-ERN-120 is applied, adding APPLICATION USAGE.
The sched_yield() function is moved to the Base.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/strcpy.html =====
strcpy
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
stpcpy, strcpy — copy a string
SYNOPSIS
#include
[CX]  char *stpcpy(char *restrict s1, const char *restrict s2);
char *strcpy(char *restrict s1, const char *restrict s2);
DESCRIPTION
For strcpy(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The [CX]
stpcpy()   and strcpy() functions shall copy the
string pointed to by s2 (including the terminating NUL character) into the array pointed to by s1.
If copying takes place between objects that overlap, the behavior is undefined.
[CX]  The
strcpy() and stpcpy() functions shall not change the setting of errno on valid input.
RETURN VALUE
[CX]  The
stpcpy() function shall return a pointer to the terminating NUL character copied into the s1 buffer.
The strcpy() function shall return s1.
No return values are reserved to indicate an error.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
Construction of a Multi-Part Message in a Single Buffer
#include
#include
int
main (void)
{
char buffer [10];
char *name = buffer;
name = stpcpy (stpcpy (stpcpy (name, "ice"),"-"), "cream");
puts (buffer);
return 0;
}
Initializing a String
The following example copies the string "----------" into the permstring variable.
#include
...
static char permstring[11];
...
strcpy(permstring, "----------");
...
Storing a Key and Data
The following example allocates space for a key using malloc() then uses
strcpy() to place the key there. Then it allocates space for data using malloc(), and uses strcpy() to place data there. (The user-defined function
dbfree() frees memory previously allocated to an array of type struct element *.)
#include
#include
#include
...
/* Structure used to read data and store it. */
struct element {
char *key;
char *data;
};
struct element *tbl, *curtbl;
char *key, *data;
int count;
...
void dbfree(struct element *, int);
...
if ((curtbl->key = malloc(strlen(key) + 1)) == NULL) {
perror("malloc"); dbfree(tbl, count); return NULL;
}
strcpy(curtbl->key, key);
if ((curtbl->data = malloc(strlen(data) + 1)) == NULL) {
perror("malloc"); free(curtbl->key); dbfree(tbl, count); return NULL;
}
strcpy(curtbl->data, data);
...
APPLICATION USAGE
Character movement is performed differently in different implementations. Thus, overlapping moves may yield surprises.
This version is aligned with the ISO C standard; this does not affect compatibility with XPG3 applications. Reliable error
detection by this function was never guaranteed.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
strncpy(), wcscpy()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The strcpy() prototype is updated for alignment with the ISO/IEC 9899:1999 standard.
Issue 7
The stpcpy() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 1.
Issue 8
Austin Group Defect 448 is applied, adding a requirement that strcpy() and stpcpy() do not change the setting of
errno on valid input.
Austin Group Defect 1787 is applied, changing the NAME section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/qsort_r.html =====
qsort
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
qsort, qsort_r — sort a table of data
SYNOPSIS
#include
void qsort(void *base, size_t nel, size_t width,
int (*compar)(const void *, const void *));
[CX]  void qsort_r(void *base, size_t nel, size_t width,
int (*compar)(const void *, const void *, void *), void *arg);
DESCRIPTION
For qsort(): [CX]  The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The qsort() function shall sort an array of nel objects, the initial element of which is pointed to by
base. The size of each object, in bytes, is specified by the width argument. If the nel argument has the value
zero, the comparison function pointed to by compar shall not be called and no rearrangement shall take place.
The application shall ensure that the comparison function pointed to by compar does not alter the contents of the array.
The implementation may reorder elements of the array between calls to the comparison function, but shall not alter the contents of
any individual element.
When the same objects (consisting of width bytes, irrespective of their current positions in the array) are passed more than
once to the comparison function, the results shall be consistent with one another. That is, they shall define a total ordering on
the array.
The contents of the array shall be sorted in ascending order according to a comparison function. The compar argument is a
pointer to the comparison function, which is called with two arguments that point to the elements being compared. The application
shall ensure that the function returns an integer less than, equal to, or greater than 0, if the first argument is considered
respectively less than, equal to, or greater than the second. If two members compare as equal, their order in the sorted array is
unspecified.
[CX]  The
qsort_r() function shall be identical to qsort() except that the comparison function compar takes a third
argument. The arg opaque pointer passed to qsort_r() shall in turn be passed as the third argument to the comparison
function.
RETURN VALUE
These functions shall not return a value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The comparison function need not compare every byte, so arbitrary data may be contained in the elements in addition to the
values being compared.
If the compar callback function requires any additional state outside of the items being sorted, it can only access this
state through global variables, making it potentially unsafe to use qsort() with the same compar function from
separate threads at the same time. The qsort_r() function was added with the ability to pass through arbitrary arguments to
the comparator, which avoids the need to access global variables and thus making it possible to safely share a stateful comparator
across threads.
RATIONALE
The requirement that each argument (hereafter referred to as p) to the comparison function is a pointer to elements of
the array implies that for every call, for each argument separately, all of the following expressions are non-zero:
((char *)p - (char *)base) % width == 0
(char *)p >= (char *)base
(char *)p
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/49 is applied, adding the last sentence to the first non-shaded
paragraph in the DESCRIPTION, and the following two paragraphs. The RATIONALE is also updated. These changes are for alignment with
the ISO C standard.
Issue 8
Austin Group Defect 900 is applied, adding the qsort_r() function.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/V2_chap03.html =====
System Interfaces
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
3. System Interfaces
This chapter describes the functions, macros, and external variables to support applications portability at the C-language
source level.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_mutexattr_setprotocol.html =====
pthread_mutexattr_getprotocol
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_mutexattr_getprotocol, pthread_mutexattr_setprotocol — get and set the protocol attribute of the mutex
attributes object (REALTIME THREADS)
SYNOPSIS
[MC1]  #include
int pthread_mutexattr_getprotocol(const pthread_mutexattr_t
*restrict attr, int *restrict protocol);
int pthread_mutexattr_setprotocol(pthread_mutexattr_t *attr,
int protocol);
DESCRIPTION
The pthread_mutexattr_getprotocol() and pthread_mutexattr_setprotocol() functions, respectively, shall get and set
the protocol attribute of a mutex attributes object pointed to by attr which was previously created by the function pthread_mutexattr_init().
The protocol attribute defines the protocol to be followed in utilizing mutexes. The value of protocol may be one
of:
[RPI|TPI]
PTHREAD_PRIO_INHERIT
[MC1]
PTHREAD_PRIO_NONE
[RPP|TPP]
PTHREAD_PRIO_PROTECT
which are defined in the  header. The default value of the
attribute shall be PTHREAD_PRIO_NONE.
When a thread owns a mutex with the PTHREAD_PRIO_NONE protocol attribute, its priority and scheduling shall not be
affected by its mutex ownership.
[RPI]
When a thread is blocking higher priority threads because of owning one or more robust mutexes with the PTHREAD_PRIO_INHERIT
protocol attribute, it shall execute at the higher of its priority or the priority of the highest priority thread waiting on
any of the robust mutexes owned by this thread and initialized with this protocol.
[TPI]
When a thread is blocking higher priority threads because of owning one or more non-robust mutexes with the PTHREAD_PRIO_INHERIT
protocol attribute, it shall execute at the higher of its priority or the priority of the highest priority thread waiting on
any of the non-robust mutexes owned by this thread and initialized with this protocol.
[RPP]
When a thread owns one or more robust mutexes initialized with the PTHREAD_PRIO_PROTECT protocol, it shall execute at the higher of
its priority or the highest of the priority ceilings of all the robust mutexes owned by this thread and initialized with this
attribute, regardless of whether other threads are blocked on any of these robust mutexes or not.
[TPP]
When a thread owns one or more non-robust mutexes initialized with the PTHREAD_PRIO_PROTECT protocol, it shall execute at the
higher of its priority or the highest of the priority ceilings of all the non-robust mutexes owned by this thread and initialized
with this attribute, regardless of whether other threads are blocked on any of these non-robust mutexes or not.
If a thread simultaneously owns several mutexes initialized with different protocols, it shall execute at the highest of the
priorities that it would have obtained by each of these protocols.
[RPI|TPI]  When a thread makes a call to pthread_mutex_lock(), the mutex was
initialized with the protocol attribute having the value PTHREAD_PRIO_INHERIT, when the calling thread is blocked because the mutex
is owned by another thread, that owner thread shall inherit the priority level of the calling thread as long as it continues to own
the mutex. The implementation shall update its execution priority to the maximum of its assigned priority and all its inherited
priorities. Furthermore, if this owner thread itself becomes blocked on another mutex with the protocol attribute having the
value PTHREAD_PRIO_INHERIT, the same priority inheritance effect shall be propagated to this other owner thread, in a recursive
manner.
The behavior is undefined if the value specified by the attr argument to pthread_mutexattr_getprotocol() or
pthread_mutexattr_setprotocol() does not refer to an initialized mutex attributes object.
RETURN VALUE
Upon successful completion, the pthread_mutexattr_getprotocol() and pthread_mutexattr_setprotocol() functions
shall return zero; otherwise, an error number shall be returned to indicate the error.
ERRORS
The pthread_mutexattr_setprotocol() function shall fail if:
[ENOTSUP]
The value specified by protocol is an unsupported value.
The pthread_mutexattr_getprotocol() and pthread_mutexattr_setprotocol() functions may fail if:
[EINVAL]
The value specified by protocol is invalid.
[EPERM]
The caller does not have the privilege to perform the operation.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
If an implementation detects that the value specified by the attr argument to pthread_mutexattr_getprotocol() or
pthread_mutexattr_setprotocol() does not refer to an initialized mutex attributes object, it is recommended that the
function should fail and report an [EINVAL] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_cond_destroy(), pthread_create(), pthread_mutex_destroy()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Marked as part of the Realtime Threads Feature Group.
Issue 6
The pthread_mutexattr_getprotocol() and pthread_mutexattr_setprotocol() functions are marked as part of the
Threads option and either the Thread Priority Protection or Thread Priority Inheritance options.
The [ENOSYS] error condition has been removed as stubs need not be provided if an implementation does not support the Thread
Priority Protection or Thread Priority Inheritance options.
The restrict keyword is added to the pthread_mutexattr_getprotocol() prototype for alignment with the
ISO/IEC 9899:1999 standard.
Issue 7
SD5-XSH-ERN-135 is applied, updating the DESCRIPTION to define a default value for the protocol attribute.
SD5-XSH-ERN-188 is applied, updating the DESCRIPTION.
The pthread_mutexattr_getprotocol() and pthread_mutexattr_setprotocol() functions are moved from the Threads
option to require support of either the Non-Robust Mutex Priority Protection option or the Non-Robust Mutex Priority Inheritance
option or the Robust Mutex Priority Protection option or the Robust Mutex Priority Inheritance option.
The [EINVAL] error for an uninitialized mutex attributes object is removed; this condition results in undefined behavior.
Issue 8
Austin Group Defect 1610 is applied, moving text relating to the effects of PTHREAD_PRIO_INHERIT and PTHREAD_PRIO_PROTECT on
scheduling queues to Scheduling Policies.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fwide.html =====
fwide
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fwide — set stream orientation
SYNOPSIS
#include
#include
int fwide(FILE *stream, int mode);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The fwide() function shall determine the orientation of the stream pointed to by stream. If mode is greater
than zero, the function first attempts to make the stream wide-oriented. If mode is less than zero, the function first
attempts to make the stream byte-oriented. Otherwise, mode is zero and the function does not alter the orientation of the
stream.
If the orientation of the stream has already been determined, fwide() shall not change it.
[CX]  The
fwide() function shall not change the setting of errno if successful.
Since no return value is reserved to indicate an error, an application wishing to check for error situations should set
errno to 0, then call fwide(), then check errno, and if it is non-zero, assume an error has occurred.
RETURN VALUE
The fwide() function shall return a value greater than zero if, after the call, the stream has wide-orientation, a value
less than zero if the stream has byte-orientation, or zero if the stream has no orientation.
ERRORS
The fwide() function may fail if:
[EBADF]
[CX]
The stream argument is not a valid stream.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
A call to fwide() with mode set to zero can be used to determine the current orientation of a stream.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD ,
CHANGE HISTORY
First released in Issue 5. Included for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E).
Issue 6
Extensions beyond the ISO C standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0225 [272] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/nl_langinfo.html =====
nl_langinfo
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
nl_langinfo, nl_langinfo_l — language information
SYNOPSIS
#include
char *nl_langinfo(nl_item item);
char *nl_langinfo_l(nl_item item, locale_t locale);
DESCRIPTION
The nl_langinfo() and nl_langinfo_l() functions shall return a pointer to a string containing information relevant
to the particular language or cultural area defined in the current locale, or in the locale represented by locale,
respectively (see ). The manifest constant names and values of
item are defined in . For example:
nl_langinfo(ABDAY_1)
would return a pointer to the string "Dom" if the identified language was Portuguese, and "Sun" if the
identified language was English.
nl_langinfo_l(ABDAY_1, loc)
would return a pointer to the string "Dom" if the identified language of the locale represented by loc was
Portuguese, and "Sun" if the identified language of the locale represented by loc was English.
The nl_langinfo() function need not be thread-safe.
The behavior is undefined if the locale argument to nl_langinfo_l() is the special locale object LC_GLOBAL_LOCALE
or is not a valid locale object handle.
RETURN VALUE
In a locale where langinfo data is not defined, these functions shall return a pointer to the corresponding string in the
POSIX locale. In all locales, these functions shall return a pointer to an empty string if item contains an invalid
setting.
The application shall not modify the string returned. The pointer returned by nl_langinfo() might be invalidated or the
string content might be overwritten by a subsequent call to nl_langinfo() in any thread or to nl_langinfo_l() in the
same thread or the initial thread, by subsequent calls to setlocale() with a
category corresponding to the category of item (see ) or
the category LC_ALL, or by subsequent calls to uselocale() which change the
category corresponding to the category of item. The pointer returned by nl_langinfo_l() might be invalidated or the
string content might be overwritten by a subsequent call to nl_langinfo_l() in the same thread or to nl_langinfo() in
any thread, or by subsequent calls to freelocale() or newlocale() which free or modify the locale object that was passed to
nl_langinfo_l(). The returned pointer and the string content might also be invalidated if the calling thread is
terminated.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
Getting Date and Time Formatting Information
The following example returns a pointer to a string containing date and time formatting information, as defined in the
LC_TIME category of the current locale.
#include
#include
...
strftime(datestring, sizeof(datestring), nl_langinfo(D_T_FMT), tm);
...
APPLICATION USAGE
The array pointed to by the return value should not be modified by the program, but may be modified by further calls to these
functions.
RATIONALE
The possible interactions between internal data used by nl_langinfo() and nl_langinfo_l() are complicated by the
fact that nl_langinfo_l() must be thread-safe but nl_langinfo() need not be. The various implementation choices
are:
nl_langinfo_l() and nl_langinfo() use separate buffers, or at least one of them does not use an internal string
buffer. In this case there are no interactions.
nl_langinfo_l() and nl_langinfo() share an internal per-thread buffer. There can be interactions, but only in the
same thread.
nl_langinfo_l() uses an internal per-thread buffer, and nl_langinfo() uses (in all threads) the same buffer that
nl_langinfo_l() uses in the initial thread. There can be interactions, but only when nl_langinfo_l() is called in the
initial thread.
FUTURE DIRECTIONS
None.
SEE ALSO
setlocale(), uselocale()
XBD 7. Locale, , ,
CHANGE HISTORY
First released in Issue 2.
Issue 5
The last paragraph of the DESCRIPTION is moved from the APPLICATION USAGE section.
A note indicating that this function need not be reentrant is added to the DESCRIPTION.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
The nl_langinfo() function is moved from the XSI option to the Base.
The nl_langinfo_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0412 [302], XSH/TC1-2008/0413 [75], XSH/TC1-2008/0414 [283],
XSH/TC1-2008/0415 [75,402], XSH/TC1-2008/0416 [283], and XSH/TC1-2008/0417 [402] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0234 [656] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/remque.html =====
insque
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
insque, remque — insert or remove an element in a queue
SYNOPSIS
[XSI]  #include
void insque(void *element, void *pred);
void remque(void *element);
DESCRIPTION
The insque() and remque() functions shall manipulate queues built from doubly-linked lists. The queue can be
either circular or linear. An application using insque() or remque() shall ensure it defines a structure in which the
first two members of the structure are pointers to the same type of structure, and any further members are application-specific.
The first member of the structure is a forward pointer to the next entry in the queue. The second member is a backward pointer to
the previous entry in the queue. If the queue is linear, the queue is terminated with null pointers. The names of the structure and
of the pointer members are not subject to any special restriction.
The insque() function shall insert the element pointed to by element into a queue immediately after the element
pointed to by pred.
The remque() function shall remove the element pointed to by element from a queue.
If the queue is to be used as a linear list, invoking insque(&element, NULL), where element is the initial
element of the queue, shall initialize the forward and backward pointers of element to null pointers.
If the queue is to be used as a circular list, the application shall ensure it initializes the forward pointer and the backward
pointer of the initial element of the queue to the element's own address.
RETURN VALUE
The insque() and remque() functions do not return a value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
Creating a Linear Linked List
The following example creates a linear linked list.
#include
...
struct myque element1;
struct myque element2;
char *data1 = "DATA1";
char *data2 = "DATA2";
...
element1.data = data1;
element2.data = data2;
insque (&element1, NULL);
insque (&element2, &element1);
Creating a Circular Linked List
The following example creates a circular linked list.
#include
...
struct myque element1;
struct myque element2;
char *data1 = "DATA1";
char *data2 = "DATA2";
...
element1.data = data1;
element2.data = data2;
element1.fwd = &element1;
element1.bck = &element1;
insque (&element2, &element1);
Removing an Element
The following example removes the element pointed to by element1.
#include
...
struct myque element1;
...
remque (&element1);
APPLICATION USAGE
The historical implementations of these functions described the arguments as being of type struct qelem * rather than as
being of type void * as defined here. In those implementations, struct qelem was commonly defined in  as:
struct qelem {
struct qelem  *q_forw;
struct qelem  *q_back;
};
Applications using these functions, however, were never able to use this structure directly since it provided no room for the
actual data contained in the elements. Most applications defined structures that contained the two pointers as the initial elements
and also provided space for, or pointers to, the object's data. Applications that used these functions to update more than one type
of table also had the problem of specifying two or more different structures with the same name, if they literally used struct
qelem as specified.
As described here, the implementations were actually expecting a structure type where the first two members were forward and
backward pointers to structures. With C compilers that didn't provide function prototypes, applications used structures as
specified in the DESCRIPTION above and the compiler did what the application expected.
If this method had been carried forward with an ISO C standard compiler and the historical function prototype, most
applications would have to be modified to cast pointers to the structures actually used to be pointers to struct qelem to
avoid compilation warnings. By specifying void * as the argument type, applications do not need to change (unless they
specifically referenced struct qelem and depended on it being defined in ).
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/glob.html =====
glob
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
glob, globfree — generate pathnames matching a pattern
SYNOPSIS
#include
int glob(const char *restrict pattern, int flags,
int(*errfunc)(const char *epath, int
eerrno),
glob_t *restrict pglob);
void globfree(glob_t *pglob);
DESCRIPTION
The glob() function is a pathname generator that shall implement the rules defined in XCU 2.14 Pattern Matching Notation, with optional support for rule 3 in XCU
2.14.3 Patterns Used for Filename Expansion.
The structure type glob_t is defined in  and includes at least
the following members:
Member Type
Member Name
Description
size_t
gl_pathc
Count of paths matched by pattern.
char **
gl_pathv
Pointer to a list of matched pathnames.
size_t
gl_offs
Slots to reserve at the beginning of gl_pathv.
The argument pattern is a pointer to a pathname pattern to be expanded. The glob() function shall
match all accessible pathnames against this pattern and develop a list of all pathnames that match. In order to have access to a
pathname, glob() requires search permission on every component of a path except the last, and read permission on each
directory of any filename component of pattern that contains any of the following special characters: '*',
'?', and '['.
The glob() function shall store the number of matched pathnames into pglob->gl_pathc and a
pointer to a list of pointers to pathnames into pglob->gl_pathv. The pathnames shall be in sort order as defined
by the current setting of the LC_COLLATE category; see XBD 7.3.2
LC_COLLATE. The first pointer after the last pathname shall be a null pointer. If the pattern does not match any
pathnames, the returned number of matched paths is set to 0, and the contents of pglob->gl_pathv are
implementation-defined.
It is the caller's responsibility to create the structure pointed to by pglob. The glob() function
shall allocate other space as needed, including the memory pointed to by gl_pathv. The globfree() function shall free
any space associated with pglob from a previous call to glob(). The globfree() function shall not modify
errno if pglob was previously used by glob() and not yet freed.
The flags argument is used to control the behavior of glob(). The value of flags is a
bitwise-inclusive OR of zero or more of the following constants, which are defined in :
GLOB_APPEND
Append pathnames generated to the ones from a previous call to glob().
GLOB_DOOFFS
Make use of pglob->gl_offs. If this flag is set, pglob->gl_offs is used to specify how many
null pointers to add to the beginning of pglob->gl_pathv. In other words, pglob->gl_pathv shall
point to pglob->gl_offs null pointers, followed by pglob->gl_pathc pathname pointers, followed by
a null pointer.
GLOB_ERR
Cause glob() to return when an attempt to open or search a pathname as a directory, or an attempt to read an opened
directory, fails because of an error condition that is related to file system contents and prevents glob() from expanding
the pattern. If this flag is not set, glob() shall not treat such conditions as an error, and shall continue to look for
matches. Other error conditions may also be treated the same way as error conditions that are related to file system contents.
GLOB_MARK
For each pathname that matches pattern and is determined to be a directory after pathname resolution, process the
pathname so the result is as if the following steps are applied in order:
If the pathname is , do not modify the pathname and skip the remaining steps.
If the pathname is  and the implementation handles pathname resolution of a pathname
starting with exactly two successive  characters differently than it handles a pathname starting with only a single
, do not modify the pathname and skip the remaining steps.
If the pathname does not end with a , append a  to the pathname and skip the remaining
steps.
A  may be appended to the pathname.
If there are multiple  characters at the end of the pathname, all but one of those trailing
characters may be removed from the pathname.
GLOB_NOCHECK
Supports rule 3 in XCU 2.14.3 Patterns Used for Filename
Expansion. If pattern does not match any pathname, then glob() shall return a list consisting of only
pattern, and the number of matched pathnames is 1.
GLOB_NOESCAPE
Disable backslash escaping.
GLOB_NOSORT
Ordinarily, glob() sorts the matching pathnames according to the current setting of the LC_COLLATE category; see
XBD 7.3.2 LC_COLLATE. When this flag is used, the order of pathnames
returned is unspecified.
The GLOB_APPEND flag can be used to append a new set of pathnames to those found in a previous call to
glob(). The following rules apply to applications when two or more calls to glob() are made with the same value of
pglob and without intervening calls to globfree():
The first such call shall not set GLOB_APPEND. All subsequent calls shall set it.
All the calls shall set GLOB_DOOFFS, or all shall not set it.
After the second call, pglob->gl_pathv points to a list containing the following:
Zero or more null pointers, as specified by GLOB_DOOFFS and pglob->gl_offs.
Pointers to the pathnames that were in the pglob->gl_pathv list before the call, in the same
order as before.
Pointers to the new pathnames generated by the second call, in the specified order.
The count returned in pglob->gl_pathc shall be the total number of pathnames from the two
calls.
The application can change any of the fields after a call to glob(). If it does, the application shall
reset them to the original value before a subsequent call, using the same pglob value, to globfree() or glob()
with the GLOB_APPEND flag.
If errfunc is not a null pointer and, during the search, an attempt to open or search a pathname as a
directory, or an attempt to read an opened directory, fails because of an error condition that prevents glob() from
expanding the pattern, glob() calls (*errfunc()) with two arguments:
The epath argument is a pointer to the path that failed.
The eerrno argument is the value of errno from the failure, as set by opendir(), readdir(), or stat(). (Other values may be used to report other errors not explicitly documented for those
functions.)
If (*errfunc()) is called and returns non-zero, or, optionally, if errfunc is a null pointer and the
attempt failed because of an error condition that is not related to file system contents, or if the GLOB_ERR flag is set in
flags, glob() shall stop the scan and return GLOB_ABORTED after setting gl_pathc and gl_pathv in
pglob to reflect the paths already scanned. If GLOB_ERR is not set and either errfunc is a null pointer or
(*errfunc()) returns 0, the error shall be ignored.
The set of error conditions that are considered to prevent glob() from expanding the pattern shall include
[EACCES], [ENAMETOOLONG], and [ELOOP]. It is implementation-defined what other error conditions are included in the set.
The glob() function shall not fail because of large files.
RETURN VALUE
Upon successful completion, glob() shall return 0. The argument pglob->gl_pathc shall return the number
of matched pathnames and the argument pglob->gl_pathv shall contain a pointer to a null-terminated list of matched
and sorted pathnames. However, if pglob->gl_pathc is 0, the content of pglob->gl_pathv is
undefined.
The globfree() function shall not return a value.
If glob() terminates due to an error, it shall return one of the non-zero constants defined in . The arguments pglob->gl_pathc and
pglob->gl_pathv are still set as defined above.
ERRORS
The glob() function shall fail and return the corresponding value if:
GLOB_ABORTED
The scan was stopped because (*errfunc()) was called and returned non-zero, or, optionally, errfunc was a null
pointer and an attempt to open, read, or search a directory failed because of an error condition that is not related to file system
contents, or GLOB_ERR was set.
GLOB_NOMATCH
The pattern does not match any existing pathname, and GLOB_NOCHECK was not set in flags.
GLOB_NOSPACE
An attempt to allocate memory failed.
The following sections are informative.
EXAMPLES
One use of the GLOB_DOOFFS flag is by applications that build an argument list for use with execv(), execve(), or execvp(). Suppose, for example, that an application wants to do the equivalent of:
ls -ld -- *.c
but for some reason:
system("ls -ld -- *.c")
is not acceptable. The application could obtain the same result (except for error handling, omitted here for
simplicity) using the sequence:
globbuf.gl_offs = 3;
glob("*.c", GLOB_DOOFFS|GLOB_NOCHECK, NULL, &globbuf);
globbuf.gl_pathv[0] = "ls";  // to establish the initial arguments
globbuf.gl_pathv[1] = "-ld"; // that sh -c "ls -ld --" would
globbuf.gl_pathv[2] = "--";  // produce for both examples
execvp("ls", &globbuf.gl_pathv[0]);
Using the same example:
ls -ld -- *.c *.h
could be simulated using GLOB_APPEND as follows:
globbuf.gl_offs = 3;
glob("*.c", GLOB_DOOFFS|GLOB_NOCHECK, NULL, &globbuf);
glob("*.h", GLOB_DOOFFS|GLOB_NOCHECK|GLOB_APPEND, NULL, &globbuf);
...
APPLICATION USAGE
This function is not provided for the purpose of enabling utilities to perform pathname expansion on their arguments, as this
operation is performed by the shell, and utilities are explicitly not expected to redo this. Instead, it is provided for
applications that need to do pathname expansion on strings obtained from other sources, such as a pattern typed by a user or read
from a file.
If a utility needs to see if a pathname matches a given pattern, it can use fnmatch().
Note that gl_pathc and gl_pathv have meaning even if glob() fails. This allows glob()
to report partial results in the event of an error. However, if gl_pathc is 0, gl_pathv is unspecified even if
glob() did not return an error.
The GLOB_NOCHECK option could be used when an application wants to expand a pathname if wildcards are specified,
but wants to treat the pattern as just a string otherwise. The sh utility might use this
for option-arguments, for example.
The new pathnames generated by a subsequent call with GLOB_APPEND are not sorted together with the previous
pathnames. This mirrors the way that the shell handles pathname expansion when multiple expansions are done on a command line.
It is recommended that (*errfunc()) should always return a non-zero value if the eerrno parameter
indicates an error condition that is not related to file system contents. See XRAT C.2.14.3 Patterns Used for Filename Expansion for information about which
error conditions are related to file system contents.
Applications that need tilde and parameter expansion should use wordexp().
RATIONALE
It was claimed that the GLOB_DOOFFS flag is unnecessary because it could be simulated using:
new = (char **)malloc((n + pglob->gl_pathc + 1)
* sizeof(char *));
(void) memcpy(new+n, pglob->gl_pathv,
pglob->gl_pathc * sizeof(char *));
(void) memset(new, 0, n * sizeof(char *));
free(pglob->gl_pathv);
pglob->gl_pathv = new;
However, this assumes that the memory pointed to by gl_pathv is a block that was separately created using
malloc(). This is not necessarily the case. An application should make no assumptions
about how the memory referenced by fields in pglob was allocated. It might have been obtained from malloc() in a large chunk and then carved up within glob(), or it might have been
created using a different memory allocator. It is not the intent of the standard developers to specify or imply how the memory used
by glob() is managed.
The GLOB_APPEND flag would be used when an application wants to expand several different patterns into a single
list.
Earlier versions of this standard defined the behavior associated with the flag GLOB_MARK as: "Each pathname that
is a directory that matches pattern shall have a  appended." This was undesirable if the matched pathname was
or if the matched pathname was  and the implementation treats a leading
differently than it treats a pathname with a single leading . Only a few implementations
were known to conform to this requirement (maybe only one) and there was a lot of variation in the way other implementations
behaved. The current wording allows many of the alternative behaviors that were observed, except that the pathnames "/"
and "//" (if it is treated differently than "/") must not be modified.
Implementations should consider the following much simpler requirement (which is allowed by the current standard)
when processing the GLOB_MARK flag: "Each pathname that matches pattern, is determined to be a directory after pathname
resolution, and does not end with a  shall have a  appended."
Implementations differ as to which error conditions they consider prevent glob() from expanding the pattern.
The standard requires that [EACCES], [ENAMETOOLONG], and [ELOOP] are included because in these cases the expansion could succeed if
performed with a different effective user or group ID, or with an alternative pathname (shorter than {PATH_MAX}, or traversing
fewer symbolic links).
Implementations are encouraged to call (*errfunc()) for all error conditions that are related to file system
contents which occur when attempting to open or search a pathname as a directory or attempting to read an opened directory. The
appropriate way to handle such errors varies according to the provenance of the pattern and what the application will do with the
resulting pathnames, and should therefore be for the application to decide. For example, given the pattern
"non-existing/*", some applications may want glob() to succeed and return an empty list because there are no
existing files that match the pattern, but for others that would not be appropriate, such as if an application asks the user to
name a directory containing files to be processed and the user makes a typing mistake when responding; the application will want to
alert the user to the mistake instead of behaving as if the user had named an empty directory. If (*errfunc()) is called for
[ENOENT] errors, the first application can ignore them in that function, but if (*errfunc()) is not called, the second
application cannot achieve what it wants using glob(). Similar reasoning applies for the pattern "regular_file/*"
and [ENOTDIR] errors.
FUTURE DIRECTIONS
A future version of this standard may require that (*errfunc()) is called for all error conditions that are related to
file system contents which occur when attempting to open or search a pathname as a directory or attempting to read an opened
directory.
SEE ALSO
exec, fdopendir(), fnmatch(), fstatat(), readdir(), wordexp()
XBD 7.3.2 LC_COLLATE,
CHANGE HISTORY
First released in Issue 4. Derived from the ISO POSIX-2 standard.
Issue 5
Moved from POSIX2 C-language Binding to BASE.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
The restrict keyword is added to the glob() prototype for alignment with the ISO/IEC 9899:1999
standard.
Issue 8
Austin Group Defect 385 is applied, adding a requirement that globfree() does not modify errno when passed a
pointer to a glob_t that can be freed.
Austin Group Defect 1255 is applied, changing the EXAMPLES section.
Austin Group Defects 1273 and 1275 are applied, clarifying how errors are treated when attempting to open or search
a pathname as a directory or attempting to read an opened directory.
Austin Group Defect 1300 is applied, changing the description of GLOB_MARK.
Austin Group Defect 1444 is applied, correcting cross-references to wordexp().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/gmtime.html =====
gmtime
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
gmtime, gmtime_r — convert a time value to a broken-down UTC time
SYNOPSIS
#include
struct tm *gmtime(const time_t *timer);
[CX]  struct tm *gmtime_r(const time_t *restrict timer,
struct tm *restrict result);
DESCRIPTION
For gmtime(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The gmtime() function shall convert the time in seconds since the Epoch pointed to by timer into a broken-down
time, expressed as Coordinated Universal Time (UTC).
[CX]  The
relationship between a time in seconds since the Epoch used as an argument to gmtime() and the tm structure (defined
in the  header) is that the result shall be as specified in the
expression given in the definition of seconds since the Epoch (see XBD 4.19
Seconds Since the Epoch), where the names in the structure and in the expression correspond.
The same relationship shall apply for gmtime_r().
The gmtime() function need not be thread-safe; however, gmtime() shall avoid data races with all functions other
than itself, asctime(), ctime(), and
localtime().
The asctime(), ctime(),
gmtime(), and localtime() functions shall return values in one of two
static objects: a broken-down time structure and an array of type char. Execution of any of the functions that return a
pointer to one of these object types may overwrite the information in any object of the same type pointed to by the value returned
from any previous call to any of them.
[CX]  The
gmtime_r() function shall convert the time in seconds since the Epoch pointed to by timer into a broken-down time
expressed as Coordinated Universal Time (UTC). The broken-down time is stored in the structure referred to by result. The
gmtime_r() function shall also return the address of the same structure.
RETURN VALUE
Upon successful completion, the gmtime() function shall return a pointer to a struct tm. If an error is detected,
gmtime() shall return a null pointer [CX]   and set errno to indicate the error.
Upon successful completion, gmtime_r() shall return the address of the structure pointed to by the argument
result. The structure's tm_zone member shall be set to a pointer to the string "UTC", which shall have
static storage duration. If an error is detected, gmtime_r() shall return a null pointer and set errno to indicate
the error.
ERRORS
The gmtime() [CX]   and gmtime_r()
functions shall fail if:
[EOVERFLOW]
[CX]
The result cannot be represented.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The gmtime_r() function is thread-safe and returns values in a user-supplied buffer instead of possibly using a static
data area that may be overwritten by each call.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
asctime(), clock(), ctime(), difftime(), futimens(), localtime(), mktime(), strftime(), strptime(), time()
XBD 4.19 Seconds Since the Epoch,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
A note indicating that the gmtime() function need not be reentrant is added to the DESCRIPTION.
The gmtime_r() function is included for alignment with the POSIX Threads Extension.
Issue 6
The gmtime_r() function is marked as part of the Thread-Safe Functions option.
Extensions beyond the ISO C standard are marked.
The APPLICATION USAGE section is updated to include a note on the thread-safe function and its avoidance of possibly using a
static data area.
The restrict keyword is added to the gmtime_r() prototype for alignment with the ISO/IEC 9899:1999
standard.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/27 is applied, adding the [EOVERFLOW] error.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/48 is applied, updating the error handling for
gmtime_r().
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
The gmtime_r() function is moved from the Thread-Safe Functions option to the Base.
Issue 8
Austin Group Defect 1302 is applied, aligning the gmtime() function with the ISO/IEC 9899:2018 standard.
Austin Group Defect 1376 is applied, removing CX shading from some text derived from the ISO C standard and updating it to
match the ISO C standard.
Austin Group Defect 1533 is applied, adding tm_gmtoff and tm_zone to the tm structure.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/acosf.html =====
acos
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
acos, acosf, acosl — arc cosine functions
SYNOPSIS
#include
double acos(double x);
float acosf(float x);
long double acosl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the principal value of the arc cosine of their argument x. The value of x should be
in the range [-1,1].
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the arc cosine of x, in the range [0,ℼ] radians.
For finite values of x not in the range [-1,1], a domain error shall occur, and [MX]   either a NaN
(if supported), or   an implementation-defined value shall be
returned.
[MX]  If
x is NaN, a NaN shall be returned.
If x is +1, +0 shall be returned.
If x is ±Inf, a domain error shall occur, and a NaN shall be returned.
ERRORS
These functions shall fail if:
Domain Error
The x argument is finite and is not in the range [-1,1], [MX]
or is ±Inf.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
cos(), feclearexcept(),
fetestexcept(), isnan()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The acosf() and acosl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0024 [320] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/stpncpy.html =====
strncpy
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
stpncpy, strncpy — copy fixed length string, returning a pointer to the array end
SYNOPSIS
#include
[CX]  char *stpncpy(char *restrict s1, const char *restrict s2, size_t
n);
char *strncpy(char *restrict s1, const char *restrict s2, size_t
n);
DESCRIPTION
For strncpy(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The [CX]
stpncpy()   and strncpy() functions shall copy
not more than n bytes (bytes that follow a NUL character are not copied) from the array pointed to by s2 to the array
pointed to by s1.
If the array pointed to by s2 is a string that is shorter than n bytes, NUL characters shall be appended to the
copy in the array pointed to by s1, until n bytes in all are written.
If copying takes place between objects that overlap, the behavior is undefined.
[CX]  The
strncpy() and stpncpy() functions shall not change the setting of errno on valid input.
RETURN VALUE
[CX]  If
a NUL character is written to the destination, the stpncpy() function shall return the address of the first such NUL
character. Otherwise, it shall return &s1[n].
The strncpy() function shall return s1.
No return values are reserved to indicate an error.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Applications must provide the space in s1 for the n bytes to be transferred, as well as ensure that the s2
and s1 arrays do not overlap.
Character movement is performed differently in different implementations. Thus, overlapping moves may yield surprises.
If there is no NUL character byte in the first n bytes of the array pointed to by s2, the result is not
null-terminated.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
strcpy(), strlcat(), wcsncpy()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The strncpy() prototype is updated for alignment with the ISO/IEC 9899:1999 standard.
Issue 7
The stpncpy() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 1.
Issue 8
Austin Group Defect 448 is applied, adding a requirement that strncpy() and stpncpy() do not change the setting of
errno on valid input.
Austin Group Defect 986 is applied, adding strlcat() to the SEE ALSO section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/posix_typed_mem_get_info.html =====
posix_typed_mem_get_info
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
posix_typed_mem_get_info — query typed memory information (ADVANCED REALTIME)
SYNOPSIS
[TYM]  #include
int posix_typed_mem_get_info(int fildes,
struct posix_typed_mem_info *info);
DESCRIPTION
The posix_typed_mem_get_info() function shall return, in the posix_tmi_length field of the
posix_typed_mem_info structure pointed to by info, the maximum length which may be successfully allocated by the
typed memory object designated by fildes. This maximum length shall take into account the flag POSIX_TYPED_MEM_ALLOCATE or
POSIX_TYPED_MEM_ALLOCATE_CONTIG specified when the typed memory object represented by fildes was opened. The maximum length
is dynamic; therefore, the value returned is valid only while the current mapping of the corresponding typed memory pool remains
unchanged.
If fildes represents a typed memory object opened with neither the POSIX_TYPED_MEM_ALLOCATE flag nor the
POSIX_TYPED_MEM_ALLOCATE_CONTIG flag specified, the returned value of info->posix_tmi_length is unspecified.
The posix_typed_mem_get_info() function may return additional implementation-defined information in other fields of the
posix_typed_mem_info structure pointed to by info.
If the memory object specified by fildes is not a typed memory object, then the behavior of this function is
undefined.
RETURN VALUE
Upon successful completion, the posix_typed_mem_get_info() function shall return zero; otherwise, the corresponding error
status value shall be returned.
ERRORS
The posix_typed_mem_get_info() function shall fail if:
[EBADF]
The fildes argument is not a valid open file descriptor.
[ENODEV]
The fildes argument is not connected to a memory object supported by this function.
This function shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
An application that needs to allocate a block of typed memory with length dependent upon the amount of memory currently
available must either query the typed memory object to obtain the amount available, or repeatedly invoke mmap() attempting to guess an appropriate length. While the latter method is existing practice
with malloc(), it is awkward and imprecise. The posix_typed_mem_get_info()
function allows an application to immediately determine available memory. This is particularly important for typed memory objects
that may in some cases be scarce resources. Note that when a typed memory pool is a shared resource, some form of mutual-exclusion
or synchronization may be required while typed memory is being queried and allocated to prevent race conditions.
The existing fstat() function is not suitable for this purpose. We realize that
implementations may wish to provide other attributes of typed memory objects (for example, alignment requirements, page size, and
so on). The fstat() function returns a structure which is not extensible and,
furthermore, contains substantial information that is inappropriate for typed memory objects.
FUTURE DIRECTIONS
None.
SEE ALSO
fstat(), mmap(), posix_typed_mem_open()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from IEEE Std 1003.1j-2000.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fputwc.html =====
fputwc
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fputwc — put a wide-character code on a stream
SYNOPSIS
#include
#include
wint_t fputwc(wchar_t wc, FILE *stream);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The fputwc() function shall write the character corresponding to the wide-character code wc to the output stream
pointed to by stream, at the position indicated by the associated file-position indicator for the stream (if defined), and
advances the indicator appropriately. If the file cannot support positioning requests, or if the stream was opened with append
mode, the character is appended to the output stream. If an error occurs while writing the character, the shift state of the output
file is left in an undefined state.
[CX]  The
last data modification and last file status change timestamps of the file shall be marked for update between the successful
execution of fputwc() and the next successful completion of a call to fflush()
or fclose() on the same stream or a call to exit() or abort().
The fputwc() function shall not change the setting of errno if successful.
RETURN VALUE
Upon successful completion, fputwc() shall return wc. Otherwise, it shall return WEOF, [CX]   errno
shall be set to indicate the error,  and for errors other than
[EILSEQ] the error indicator for the stream shall be set; [CX]   the error indicator for the stream shall also be set for [EILSEQ]
errors.
ERRORS
The fputwc() function shall fail if either the stream is unbuffered or data in the stream's buffer needs to be
written, and:
[EAGAIN]
[CX]
The O_NONBLOCK flag is set for the file descriptor underlying stream and the thread would be delayed in the write operation.
[EBADF]
[CX]
The file descriptor underlying stream is not a valid file descriptor open for writing.
[EFBIG]
[CX]  An
attempt was made to write to a file that exceeds the maximum file size.
[EFBIG]
[CX]  An
attempt was made to write to a file that exceeds the file size limit of the process.
[XSI]
A SIGXFSZ signal shall also be generated for the thread.
[EFBIG]
[CX]
The file is a regular file and an attempt was made to write at or beyond the offset maximum associated with the corresponding
stream.
[EILSEQ]
The wide-character code wc does not correspond to a valid character.
[EINTR]
[CX]
The write operation was terminated due to the receipt of a signal, and no data was transferred.
[EIO]
[CX]  A
physical I/O error has occurred, or the process is a member of a background process group attempting to write to its controlling
terminal, TOSTOP is set, the calling thread is not blocking SIGTTOU, the process is not ignoring SIGTTOU, and the process group of
the process is orphaned. This error may also be returned under implementation-defined conditions.
[ENOSPC]
[CX]
There was no free space remaining on the device containing the file.
[EPIPE]
[CX]  An
attempt is made to write to a pipe or FIFO that is not open for reading by any process. A SIGPIPE signal shall also be sent to the
thread.
The fputwc() function may fail if:
[ENOMEM]
[CX]
Insufficient storage space is available.
[ENXIO]
[CX]  A
request was made of a nonexistent device, or the request was outside the capabilities of the device.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
The requirement to set the error indicator for the stream on [EILSEQ] errors is CX shaded because the ISO C standard does
not require it to be set for fputwc() encoding errors, although it does for fgetwc(). The next revision of the ISO C standard is expected to address this
inconsistency by requiring the error indicator for the stream to be set for fputwc() encoding errors.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, ferror(), fopen(), getrlimit(), setbuf()
XBD ,
CHANGE HISTORY
First released in Issue 4. Derived from the MSE working draft.
Issue 5
Aligned with ISO/IEC 9899:1990/Amendment 1:1995 (E). Specifically, the type of argument wc is changed from
wint_t to wchar_t.
The Optional Header (OH) marking is removed from .
Large File Summit extensions are added.
Issue 6
Extensions beyond the ISO C standard are marked.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The [EFBIG] and [EIO] mandatory error conditions are added.
The [ENOMEM] and [ENXIO] optional error conditions are added.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/38 is applied, updating the [EAGAIN] error in the ERRORS section
from "the process would be delayed" to "the thread would be delayed".
Issue 7
Changes are made related to support for finegrained timestamps.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0173 [105], XSH/TC1-2008/0174 [79], and XSH/TC1-2008/0175 [14] are
applied.
Issue 8
Austin Group Defect 308 is applied, clarifying the handling of [EFBIG] errors.
Austin Group Defect 1669 is applied, removing XSI shading from part of the [EFBIG] error relating to the file size limit for the
process.
Austin Group Defect 1769 is applied, changing the CX shading in the RETURN VALUE section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/y0.html =====
y0
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
y0, y1, yn — Bessel functions of the second kind
SYNOPSIS
[XSI]  #include
double y0(double x);
double y1(double x);
double yn(int n, double x);
DESCRIPTION
The y0(), y1(), and yn() functions shall compute Bessel functions of x of the second kind of orders
0, 1, and n, respectively. y0(x) shall be equivalent to yn(0, x), and y1(x) shall
be equivalent to yn(1, x).
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the relevant Bessel value of x of the second kind.
[MXX]
If x is NaN, NaN shall be returned.
If the x argument to these functions is negative, [MXX]   either NaN (if supported) or  the same return value as when x is 0.0 (see below) shall be returned, and a domain error may
occur.
If x is 0.0, y0() and y1() shall return -HUGE_VAL and a pole error may occur. If x is 0.0 and
n is not both negative and odd, yn() shall return -HUGE_VAL and a pole error may occur. If x is 0.0 and
n is negative and odd, yn() shall return +HUGE_VAL and a pole error may occur.
[MXX]
If x is +Inf, +0 shall be returned.
If the correct result would cause underflow [MXX]   and is not representable,  a range error may occur, and the function shall return [MXX]   0.0, or
(if the IEC 60559 Floating-Point option is not supported) an
implementation-defined value no greater in magnitude than DBL_MIN.
[MXX]  If
the correct result would cause underflow, and is representable, a range error may occur and the correct value shall be returned.
If the correct result of calling y1() would cause overflow, -HUGE_VAL shall be returned and a range error may occur. If
n is not both negative and odd, and the correct result of calling yn() would cause overflow, -HUGE_VAL shall be
returned and a range error may occur. If n is negative and odd, and the correct result of calling yn() would cause
overflow, +HUGE_VAL shall be returned and a range error may occur.
ERRORS
These functions may fail if:
Domain Error
The value of x is negative.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
Pole Error
The value of x is zero.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the divide-by-zero floating-point exception shall
be raised.
Range Error
The value of x is too large in magnitude, or the correct result would cause underflow.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The y1() and yn() functions may fail if:
Range Error
The correct result would cause overflow.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the overflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept(), isnan(), j0()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
The RETURN VALUE and ERRORS sections are reworked for alignment of the error handling with the ISO/IEC 9899:1999
standard.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/148 is applied, updating the RETURN VALUE and ERRORS sections.
The changes are made for consistency with the general rules stated in "Treatment of Error Conditions for Mathematical Functions"
in the Base Definitions volume of POSIX.1-2024.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0746 [68] is applied.
Issue 8
Austin Group Defect 714 is applied, changing the behavior of these functions for special cases to be a better match for their
mathematical behavior.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/erf.html =====
erf
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
erf, erff, erfl — error functions
SYNOPSIS
#include
double erf(double x);
float erff(float x);
long double erfl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the error function of their argument x, defined as:
\( \frac{2}{\sqrt{\pi}} \int_0^x e^{-t^2} d t\)
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the value of the error function.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0, ±0 shall be returned.
If x is ±Inf, ±1 shall be returned.
If the correct value would cause underflow, a range error may occur, and erf(), erff(), and erfl() shall
return an implementation-defined value no greater in magnitude than DBL_MIN, FLT_MIN, and LDBL_MIN, respectively. [MXX]   If the IEC
60559 Floating-Point option is supported, 2* x/ sqrt() should be returned.
ERRORS
These functions may fail if:
Range Error
[MX]
The result underflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If
the integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception
shall be raised.
The following sections are informative.
EXAMPLES
Computing the Probability for a Normal Variate
This example shows how to use erf() to compute the probability that a normal variate assumes a value in the range
[x1,x2] with x1
double
Phi(const double x1, const double x2)
{
return ( erf(x2*M_SQRT1_2) - erf(x1*M_SQRT1_2) ) / 2;
}
APPLICATION USAGE
Underflow occurs when |x|
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The erf() function is no longer marked as an extension.
The erfc() function is split out onto its own reference page.
The erff() and erfl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/22 is applied, adding the example to the EXAMPLES section.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0092 [68] is applied.
Issue 8
Austin Group Defect 1178 is applied, joining two paragraphs in the RETURN VALUE section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/dcngettext_l.html =====
gettext
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
dgettext, dgettext_l, dcgettext, dcgettext_l, gettext, gettext_l, ngettext, ngettext_l, dngettext, dngettext_l,
dcngettext, dcngettext_l — message handling functions
SYNOPSIS
#include
char *dgettext(const char *domainname, const char *msgid);
char *dgettext_l(const char *domainname, const char *msgid,
locale_t locale);
char *dcgettext(const char *domainname, const char *msgid,
int category);
char *dcgettext_l(const char *domainname, const char *msgid,
int category, locale_t locale);
char *dngettext(const char *domainname, const char *msgid,
const char *msgid_plural, unsigned long int n);
char *dngettext_l(const char *domainname, const char *msgid,
const char *msgid_plural, unsigned long int n,
locale_t locale);
char *dcngettext(const char *domainname, const char *msgid,
const char *msgid_plural, unsigned long int n,
int category);
char *dcngettext_l(const char *domainname, const char *msgid,
const char *msgid_plural, unsigned long int n,
int category, locale_t locale);
char *gettext(const char *msgid);
char *gettext_l(const char *msgid, locale_t locale);
char *ngettext(const char *msgid, const char *msgid_plural,
unsigned long int n);
char *ngettext_l(const char *msgid, const char *msgid_plural,
unsigned long int n, locale_t locale);
DESCRIPTION
The gettext() function shall:
attempt to locate a suitable messages object (described in detail below) for the LC_MESSAGES category in the current
locale, and for the current text domain (see bindtextdomain()), containing
the string identified by msgid,
retrieve the string identified by msgid from the messages object,
convert the string to the output codeset if necessary (described in detail below), and
return the result.
If the locale name in effect is "POSIX" or "C" (i.e. the name associated with the LC_MESSAGES locale
category in the current locale), or if no suitable messages object exists, or if no string identified by msgid exists in the
messages object, or if an error occurs, msgid shall be returned.
The dgettext() function shall be equivalent to gettext(), except domainname shall be used instead of the
current text domain to locate the messages object.
The dcgettext() function shall be equivalent to dgettext(), except the locale category identified by
category shall be used instead of LC_MESSAGES .
The ngettext() function shall be equivalent to gettext(), except:
The string to retrieve shall be identified by a combination of msgid and n (see msgfmt).
If the locale name in effect is "POSIX" or "C", or if no suitable messages object exists, or if no string
identified by the combination of msgid and n exists in the messages object, or if an error occurs, the return value
shall be msgid if n is 1, otherwise msgid_plural.
The dngettext() function shall be equivalent to ngettext(), except domainname shall be used instead of the
current text domain to locate the messages object.
The dcngettext() function shall be equivalent to dngettext(), except the locale category identified by
category shall be used instead of LC_MESSAGES .
The *_l() functions shall be equivalent to their counterparts without the _l suffix, except locale shall be
used instead of the current locale. If locale is the special locale object LC_GLOBAL_LOCALE or is not a valid locale object
handle, the behavior is undefined.
The application shall ensure that the msgid and msgid_plural arguments are strings. If either msgid or
msgid_plural is an empty string, or contains characters not in the portable character set, the results are unspecified. If
the category argument is LC_ALL , the results are unspecified.
The location of the messages object shall be determined according to the following criteria, stopping when the first messages
object is found:
[XSI]
If the NLSPATH environment variable is set to a non-empty string, an NLSPATH search shall be performed as described
in XBD 8.2 Internationalization Variables. If NLSPATH identifies
more than one template to use, each template in turn shall be used until a valid messages object is found.
If the LANGUAGE environment variable is set to a non-empty string, a LANGUAGE search shall be performed as
described below. If LANGUAGE identifies more than one directory to search, each directory shall be searched until a valid
messages object is found.
A single-locale search shall be performed as described below.
For [XSI]   the NLSPATH search and   the single-locale search,
the single locale name used to locate the messages object shall be the locale name associated with the selected locale category
from the current locale, or the provided locale object if calling one of the *_l() functions; additional searches of locale
names without .codeset (if present), without _territory (if present), and without @modifier (if present) may
be performed.
For the LANGUAGE search, the value of the LANGUAGE environment variable shall be a list of one or more locale
names separated by a  (':') character. Each locale name shall be tried in the specified order. If a messages
object for the locale does not exist, or cannot be opened, or is unsuitable for implementation-defined reasons (such as security),
the next locale name (if any) shall be tried. If:
a messages object for the locale can be opened but cannot be processed without error, or
the messages object does not contain a string identified by msgid, or msgid and n for the ngettext
functions,
it is unspecified whether the next locale name (if any) is tried. In all other cases, the messages object for the locale shall
be used.
For each locale name in LANGUAGE , or if LANGUAGE is not set or is empty, or no suitable messages object is found
in processing LANGUAGE , the pathname used to locate the messages object shall be
dirname/localename/categoryname/textdomainname.mo, where:
The dirname part is the dirname argument of the most recent successful call to bindtextdomain() that had textdomainname as the domainname argument;
any trailing  characters in dirname shall be discarded. If a successful call to bindtextdomain() has not been made for textdomainname, an
implementation-defined default directory shall be used.
For the LANGUAGE search, the localename part is each locale name from LANGUAGE in turn; if a locale name
has the format language[_territory][.codeset][@modifier], additional
searches of locale names without .codeset (if present), without _territory (if present), and without @modifier
(if present) may be performed; if .codeset is not present, additional searches of locale names with an added .codeset
may be performed. For the single-locale search, the localename part is the name of the current locale, or the locale
specified in an *_l() function call, for the category named by categoryname. Spellings of codeset names are not
standardized, and implementations may attempt to use different commonly known spellings, for example "utf8" and
"UTF-8".
The categoryname part is the string "LC_MESSAGES" if gettext(), dgettext(), ngettext(), or
dngettext() is called, or the locale category name corresponding to the category argument to dcgettext() or
dcngettext(). Likewise for the *_l() variants of all these functions.
For gettext(), gettext_l(), ngettext(), and ngettext_l(), the textdomainname part is the text
domain set by the last successful call to textdomain(). For dgettext(),
dcgettext(), dngettext(), dcngettext(), and the *_l() variants of these functions,
textdomainname is the text domain specified by the domainname argument. The domainname argument shall be
equivalent in syntax and meaning to the domainname argument to textdomain(), except that the selection of the text domain shall affect only the
dgettext(), dcgettext(), dngettext(), and dcngettext() function calls and their *_l() variants.
If the domainname argument is a null pointer, the text domain set by the last successful call to textdomain() shall be used. For all of these functions, if a successful call to textdomain() has not been made the default text domain "messages" shall be
used.
Resolution of the messages object pathname shall be performed the first time one of the gettext family of functions is
called for a given combination of dirname, localename, categoryname, and textdomainname. It is
unspecified whether the pathname is re-resolved if the combination has been used before in a call to one of the gettext
family of functions. If bindtextdomain() performs pathname resolution of its
dirname argument, only the part of the messages object pathname after dirname shall be resolved by the gettext
family of functions.
When one of the gettext family of functions returns a message string that was found in a messages object, it shall
convert the codeset of the message string to the output codeset if a codeset is specified in the messages object (see msgfmt) and the output codeset is not the same as that codeset. If a successful call to
bind_textdomain_codeset() has been made with the text domain of the
messages object as the domainname argument and a non-null codeset argument, the output codeset shall be the
codeset argument from the most recent such call. Otherwise, the output codeset shall be the codeset of characters in the
current locale, or the provided locale object if calling one of the *_l() functions, as specified by the LC_CTYPE
category of the locale. The conversion shall be performed as if by a call to iconv()
using a conversion descriptor returned by iconv_open(, ),
except that if the return value of iconv() would be greater than zero, the
non-identical conversions performed by the gettext family of functions need not be the same as those that such an iconv() call would perform. If an error prevents the codeset conversion from being performed,
the gettext family of functions shall behave as if no message string was found in the messages object. If at least one
non-identical conversion is performed that results in a fallback character (one that does not provide any information about the
character it was converted from, for example, a  or "replacement-character"), the gettext family of
functions may behave as if no message string was found in the messages object.
RETURN VALUE
The gettext(), gettext_l(), dgettext(), dgettext_l(), dcgettext(), and dcgettext_l()
functions shall return the message string described in DESCRIPTION if successful. Otherwise, they shall return msgid.
The ngettext(), ngettext_l(), dngettext(), dngettext_l(), dcngettext(), and
dcngettext_l() functions shall return the message string described in DESCRIPTION if successful. Otherwise, msgid
shall be returned if n is equal to 1, or msgid_plural if n is not equal to 1.
The application shall ensure that it does not modify the returned string. A subsequent call to a gettext family function
shall not overwrite or invalidate the returned string. The returned string may be invalidated by a subsequent call to bind_textdomain_codeset(), bindtextdomain(), setlocale(), or
textdomain() in the same process, except for calls that only query values. The
returned string shall not be invalidated by a subsequent call to uselocale().
ERRORS
The gettext family of functions shall not modify errno. If an error occurs these functions shall return a string
as described in RETURN VALUE.
The following sections are informative.
EXAMPLES
The example code below assumes the following:
The implementation-defined default directory is /system/gettextlib.
The following locales are available on the target system: en_US, en_GB, de_DE. The codeset used for all of these locales is
UTF-8.
The en_AU locale is not available on the target system.
The target system supports conversion from ISO/IEC 8859-1 to UTF-8.
The codeset used for the POSIX locale is ASCII.
The target system does not support conversion from ISO/IEC 8859-1 to ASCII.
Furthermore, the following .mo files (and only the following .mo files) are installed:
/system/gettextlib/en_US/LC_MESSAGES/mail.mo
/messagecatalogs/example/en_US/LC_MESSAGES/mail.mo
These are compiled from a portable messages object source file (dot-po file) with the following ISO/IEC 8859-1 encoded contents
(see the EXTENDED DESCRIPTION of the msgfmt utility for a description of the dot-po
file format):
msgid ""
msgstr ""
"Content-Type: text/plain; charset=ISO_8859-1\n"
"Plural-Forms: nplurals=4; plural= n==1?0: (n>1&&n1&&n1&&n,
XCU gettext, msgfmt,
xgettext
CHANGE HISTORY
First released in Issue 8.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_cond_signal.html =====
pthread_cond_broadcast
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_cond_broadcast, pthread_cond_signal — broadcast or signal a condition
SYNOPSIS
#include
int pthread_cond_broadcast(pthread_cond_t *cond);
int pthread_cond_signal(pthread_cond_t *cond);
DESCRIPTION
These functions shall unblock threads blocked on a condition variable.
The pthread_cond_broadcast() function shall, as a single atomic operation, determine which threads, if any, are blocked
on the specified condition variable cond and unblock all of these threads.
The pthread_cond_signal() function shall, as a single atomic operation, determine which threads, if any, are blocked on
the specified condition variable cond and unblock at least one of these threads.
If more than one thread is blocked on a condition variable, the scheduling policy shall determine the order in which threads are
unblocked. When each thread unblocked as a result of a pthread_cond_broadcast() or pthread_cond_signal() returns from
its call to pthread_cond_clockwait(), pthread_cond_timedwait(), or pthread_cond_wait(), the thread shall own the mutex with which it called pthread_cond_clockwait(), pthread_cond_timedwait(), or pthread_cond_wait(). The thread(s) that are unblocked shall contend for the mutex
according to the scheduling policy (if applicable), and as if each had called pthread_mutex_lock().
The pthread_cond_broadcast() or pthread_cond_signal() functions may be called by a thread whether or not it
currently owns the mutex that threads calling pthread_cond_clockwait(), pthread_cond_timedwait(), or pthread_cond_wait() have associated with the condition variable during their
waits; however, if predictable scheduling behavior is required, then that mutex shall be locked by the thread calling
pthread_cond_broadcast() or pthread_cond_signal().
The pthread_cond_broadcast() and pthread_cond_signal() functions shall have no effect if they determine that there
are no threads blocked on cond.
The behavior is undefined if the value specified by the cond argument to pthread_cond_broadcast() or
pthread_cond_signal() does not refer to an initialized condition variable.
RETURN VALUE
If successful, the pthread_cond_broadcast() and pthread_cond_signal() functions shall return zero; otherwise, an
error number shall be returned to indicate the error.
ERRORS
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The pthread_cond_broadcast() function is used whenever the shared-variable state has been changed in a way that more than
one thread can proceed with its task. Consider a single producer/multiple consumer problem, where the producer can insert multiple
items on a list that is accessed one item at a time by the consumers. By calling the pthread_cond_broadcast() function, the
producer would notify all consumers that might be waiting, and thereby the application would receive more throughput on a
multi-processor. In addition, pthread_cond_broadcast() makes it easier to implement a read-write lock. The
pthread_cond_broadcast() function is needed in order to wake up all waiting readers when a writer releases its lock.
Finally, the two-phase commit algorithm can use this broadcast function to notify all clients of an impending transaction
commit.
It is not safe to use the pthread_cond_signal() function in a signal handler that is invoked asynchronously. Even if it
were safe, there would still be a race between the test of the Boolean pthread_cond_wait() that could not be efficiently eliminated.
Mutexes and condition variables are thus not suitable for releasing a waiting thread by signaling from code running in a signal
handler.
RATIONALE
If an implementation detects that the value specified by the cond argument to pthread_cond_broadcast() or
pthread_cond_signal() does not refer to an initialized condition variable, it is recommended that the function should fail
and report an [EINVAL] error.
Multiple Awakenings by Condition Signal
On a multi-processor, it may be impossible for an implementation of pthread_cond_signal() to avoid the unblocking of more
than one thread blocked on a condition variable. For example, consider the following partial implementation of pthread_cond_wait() and pthread_cond_signal(), executed by two threads in
the order given. One thread is trying to wait on the condition variable, another is concurrently executing
pthread_cond_signal(), while a third thread is already waiting.
pthread_cond_wait(mutex, cond):
value = cond->value; /* 1 */
pthread_mutex_unlock(mutex); /* 2 */
pthread_mutex_lock(cond->mutex); /* 10 */
if (value == cond->value) { /* 11 */
me->next_cond = cond->waiter;
cond->waiter = me;
pthread_mutex_unlock(cond->mutex);
unable_to_run(me);
} else
pthread_mutex_unlock(cond->mutex); /* 12 */
pthread_mutex_lock(mutex); /* 13 */
pthread_cond_signal(cond):
pthread_mutex_lock(cond->mutex); /* 3 */
cond->value++; /* 4 */
if (cond->waiter) { /* 5 */
sleeper = cond->waiter; /* 6 */
cond->waiter = sleeper->next_cond; /* 7 */
able_to_run(sleeper); /* 8 */
}
pthread_mutex_unlock(cond->mutex); /* 9 */
The effect is that more than one thread can return from its call to pthread_cond_clockwait(), pthread_cond_timedwait(), or pthread_cond_wait() as a result of one call to pthread_cond_signal(). This
effect is called "spurious wakeup". Note that the situation is self-correcting in that the number of threads that are so awakened
is finite; for example, the next thread to call pthread_cond_wait() after
the sequence of events above blocks.
While this problem could be resolved, the loss of efficiency for a fringe condition that occurs only rarely is unacceptable,
especially given that one has to check the predicate associated with a condition variable anyway. Correcting this problem would
unnecessarily reduce the degree of concurrency in this basic building block for all higher-level synchronization operations.
An added benefit of allowing spurious wakeups is that applications are forced to code a predicate-testing-loop around the
condition wait. This also makes the application tolerate superfluous condition broadcasts or signals on the same condition variable
that may be coded in some other part of the application. The resulting applications are thus more robust. Therefore, POSIX.1-2024
explicitly documents that spurious wakeups may occur.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_cond_clockwait(), pthread_cond_destroy()
XBD 4.15.2 Memory Synchronization,
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
The pthread_cond_broadcast() and pthread_cond_signal() functions are marked as part of the Threads option.
The APPLICATION USAGE section is added.
Issue 7
The pthread_cond_broadcast() and pthread_cond_signal() functions are moved from the Threads option to the
Base.
The [EINVAL] error for an uninitialized condition variable is removed; this condition results in undefined behavior.
Issue 8
Austin Group Defect 609 is applied, adding atomicity requirements.
Austin Group Defect 1216 is applied, adding pthread_cond_clockwait().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/nanl.html =====
nan
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
nan, nanf, nanl — return quiet NaN
SYNOPSIS
#include
double nan(const char *tagp);
float nanf(const char *tagp);
long double nanl(const char *tagp);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The function call nan("n-char-sequence") shall be equivalent to:
strtod("NAN(n-char-sequence)", (char **) NULL);
The function call nan("") shall be equivalent to:
strtod("NAN()", (char **) NULL)
If tagp does not point to an n-char sequence or an empty string, the function call shall be equivalent
to:
strtod("NAN", (char **) NULL)
Function calls to nanf() and nanl() are equivalent to the corresponding function calls to strtof() and strtold().
RETURN VALUE
These functions shall return a quiet NaN, if available, with content indicated through tagp.
[MX]  The
returned value shall be exact and shall be independent of the current rounding direction mode.
If the implementation does not support quiet NaNs, these functions shall return zero.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
strtod()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/iswxdigit_l.html =====
iswxdigit
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
iswxdigit, iswxdigit_l — test for a hexadecimal digit wide-character code
SYNOPSIS
#include
int iswxdigit(wint_t wc);
[CX]  int iswxdigit_l(wint_t wc, locale_t locale);
DESCRIPTION
For iswxdigit(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The iswxdigit() [CX]   and iswxdigit_l()
functions shall test whether wc is a wide-character code representing a character of class xdigit in the
current locale, [CX]   or in the locale represented by locale,
respectively; see XBD 7. Locale.
The wc argument is a wint_t, the value of which the application shall ensure is a wide-character code
corresponding to a valid character in the locale used by the function, or equal to the value of the macro WEOF. If the argument has
any other value, the behavior is undefined.
[CX]  The
behavior is undefined if the locale argument to iswxdigit_l() is the special locale object LC_GLOBAL_LOCALE or is not
a valid locale object handle.
RETURN VALUE
The iswxdigit() [CX]   and iswxdigit_l()
functions shall return non-zero if wc is a hexadecimal digit wide-character code; otherwise, they shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
To ensure applications portability, especially across natural languages, only these functions and the functions in the reference
pages listed in the SEE ALSO section should be used for character classification.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
iswalnum(), iswalpha(),
iswcntrl(), iswctype(),
iswdigit(), iswgraph(),
iswlower(), iswprint(),
iswpunct(), iswspace(),
iswupper(), setlocale(),
uselocale()
XBD 7. Locale, ,
CHANGE HISTORY
First released in Issue 4.
Issue 5
The following change has been made in this version for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E):
The SYNOPSIS has been changed to indicate that this function and associated data types are now made visible by inclusion of the
header rather than .
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
The iswxdigit_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0344 [302], XSH/TC1-2008/0345 [283], and XSH/TC1-2008/0346 [283] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0193 [685] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/atan2l.html =====
atan2
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
atan2, atan2f, atan2l — arc tangent functions
SYNOPSIS
#include
double atan2(double y, double x);
float atan2f(float y, float x);
long double atan2l(long double y, long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the principal value of the arc tangent of y/x, using the signs of both arguments to
determine the quadrant of the return value.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the arc tangent of y/x in the range [-ℼ,ℼ] radians.
If y is ±0 and x is  0, ±0 shall be returned.
If y is  0 and x is ±0, ℼ/2 shall be returned.
If x is 0, a pole error shall not occur.
[MX]  If
either x or y is NaN, a NaN shall be returned.
If the correct value would cause underflow, a range error may occur, and atan(),
atan2f(), and atan2l() shall return an implementation-defined value no greater in magnitude than DBL_MIN, FLT_MIN,
and LDBL_MIN, respectively. [MXX]   If the IEC 60559 Floating-Point option is supported, y/x should be returned.
[MX]  If
y is ±0 and x is -0, ±ℼ shall be returned.
If y is ±0 and x is +0, ±0 shall be returned.
For finite values of ±y > 0, if x is -Inf, ±ℼ shall be returned.
For finite values of ±y > 0, if x is +Inf, ±0 shall be returned.
For finite values of x, if y is ±Inf, ±ℼ/2 shall be returned.
If y is ±Inf and x is -Inf, ±3ℼ/4 shall be returned.
If y is ±Inf and x is +Inf, ±ℼ/4 shall be returned.
If both arguments are 0, a domain error shall not occur.
ERRORS
These functions may fail if:
Range Error
[MX]
The result underflows.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
Converting Cartesian to Polar Coordinates System
The function below uses atan2() to convert a 2d vector expressed in cartesian coordinates (x,y) to the
polar coordinates (rho,theta). There are other ways to compute the angle theta, using asin() acos(), or atan(). However, atan2() presents here two advantages:
The angle's quadrant is automatically determined.
The singular cases (0,y) are taken into account.
Finally, this example uses hypot() rather than sqrt() since it is better for special cases; see hypot() for more information.
#include
void
cartesian_to_polar(const double x, const double y,
double *rho, double *theta
)
{
*rho   = hypot (x,y); /* better than sqrt(x*x+y*y) */
*theta = atan2 (y,x);
}
APPLICATION USAGE
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
acos(), asin(), atan(), feclearexcept(), fetestexcept(), hypot(), isnan(), sqrt(), tan()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is updated to indicate how an application should check for an error. This text was previously published in the
APPLICATION USAGE section.
Issue 6
The atan2f() and atan2l() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard, and the IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/18 is applied, adding to the EXAMPLES section.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0038 [68,428] is applied.
Issue 8
Austin Group Defect 1178 is applied, removing MX shading from a paragraph in the RETURN VALUE section and joining it with the
following paragraph.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/isupper.html =====
isupper
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
isupper, isupper_l — test for an uppercase letter
SYNOPSIS
#include
int isupper(int c);
[CX]  int isupper_l(int c, locale_t locale);
DESCRIPTION
For isupper(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The isupper() [CX]   and isupper_l()
functions shall test whether c is a character of class upper in the current locale, [CX]   or in the
locale represented by locale,  respectively; see XBD 7. Locale.
The c argument is an int, the value of which the application shall ensure is a character representable as an
unsigned char or equal to the value of the macro EOF. If the argument has any other value, the behavior is undefined.
[CX]  The
behavior is undefined if the locale argument to isupper_l() is the special locale object LC_GLOBAL_LOCALE or is not a
valid locale object handle.
RETURN VALUE
The isupper() [CX]   and isupper_l()
functions shall return non-zero if c is an uppercase letter; otherwise, they shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
To ensure applications portability, especially across natural languages, only these functions and the functions in the reference
pages listed in the SEE ALSO section should be used for character classification.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
isalnum(), isalpha(), isblank(), iscntrl(), isdigit(), isgraph(), islower(), isprint(), ispunct(), isspace(), isxdigit(), setlocale(), uselocale()
XBD 7. Locale, ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
The isupper_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0306 [302], XSH/TC1-2008/0307 [283], and XSH/TC1-2008/0308 [283] are
applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/freelocale.html =====
freelocale
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
freelocale — free resources allocated for a locale object
SYNOPSIS
[CX]  #include
void freelocale(locale_t locobj);
DESCRIPTION
The freelocale() function shall cause the resources allocated for a locale object returned by a call to the newlocale() or duplocale() functions to
be released. The freelocale() function shall not modify errno if locobj is a locale object previously returned
by newlocale() or duplocale() and
not yet released by freelocale() or newlocale().
The behavior is undefined if the locobj argument is the special locale object LC_GLOBAL_LOCALE or is not a valid locale
object handle.
Any use of a locale object that has been freed results in undefined behavior.
RETURN VALUE
None.
ERRORS
None.
The following sections are informative.
EXAMPLES
Freeing Up a Locale Object
The following example shows a code fragment to free a locale object created by newlocale():
#include
...
/* Every locale object allocated with newlocale() should be
* freed using freelocale():
*/
locale_t loc;
/* Get the locale. */
loc = newlocale (LC_CTYPE_MASK | LC_TIME_MASK, "locname", NULL);
/* ... Use the locale object ... */
...
/* Free the locale object resources. */
freelocale (loc);
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
duplocale(), getlocalename_l(), newlocale(),
uselocale()
XBD
CHANGE HISTORY
First released in Issue 7.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0180 [283] is applied.
Issue 8
Austin Group Defect 385 is applied, adding a requirement that freelocale() does not modify errno when passed a
locale object than can be freed.
Austin Group Defect 1220 is applied, adding getlocalename_l() to the SEE
ALSO section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/atomic_compare_exchange_strong.html =====
atomic_compare_exchange_strong
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
atomic_compare_exchange_strong, atomic_compare_exchange_strong_explicit, atomic_compare_exchange_weak,
atomic_compare_exchange_weak_explicit — atomically compare and exchange the values of two objects
SYNOPSIS
#include
_Bool atomic_compare_exchange_strong(volatile A *object,
C *expected, C desired);
_Bool atomic_compare_exchange_strong_explicit(volatile A *object,
C *expected, C desired, memory_order
success, memory_order failure);
_Bool atomic_compare_exchange_weak(volatile A *object,
C *expected, C desired);
_Bool atomic_compare_exchange_weak_explicit(volatile A *object,
C *expected, C desired, memory_order
success, memory_order failure);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
Implementations that define the macro __STDC_NO_ATOMICS__ need not provide the  header nor support these generic functions.
The atomic_compare_exchange_strong_explicit() generic function shall atomically compare the contents of the memory
pointed to by object for equality with that pointed to by expected, and if true, shall replace the contents of the
memory pointed to by object with desired, and if false, shall update the contents of the memory pointed to by
expected with that pointed to by object. This operation shall be an atomic read-modify-write operation (see XBD
4.15.1 Memory Ordering). If the comparison is true, memory
shall be affected according to the value of success, and if the comparison is false, memory shall be affected
according to the value of failure. The application shall ensure that failure is not memory_order_release nor
memory_order_acq_rel, and shall ensure that failure is no stronger than success.
The atomic_compare_exchange_strong() generic function shall be equivalent to
atomic_compare_exchange_strong_explicit() called with success and failure both set to
memory_order_seq_cst.
The atomic_compare_exchange_weak_explicit() generic function shall be equivalent to
atomic_compare_exchange_strong_explicit(), except that the compare-and-exchange operation may fail spuriously. That is, even
when the contents of memory referred to by expected and object are equal, it may return zero and store back to
expected the same memory contents that were originally there.
The atomic_compare_exchange_weak() generic function shall be equivalent to atomic_compare_exchange_weak_explicit()
called with success and failure both set to memory_order_seq_cst.
RETURN VALUE
These generic functions shall return the result of the comparison.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
A consequence of spurious failure is that nearly all uses of weak compare-and-exchange will be in a loop. For example:
exp = atomic_load(&cur);
do {
des = function(exp);
} while (!atomic_compare_exchange_weak(&cur, &exp, des));
When a compare-and-exchange is in a loop, the weak version will yield better performance on some platforms. When a weak
compare-and-exchange would require a loop and a strong one would not, the strong one is preferable.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD 4.15.1 Memory Ordering,
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_cleanup_pop.html =====
pthread_cleanup_pop
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_cleanup_pop, pthread_cleanup_push — establish cancellation handlers
SYNOPSIS
#include
void pthread_cleanup_pop(int execute);
void pthread_cleanup_push(void (*routine)(void*), void *arg);
DESCRIPTION
The pthread_cleanup_pop() function shall remove the routine at the top of the calling thread's cancellation cleanup stack
and optionally invoke it (if execute is non-zero).
The pthread_cleanup_push() function shall push the specified cancellation cleanup handler routine onto the calling
thread's cancellation cleanup stack. The cancellation cleanup handler shall be popped from the cancellation cleanup stack and
invoked with the argument arg when:
The thread exits (that is, calls pthread_exit()).
The thread acts upon a cancellation request.
The thread calls pthread_cleanup_pop() with a non-zero execute argument.
It is unspecified whether pthread_cleanup_push() and pthread_cleanup_pop() are macros or functions. If a macro
definition is suppressed in order to access an actual function, or a program defines an external identifier with any of these
names, the behavior is undefined. The application shall ensure that they appear as statements, and in pairs within the same lexical
scope (that is, the pthread_cleanup_push() macro may be thought to expand to a token list whose first token is '{'
with pthread_cleanup_pop() expanding to a token list whose last token is the corresponding '}').
The effect of calling longjmp() or siglongjmp() is undefined if there have been any calls to pthread_cleanup_push()
or pthread_cleanup_pop() made without the matching call since the jump buffer was filled. The effect of calling longjmp() or siglongjmp() from inside a
cancellation cleanup handler is also undefined unless the jump buffer was also filled in the cancellation cleanup handler.
Invoking a cancellation cleanup handler may terminate the execution of any code block being executed by the thread whose
execution began after the corresponding invocation of pthread_cleanup_push().
The effect of the use of return, break, continue, and goto to prematurely leave a code block
described by a pair of pthread_cleanup_push() and pthread_cleanup_pop() functions calls is undefined.
RETURN VALUE
The pthread_cleanup_push() and pthread_cleanup_pop() functions shall not return a value.
ERRORS
No errors are defined.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
The following is an example using thread primitives to implement a cancelable, writers-priority read-write lock:
typedef struct {
pthread_mutex_t lock;
pthread_cond_t rcond,
wcond;
int lock_count; /*  0 .. Held by lock_count readers. */
/* = 0 .. Held by nobody. */
int waiting_writers; /* Count of waiting writers. */
} rwlock;
void
waiting_reader_cleanup(void *arg)
{
rwlock *l;
l = (rwlock *) arg;
pthread_mutex_unlock(&l->lock);
}
void
lock_for_read(rwlock *l)
{
pthread_mutex_lock(&l->lock);
pthread_cleanup_push(waiting_reader_cleanup, l);
while ((l->lock_count waiting_writers != 0))
pthread_cond_wait(&l->rcond, &l->lock);
l->lock_count++;
/*
* Note the pthread_cleanup_pop executes
* waiting_reader_cleanup.
*/
pthread_cleanup_pop(1);
}
void
release_read_lock(rwlock *l)
{
pthread_mutex_lock(&l->lock);
if (--l->lock_count == 0)
pthread_cond_signal(&l->wcond);
pthread_mutex_unlock(&l->lock);
}
void
waiting_writer_cleanup(void *arg)
{
rwlock *l;
l = (rwlock *) arg;
if ((--l->waiting_writers == 0) && (l->lock_count >= 0)) {
/*
* This only happens if we have been canceled. If the
* lock is not held by a writer, there may be readers who
* were blocked because waiting_writers was positive; they
* can now be unblocked.
*/
pthread_cond_broadcast(&l->rcond);
}
pthread_mutex_unlock(&l->lock);
}
void
lock_for_write(rwlock *l)
{
pthread_mutex_lock(&l->lock);
l->waiting_writers++;
pthread_cleanup_push(waiting_writer_cleanup, l);
while (l->lock_count != 0)
pthread_cond_wait(&l->wcond, &l->lock);
l->lock_count = -1;
/*
* Note the pthread_cleanup_pop executes
* waiting_writer_cleanup.
*/
pthread_cleanup_pop(1);
}
void
release_write_lock(rwlock *l)
{
pthread_mutex_lock(&l->lock);
l->lock_count = 0;
if (l->waiting_writers == 0)
pthread_cond_broadcast(&l->rcond);
else
pthread_cond_signal(&l->wcond);
pthread_mutex_unlock(&l->lock);
}
/*
* This function is called to initialize the read/write lock.
*/
void
initialize_rwlock(rwlock *l)
{
pthread_mutex_init(&l->lock, pthread_mutexattr_default);
pthread_cond_init(&l->wcond, pthread_condattr_default);
pthread_cond_init(&l->rcond, pthread_condattr_default);
l->lock_count = 0;
l->waiting_writers = 0;
}
reader_thread()
{
lock_for_read(&lock);
pthread_cleanup_push(release_read_lock, &lock);
/*
* Thread has read lock.
*/
pthread_cleanup_pop(1);
}
writer_thread()
{
lock_for_write(&lock);
pthread_cleanup_push(release_write_lock, &lock);
/*
* Thread has write lock.
*/
pthread_cleanup_pop(1);
}
APPLICATION USAGE
The two routines that push and pop cancellation cleanup handlers, pthread_cleanup_push() and
pthread_cleanup_pop(), can be thought of as left and right-parentheses. They always need to be matched.
RATIONALE
The restriction that the two routines that push and pop cancellation cleanup handlers, pthread_cleanup_push() and
pthread_cleanup_pop(), have to appear in the same lexical scope allows for efficient macro or compiler implementations and
efficient storage management. A sample implementation of these routines as macros might look like this:
#define pthread_cleanup_push(rtn,arg) { \
struct _pthread_handler_rec __cleanup_handler, **__head; \
__cleanup_handler.rtn = rtn; \
__cleanup_handler.arg = arg; \
(void) pthread_getspecific(_pthread_handler_key, &__head); \
__cleanup_handler.next = *__head; \
*__head = &__cleanup_handler;
#define pthread_cleanup_pop(ex) \
*__head = __cleanup_handler.next; \
if (ex) (*__cleanup_handler.rtn)(__cleanup_handler.arg); \
}
A more ambitious implementation of these routines might do even better by allowing the compiler to note that the cancellation
cleanup handler is a constant and can be expanded inline.
This volume of POSIX.1-2024 currently leaves unspecified the effect of calling longjmp() from a signal handler executing in a POSIX System Interfaces function. If an
implementation wants to allow this and give the programmer reasonable behavior, the longjmp() function has to call all cancellation cleanup handlers that have been pushed but
not popped since the time setjmp() was called.
Consider a multi-threaded function called by a thread that uses signals. If a signal were delivered to a signal handler during
the operation of qsort() and that handler were to call longjmp() (which, in turn, did not call the cancellation cleanup handlers) the helper
threads created by the qsort() function would not be canceled. Instead, they would
continue to execute and write into the argument array even though the array might have been popped off the stack.
Note that the specified cleanup handling mechanism is especially tied to the C language and, while the requirement for a uniform
mechanism for expressing cleanup is language-independent, the mechanism used in other languages may be quite different. In
addition, this mechanism is really only necessary due to the lack of a real exception mechanism in the C language, which would be
the ideal solution.
There is no notion of a cancellation cleanup-safe function. If an application has no cancellation points in its signal handlers,
blocks any signal whose handler may have cancellation points while calling async-unsafe functions, or disables cancellation while
calling async-unsafe functions, all functions may be safely called from cancellation cleanup routines.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_cancel(), pthread_setcancelstate()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
The pthread_cleanup_pop() and pthread_cleanup_push() functions are marked as part of the Threads option.
The APPLICATION USAGE section is added.
The normative text is updated to avoid use of the term "must" for application requirements.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/88 is applied, updating the DESCRIPTION to describe the
consequences of prematurely leaving a code block defined by the pthread_cleanup_push() and pthread_cleanup_pop()
functions.
Issue 7
The pthread_cleanup_pop() and pthread_cleanup_push() functions are moved from the Threads option to the Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0454 [229] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0268 [624] is applied.
Issue 8
Austin Group Defect 613 is applied, clarifying the relationship of automatic object lifetimes to cancellation cleanup
functions.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/bsearch.html =====
bsearch
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
bsearch — binary search a sorted table
SYNOPSIS
#include
void *bsearch(const void *key, const void *base, size_t nel,
size_t width, int (*compar)(const void *, const void
*));
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The bsearch() function shall search an array of nel objects, the initial element of which is pointed to by
base, for an element that matches the object pointed to by key. The size of each element in the array is specified by
width. If the nel argument has the value zero, the comparison function pointed to by compar shall not be
called and no match shall be found.
The comparison function pointed to by compar shall be called with two arguments that point to the key object and
to an array element, in that order.
The application shall ensure that the comparison function pointed to by compar does not alter the contents of the array.
The implementation may reorder elements of the array between calls to the comparison function, but shall not alter the contents of
any individual element.
The implementation shall ensure that the first argument is always a pointer to the key.
When the same objects (consisting of width bytes, irrespective of their current positions in the array) are passed more than
once to the comparison function, the results shall be consistent with one another. That is, the same object shall always compare
the same way with the key.
The application shall ensure that the function returns an integer less than, equal to, or greater than 0 if the key
object is considered, respectively, to be less than, to match, or to be greater than the array element. The application shall
ensure that the array consists of all the elements that compare less than, all the elements that compare equal to, and all the
elements that compare greater than the key object, in that order.
RETURN VALUE
The bsearch() function shall return a pointer to a matching member of the array, or a null pointer if no match is found.
If two or more members compare equal, which member is returned is unspecified.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
The example below searches a table containing pointers to nodes consisting of a string and its length. The table is ordered
alphabetically on the string in the node pointed to by each entry.
The code fragment below reads in strings and either finds the corresponding node and prints out the string and its length, or
prints an error message.
#include
#include
#include
#define TABSIZE    1000
struct node {                  /* These are stored in the table. */
char *string;
int length;
};
struct node table[TABSIZE];    /* Table to be searched. */
.
.
.
{
struct node *node_ptr, node;
/* Routine to compare 2 nodes. */
int node_compare(const void *, const void *);
.
.
.
while (scanf("%ms", &node.string) != EOF) {
node_ptr = (struct node *)bsearch((void *)(&node),
(void *)table, TABSIZE,
sizeof(struct node), node_compare);
if (node_ptr != NULL) {
(void)printf("string = %20s, length = %d\n",
node_ptr->string, node_ptr->length);
} else {
(void)printf("not found: %s\n", node.string);
}
free(node.string);
}
}
/*
This routine compares two nodes based on an
alphabetical ordering of the string field.
*/
int
node_compare(const void *node1, const void *node2)
{
return strcoll(((const struct node *)node1)->string,
((const struct node *)node2)->string);
}
APPLICATION USAGE
The pointers to the key and the element at the base of the table should be of type pointer-to-element.
The comparison function need not compare every byte, so arbitrary data may be contained in the elements in addition to the
values being compared.
In practice, the array is usually sorted according to the comparison function.
RATIONALE
The requirement that the second argument (hereafter referred to as p) to the comparison function is a pointer to an
element of the array implies that for every call all of the following expressions are non-zero:
( (char *)p - (char *)base ) % width == 0
(char *)p >= (char *)base
(char *)p
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/11 is applied, adding to the DESCRIPTION the last sentence of
the first non-shaded paragraph, and the following three paragraphs. The RATIONALE section is also updated. These changes are for
alignment with the ISO C standard.
Issue 7
The EXAMPLES section is revised.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0051 [756] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_mutex_setprioceiling.html =====
pthread_mutex_getprioceiling
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_mutex_getprioceiling, pthread_mutex_setprioceiling — get and set the priority ceiling of a mutex (REALTIME
THREADS)
SYNOPSIS
[RPP|TPP]  #include
int pthread_mutex_getprioceiling(const pthread_mutex_t *restrict mutex,
int *restrict prioceiling);
int pthread_mutex_setprioceiling(pthread_mutex_t *restrict mutex,
int prioceiling, int *restrict old_ceiling);
DESCRIPTION
The pthread_mutex_getprioceiling() function shall return the current priority ceiling of the mutex.
The pthread_mutex_setprioceiling() function shall attempt to lock the mutex as if by a call to pthread_mutex_lock(), except that the process of locking the mutex need not
adhere to the priority protect protocol. On acquiring the mutex it shall change the mutex's priority ceiling and then release the
mutex as if by a call to pthread_mutex_unlock(). When the change is
successful, the previous value of the priority ceiling shall be returned in old_ceiling.
If the pthread_mutex_setprioceiling() function fails, the mutex priority ceiling shall not be changed.
RETURN VALUE
If successful, the pthread_mutex_getprioceiling() and pthread_mutex_setprioceiling() functions shall return zero;
otherwise, an error number shall be returned to indicate the error.
ERRORS
These functions shall fail if:
[EINVAL]
The protocol attribute of mutex is PTHREAD_PRIO_NONE.
[EPERM]
The implementation requires appropriate privileges to perform the operation and the caller does not have appropriate
privileges.
The pthread_mutex_setprioceiling() function shall fail if:
[EAGAIN]
The mutex could not be acquired because the maximum number of recursive locks for mutex has been exceeded.
[EAGAIN]
The mutex is a robust mutex and the system resources available for robust mutexes owned would be exceeded.
[EDEADLK]
The mutex type is PTHREAD_MUTEX_ERRORCHECK and the current thread already owns the mutex.
[EINVAL]
The mutex was created with the protocol attribute having the value PTHREAD_PRIO_PROTECT and the calling thread's priority is
higher than the mutex's current priority ceiling, and the implementation adheres to the priority protect protocol in the process of
locking the mutex.
[ENOTRECOVERABLE]
The mutex is a robust mutex and the state protected by the mutex is not recoverable.
[EOWNERDEAD]
The mutex is a robust mutex and the process containing the previous owning thread terminated while holding the mutex lock. The
mutex lock shall be acquired by the calling thread and it is up to the new owner to make the state consistent (see pthread_mutex_lock()).
The pthread_mutex_setprioceiling() function may fail if:
[EDEADLK]
A deadlock condition was detected.
[EINVAL]
The priority requested by prioceiling is out of range.
[EOWNERDEAD]
The mutex is a robust mutex and the previous owning thread terminated while holding the mutex lock. The mutex lock shall be
acquired by the calling thread and it is up to the new owner to make the state consistent (see pthread_mutex_lock()).
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_mutex_clocklock(), pthread_mutex_destroy(), pthread_mutex_lock()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Marked as part of the Realtime Threads Feature Group.
Issue 6
The pthread_mutex_getprioceiling() and pthread_mutex_setprioceiling() functions are marked as part of the Threads
and Thread Priority Protection options.
The [ENOSYS] error conditions have been removed.
The pthread_mutex_timedlock() function is added to the SEE ALSO
section for alignment with IEEE Std 1003.1d-1999.
The restrict keyword is added to the pthread_mutex_getprioceiling() and pthread_mutex_setprioceiling()
prototypes for alignment with the ISO/IEC 9899:1999 standard.
Issue 7
SD5-XSH-ERN-39 is applied.
Austin Group Interpretation 1003.1-2001 #052 is applied, adding [EDEADLK] as a "may fail" error.
SD5-XSH-ERN-158 is applied, updating the ERRORS section to include a "shall fail" error case for when the protocol attribute
of mutex is PTHREAD_PRIO_NONE.
The pthread_mutex_getprioceiling() and pthread_mutex_setprioceiling() functions are moved from the Threads option
to require support of either the Robust Mutex Priority Protection option or the Non-Robust Mutex Priority Protection
option.
The DESCRIPTION and ERRORS sections are updated to account properly for all of the various mutex types.
Issue 8
Austin Group Defect 354 is applied, adding the [EAGAIN] error for exceeding system resources available for robust mutexes
owned.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/le16toh.html =====
be16toh
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
be16toh, be32toh, be64toh, htobe16, htobe32, htobe64, htole16, htole32, htole64, le16toh, le32toh, le64toh — convert
values between host and specified byte order
SYNOPSIS
#include
uint16_t be16toh(uint16_t big_endian_16bits);
uint32_t be32toh(uint32_t big_endian_32bits);
uint64_t be64toh(uint64_t big_endian_64bits);
uint16_t htobe16(uint16_t host_16bits);
uint32_t htobe32(uint32_t host_32bits);
uint64_t htobe64(uint64_t host_64bits);
uint16_t htole16(uint16_t host_16bits);
uint32_t htole32(uint32_t host_32bits);
uint64_t htole64(uint64_t host_64bits);
uint16_t le16toh(uint16_t little_endian_16bits);
uint32_t le32toh(uint32_t little_endian_32bits);
uint64_t le64toh(uint64_t little_endian_64bits);
DESCRIPTION
These functions shall convert integer values of various sizes between host representations and representations in a specified
order.
On some implementations, these functions are defined as macros.
A little-endian representation of an integer has the least significant byte stored as the first byte, with the significance of
the bytes increasing as the byte address increases. A big-endian representation has the most significant byte as the first byte,
with the significance of the bytes reducing as the byte address increases.
Note:
Network byte order is big-endian.
For example, the uint32_t value 0x01020304 is represented as the four bytes 0x04, 0x03, 0x02, 0x01 on a little-endian
host, and as 0x01, 0x02, 0x03, 0x04 on a big-endian host.
For each of the sizes 16, 32 and 64, the htobeSIZE() function shall convert from whatever order the host uses to
big-endian representation, htoleSIZE() shall convert to little-endian representation, beSIZEtoh() shall convert from
big-endian to host order, and leSIZEtoh() shall convert from little-endian to host order.
RETURN VALUE
These functions shall return an unsigned integer of the appropriate size and representation.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
#include
#include
#include
int main(int argc, char *argv[])
{
uint32_t val;
if (argc > 1) {
val = (uint32_t)strtoul(argv[1], NULL, 0);
printf("Value: %08x\n", val);
printf("As bytes:\n");
union {
uint32_t asint;
unsigned char asbytes[sizeof(uint32_t)];
} u;
printf("Little endian: ");
u.asint = htole32(val);
for (int i = 0; i  is included:
htobe32
htonl
htobe16
htons
be32toh
ntohl
be16toh
ntohs
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
htonl()
XBD ,
CHANGE HISTORY
First released in Issue 8.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_attr_destroy.html =====
pthread_attr_destroy
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_attr_destroy, pthread_attr_init — destroy and initialize the thread attributes object
SYNOPSIS
#include
int pthread_attr_destroy(pthread_attr_t *attr);
int pthread_attr_init(pthread_attr_t *attr);
DESCRIPTION
The pthread_attr_destroy() function shall destroy a thread attributes object. An implementation may cause
pthread_attr_destroy() to set attr to an implementation-defined invalid value. A destroyed attr attributes
object can be reinitialized using pthread_attr_init(); the results of otherwise referencing the object after it has been
destroyed are undefined.
The pthread_attr_init() function shall initialize a thread attributes object attr with the default value for all
of the individual attributes used by a given implementation.
The resulting attributes object (possibly modified by setting individual attribute values) when used by pthread_create() defines the attributes of the thread created. A single attributes
object can be used in multiple simultaneous calls to pthread_create().
Results are undefined if pthread_attr_init() is called specifying an already initialized attr attributes object.
The behavior is undefined if the value specified by the attr argument to pthread_attr_destroy() does not refer to
an initialized thread attributes object.
RETURN VALUE
Upon successful completion, pthread_attr_destroy() and pthread_attr_init() shall return a value of 0; otherwise,
an error number shall be returned to indicate the error.
ERRORS
The pthread_attr_init() function shall fail if:
[ENOMEM]
Insufficient memory exists to initialize the thread attributes object.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
Attributes objects are provided for threads, mutexes, and condition variables as a mechanism to support probable future
standardization in these areas without requiring that the function itself be changed.
Attributes objects provide clean isolation of the configurable aspects of threads. For example, "stack size" is an important
attribute of a thread, but it cannot be expressed portably. When porting a threaded program, stack sizes often need to be adjusted.
The use of attributes objects can help by allowing the changes to be isolated in a single place, rather than being spread across
every instance of thread creation.
Attributes objects can be used to set up "classes' of threads with similar attributes; for example, "threads with large stacks
and high priority" or "threads with minimal stacks". These classes can be defined in a single place and then referenced wherever
threads need to be created. Changes to "class" decisions become straightforward, and detailed analysis of each pthread_create() call is not required.
The attributes objects are defined as opaque types as an aid to extensibility. If these objects had been specified as
structures, adding new attributes would force recompilation of all multi-threaded programs when the attributes objects are
extended; this might not be possible if different program components were supplied by different vendors.
Additionally, opaque attributes objects present opportunities for improving performance. Argument validity can be checked once
when attributes are set, rather than each time a thread is created. Implementations often need to cache kernel objects that are
expensive to create. Opaque attributes objects provide an efficient mechanism to detect when cached objects become invalid due to
attribute changes.
Since assignment is not necessarily defined on a given opaque type, implementation-defined default values cannot be defined in a
portable way. The solution to this problem is to allow attributes objects to be initialized dynamically by attributes object
initialization functions, so that default values can be supplied automatically by the implementation.
The following proposal was provided as a suggested alternative to the supplied attributes:
Maintain the style of passing a parameter formed by the bitwise-inclusive OR of flags to the initialization routines (pthread_create(), pthread_mutex_init(), pthread_cond_init()). The parameter containing the flags should be an opaque type
for extensibility. If no flags are set in the parameter, then the objects are created with default characteristics. An
implementation may specify implementation-defined flag values and associated behavior.
If further specialization of mutexes and condition variables is necessary, implementations may specify additional procedures
that operate on the pthread_mutex_t and pthread_cond_t objects (instead of on attributes objects).
The difficulties with this solution are:
A bitmask is not opaque if bits have to be set into bitvector attributes objects using explicitly-coded bitwise-inclusive OR
operations. If the set of options exceeds an int, application programmers need to know the location of each bit. If bits are
set or read by encapsulation (that is, get and set functions), then the bitmask is merely an implementation of attributes objects
as currently defined and should not be exposed to the programmer.
Many attributes are not Boolean or very small integral values. For example, scheduling policy may be placed in 3-bit or 4-bit,
but priority requires 5-bit or more, thereby taking up at least 8 bits out of a possible 16 bits on machines with 16-bit integers.
Because of this, the bitmask can only reasonably control whether particular attributes are set or not, and it cannot serve as the
repository of the value itself. The value needs to be specified as a function parameter (which is non-extensible), or by setting a
structure field (which is non-opaque), or by get and set functions (making the bitmask a redundant addition to the attributes
objects).
Stack size is defined as an optional attribute because the very notion of a stack is inherently machine-dependent. Some
implementations may not be able to change the size of the stack, for example, and others may not need to because stack pages may be
discontiguous and can be allocated and released on demand.
The attribute mechanism has been designed in large measure for extensibility. Future extensions to the attribute mechanism or to
any attributes object defined in this volume of POSIX.1-2024 has to be done with care so as not to affect binary-compatibility.
Attributes objects, even if allocated by means of dynamic allocation functions such as malloc(), may have their size fixed at compile time. This means, for example, a pthread_create() in an implementation with extensions to pthread_attr_t cannot
look beyond the area that the binary application assumes is valid. This suggests that implementations should maintain a size field
in the attributes object, as well as possibly version information, if extensions in different directions (possibly by different
vendors) are to be accommodated.
If an implementation detects that the value specified by the attr argument to pthread_attr_destroy() does not
refer to an initialized thread attributes object, it is recommended that the function should fail and report an [EINVAL] error.
If an implementation detects that the value specified by the attr argument to pthread_attr_init() refers to an
already initialized thread attributes object, it is recommended that the function should fail and report an [EBUSY] error.
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_attr_getstacksize(), pthread_attr_getdetachstate(), pthread_create()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
The pthread_attr_destroy() and pthread_attr_init() functions are marked as part of the Threads option.
IEEE PASC Interpretation 1003.1 #107 is applied, noting that the effect of initializing an already initialized thread attributes
object is undefined.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/71 is applied, updating the ERRORS section to add the optional
[EINVAL] error for the pthread_attr_destroy() function, and the optional [EBUSY] error for the pthread_attr_init()
function.
Issue 7
The pthread_attr_destroy() and pthread_attr_init() functions are moved from the Threads option to the Base.
The [EINVAL] error for an uninitialized thread attributes object is removed; this condition results in undefined behavior.
The [EBUSY] error for an already initialized thread attributes object is removed; this condition results in undefined
behavior.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/le64toh.html =====
be16toh
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
be16toh, be32toh, be64toh, htobe16, htobe32, htobe64, htole16, htole32, htole64, le16toh, le32toh, le64toh — convert
values between host and specified byte order
SYNOPSIS
#include
uint16_t be16toh(uint16_t big_endian_16bits);
uint32_t be32toh(uint32_t big_endian_32bits);
uint64_t be64toh(uint64_t big_endian_64bits);
uint16_t htobe16(uint16_t host_16bits);
uint32_t htobe32(uint32_t host_32bits);
uint64_t htobe64(uint64_t host_64bits);
uint16_t htole16(uint16_t host_16bits);
uint32_t htole32(uint32_t host_32bits);
uint64_t htole64(uint64_t host_64bits);
uint16_t le16toh(uint16_t little_endian_16bits);
uint32_t le32toh(uint32_t little_endian_32bits);
uint64_t le64toh(uint64_t little_endian_64bits);
DESCRIPTION
These functions shall convert integer values of various sizes between host representations and representations in a specified
order.
On some implementations, these functions are defined as macros.
A little-endian representation of an integer has the least significant byte stored as the first byte, with the significance of
the bytes increasing as the byte address increases. A big-endian representation has the most significant byte as the first byte,
with the significance of the bytes reducing as the byte address increases.
Note:
Network byte order is big-endian.
For example, the uint32_t value 0x01020304 is represented as the four bytes 0x04, 0x03, 0x02, 0x01 on a little-endian
host, and as 0x01, 0x02, 0x03, 0x04 on a big-endian host.
For each of the sizes 16, 32 and 64, the htobeSIZE() function shall convert from whatever order the host uses to
big-endian representation, htoleSIZE() shall convert to little-endian representation, beSIZEtoh() shall convert from
big-endian to host order, and leSIZEtoh() shall convert from little-endian to host order.
RETURN VALUE
These functions shall return an unsigned integer of the appropriate size and representation.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
#include
#include
#include
int main(int argc, char *argv[])
{
uint32_t val;
if (argc > 1) {
val = (uint32_t)strtoul(argv[1], NULL, 0);
printf("Value: %08x\n", val);
printf("As bytes:\n");
union {
uint32_t asint;
unsigned char asbytes[sizeof(uint32_t)];
} u;
printf("Little endian: ");
u.asint = htole32(val);
for (int i = 0; i  is included:
htobe32
htonl
htobe16
htons
be32toh
ntohl
be16toh
ntohs
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
htonl()
XBD ,
CHANGE HISTORY
First released in Issue 8.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/tcsetwinsize.html =====
tcsetwinsize
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
tcsetwinsize — set the size of a terminal window
SYNOPSIS
#include
int tcsetwinsize(int fildes, const struct winsize *winsize_p);
DESCRIPTION
The tcsetwinsize() function shall set the terminal window size associated with the terminal referred to by the open file
descriptor fildes (an open file descriptor associated with a terminal) from the winsize structure referenced by
winsize_p. The change shall occur immediately.
If the terminal size was changed successfully, a SIGWINCH shall be delivered to the foreground process group associated with the
terminal. No signal shall be delivered if the terminal size was changed to the same value it had before the tcsetwinsize()
call. A SIGWINCH may also be delivered to an implementation-defined set of other processes.
The tcsetwinsize() function shall return successfully if it was able to update all members of the winsize
structure associated with the terminal.
It is unspecified whether changing the terminal window size causes any changes to the size of the terminal's font.
The effect of tcsetwinsize() is undefined if the value of the winsize structure pointed to by winsize_p was
not derived from the result of a call to tcgetwinsize() on fildes; an
application should modify only fields defined by this volume of POSIX.1-2024 between the call to tcgetwinsize() and tcsetwinsize(), leaving all other fields unmodified.
No actions defined by this volume of POSIX.1-2024, other than a call to tcsetwinsize(), a close of the last file
descriptor in the system associated with this terminal device, or an open of the first file descriptor in the system associated
with this terminal device (using the O_TTY_INIT flag if it is non-zero and the device is not a pseudo-terminal), shall cause the
terminal window size to change.
If tcsetwinsize() is called from a process which is a member of a background process group on a fildes associated
with its controlling terminal:
If the calling thread is blocking SIGTTOU signals or the process is ignoring SIGTTOU signals, the operation completes normally
and no signal is sent.
Otherwise, a SIGTTOU signal shall be sent to the process group.
RETURN VALUE
Upon successful completion, 0 shall be returned. Otherwise, -1 shall be returned, the terminal window size shall not be changed,
and errno shall be set to indicate the error.
ERRORS
The tcsetwinsize() function shall fail if:
[EBADF]
The fildes argument is not a valid file descriptor.
[EIO]
The process group of the writing process is orphaned, the calling thread is not blocking SIGTTOU, and the process is not
ignoring SIGTTOU.
[ENOTTY]
The file associated with fildes is not a terminal.
The tcsetwinsize() function may fail if:
[EINVAL]
An attempt was made to change an attribute represented in the winsize structure to an unsupported value.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
If the terminal window of a pseudo terminal is resized, the attached manager process should invoke tcsetwinsize() to
relay the new terminal window size to the foreground process group.
If a process attached to the subsidiary device of a pseudo-terminal calls tcsetwinsize(), the attached manager process
should attempt to change the screen to reflect the new size.
RATIONALE
This standard does not mention the ws_xpixel and ws_ypixel fields that appear in the winsize structure of
some historical implementations. With current hardware, it is not obvious that the unsigned short type used for these fields
is sufficient and no uses of these fields in portable code were found. However, since these and other fields may be included in the
winsize structure, the standard requires that applications use tcgetwinsize() to initialize any fields that may be provided by an implementation
before setting the ws_cols and ws_rows fields using tcsetwinsize() to avoid unintentionally destroying data in
other fields in this structure.
FUTURE DIRECTIONS
None.
SEE ALSO
tcgetwinsize()
XBD
CHANGE HISTORY
First released in Issue 8.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/cfgetospeed.html =====
cfgetospeed
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
cfgetospeed — get output baud rate
SYNOPSIS
#include
speed_t cfgetospeed(const struct termios *termios_p);
DESCRIPTION
The cfgetospeed() function shall extract the output baud rate from the termios structure to which the
termios_p argument points.
This function shall return exactly the value in the termios data structure, without interpretation.
RETURN VALUE
Upon successful completion, cfgetospeed() shall return a value of type speed_t representing the output baud
rate.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
Refer to cfgetispeed().
FUTURE DIRECTIONS
None.
SEE ALSO
cfgetispeed(), cfsetispeed(), cfsetospeed(),
tcgetattr()
XBD 11. General Terminal Interface,
CHANGE HISTORY
First released in Issue 3. Included for alignment with the POSIX.1-1988 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wcscoll.html =====
wcscoll
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wcscoll, wcscoll_l — wide-character string comparison using collating information
SYNOPSIS
#include
int wcscoll(const wchar_t *ws1, const wchar_t *ws2);
[CX]  int wcscoll_l(const wchar_t *ws1, const wchar_t *ws2,
locale_t locale);
DESCRIPTION
For wcscoll(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The wcscoll() [CX]   and wcscoll_l()
functions shall compare the wide-character string pointed to by ws1 to the wide-character string pointed to by
ws2, both interpreted as appropriate to the LC_COLLATE category of the current locale, [CX]   or the locale
represented by locale,   respectively.
The wcscoll() [CX]   and wcscoll_l()
functions shall not change the setting of errno if successful.
An application wishing to check for error situations should set errno to 0 before calling wcscoll() [CX]   or
wcscoll_l().   If errno is non-zero on return, an
error has occurred.
[CX]  The
behavior is undefined if the locale argument to wcscoll_l() is the special locale object LC_GLOBAL_LOCALE or is not a
valid locale object handle.
RETURN VALUE
Upon successful completion, wcscoll() [CX]   and wcscoll_l()   shall return an integer greater than, equal to, or less than 0, according to whether the
wide-character string pointed to by ws1 is greater than, equal to, or less than the wide-character string pointed to by
ws2, when both are interpreted as appropriate to the current locale, [CX]   or to the
locale represented by locale,   respectively. On error,
wcscoll() [CX]   and wcscoll_l()   shall set
errno, but no return value is reserved to indicate an error.
ERRORS
These functions may fail if:
[EINVAL]
[CX]
The ws1 or ws2 arguments contain wide-character codes outside the domain of the collating sequence.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The wcsxfrm() and wcscmp()
functions should be used for sorting large lists.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
wcscmp(), wcsxfrm()
XBD
CHANGE HISTORY
First released in Issue 4. Derived from the MSE working draft.
Issue 5
Moved from ENHANCED I18N to BASE and the [ENOSYS] error is removed.
The DESCRIPTION is updated to indicate that errno is not changed if the function is successful.
Issue 7
The wcscoll_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0719 [302], XSH/TC1-2008/0720 [283], and XSH/TC1-2008/0721 [283] are
applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/FD_SET.html =====
pselect
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pselect, select — synchronous I/O multiplexing
SYNOPSIS
#include
int pselect(int nfds, fd_set *restrict readfds,
fd_set *restrict writefds, fd_set *restrict errorfds,
const struct timespec *restrict timeout,
const sigset_t *restrict sigmask);
int select(int nfds, fd_set *restrict readfds,
fd_set *restrict writefds, fd_set *restrict errorfds,
struct timeval *restrict timeout);
void FD_CLR(int fd, fd_set *fdset);
int FD_ISSET(int fd, const fd_set *fdset);
void FD_SET(int fd, fd_set *fdset);
void FD_ZERO(fd_set *fdset);
DESCRIPTION
The pselect() function shall examine the file descriptor sets whose addresses are passed in the readfds,
writefds, and errorfds parameters to see whether some of their descriptors are ready for reading, are ready for
writing, or have an exceptional condition pending, respectively.
The select() function shall be equivalent to the pselect() function, except as follows:
For the select() function, the timeout period is given in seconds and microseconds in an argument of type struct
timeval, whereas for the pselect() function the timeout period is given in seconds and nanoseconds in an argument of
type struct timespec.
The select() function has no sigmask argument; it shall behave as pselect() does when sigmask is a
null pointer.
Upon successful completion, the select() function may modify the object pointed to by the timeout argument.
The pselect() and select() functions shall support regular files, terminal and pseudo-terminal devices, FIFOs,
pipes, and sockets. The behavior of pselect() and select() on file descriptors that refer to other types of file is
unspecified.
The nfds argument specifies the range of descriptors to be tested. The first nfds descriptors shall be checked in
each set; that is, the descriptors from zero through nfds-1 in the descriptor sets shall be examined.
If the readfds argument is not a null pointer, it points to an object of type fd_set that on input specifies the
file descriptors to be checked for being ready to read, and on output indicates which file descriptors are ready to read.
If the writefds argument is not a null pointer, it points to an object of type fd_set that on input specifies the
file descriptors to be checked for being ready to write, and on output indicates which file descriptors are ready to write.
If the errorfds argument is not a null pointer, it points to an object of type fd_set that on input specifies the
file descriptors to be checked for error conditions pending, and on output indicates which file descriptors have error conditions
pending.
Upon successful completion, the pselect() or select() function shall modify the objects pointed to by the
readfds, writefds, and errorfds arguments to indicate which file descriptors are ready for reading, ready for
writing, or have an error condition pending, respectively, and shall return the total number of ready descriptors in all the output
sets. For each file descriptor less than nfds, the corresponding bit shall be set upon successful completion if it was set
on input and the associated condition is true for that file descriptor.
If none of the selected descriptors are ready for the requested operation, the pselect() or select() function
shall block until at least one of the requested operations becomes ready, until the timeout occurs, or until interrupted by
a signal. The timeout parameter controls how long the pselect() or select() function shall take before timing
out. If the timeout parameter is not a null pointer, it specifies a maximum interval to wait for the selection to complete.
If the specified time interval expires without any requested operation becoming ready, the function shall return. If the
timeout parameter is a null pointer, then the call to pselect() or select() shall block indefinitely until at
least one descriptor meets the specified criteria. To effect a poll, the timeout parameter should not be a null pointer, and
should point to a zero-valued timespec structure.
The use of a timeout does not affect any pending timers set up by alarm().
Implementations may place limitations on the maximum timeout interval supported. All implementations shall support a maximum
timeout interval of at least 31 days. If the timeout argument specifies a timeout interval greater than the
implementation-defined maximum value, the maximum value shall be used as the actual timeout value. Implementations may also place
limitations on the granularity of timeout intervals. If the requested timeout interval requires a finer granularity than the
implementation supports, the actual timeout interval shall be rounded up to the next supported value.
If sigmask is not a null pointer, then the pselect() function shall replace the signal mask of the caller by the
set of signals pointed to by sigmask before examining the descriptors, and shall restore the signal mask of the calling
thread before returning. If a signal is unmasked as a result of the signal mask being altered by pselect(), and a
signal-catching function is called for that signal during the execution of the pselect() function, and SA_RESTART is clear
for the interrupting signal, then
If none of the selected file descriptors are ready, pselect() shall immediately fail with the [EINTR] error after the
signal-catching function returns.
If one or more of the selected file descriptors are ready, it is unspecified whether pselect() behaves the same as if
none of the descriptors were ready (failing with [EINTR] as above) or behaves the same as if it was not interrupted (returning the
total number of ready descriptors).
A descriptor shall be considered ready for reading when a call to an input function with O_NONBLOCK clear would not block,
whether or not the function would transfer data successfully. (The function might return data, an end-of-file indication, or an
error other than one indicating that it is blocked, and in each of these cases the descriptor shall be considered ready for
reading.)
A descriptor shall be considered ready for writing when a call to an output function with O_NONBLOCK clear would not block,
whether or not the function would transfer data successfully.
If a socket has a pending error, it shall be considered to have an exceptional condition pending. Otherwise, what constitutes an
exceptional condition is file type-specific. For a file descriptor for use with a socket, it is protocol-specific except as noted
below. For other file types it is implementation-defined. If the operation is meaningless for a particular file type,
pselect() or select() shall indicate that the descriptor is ready for read or write operations, and shall indicate
that the descriptor has no exceptional condition pending.
If a descriptor refers to a socket, the implied input function is the recvmsg()
function with parameters requesting normal and ancillary data, such that the presence of either type shall cause the socket to be
marked as readable. The presence of out-of-band data shall be checked if the socket option SO_OOBINLINE has been enabled, as
out-of-band data is enqueued with normal data. If the socket is currently listening, then it shall be marked as readable if an
incoming connection request has been received, and a call to the accept() or accept4() function shall complete without blocking.
If a descriptor refers to a socket, the implied output function is the sendmsg()
function supplying an amount of normal data equal to the current value of the SO_SNDLOWAT option for the socket. If a non-blocking
call to the connect() function has been made for a socket, and the connection
attempt has either succeeded or failed leaving a pending error, the socket shall be marked as writable.
A socket shall be considered to have an exceptional condition pending if a receive operation with O_NONBLOCK clear for the open
file description and with the MSG_OOB flag set would return out-of-band data without blocking. (It is protocol-specific whether the
MSG_OOB flag would be used to read out-of-band data.) A socket shall also be considered to have an exceptional condition pending if
an out-of-band data mark is present in the receive queue. Other circumstances under which a socket may be considered to have an
exceptional condition pending are protocol-specific and implementation-defined.
If the readfds, writefds, and errorfds arguments are all null pointers and the timeout argument is
not a null pointer, the pselect() or select() function shall block for the time specified, or until interrupted by a
signal. If the readfds, writefds, and errorfds arguments are all null pointers and the timeout argument
is a null pointer, the pselect() or select() function shall block until interrupted by a signal.
File descriptors associated with regular files shall always select true for ready to read, ready to write, and error
conditions.
On failure, the objects pointed to by the readfds, writefds, and errorfds arguments shall not be modified.
If the timeout interval expires without the specified condition being true for any of the specified file descriptors, the objects
pointed to by the readfds, writefds, and errorfds arguments shall have all bits set to 0.
File descriptor masks of type fd_set can be initialized and tested with FD_CLR(), FD_ISSET(),
FD_SET(), and FD_ZERO(). It is unspecified whether each of these is a macro or a function. If a macro definition is
suppressed in order to access an actual function, or a program defines an external identifier with any of these names, the behavior
is undefined.
FD_CLR(fd, fdsetp) shall remove the file descriptor fd from the set pointed to by fdsetp. If
fd is not a member of this set, there shall be no effect on the set, and this shall not be treated as an error.
FD_ISSET(fd, fdsetp) shall evaluate to non-zero if the file descriptor fd is a member of the set
pointed to by fdsetp, and shall evaluate to zero otherwise.
FD_SET(fd, fdsetp) shall add the file descriptor fd to the set pointed to by fdsetp. If the
file descriptor fd is already in this set, there shall be no effect on the set, and this shall not be treated as an
error.
FD_ZERO(fdsetp) shall initialize the descriptor set pointed to by fdsetp to the null set. No error is
returned if the set is not empty at the time FD_ZERO() is invoked.
The behavior of these macros is undefined if the fd argument is less than 0 or greater than or equal to FD_SETSIZE, or if
fd is not a valid file descriptor, or if any of the arguments are expressions with side-effects.
If a thread gets canceled during a pselect() call, the signal mask in effect when executing the registered cleanup
functions is either the original signal mask or the signal mask installed as part of the pselect() call.
RETURN VALUE
Upon successful completion, the pselect() and select() functions shall return the total number of bits set in the
bit masks. Otherwise, -1 shall be returned, and errno shall be set to indicate the error.
FD_CLR(), FD_SET(), and FD_ZERO() do not return a value. FD_ISSET() shall return a non-zero value if
the bit for the file descriptor fd is set in the file descriptor set pointed to by fdset, and 0 otherwise.
ERRORS
Under the following conditions, pselect() and select() shall fail and set errno to:
[EBADF]
One or more of the file descriptor sets specified a file descriptor that is not a valid open file descriptor.
[EINTR]
The function was interrupted by a signal.
If SA_RESTART has been set for the interrupting signal, it is implementation-defined whether the function restarts or returns
with [EINTR].
[EINVAL]
An invalid timeout interval was specified.
[EINVAL]
The nfds argument is less than 0 or greater than FD_SETSIZE.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The use of select() and pselect() requires that the application construct the set of file descriptors to work on
each time through a polling loop, and is inherently limited from operating on file descriptors larger than FD_SETSIZE. Also, the
amount of work to perform scales as nfds increases, even if the number of file descriptors selected within the larger set
remains the same. Thus, applications may wish to consider using poll() and ppoll() instead, for better scaling.
When a pselect() or select() call indicates a file descriptor is ready for reading, this means that if an attempt
to read data had been made at the time that the status of the file descriptor was checked, it would have returned at least one byte
of data, an end-of-file indication, or an error, without blocking (even if O_NONBLOCK is clear). When a pselect() or
select() call indicates that a file descriptor is ready for writing, this means that if an attempt to write one byte of data
had been made at the time that the status of the file descriptor was checked, it would have written that byte or returned an error,
without blocking. However, if an attempt to write more than one byte had been made, it might have blocked (if O_NONBLOCK is clear).
In both cases, by the time the call returns and a subsequent I/O operation is attempted, the state of the file descriptor might
have changed (for example, because another thread read or wrote some data) and, if O_NONBLOCK is clear, there is no guarantee that
the operation will not block (unless it would not block for some other reason, such as setting MIN=0 and TIME=0 for a terminal in
non-canonical mode). Therefore it is recommended that applications always set O_NONBLOCK on file descriptors whose readiness for
I/O they query with pselect() or select().
RATIONALE
In earlier versions of the Single UNIX Specification, the select() function was defined in the  header. This is now changed to . The rationale for this change was as follows: the introduction of
the pselect() function included the  header and the
header defines all the related definitions for the
pselect() and select() functions. Backwards-compatibility to existing XSI implementations is handled by allowing
to include .
Code which wants to avoid the ambiguity of the signal mask for thread cancellation handlers can install an additional
cancellation handler which resets the signal mask to the expected value.
void cleanup(void *arg)
{
sigset_t *ss = (sigset_t *) arg;
pthread_sigmask(SIG_SETMASK, ss, NULL);
}
int call_pselect(int nfds, fd_set *readfds, fd_set *writefds,
fd_set errorfds, const struct timespec *timeout,
const sigset_t *sigmask)
{
sigset_t oldmask;
int result;
pthread_sigmask(SIG_SETMASK, NULL, &oldmask);
pthread_cleanup_push(cleanup, &oldmask);
result = pselect(nfds, readfds, writefds, errorfds, timeout, sigmask);
pthread_cleanup_pop(0);
return result;
}
FUTURE DIRECTIONS
None.
SEE ALSO
accept(), alarm(), connect(), fcntl(), poll(), read(), recvmsg(), sendmsg(), write()
XBD ,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
In the ERRORS section, the text has been changed to indicate that [EINVAL] is returned when nfds is less than 0 or
greater than FD_SETSIZE. It previously stated less than 0, or greater than or equal to FD_SETSIZE.
Text about timeout is moved from the APPLICATION USAGE section to the DESCRIPTION.
Issue 6
The Open Group Corrigendum U026/6 is applied, changing the occurrences of readfs and writefs in the
select() DESCRIPTION to be readfds and writefds.
Text referring to sockets is added to the DESCRIPTION.
The DESCRIPTION and ERRORS sections are updated so that references to STREAMS are marked as part of the XSI STREAMS Option
Group.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
These functions are now mandatory.
The pselect() function is added for alignment with IEEE Std 1003.1g-2000 and additional detail related to
sockets semantics is added to the DESCRIPTION.
The select() function now requires inclusion of .
The restrict keyword is added to the select() prototype for alignment with the ISO/IEC 9899:1999
standard.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/70 is applied, updating the DESCRIPTION to reference the signal
mask in terms of the calling thread rather than the process.
Issue 7
SD5-XSH-ERN-122 is applied, adding text to the DESCRIPTION for when a thread is canceled during a call to pselect(), and
adding example code to the RATIONALE.
Functionality relating to the XSI STREAMS option is marked obsolescent.
Functionality relating to the Threads option is moved to the Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0446 [372] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0259 [680] is applied.
Issue 8
Austin Group Defect 220 is applied, adding const to the second parameter of FD_ISSET().
Austin Group Defect 411 is applied, adding accept4().
Austin Group Defect 1186 is applied, clarifying the behavior when the pselect() function is interrupted by a signal.
Austin Group Defect 1263 is applied, changing the APPLICATION USAGE section.
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
Austin Group Defect 1448 is applied, changing the APPLICATION USAGE section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/atomic_fetch_sub.html =====
atomic_fetch_add
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
atomic_fetch_add, atomic_fetch_add_explicit, atomic_fetch_and, atomic_fetch_and_explicit, atomic_fetch_or,
atomic_fetch_or_explicit, atomic_fetch_sub, atomic_fetch_sub_explicit, atomic_fetch_xor, atomic_fetch_xor_explicit — atomically
replace the value of an object with the result of a computation
SYNOPSIS
#include
C atomic_fetch_add(volatile A *object, M operand); C
atomic_fetch_add_explicit(volatile A *object, M operand,
memory_order order); C atomic_fetch_and(volatile A
*object, M operand); C atomic_fetch_and_explicit(volatile A
*object, M operand,
memory_order order); C atomic_fetch_or(volatile A
*object, M operand); C atomic_fetch_or_explicit(volatile A
*object, M operand,
memory_order order); C atomic_fetch_sub(volatile A
*object, M operand); C atomic_fetch_sub_explicit(volatile A
*object, M operand,
memory_order order); C atomic_fetch_xor(volatile A
*object, M operand); C atomic_fetch_xor_explicit(volatile A
*object, M operand,
memory_order order);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
Implementations that define the macro __STDC_NO_ATOMICS__ need not provide the  header nor support these generic functions.
The atomic_fetch_add_explicit() generic function shall atomically replace the value pointed to by object with the
result of adding operand to this value. This operation shall be an atomic read-modify-write operation (see XBD 4.15.1 Memory Ordering). Memory shall be affected according to the value of
order.
The atomic_fetch_add() generic function shall be equivalent to atomic_fetch_add_explicit() called with
order set to memory_order_seq_cst.
The other atomic_fetch_*() generic functions shall be equivalent to atomic_fetch_add_explicit() if their name ends
with explicit, or to atomic_fetch_add() if it does not, respectively, except that they perform the computation
indicated in their name, instead of addition:
sub
subtraction
or
bitwise inclusive OR
xor
bitwise exclusive OR
and
bitwise AND
For addition and subtraction, the application shall ensure that A is an atomic integer type or an atomic pointer type and is not
atomic_bool. For the other operations, the application shall ensure that A is an atomic integer type and is not
atomic_bool.
For signed integer types, the computation shall silently wrap around on overflow; there are no undefined results. For pointer
types, the result can be an undefined address, but the computations otherwise have no undefined behavior.
RETURN VALUE
These generic functions shall return the value pointed to by object immediately before the effects.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The operation of these generic functions is nearly equivalent to the operation of the corresponding compound assignment
operators +=, -=, etc. The only differences are that the compound assignment operators are not guaranteed to
operate atomically, and the value yielded by a compound assignment operator is the updated value of the object, whereas the value
returned by these generic functions is the previous value of the atomic object.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD 4.15.1 Memory Ordering,
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getnetbyname.html =====
endnetent
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
endnetent, getnetbyaddr, getnetbyname, getnetent, setnetent — network database functions
SYNOPSIS
#include
void endnetent(void);
struct netent *getnetbyaddr(uint32_t net, int type);
struct netent *getnetbyname(const char *name);
struct netent *getnetent(void);
void setnetent(int stayopen);
DESCRIPTION
These functions shall retrieve information about networks. This information is considered to be stored in a database that can be
accessed sequentially or randomly. The implementation of this database is unspecified.
The setnetent() function shall open and rewind the database. If the stayopen argument is non-zero, the connection
to the net database shall not be closed after each call to getnetent() (either directly, or indirectly through one of
the other getnet*() functions), and the implementation may maintain an open file descriptor to the database. If a file
descriptor is used, the FD_CLOEXEC flag shall be set; see .
The getnetent() function shall read the next entry of the database, opening and closing a connection to the database as
necessary.
The getnetbyaddr() function shall search the database from the beginning, and find the first entry for which the address
family specified by type matches the n_addrtype member and the network number net matches the n_net
member, opening and closing a connection to the database as necessary. The net argument shall be the network number in host
byte order.
The getnetbyname() function shall search the database from the beginning and find the first entry for which the network
name specified by name matches the n_name member, opening and closing a connection to the database as necessary.
The getnetbyaddr(), getnetbyname(), and getnetent() functions shall each return a pointer to a
netent structure, the members of which shall contain the fields of an entry in the network database.
The endnetent() function shall close the database, releasing any open file descriptor.
These functions need not be thread-safe.
RETURN VALUE
Upon successful completion, getnetbyaddr(), getnetbyname(), and getnetent() shall return a pointer to a
netent structure if the requested entry was found, and a null pointer if the end of the database was reached or the
requested entry was not found. Otherwise, a null pointer shall be returned.
The application shall not modify the structure to which the return value points, nor any storage areas pointed to by pointers
within the structure. The returned pointer, and pointers within the structure, might be invalidated or the structure or the storage
areas might be overwritten by a subsequent call to getnetbyaddr(), getnetbyname(), or getnetent(). The
returned pointer, and pointers within the structure, might also be invalidated if the calling thread is terminated.
ERRORS
The getnetbyaddr(), getnetbyname(), getnetent(), and setnetent() functions may fail if:
[EMFILE]
All file descriptors available to the process are currently open.
[ENFILE]
The maximum allowable number of files is currently open in the system.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD ,
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0083 [75] and XSH/TC1-2008/0084 [75] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0090 [656] is applied.
Issue 8
Austin Group Defect 368 is applied, adding a requirement for FD_CLOEXEC to be set if a file descriptor is used, and adding the
[EMFILE] and [ENFILE] errors.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/strerror.html =====
strerror
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
strerror, strerror_l, strerror_r — get error message string
SYNOPSIS
#include
char *strerror(int errnum);
[CX]  char *strerror_l(int errnum, locale_t locale);
int strerror_r(int errnum, char *strerrbuf, size_t buflen);
DESCRIPTION
For strerror(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The strerror() function shall map the error number in errnum to a locale-dependent error message string and shall
return a pointer to it. Typically, the values for errnum come from errno, but strerror() shall map any value
of type int to a message.
The application shall not modify the string returned. [CX]   The returned string pointer might be invalidated or   the string content might be overwritten by a subsequent call to
strerror(), [CX]   or by a subsequent call to strerror_l() in the same thread. The returned pointer and the string content
might also be invalidated if the calling thread is terminated.
[CX]  The
string may be overwritten by a subsequent call to strerror_l() in the same thread.
The contents of the error message strings returned by strerror() should be determined by the setting of the
LC_MESSAGES category in the current locale.
The implementation shall behave as if no function defined in this volume of POSIX.1-2024 calls strerror().
[CX]  The
strerror() and strerror_l() functions shall not change the setting of errno if successful.
Since no return value is reserved to indicate an error of strerror(), an application wishing to check for error
situations should set errno to 0, then call strerror(), then check errno. Similarly, since strerror_l()
is required to return a string for some errors, an application wishing to check for all error situations should set errno to
0, then call strerror_l(), then check errno.
The strerror() function need not be thread-safe; however, strerror() shall avoid data races with all other
functions.
[CX]  The
strerror_l() function shall map the error number in errnum to a locale-dependent error message string in the locale
represented by locale and shall return a pointer to it.
The strerror_r() function shall map the error number in errnum to a locale-dependent error message string and
shall return the string in the buffer pointed to by strerrbuf, with length buflen.
[CX]  If
the value of errnum is a valid error number, the message string shall indicate what error occurred; if the value of
errnum is zero, the message string shall either be an empty string or indicate that no error occurred; otherwise, if these
functions complete successfully, the message string shall indicate that an unknown error occurred.
[CX]  The
behavior is undefined if the locale argument to strerror_l() is the special locale object LC_GLOBAL_LOCALE or is not
a valid locale object handle.
RETURN VALUE
Upon completion, whether successful or not, strerror() shall return a pointer to the generated message string.
[CX]
On error errno may be set, but no return value is reserved to indicate an error.
Upon successful completion, strerror_l() shall return a pointer to the generated message string. If errnum is not
a valid error number, errno may be set to [EINVAL], but a pointer to a message string shall still be returned. If any other
error occurs, errno shall be set to indicate the error and a null pointer shall be returned.
Upon successful completion, strerror_r() shall return 0. Otherwise, an error number shall be returned to indicate the
error.
ERRORS
These functions may fail if:
[EINVAL]
[CX]
The value of errnum is neither a valid error number nor zero.
The strerror_r() function shall fail if:
[ERANGE]
[CX]
Insufficient storage was supplied via strerrbuf and buflen to contain the generated message string.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Historically in some implementations, calls to perror() would overwrite the string
that the pointer returned by strerror() points to. Such implementations did not conform to the ISO C standard; however,
application developers should be aware of this behavior if they wish their applications to be portable to such implementations.
Applications should use strerror_l() rather than strerror() or strerror_r() to avoid thread safety and
possible alternative (non-conforming) versions of these functions in some implementations.
RATIONALE
The strerror_l() function is required to be thread-safe, thereby eliminating the need for an equivalent to the
strerror_r() function.
Earlier versions of this standard did not explicitly require that the error message strings returned by strerror() and
strerror_r() provide any information about the error. This version of the standard requires a meaningful message for any
successful completion.
Since no return value is reserved to indicate a strerror() error, but all calls (whether successful or not) must return a
pointer to a message string, on error strerror() can return a pointer to an empty string or a pointer to a meaningful string
that can be printed.
Note that the [EINVAL] error condition is a may fail error. If an invalid error number is supplied as the value of
errnum, applications should be prepared to handle any of the following:
Error (with no meaningful message): errno is set to [EINVAL], the return value is a pointer to an empty string.
Successful completion: errno is unchanged and the return value points to a string like "unknown error" or
"error number xxx" (where xxx is the value of errnum).
Combination of #1 and #2: errno is set to [EINVAL] and the return value points to a string like "unknown error"
or "error number xxx" (where xxx is the value of errnum). Since applications frequently use the return value
of strerror() as an argument to functions like fprintf() (without checking
the return value) and since applications have no way to parse an error message string to determine whether errnum represents
a valid error number, implementations are encouraged to implement #3. Similarly, implementations are encouraged to have
strerror_r() return [EINVAL] and put a string like "unknown error" or "error number xxx" in the buffer
pointed to by strerrbuf when the value of errnum is not a valid error number.
Additionally, implementations are encouraged to null terminate strerrbuf when failing with [ERANGE] for any size other
than buflen of zero.
Some applications rely on being able to set errno to 0 before calling a function with no reserved value to indicate an
error, then call strerror(errno) afterwards to detect whether an error occurred (because errno changed) or to
indicate success (because errno remained zero). This usage pattern requires that strerror(0) succeed with useful
results. Previous versions of the standard did not specify the behavior when errnum is zero.
FUTURE DIRECTIONS
None.
SEE ALSO
perror()
XBD
CHANGE HISTORY
First released in Issue 3.
Issue 5
The DESCRIPTION is updated to indicate that errno is not changed if the function is successful.
A note indicating that the strerror() function need not be reentrant is added to the DESCRIPTION.
Issue 6
Extensions beyond the ISO C standard are marked.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
In the RETURN VALUE section, the fact that errno may be set is added.
The [EINVAL] optional error condition is added.
The normative text is updated to avoid use of the term "must" for application requirements.
The strerror_r() function is added in response to IEEE PASC Interpretation 1003.1c #39.
The strerror_r() function is marked as part of the Thread-Safe Functions option.
Issue 7
Austin Group Interpretation 1003.1-2001 #072 is applied, updating the ERRORS section.
Austin Group Interpretation 1003.1-2001 #156 is applied.
Austin Group Interpretation 1003.1-2001 #187 is applied, clarifying the behavior when the generated error message is an empty
string.
SD5-XSH-ERN-191 is applied, updating the APPLICATION USAGE section.
The strerror_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
The strerror_r() function is moved from the Thread-Safe Functions option to the Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0595 [75], XSH/TC1-2008/0596 [447], XSH/TC1-2008/0597 [382,428],
XSH/TC1-2008/0598 [283], XSH/TC1-2008/0599 [382,428], XSH/TC1-2008/0600 [283], and XSH/TC1-2008/0601 [382,428] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0339 [656] is applied.
Issue 8
Austin Group Defect 398 is applied, changing the [ERANGE] error from "may fail" to "shall fail".
Austin Group Defect 655 is applied, changing the APPLICATION USAGE section.
Austin Group Defect 1302 is applied, aligning the strerror() function with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/dladdr.html =====
dladdr
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
dladdr — get information relating to an address
SYNOPSIS
#include
int dladdr(const void *restrict addr, Dl_info_t *restrict dlip);
DESCRIPTION
The dladdr() function shall determine whether the address specified by addr is located within the address range
occupied by a mapped object. The mapped objects examined shall include any executable object files that have previously been loaded
by a call to dlopen() and for which dlclose() has not subsequently been called, and any shared library files that were loaded as
dependencies of the executable file from which the current process image was loaded; they may also include any executable object
files that have previously been loaded by a call to dlopen() and for which dlclose() has subsequently been called, the executable file from which the current process
image was loaded, and implementation-defined additional mapped objects (for example, all regular files mapped using mmap() might be included). If the specified address is within the mapped address range of one
of these mapped objects and the object contains a symbol table, the symbol table shall be searched for a symbol (a function
identifier or a data object identifier) that has the largest address less than or equal to the specified address.
If the address specified by addr is within the mapped address range of one of the examined mapped objects, the structure
pointed to by dlip shall be populated as follows:
The value of the dli_fname member shall be set to point to the pathname of the mapped object. (This might no longer
resolve to the file that was mapped, for example if it was a link that has subsequently been removed or renamed.)
The value of the dli_fbase member shall be set to the base of the address range occupied by the mapped object.
The value of the dli_sname member shall be set to point to the name of the symbol that has the largest address less than
or equal to the specified address, or to a null pointer if no such symbol was found.
If dli_sname is set to a null pointer, the value of the dli_saddr member shall also be set to a null pointer.
Otherwise, if dli_sname names a function identifier, dli_saddr shall be set to the address of the function converted
from type pointer to function to type pointer to void; otherwise, dli_saddr shall be set to the address of the data
object named by dli_sname converted from a pointer to the type of the data object to a pointer to void.
RETURN VALUE
Upon successful completion, a non-zero value shall be returned. If the specified address is not located within the address range
occupied by an examined mapped object, or if an error occurs, zero shall be returned. More detailed diagnostic information shall be
available through dlerror().
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The Dl_info_t members may point to addresses within the mapped object. These pointers can become invalid if the object is
unmapped (for example, loaded executable objects may be unloaded by dlclose()).
If dli_sname names a function identifier, the value of dli_saddr can be converted back to type pointer to function
using a cast in the manner shown in the dlsym() EXAMPLES section. Note that this
conversion is not defined by the ISO C standard. This standard requires this conversion to work correctly on conforming
implementations.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
dlclose(), dlerror(), dlopen(), dlsym()
XBD
CHANGE HISTORY
First released in Issue 8.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/abort.html =====
abort
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
abort — generate an abnormal process abort
SYNOPSIS
#include
_Noreturn void abort(void);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The abort() function shall cause abnormal process termination to occur, unless a SIGABRT signal that it generates is
caught and the signal handler does not return.
[CX]  The
abnormal termination processing shall include the default actions defined for SIGABRT and may include an attempt to effect fclose() on all open streams.
The SIGABRT signal shall be sent to the calling [CX]   thread   as if by means of raise() with the argument SIGABRT. [CX]  If this signal does
not terminate the process (for example, if the signal is caught and the handler returns), abort() may change the disposition
of SIGABRT to SIG_DFL and send the signal (in the same way) again. If a second signal is sent and it does not terminate the
process, the behavior is unspecified, except that the abort() call shall not return.
[CX]  The
status made available to wait(), waitid(), or waitpid() by abort() shall
be that of a process terminated by the SIGABRT signal.  The
abort() function shall override blocking or ignoring the SIGABRT signal.
RETURN VALUE
The abort() function shall not return.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Catching the signal is intended to provide the application developer with a portable means to abort processing, free from
possible interference from any implementation-supplied functions.
RATIONALE
Historically, abort() has been implemented by calling other signal manipulation functions such as raise(), sigaction(), and pthread_sigmask(). This means that its operation can be affected by concurrent
actions in other threads. For example, if abort() attempts to terminate the process by calling sigaction() to change the disposition for SIGABRT to SIG_DFL and then calling raise(), another thread could change the disposition in between those two calls, resulting in
the process not being terminated. If this happens, the only requirement is that abort() does not return. An implementation
could call those functions in a loop (which could in theory then execute indefinitely), or could terminate the process by calling
_exit() (which would ensure termination but result in the wrong wait status). To avoid
these issues, implementations are encouraged to implement abort() in a manner such that its operation cannot be affected by
concurrent actions in other threads. For example, it could first halt the execution of all other threads, or it could terminate the
process using a "terminate as if by a signal" system call instead of by raising (a second) SIGABRT.
The ISO/IEC 9899:1999 standard required (and the current standard still requires) the abort() function to be
async-signal-safe. Since POSIX.1-2024 defers to the ISO C standard, this required a change to the DESCRIPTION from "shall
include the effect of fclose()" to "may include an attempt to effect fclose()."
The revised wording permits some backwards-compatibility and avoids a potential deadlock situation.
The Open Group Base Resolution bwg2002-003 is applied, removing the following XSI shaded paragraph from the DESCRIPTION:
"On XSI-conformant systems, in addition the abnormal termination processing shall include the effect of fclose() on message catalog descriptors."
There were several reasons to remove this paragraph:
No special processing of open message catalogs needs to be performed prior to abnormal process termination.
The main reason to specifically mention that abort() includes the effect of fclose() on open streams is to flush output queued on the stream. Message catalogs in this
context are read-only and, therefore, do not need to be flushed.
The effect of fclose() on a message catalog descriptor is unspecified. Message
catalog descriptors are allowed, but not required to be implemented using a file descriptor, but there is no mention in
POSIX.1-2024 of a message catalog descriptor using a standard I/O stream FILE object as would be expected by fclose().
FUTURE DIRECTIONS
A future version of this standard may require abort() to be implemented in a manner such that its operation cannot be
affected by concurrent actions in other threads.
SEE ALSO
exit(), kill(),
raise(), signal(), wait(), waitid()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
Extensions beyond the ISO C standard are marked.
Changes are made to the DESCRIPTION for alignment with the ISO/IEC 9899:1999 standard.
The Open Group Base Resolution bwg2002-003 is applied.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/10 is applied, changing the DESCRIPTION of abnormal termination
processing and adding to the RATIONALE section.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/9 is applied, changing "implementation-defined functions" to
"implementation-supplied functions" in the APPLICATION USAGE section.
Issue 8
Austin Group Defect 906 is applied, clarifying how the behavior of abort() may be affected by concurrent actions in other
threads.
Austin Group Defect 1302 is applied, aligning this function with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/pthread_cond_destroy.html =====
pthread_cond_destroy
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pthread_cond_destroy, pthread_cond_init — destroy and initialize condition variables
SYNOPSIS
#include
int pthread_cond_destroy(pthread_cond_t *cond);
int pthread_cond_init(pthread_cond_t *restrict cond,
const pthread_condattr_t *restrict attr);
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
DESCRIPTION
The pthread_cond_destroy() function shall destroy the given condition variable specified by cond; the object
becomes, in effect, uninitialized. An implementation may cause pthread_cond_destroy() to set the object referenced by
cond to an invalid value. A destroyed condition variable object can be reinitialized using pthread_cond_init(); the
results of otherwise referencing the object after it has been destroyed are undefined.
It shall be safe to destroy an initialized condition variable upon which no threads are currently blocked. Attempting to destroy
a condition variable upon which other threads are currently blocked results in undefined behavior.
The pthread_cond_init() function shall initialize the condition variable referenced by cond with attributes
referenced by attr. If attr is NULL, the default condition variable attributes shall be used; the effect is the same
as passing the address of a default condition variable attributes object. Upon successful initialization, the state of the
condition variable shall become initialized.
See 2.9.9 Synchronization Object Copies and Alternative Mappings
for further requirements.
Attempting to initialize an already initialized condition variable results in undefined behavior.
In cases where default condition variable attributes are appropriate, the macro PTHREAD_COND_INITIALIZER can be used to
initialize condition variables. The effect shall be equivalent to dynamic initialization by a call to pthread_cond_init()
with parameter attr specified as NULL, except that no error checks are performed.
The behavior is undefined if the value specified by the cond argument to pthread_cond_destroy() does not refer to
an initialized condition variable.
The behavior is undefined if the value specified by the attr argument to pthread_cond_init() does not refer to an
initialized condition variable attributes object.
RETURN VALUE
If successful, the pthread_cond_destroy() and pthread_cond_init() functions shall return zero; otherwise, an error
number shall be returned to indicate the error.
ERRORS
The pthread_cond_init() function shall fail if:
[EAGAIN]
The system lacked the necessary resources (other than memory) to initialize another condition variable.
[ENOMEM]
Insufficient memory exists to initialize the condition variable.
These functions shall not return an error code of [EINTR].
The following sections are informative.
EXAMPLES
A condition variable can be destroyed immediately after all the threads that are blocked on it are awakened. For example,
consider the following code:
struct list {
pthread_mutex_t lm;
...
}
struct elt {
key k;
int busy;
pthread_cond_t notbusy;
...
}
/* Find a list element and reserve it. */
struct elt *
list_find(struct list *lp, key k)
{
struct elt *ep;
pthread_mutex_lock(&lp->lm);
while ((ep = find_elt(l, k) != NULL) && ep->busy)
pthread_cond_wait(&ep->notbusy, &lp->lm);
if (ep != NULL)
ep->busy = 1;
pthread_mutex_unlock(&lp->lm);
return(ep);
}
delete_elt(struct list *lp, struct elt *ep)
{
pthread_mutex_lock(&lp->lm);
assert(ep->busy);
... remove ep from list ...
ep->busy = 0;  /* Paranoid. */
(A) pthread_cond_broadcast(&ep->notbusy);
pthread_mutex_unlock(&lp->lm);
(B) pthread_cond_destroy(&ep->notbusy);
free(ep);
}
In this example, the condition variable and its list element may be freed (line B) immediately after all threads waiting for it
are awakened (line A), since the mutex and the code ensure that no other thread can touch the element to be deleted.
APPLICATION USAGE
None.
RATIONALE
If an implementation detects that the value specified by the cond argument to pthread_cond_destroy() does not
refer to an initialized condition variable, it is recommended that the function should fail and report an [EINVAL] error.
If an implementation detects that the value specified by the cond argument to pthread_cond_destroy() or
pthread_cond_init() refers to a condition variable that is in use (for example, in a pthread_cond_wait() call) by another thread, or detects that the value specified
by the cond argument to pthread_cond_init() refers to an already initialized condition variable, it is recommended
that the function should fail and report an [EBUSY] error.
If an implementation detects that the value specified by the attr argument to pthread_cond_init() does not refer
to an initialized condition variable attributes object, it is recommended that the function should fail and report an [EINVAL]
error.
See also pthread_mutex_destroy().
FUTURE DIRECTIONS
None.
SEE ALSO
pthread_cond_broadcast(), pthread_cond_clockwait(), pthread_mutex_destroy()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
The pthread_cond_destroy() and pthread_cond_init() functions are marked as part of the Threads option.
IEEE PASC Interpretation 1003.1c #34 is applied, updating the DESCRIPTION.
The restrict keyword is added to the pthread_cond_init() prototype for alignment with the ISO/IEC 9899:1999
standard.
Issue 7
The pthread_cond_destroy() and pthread_cond_init() functions are moved from the Threads option to the Base.
The [EINVAL] error for an uninitialized condition variable and an uninitialized condition variable attributes object is removed;
this condition results in undefined behavior.
The [EBUSY] error for a condition variable already in use or an already initialized condition variable is removed; this
condition results in undefined behavior.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0455 [70] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0269 [972] and XSH/TC2-2008/0270 [910] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/feraiseexcept.html =====
feraiseexcept
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
feraiseexcept — raise floating-point exception
SYNOPSIS
#include
int feraiseexcept(int excepts);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The feraiseexcept() function shall attempt to raise the supported floating-point exceptions represented by the
excepts argument. The order in which these floating-point exceptions are raised is unspecified, [MX]   except that if
the excepts argument represents IEC 60559 valid coincident floating-point exceptions for atomic operations (namely overflow
and inexact, or underflow and inexact), then overflow or underflow shall be raised before inexact.   Whether the feraiseexcept() function additionally raises the inexact floating-point
exception whenever it raises the overflow or underflow floating-point exception is implementation-defined.
RETURN VALUE
If the argument is zero or if all the specified exceptions were successfully raised, feraiseexcept() shall return zero.
Otherwise, it shall return a non-zero value.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The effect is intended to be similar to that of floating-point exceptions raised by arithmetic operations. Hence, enabled traps
for floating-point exceptions raised by this function are taken.
RATIONALE
Raising overflow or underflow is allowed to also raise inexact because on some architectures the only practical way to raise an
exception is to execute an instruction that has the exception as a side-effect. The function is not restricted to accept only valid
coincident expressions for atomic operations, so the function can be used to raise exceptions accrued over several operations.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fegetexceptflag(), fetestexcept()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
ISO/IEC 9899:1999 standard, Technical Corrigendum 1 is incorporated.
Issue 7
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0111 [543] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/posix_openpt.html =====
posix_openpt
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
posix_openpt — open a pseudo-terminal device
SYNOPSIS
[XSI]  #include
int posix_openpt(int oflag);
DESCRIPTION
The posix_openpt() function shall establish a connection between a manager device for a pseudo-terminal and a file
descriptor. The file descriptor shall be allocated as described in 2.6 File
Descriptor Allocation and can be used by other I/O functions that refer to that pseudo-terminal.
The file status flags and file access modes of the open file description shall be set according to the value of
oflag.
Values for oflag are constructed by a bitwise-inclusive OR of flags from the following list:
O_RDWR
Open for reading and writing.
O_CLOEXEC
Atomically set the FD_CLOEXEC flag on the file descriptor.
O_CLOFORK
Atomically set the FD_CLOFORK flag on the file descriptor.
O_NOCTTY
If set posix_openpt() shall not cause the terminal device to become the controlling terminal for the process.
The behavior of other values for the oflag argument is unspecified.
RETURN VALUE
Upon successful completion, the posix_openpt() function shall open a file descriptor for a manager pseudo-terminal device
and return a non-negative integer representing the file descriptor. Otherwise, -1 shall be returned and errno set to
indicate the error.
ERRORS
The posix_openpt() function shall fail if:
[EMFILE]
All file descriptors available to the process are currently open.
[ENFILE]
The maximum allowable number of files is currently open in the system.
The posix_openpt() function may fail if:
[EINVAL]
The value of oflag is not valid.
[EAGAIN]
Out of pseudo-terminal resources.
The following sections are informative.
EXAMPLES
Opening a Pseudo-Terminal and Returning the Name of the Subsidiary Device
and a File Descriptor
#include
#include
#include
int managerfd, subsidiaryfd;
char *subsidiarydevice;
managerfd = posix_openpt(O_RDWR|O_NOCTTY);
if (managerfd == -1
|| grantpt (managerfd) == -1
|| unlockpt (managerfd) == -1
|| (subsidiarydevice = ptsname (managerfd)) == NULL)
return -1;
printf("subsidiary device is: %s\n", subsidiarydevice);
subsidiaryfd = open(subsidiarydevice, O_RDWR|O_NOCTTY);
if (subsidiaryfd ,
CHANGE HISTORY
First released in Issue 6.
Issue 7
SD5-XBD-ERN-4 is applied, changing the definition of the [EMFILE] error.
SD5-XSH-ERN-51 is applied, correcting an error in the EXAMPLES section.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0253 [835] and XSH/TC2-2008/0254 [835] are applied.
Issue 8
Austin Group Defects 411 and 1318 are applied, adding O_CLOEXEC and O_CLOFORK.
Austin Group Defect 508 is applied, changing the APPLICATION USAGE and RATIONALE sections to refer to ptsname_r() as well as ptsname().
Austin Group Defect 593 is applied, removing #include  from the SYNOPSIS and a reference to  from the DESCRIPTION section.
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
Austin Group Defect 1466 is applied, changing the terminology used for pseudo-terminal devices.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/munmap.html =====
munmap
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
munmap — unmap pages of memory
SYNOPSIS
#include
int munmap(void *addr, size_t len);
DESCRIPTION
The munmap() function shall remove any mappings for those entire pages containing any part of the address space of the
process starting at addr and continuing for len bytes. Further references to these pages shall result in the
generation of a SIGSEGV signal to the process. If there are no mappings in the specified address range, then munmap() has no
effect.
The implementation may require that addr be a multiple of the page size as returned by sysconf().
If a mapping to be removed was private, any modifications made in this address range shall be discarded.
[ML|MLR]
Any memory locks (see mlock() and mlockall()) associated with this address range shall be removed, as if by an appropriate
call to munlock().
[TYM]
If a mapping removed from a typed memory object causes the corresponding address range of the memory pool to be inaccessible by any
process in the system except through allocatable mappings (that is, mappings of typed memory objects opened with the
POSIX_TYPED_MEM_MAP_ALLOCATABLE flag), then that range of the memory pool shall become deallocated and may become available to
satisfy future typed memory allocation requests.
A mapping removed from a typed memory object opened with the POSIX_TYPED_MEM_MAP_ALLOCATABLE flag shall not affect in any way
the availability of that typed memory for allocation.
The behavior of this function is unspecified if the mapping was not established by a call to mmap().
RETURN VALUE
Upon successful completion, munmap() shall return 0; otherwise, it shall return -1 and set errno to indicate the
error.
ERRORS
The munmap() function shall fail if:
[EINVAL]
Addresses in the range [addr,addr+len) are outside the valid range for the address space of a
process.
[EINVAL]
The len argument is 0.
The munmap() function may fail if:
[EINVAL]
The addr argument is not a multiple of the page size as returned by sysconf().
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
The munmap() function corresponds to SVR4, just as the mmap() function
does.
It is possible that an application has applied process memory locking to a region that contains shared memory. If this has
occurred, the munmap() call ignores those locks and, if necessary, causes those locks to be removed.
Most implementations require that addr is a multiple of the page size as returned by sysconf().
FUTURE DIRECTIONS
None.
SEE ALSO
mlock(), mlockall(), mmap(), posix_typed_mem_open(),
sysconf()
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Aligned with munmap() in the POSIX Realtime Extension as follows:
The DESCRIPTION is extensively reworded.
The SIGBUS error is no longer permitted to be generated.
Issue 6
The munmap() function is marked as part of the Memory Mapped Files and Shared Memory Objects option.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The DESCRIPTION is updated to state that implementations require addr to be a multiple of the page size.
The [EINVAL] error conditions are added.
The following changes are made for alignment with IEEE Std 1003.1j-2000:
Semantics for typed memory objects are added to the DESCRIPTION.
The posix_typed_mem_open() function is added to the SEE ALSO
section.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/36 is applied, changing the margin code in the SYNOPSIS from
MF|SHM to MC3 (notation for MF|SHM|TYM).
Issue 7
Austin Group Interpretation 1003.1-2001 #078 is applied, clarifying page alignment requirements.
The munmap() function is moved from the Memory Mapped Files option to the Base.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/catanf.html =====
catan
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
catan, catanf, catanl — complex arc tangent functions
SYNOPSIS
#include
double complex catan(double complex z);
float complex catanf(float complex z);
long double complex catanl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex arc tangent of z, with branch cuts outside the interval
[-i, +i] along the imaginary axis.
RETURN VALUE
These functions shall return the complex arc tangent value, in the range of a strip mathematically unbounded along the imaginary
axis and in the interval [-ℼ/2, +ℼ/2] along the real axis.
[MXC]
catan(conj(iz)), catanf(conjf(iz)), and catanl(conjl(iz)) shall
return exactly the same value as conj(catan(iz)), conjf(catanf(iz)), and
conjl(catanl(iz)), respectively, and catan(-iz), catanf(-iz), and
catanl(-iz) shall return exactly the same value as -catan(iz), -catanf(iz), and
-catanl(iz), respectively, including for the special values of iz below.
If iz is +0 + i0, -i (+0 + i0) shall be returned.
If iz is +0 + iNaN, -i (+0 + iNaN) shall be returned.
If iz is +1 + i0, -i (+Inf + i0) shall be returned and the divide-by-zero floating-point exception
shall be raised.
If iz is x + iInf where x is positive-signed and finite, -i (+0 + iℼ/2) shall be
returned.
If iz is x + iNaN where x is non-zero and finite, -i (NaN + iNaN) shall be returned
and the invalid floating-point exception may be raised.
If iz is +Inf + iy where y is positive-signed and finite, -i (+0 + iℼ/2) shall be
returned.
If iz is +Inf + iInf, -i (+0 + iℼ/2) shall be returned.
If iz is +Inf + iNaN, -i (+0 + iNaN) shall be returned.
If iz is NaN + iy where y is finite, -i (NaN + iNaN) shall be returned and the invalid
floating-point exception may be raised.
If iz is NaN + iInf, -i (±0 + iℼ/2) shall be returned; the sign of the imaginary part of the result
is unspecified.
If iz is NaN + iNaN, -i (NaN + iNaN) shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
The MXC special cases for catan() are derived from those for catanh() by
applying the formula catan(z) = -i catanh(iz).
FUTURE DIRECTIONS
None.
SEE ALSO
catanh(), ctan()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/socketpair.html =====
socketpair
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
socketpair — create a pair of connected sockets
SYNOPSIS
#include
int socketpair(int domain, int type, int protocol,
int socket_vector[2]);
DESCRIPTION
The socketpair() function shall create an unbound pair of connected sockets in a specified domain, of a specified
type, under the protocol optionally specified by the protocol argument. The two sockets shall be identical. The file
descriptors used in referencing the created sockets shall be returned in socket_vector[0] and socket_vector[1]. The
file descriptors shall be allocated as described in 2.6 File Descriptor
Allocation.
The socketpair() function takes the following arguments:
domain
Specifies the communications domain in which the sockets are to be created.
type
Specifies the type of sockets to be created.
protocol
Specifies a particular protocol to be used with the sockets. Specifying a protocol of 0 causes socketpair() to
use an unspecified default protocol appropriate for the requested socket type.
socket_vector
Specifies a 2-integer array to hold the file descriptors of the created socket pair.
The type argument specifies the socket type, which determines the semantics of communications over the socket. The
following socket types are defined; implementations may specify additional socket types:
SOCK_STREAM
Provides sequenced, reliable, bidirectional, connection-mode byte streams, and may provide a transmission mechanism for
out-of-band data.
SOCK_DGRAM
Provides datagrams, which are connectionless-mode, unreliable messages of fixed maximum length.
SOCK_SEQPACKET
Provides sequenced, reliable, bidirectional, connection-mode transmission paths for records. A record can be sent using one or
more output operations and received using one or more input operations, but a single operation never transfers part of more than
one record. Record boundaries are visible to the receiver via the MSG_EOR flag.
Additionally, the type argument can contain the bitwise-inclusive OR of flags from the following list:
SOCK_CLOEXEC
Atomically set the FD_CLOEXEC flag on the new file descriptors.
SOCK_CLOFORK
Atomically set the FD_CLOFORK flag on the new file descriptors.
SOCK_NONBLOCK
Set the O_NONBLOCK file status flag on the new file descriptions.
Implementations may define additional flags.
If the protocol argument is non-zero, it shall specify a protocol that is supported by the address family. If the
protocol argument is zero, the default protocol for this address family and type shall be used. The protocols supported by
the system are implementation-defined.
The process may need to have appropriate privileges to use the socketpair() function or to create some sockets.
RETURN VALUE
Upon successful completion, this function shall return 0; otherwise, -1 shall be returned and errno set to indicate the
error, no file descriptors shall be allocated, and the contents of socket_vector shall be left unmodified.
ERRORS
The socketpair() function shall fail if:
[EAFNOSUPPORT]
The implementation does not support the specified address family.
[EMFILE]
All, or all but one, of the file descriptors available to the process are currently open.
[ENFILE]
No more file descriptors are available for the system.
[EOPNOTSUPP]
The specified protocol does not permit creation of socket pairs.
[EPROTONOSUPPORT]
The protocol is not supported by the address family, or the protocol is not supported by the implementation.
[EPROTOTYPE]
The socket type is not supported by the protocol.
The socketpair() function may fail if:
[EACCES]
The process does not have appropriate privileges.
[ENOBUFS]
Insufficient resources were available in the system to perform the operation.
[ENOMEM]
Insufficient memory was available to fulfill the request.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The documentation for specific address families specifies which protocols each address family supports. The documentation for
specific protocols specifies which socket types each protocol supports.
The socketpair() function is used primarily with UNIX domain sockets and need not be supported for other domains.
RATIONALE
The use of the SOCK_CLOEXEC and SOCK_CLOFORK flags in the type argument of socketpair() is necessary to avoid a
data race in multi-threaded applications. Without SOCK_CLOFORK, a file descriptor is leaked into a child process created by one
thread in the window between another using socketpair() and using using fcntl()
to set the FD_CLOFORK flag. Without SOCK_CLOEXEC, a file descriptor intentionally inherited by child processes is similarly leaked
into an executed program if FD_CLOEXEC is not set atomically.
Since socket pairs are often used for communication between a parent and child process, SOCK_CLOFORK has to be used with care in
order for the pair to be usable. If the parent will be writing and the child will be reading, SOCK_CLOFORK should be used when
creating the pair, and then fcntl() should be used to clear FD_CLOFORK for the read
side of the pair. This prevents the write side from leaking into other children, ensuring the child will get end-of-file when the
parent closes the write side (although the read side can still be leaked). If the parent will be reading and the child will be
writing, or if the socket pair will be used bidirectionally, there is no way to prevent the write side(s) being leaked (short of
preventing other threads from creating child processes) in order to ensure the parent gets end-of-file when the child closes its
side, and so the two processes should use an alternative method of indicating the end of communications, for example using shutdown().
Arranging for FD_CLOEXEC to be set appropriately is more straightforward. The parent should use SOCK_CLOEXEC when creating the
socket pair and the child should clear FD_CLOEXEC on the side to be passed to the new program before calling an exec family function to execute it.
The SOCK_NONBLOCK flag is for convenience in avoiding additional fcntl() calls.
FUTURE DIRECTIONS
None.
SEE ALSO
2.6 File Descriptor Allocation, socket()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
Issue 7
The description of the [EMFILE] error condition is aligned with the pipe()
function.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0336 [835] and XSH/TC2-2008/0337 [483,835] are applied.
Issue 8
Austin Group Defects 411 and 1318 are applied, adding SOCK_CLOEXEC, SOCK_CLOFORK, and SOCK_NONBLOCK.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/tolower_l.html =====
tolower
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
tolower, tolower_l — transliterate uppercase characters to lowercase
SYNOPSIS
#include
int tolower(int c);
[CX]  int tolower_l(int c, locale_t locale);
DESCRIPTION
For tolower(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The tolower() [CX]   and tolower_l()
functions have as a domain a type int, the value of which is representable as an unsigned char or the value of
EOF. If the argument has any other value, the behavior is undefined. If the argument of tolower() [CX]   or
tolower_l()   represents an uppercase letter, and there
exists a corresponding lowercase letter as defined by character type information in the current locale [CX]   or in the
locale represented by locale,   respectively (category
LC_CTYPE ), the result shall be the corresponding lowercase letter. All other arguments in the domain are returned
unchanged.
[CX]  The
behavior is undefined if the locale argument to tolower_l() is the special locale object LC_GLOBAL_LOCALE or is not a
valid locale object handle.
RETURN VALUE
Upon successful completion, the tolower() [CX]   and tolower_l()   functions shall return the lowercase letter corresponding to the argument passed; otherwise, they
shall return the argument unchanged.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
setlocale(), uselocale()
XBD 7. Locale, ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
Extensions beyond the ISO C standard are marked.
Issue 7
The tolower_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0671 [283] and XSH/TC1-2008/0672 [283] are applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/c16rtomb.html =====
c16rtomb
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
c16rtomb, c32rtomb — convert a Unicode character code to a character (restartable)
SYNOPSIS
#include
size_t c16rtomb(char *restrict s, char16_t c16, mbstate_t *restrict ps);
size_t c32rtomb(char *restrict s, char32_t c32, mbstate_t *restrict
ps);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
If s is a null pointer, the c16rtomb() function shall be equivalent to the call:
c16rtomb(buf, L'\0', ps)
where buf is an internal buffer.
If s is not a null pointer, the c16rtomb() function shall determine the number of bytes needed to represent the
character that corresponds to the wide character given by c16 (including any shift sequences), and store the resulting bytes
in the array whose first element is pointed to by s. At most {MB_CUR_MAX} bytes shall be stored. If c16 is a null
wide character, a null byte shall be stored, preceded by any shift sequence needed to restore the initial shift state; the
resulting state described shall be the initial conversion state.
If ps is a null pointer, the c16rtomb() function shall use its own internal mbstate_t object, which shall
be initialized at program start-up to the initial conversion state. Otherwise, the mbstate_t object pointed to by ps
shall be used to completely describe the current conversion state of the associated character sequence.
The behavior of this function is affected by the LC_CTYPE category of the current locale.
The mbrtoc16() function shall not change the setting of errno if
successful.
The c32rtomb() function shall behave the same way as c16rtomb() except that the second parameter shall be an
object of type char32_t instead of char16_t. References to c16 in the above description shall apply as if they
were c32 when they are being read as describing c32rtomb().
If called with a null ps argument, the c16rtomb() function need not be thread-safe; however, such calls shall
avoid data races with calls to c16rtomb() with a non-null argument and with calls to all other functions.
If called with a null ps argument, the c32rtomb() function need not be thread-safe; however, such calls shall
avoid data races with calls to c32rtomb() with a non-null argument and with calls to all other functions.
The implementation shall behave as if no function defined in this volume of POSIX.1-2024 calls c16rtomb() or
c32rtomb() with a null pointer for ps.
RETURN VALUE
These functions shall return the number of bytes stored in the array object (including any shift sequences). When c16 or
c32 is not a valid wide character, an encoding error shall occur. In this case, the function shall store the value of the
macro [EILSEQ] in errno and shall return (size_t)-1; the conversion state is unspecified.
ERRORS
These functions shall fail if:
[EILSEQ]
An invalid wide-character code is detected.
These functions may fail if:
[EINVAL]
[CX]
ps points to an object that contains an invalid conversion state.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
mbrtoc16()
XBD
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/atomic_fetch_and.html =====
atomic_fetch_add
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
atomic_fetch_add, atomic_fetch_add_explicit, atomic_fetch_and, atomic_fetch_and_explicit, atomic_fetch_or,
atomic_fetch_or_explicit, atomic_fetch_sub, atomic_fetch_sub_explicit, atomic_fetch_xor, atomic_fetch_xor_explicit — atomically
replace the value of an object with the result of a computation
SYNOPSIS
#include
C atomic_fetch_add(volatile A *object, M operand); C
atomic_fetch_add_explicit(volatile A *object, M operand,
memory_order order); C atomic_fetch_and(volatile A
*object, M operand); C atomic_fetch_and_explicit(volatile A
*object, M operand,
memory_order order); C atomic_fetch_or(volatile A
*object, M operand); C atomic_fetch_or_explicit(volatile A
*object, M operand,
memory_order order); C atomic_fetch_sub(volatile A
*object, M operand); C atomic_fetch_sub_explicit(volatile A
*object, M operand,
memory_order order); C atomic_fetch_xor(volatile A
*object, M operand); C atomic_fetch_xor_explicit(volatile A
*object, M operand,
memory_order order);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
Implementations that define the macro __STDC_NO_ATOMICS__ need not provide the  header nor support these generic functions.
The atomic_fetch_add_explicit() generic function shall atomically replace the value pointed to by object with the
result of adding operand to this value. This operation shall be an atomic read-modify-write operation (see XBD 4.15.1 Memory Ordering). Memory shall be affected according to the value of
order.
The atomic_fetch_add() generic function shall be equivalent to atomic_fetch_add_explicit() called with
order set to memory_order_seq_cst.
The other atomic_fetch_*() generic functions shall be equivalent to atomic_fetch_add_explicit() if their name ends
with explicit, or to atomic_fetch_add() if it does not, respectively, except that they perform the computation
indicated in their name, instead of addition:
sub
subtraction
or
bitwise inclusive OR
xor
bitwise exclusive OR
and
bitwise AND
For addition and subtraction, the application shall ensure that A is an atomic integer type or an atomic pointer type and is not
atomic_bool. For the other operations, the application shall ensure that A is an atomic integer type and is not
atomic_bool.
For signed integer types, the computation shall silently wrap around on overflow; there are no undefined results. For pointer
types, the result can be an undefined address, but the computations otherwise have no undefined behavior.
RETURN VALUE
These generic functions shall return the value pointed to by object immediately before the effects.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The operation of these generic functions is nearly equivalent to the operation of the corresponding compound assignment
operators +=, -=, etc. The only differences are that the compound assignment operators are not guaranteed to
operate atomically, and the value yielded by a compound assignment operator is the updated value of the object, whereas the value
returned by these generic functions is the previous value of the atomic object.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD 4.15.1 Memory Ordering,
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/mtx_lock.html =====
mtx_lock
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
mtx_lock, mtx_timedlock, mtx_trylock, mtx_unlock — lock and unlock a mutex
SYNOPSIS
#include
int mtx_lock(mtx_t *mtx);
int mtx_timedlock(mtx_t *restrict mtx,
const struct timespec *restrict ts);
int mtx_trylock(mtx_t *mtx);
int mtx_unlock(mtx_t *mtx);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
The mtx_lock() function shall block until it locks the mutex pointed to by mtx. If the mutex is non-recursive, the
application shall ensure that it is not already locked by the calling thread.
The mtx_timedlock() function shall block until it locks the mutex pointed to by mtx or until after the
TIME_UTC-based calendar time pointed to by ts. The application shall ensure that the specified mutex supports timeout.
[CX]  Under
no circumstance shall the function fail with a timeout if the mutex can be locked immediately. The validity of the ts
parameter need not be checked if the mutex can be locked immediately.
The mtx_trylock() function shall endeavor to lock the mutex pointed to by mtx. If the mutex is already locked (by
any thread, including the current thread), the function shall return without blocking. If the mutex is recursive and the mutex is
currently owned by the calling thread, the mutex lock count (see below) shall be incremented by one and the mtx_trylock()
function shall immediately return success.
[CX]
These functions shall not be affected if the calling thread executes a signal handler during the call; if a signal is delivered to
a thread waiting for a mutex, upon return from the signal handler the thread shall resume waiting for the mutex as if it was not
interrupted.
If a call to mtx_lock(), mtx_timedlock() or mtx_trylock() locks the mutex, prior calls to
mtx_unlock() on the same mutex shall synchronize with this lock operation.
The mtx_unlock() function shall unlock the mutex pointed to by mtx. The application shall ensure that the mutex
pointed to by mtx is locked by the calling thread. [CX]   If there are threads blocked on the mutex object referenced by
mtx when mtx_unlock() is called, resulting in the mutex becoming available, the scheduling policy shall determine
which thread shall acquire the mutex.
A recursive mutex shall maintain the concept of a lock count. When a thread successfully acquires a mutex for the first time,
the lock count shall be set to one. Every time a thread relocks this mutex, the lock count shall be incremented by one. Each time
the thread unlocks the mutex, the lock count shall be decremented by one. When the lock count reaches zero, the mutex shall become
available for other threads to acquire.
For purposes of determining the existence of a data race, mutex lock and unlock operations on mutexes of type mtx_t
behave as atomic operations. All lock and unlock operations on a particular mutex occur in some particular total order.
If mtx does not refer to an initialized mutex object, the behavior of these functions is undefined.
RETURN VALUE
The mtx_lock() and mtx_unlock() functions shall return thrd_success on success, or thrd_error if
the request could not be honored.
The mtx_timedlock() function shall return thrd_success on success, or thrd_timedout if the time
specified was reached without acquiring the requested resource, or thrd_error if the request could not be honored.
The mtx_trylock() function shall return thrd_success on success, or thrd_busy if the resource requested
is already in use, or thrd_error if the request could not be honored. The mtx_trylock() function can spuriously
fail to lock an unused resource, in which case it shall return thrd_busy.
ERRORS
See RETURN VALUE.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
These functions are not affected by signal handlers for the reasons stated in XRAT B.2.3 Error Numbers.
Since  has no equivalent of the mtx_timed mutex
property, if the  interfaces are implemented as a thin wrapper
around  interfaces (meaning mtx_t and
pthread_mutex_t are the same type), all mutexes support timeout and mtx_timedlock() will not fail for a mutex that
was not initialized with mtx_timed. Alternatively, implementations can use a less thin wrapper where mtx_t contains
additional properties that are not held in pthread_mutex_t in order to be able to return a failure indication from
mtx_timedlock() calls where the mutex was not initialized with mtx_timed.
FUTURE DIRECTIONS
None.
SEE ALSO
mtx_destroy(), timespec_get()
XBD
CHANGE HISTORY
First released in Issue 8. Included for alignment with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/tdelete.html =====
tdelete
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
tdelete, tfind, tsearch, twalk — manage a binary search tree
SYNOPSIS
[XSI]  #include
void *tdelete(const void *restrict key,
posix_tnode **restrict rootp,
int(*compar)(const void *, const void *));
posix_tnode *tfind(const void *key,
posix_tnode *const *rootp,
int(*compar)(const void *, const void *));
posix_tnode *tsearch(const void *key,
posix_tnode **rootp,
int (*compar)(const void *, const void *));
void twalk(const posix_tnode *root,
void (*action)(const posix_tnode *, VISIT, int));
DESCRIPTION
The tdelete(), tfind(), tsearch(), and twalk() functions manipulate binary search trees. Comparisons
are made with a user-supplied routine, the address of which is passed as the compar argument. This routine is called with
two arguments, which are the pointers to the elements being compared. The application shall ensure that the user-supplied routine
returns an integer less than, equal to, or greater than 0, according to whether the first argument is to be considered less than,
equal to, or greater than the second argument. The comparison function need not compare every byte, so arbitrary data may be
contained in the elements in addition to the values being compared.
The tsearch() function shall build and access the tree. The key argument is a pointer to an element to be accessed
or stored. If there is a node in the tree whose element is equal to the value pointed to by key, a pointer to this found
node shall be returned. Otherwise, the value pointed to by key shall be inserted (that is, a new node is created and the
value of key is copied to this node), and a pointer to this node returned. Only pointers are copied, so the application
shall ensure that the calling routine stores the data. The rootp argument points to a variable that points to the root node
of the tree. A null pointer value for the variable pointed to by rootp denotes an empty tree; in this case, the variable
shall be set to point to the node which shall be at the root of the new tree.
Like tsearch(), tfind() shall search for a node in the tree, returning a pointer to it if found. However, if it is
not found, tfind() shall return a null pointer. The arguments for tfind() are the same as for tsearch().
The tdelete() function shall delete a node from a binary search tree. The arguments are the same as for tsearch().
The variable pointed to by rootp shall be set to a pointer to the new root of the tree if the root of the tree was changed.
If the deleted node was the root of the tree and had no children, the variable pointed to by rootp shall be set to a null
pointer. The tdelete() function shall return a pointer to the parent of the deleted node, or an unspecified non-null pointer
if the deleted node was the root node, or a null pointer if the node is not found.
If tsearch() adds an element to a tree, or tdelete() successfully deletes an element from a tree, the concurrent
use of that tree in another thread, or use of pointers produced by a previous call to tfind() or tsearch(), produces
undefined results.
The twalk() function shall traverse a binary search tree. The root argument is a pointer to the root node of the
tree to be traversed. (Any node in a tree may be used as the root for a walk below that node.) The argument action is the
name of a routine to be invoked at each node. This routine is, in turn, called with three arguments. The first argument shall be
the address of the node being visited. The structure pointed to by this argument is unspecified and shall not be modified by the
application, but it shall be possible to cast a pointer-to-node into a pointer-to-pointer-to-element to access the element stored
in the node. The second argument shall be a value from an enumeration data type:
typedef enum { preorder, postorder, endorder, leaf } VISIT;
(defined in ), depending on whether this is the first, second, or
third time that the node is visited (during a depth-first, left-to-right traversal of the tree), or whether the node is a leaf. The
third argument shall be the level of the node in the tree, with the root being level 0.
If the calling function alters the pointer to the root, the result is undefined.
If the functions pointed to by action or compar (for any of these binary search functions) change the tree, the
results are undefined.
These functions are thread-safe only as long as multiple threads do not access the same tree.
RETURN VALUE
If the node is found, both tsearch() and tfind() shall return a pointer to it. If not, tfind() shall return
a null pointer, and tsearch() shall return a pointer to the inserted item.
A null pointer shall be returned by tsearch() if there is not enough space available to create a new node.
A null pointer shall be returned by tdelete(), tfind(), and tsearch() if rootp is a null pointer on
entry.
The tdelete() function shall return a pointer to the parent of the deleted node, or an unspecified non-null pointer if
the deleted node was the root node, or a null pointer if the node is not found.
The twalk() function shall not return a value.
In all cases where a pointer to a node is returned, the structure pointed to by the return value is unspecified and shall not be
modified by the application, but it shall be possible to cast a pointer-to-node into a pointer-to-pointer-to-element to access the
element stored in the node.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
The following code reads in strings and stores structures containing a pointer to each string and a count of its length. It then
walks the tree, printing out the stored strings and their lengths in alphabetical order.
#include
#include
#include
#include
#include
struct element {      /* Pointers to these are stored in the tree. */
int     count;
char    string[];
};
posix_tnode  *root = NULL;          /* This points to the root. */
int main(void)
{
char   str[_POSIX2_LINE_MAX+1];
int    length = 0;
struct element *elementptr;
posix_tnode *node;
void   print_node(const posix_tnode *, VISIT, int);
int    node_compare(const void *, const void *);
while (fgets(str, sizeof(str), stdin))  {
/* Set element. */
length = strlen(str);
if (str[length-1] == '\n')
str[--length] = '\0';
elementptr = malloc(sizeof(struct element) + length + 1);
strcpy(elementptr->string, str);
elementptr->count = 1;
/* Put element into the tree. */
node = tsearch((void *)elementptr, &root, node_compare);
if (node == NULL) {
fprintf(stderr,
"tsearch: Not enough space available\n");
exit(EXIT_FAILURE);
}
else if (*(struct element **)node != elementptr) {
/* A node containing the element already exists */
(*(struct element **)node)->count++;
free(elementptr);
}
}
twalk(root, print_node);
/* Delete all nodes in the tree */
while (root != NULL) {
elementptr = *(struct element **)root;
printf("deleting node: string = %s,  count = %d\n",
elementptr->string,
elementptr->count);
tdelete((void *)elementptr, &root, node_compare);
free(elementptr);
}
return 0;
}
/*
*  This routine compares two nodes, based on an
*  alphabetical ordering of the string field.
*/
int
node_compare(const void *node1, const void *node2)
{
return strcmp(((const struct element *) node1)->string,
((const struct element *) node2)->string);
}
/*
*  This routine prints out a node, the second time
*  twalk encounters it or if it is a leaf.
*/
void
print_node(const posix_tnode *ptr, VISIT order, int level)
{
const struct element *p = *(const struct element **) ptr;
if (order == postorder || order == leaf)  {
(void) printf("string = %s,  count = %d\n",
p->string, p->count);
}
}
APPLICATION USAGE
The root argument to twalk() is one level of indirection less than the rootp arguments to tdelete()
and tsearch().
There are two nomenclatures used to refer to the order in which tree nodes are visited. The twalk() function uses
preorder, postorder, and endorder to refer respectively to visiting a node before any of its children, after
its left child and before its right, and after both its children. The alternative nomenclature uses preorder,
inorder, and postorder to refer to the same visits, which could result in some confusion over the meaning of
postorder.
Since the return value of tdelete() is an unspecified non-null pointer in the case that the root of the tree has been
deleted, applications should only use the return value of tdelete() as indication of success or failure in this case and
should not assume it can be dereferenced. However, the only way that applications can tell if this case may have occurred is by
checking whether the variable pointed to by rootp changed. Since this variable can change for other reasons (for example,
tree balancing), using the return value of tdelete() as anything other than a boolean indicator is unreliable at best and is
discouraged. Some implementations in this case will return a pointer to the new root of the tree (or to an empty tree if the
deleted root node was the only node in the tree); other implementations return arbitrary non-null pointers.
RATIONALE
Implementations are encouraged to use balanced trees to reduce the depth of the trees that are created and improve tree search
times.
FUTURE DIRECTIONS
None.
SEE ALSO
hcreate(), lsearch()
XBD
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The last paragraph of the DESCRIPTION was included as an APPLICATION USAGE note in previous issues.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
The restrict keyword is added to the tdelete() prototype for alignment with the ISO/IEC 9899:1999
standard.
Issue 7
Austin Group Interpretation 1003.1-2001 #149 is applied, clarifying concurrent use of the tree in another thread.
Austin Group Interpretation 1003.1-2001 #151 is applied, clarifying behavior for tdelete() when the deleted node is the
root node.
Austin Group Interpretation 1003.1-2001 #153 is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0366 [551] is applied.
Issue 8
Austin Group Defect 1011 is applied, changing some prototypes to use posix_tnode instead of void, and changing the
required behavior for tdelete() when the root of the tree changes.
Austin Group Defect 1470 is applied, changing the EXAMPLES section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getpriority.html =====
getpriority
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getpriority, setpriority — get and set the nice value
SYNOPSIS
[XSI]  #include
int getpriority(int which, id_t who);
int setpriority(int which, id_t who, int value);
DESCRIPTION
The getpriority() function shall obtain the nice value of a process, process group, or user. The setpriority()
function shall set the nice value of a process, process group, or user to value+{NZERO}.
Target processes are specified by the values of the which and who arguments. The which argument may be one
of the following values: PRIO_PROCESS, PRIO_PGRP, or PRIO_USER, indicating that the who argument is to be interpreted as a
process ID, a process group ID, or an effective user ID, respectively. A 0 value for the who argument specifies the current
process, process group, or user.
The nice value set with setpriority() shall be applied to the process. If the process is multi-threaded, the nice value
shall affect all system scope threads in the process.
If more than one process is specified, getpriority() shall return value {NZERO} less than the lowest nice value
pertaining to any of the specified processes, and setpriority() shall set the nice values of all of the specified processes
to value+{NZERO}.
The default nice value is {NZERO}; lower nice values shall cause more favorable scheduling. While the range of valid nice values
is [0,{NZERO}*2-1], implementations may enforce more restrictive limits. If value+{NZERO} is less than the system's lowest
supported nice value, setpriority() shall set the nice value to the lowest supported value; if value+{NZERO} is
greater than the system's highest supported nice value, setpriority() shall set the nice value to the highest supported
value.
Only a process with appropriate privileges can lower its nice value.
[PS|TPS]
Any processes or threads using SCHED_FIFO or SCHED_RR shall be unaffected by a call to setpriority(). This is not considered
an error. A process which subsequently reverts to SCHED_OTHER need not have its priority affected by such a setpriority()
call.
The effect of changing the nice value may vary depending on the process-scheduling algorithm in effect.
Since getpriority() can return the value -1 upon successful completion, it is necessary to set errno to 0 prior to
a call to getpriority(). If getpriority() returns the value -1, then errno can be checked to see if an error
occurred or if the value is a legitimate nice value.
RETURN VALUE
Upon successful completion, getpriority() shall return an integer in the range -{NZERO} to {NZERO}-1. Otherwise, -1 shall
be returned and errno set to indicate the error.
Upon successful completion, setpriority() shall return 0; otherwise, -1 shall be returned and errno set to
indicate the error.
ERRORS
The getpriority() and setpriority() functions shall fail if:
[ESRCH]
No process could be located using the which and who argument values specified.
[EINVAL]
The value of the which argument was not recognized, or the value of the who argument is not a valid process ID,
process group ID, or user ID.
In addition, setpriority() may fail if:
[EPERM]
A process was located, but neither the real nor effective user ID of the executing process match the effective user ID of the
process whose nice value is being changed.
[EACCES]
A request was made to change the nice value to a lower numeric value and the current process does not have appropriate
privileges.
The following sections are informative.
EXAMPLES
Using getpriority()
The following example returns the current scheduling priority for the process ID returned by the call to getpid().
#include
...
int which = PRIO_PROCESS;
id_t pid;
int ret;
pid = getpid();
ret = getpriority(which, pid);
Using setpriority()
The following example sets the priority for the current process ID to -20.
#include
...
int which = PRIO_PROCESS;
id_t pid;
int priority = -20;
int ret;
pid = getpid();
ret = setpriority(which, pid, priority);
APPLICATION USAGE
The getpriority() and setpriority() functions work with an offset nice value (nice value -{NZERO}). The nice value
is in the range [0,2*{NZERO} -1], while the return value for getpriority() and the third parameter for setpriority()
are in the range [-{NZERO},{NZERO} -1].
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
nice(), sched_get_priority_max(), sched_setscheduler()
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
The DESCRIPTION is reworded in terms of the nice value rather than priority to avoid confusion with functionality in the
POSIX Realtime Extension.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/getchar_unlocked.html =====
getc_unlocked
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getc_unlocked, getchar_unlocked, putc_unlocked, putchar_unlocked — stdio with explicit client locking
SYNOPSIS
[CX]  #include
int getc_unlocked(FILE *stream);
int getchar_unlocked(void);
int putc_unlocked(int c, FILE *stream);
int putchar_unlocked(int c);
DESCRIPTION
Versions of the functions getc(), getchar(), putc(), and putchar() respectively named getc_unlocked(), getchar_unlocked(),
putc_unlocked(), and putchar_unlocked() shall be provided which are functionally equivalent to the original versions,
with the exception that they are not required to be implemented in a fully thread-safe manner. They shall be thread-safe when used
within a scope protected by flockfile() (or ftrylockfile()) and funlockfile().
These functions can safely be used in a multi-threaded program if and only if they are called while the invoking thread owns the
(FILE *) object, as is the case after a successful call to the flockfile()
or ftrylockfile() functions.
If getc_unlocked() or putc_unlocked() are implemented as macros they may evaluate stream more than once, so
the stream argument should never be an expression with side-effects.
RETURN VALUE
See getc(), getchar(), putc(), and putchar().
ERRORS
See getc(), getchar(), putc(), and putchar().
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
Since they may be implemented as macros, getc_unlocked() and putc_unlocked() may treat incorrectly a stream
argument with side-effects. In particular, getc_unlocked(*f++) and putc_unlocked(c,*f++) do not necessarily work as
expected. Therefore, use of these functions in such situations should be preceded by the following statement as appropriate:
#undef getc_unlocked
#undef putc_unlocked
RATIONALE
Some I/O functions are typically implemented as macros for performance reasons (for example, putc() and getc()). For safety, they need to be
synchronized, but it is often too expensive to synchronize on every character. Nevertheless, it was felt that the safety concerns
were more important; consequently, the getc(), getchar(), putc(), and putchar() functions are required to be thread-safe. However, unlocked versions are also
provided with names that clearly indicate the unsafe nature of their operation but can be used to exploit their higher performance.
These unlocked versions can be safely used only within explicitly locked program regions, using exported locking primitives. In
particular, a sequence such as:
flockfile(fileptr);
putc_unlocked('1', fileptr);
putc_unlocked('\n', fileptr);
fprintf(fileptr, "Line 2\n");
funlockfile(fileptr);
is permissible, and results in the text sequence:
1
Line 2
being printed without being interspersed with output from other threads.
It would be wrong to have the standard names such as getc(), putc(), and so on, map to the "faster, but unsafe" rather than the "slower, but safe"
versions. In either case, you would still want to inspect all uses of getc(), putc(), and so on, by hand when converting existing code. Choosing the safe bindings as the
default, at least, results in correct code and maintains the "atomicity at the function" invariant. To do otherwise would
introduce gratuitous synchronization errors into converted code. Other routines that modify the stdio (FILE *)
structures or buffers are also safely synchronized.
Note that there is no need for functions of the form getc_locked(), putc_locked(), and so on, since this is the
functionality of getc(), putc(), et
al. It would be inappropriate to use a feature test macro to switch a macro definition of getc() between getc_locked() and getc_unlocked(), since the ISO C standard
requires an actual function to exist, a function whose behavior could not be changed by the feature test macro. Also, providing
both the xxx_locked() and xxx_unlocked() forms leads to the confusion of whether the suffix describes the behavior of
the function or the circumstances under which it should be used.
Three additional routines, flockfile(), ftrylockfile(), and funlockfile()
(which may be macros), are provided to allow the user to delineate a sequence of I/O statements that are executed
synchronously.
The ungetc() function is infrequently called relative to the other
functions/macros so no unlocked variation is needed.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Standard I/O Streams, flockfile(), getc(), getchar(), putc(), putchar()
XBD
CHANGE HISTORY
First released in Issue 5. Included for alignment with the POSIX Threads Extension.
Issue 6
These functions are marked as part of the Thread-Safe Functions option.
The Open Group Corrigendum U030/2 is applied, adding APPLICATION USAGE describing how applications should be written to avoid
the case when the functions are implemented as macros.
Issue 7
The getc_unlocked(), getchar_unlocked(), putc_unlocked(), and putchar_unlocked() functions are moved
from the Thread-Safe Functions option to the Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0232 [395], XSH/TC1-2008/0233 [395], XSH/TC1-2008/0234 [395], and
XSH/TC1-2008/0235 [14] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0151 [826] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/ispunct.html =====
ispunct
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ispunct, ispunct_l — test for a punctuation character
SYNOPSIS
#include
int ispunct(int c);
[CX]  int ispunct_l(int c, locale_t locale);
DESCRIPTION
For ispunct(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The ispunct() [CX]   and ispunct_l()
functions shall test whether c is a character of class punct in the current locale, [CX]   or in the
locale represented by locale,  respectively; see XBD 7. Locale.
The c argument is an int, the value of which the application shall ensure is a character representable as an
unsigned char or equal to the value of the macro EOF. If the argument has any other value, the behavior is undefined.
[CX]  The
behavior is undefined if the locale argument to ispunct_l() is the special locale object LC_GLOBAL_LOCALE or is not a
valid locale object handle.
RETURN VALUE
The ispunct() [CX]   and ispunct_l()
functions shall return non-zero if c is a punctuation character; otherwise, they shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
To ensure applications portability, especially across natural languages, only these functions and the functions in the reference
pages listed in the SEE ALSO section should be used for character classification.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
isalnum(), isalpha(), isblank(), iscntrl(), isdigit(), isgraph(), islower(), isprint(), isspace(), isupper(), isxdigit(), setlocale(), uselocale()
XBD 7. Locale, ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
The ispunct_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0300 [302], XSH/TC1-2008/0301 [283], and XSH/TC1-2008/0302 [283] are
applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/sinf.html =====
sin
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sin, sinf, sinl — sine function
SYNOPSIS
#include
double sin(double x);
float sinf(float x);
long double sinl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the sine of their argument x, measured in radians.
An application wishing to check for error situations should set errno to zero and call
feclearexcept(FE_ALL_EXCEPT) before calling these functions. On return, if errno is non-zero or
fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) is non-zero, an error has occurred.
RETURN VALUE
Upon successful completion, these functions shall return the sine of x.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0, x shall be returned.
If x is ±Inf, a domain error shall occur, and a NaN shall be returned.
[MXX]
If x is subnormal, x should be returned.
[MX]  If x is subnormal, a range error may occur and, if x is
not returned, sin(), sinf(), and sinl() shall return an implementation-defined value no greater in magnitude
than DBL_MIN, FLT_MIN, and LDBL_MIN, respectively.
ERRORS
These functions shall fail if:
Domain Error
[MX]
The x argument is ±Inf.
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [EDOM]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the invalid floating-point exception shall be
raised.
These functions may fail if:
Range Error
[MX]
The value of x is subnormal
If the integer expression (math_errhandling & MATH_ERRNO) is non-zero, then errno shall be set to [ERANGE]. If the
integer expression (math_errhandling & MATH_ERREXCEPT) is non-zero, then the underflow floating-point exception shall be
raised.
The following sections are informative.
EXAMPLES
Taking the Sine of a 45-Degree Angle
#include
...
double radians = 45.0 * M_PI / 180;
double result;
...
result = sin(radians);
APPLICATION USAGE
These functions may lose accuracy when their argument is near a multiple of ℼ or is far from 0.0.
On error, the expressions (math_errhandling & MATH_ERRNO) and (math_errhandling & MATH_ERREXCEPT) are independent
of each other, but at least one of them must be non-zero.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
asin(), feclearexcept(),
fetestexcept(), isnan()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The last two paragraphs of the DESCRIPTION were included as APPLICATION USAGE notes in previous issues.
Issue 6
The sinf() and sinl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0585 [68] and XSH/TC1-2008/0586 [320] are applied.
Issue 8
Austin Group Defect 1382 is applied, rearranging the text describing the behavior when x is subnormal to avoid the need
for two shading changes.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/iswlower.html =====
iswlower
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
iswlower, iswlower_l — test for a lowercase letter wide-character code
SYNOPSIS
#include
int iswlower(wint_t wc);
[CX]  int iswlower_l(wint_t wc, locale_t locale);
DESCRIPTION
For iswlower(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The iswlower() [CX]   and iswlower_l()
functions shall test whether wc is a wide-character code representing a character of class lower in the current
locale, [CX]   or in the locale represented by locale,
respectively; see XBD 7. Locale.
The wc argument is a wint_t, the value of which the application shall ensure is a wide-character code
corresponding to a valid character in the locale used by the function, or equal to the value of the macro WEOF. If the argument has
any other value, the behavior is undefined.
[CX]  The
behavior is undefined if the locale argument to iswlower_l() is the special locale object LC_GLOBAL_LOCALE or is not
a valid locale object handle.
RETURN VALUE
The iswlower() [CX]   and iswlower_l()
functions shall return non-zero if wc is a lowercase letter wide-character code; otherwise, they shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
To ensure applications portability, especially across natural languages, only these functions and the functions in the reference
pages listed in the SEE ALSO section should be used for character classification.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
iswalnum(), iswalpha(),
iswcntrl(), iswctype(),
iswdigit(), iswgraph(),
iswprint(), iswpunct(),
iswspace(), iswupper(),
iswxdigit(), setlocale(),
uselocale() 1
XBD 7. Locale, ,
CHANGE HISTORY
First released in Issue 4.
Issue 5
The following change has been made in this version for alignment with ISO/IEC 9899:1990/Amendment 1:1995 (E):
The SYNOPSIS has been changed to indicate that this function and associated data types are now made visible by inclusion of the
header rather than .
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
The iswlower_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0329 [302], XSH/TC1-2008/0330 [283], and XSH/TC1-2008/0331 [283] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0188 [685] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/FD_ISSET.html =====
pselect
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pselect, select — synchronous I/O multiplexing
SYNOPSIS
#include
int pselect(int nfds, fd_set *restrict readfds,
fd_set *restrict writefds, fd_set *restrict errorfds,
const struct timespec *restrict timeout,
const sigset_t *restrict sigmask);
int select(int nfds, fd_set *restrict readfds,
fd_set *restrict writefds, fd_set *restrict errorfds,
struct timeval *restrict timeout);
void FD_CLR(int fd, fd_set *fdset);
int FD_ISSET(int fd, const fd_set *fdset);
void FD_SET(int fd, fd_set *fdset);
void FD_ZERO(fd_set *fdset);
DESCRIPTION
The pselect() function shall examine the file descriptor sets whose addresses are passed in the readfds,
writefds, and errorfds parameters to see whether some of their descriptors are ready for reading, are ready for
writing, or have an exceptional condition pending, respectively.
The select() function shall be equivalent to the pselect() function, except as follows:
For the select() function, the timeout period is given in seconds and microseconds in an argument of type struct
timeval, whereas for the pselect() function the timeout period is given in seconds and nanoseconds in an argument of
type struct timespec.
The select() function has no sigmask argument; it shall behave as pselect() does when sigmask is a
null pointer.
Upon successful completion, the select() function may modify the object pointed to by the timeout argument.
The pselect() and select() functions shall support regular files, terminal and pseudo-terminal devices, FIFOs,
pipes, and sockets. The behavior of pselect() and select() on file descriptors that refer to other types of file is
unspecified.
The nfds argument specifies the range of descriptors to be tested. The first nfds descriptors shall be checked in
each set; that is, the descriptors from zero through nfds-1 in the descriptor sets shall be examined.
If the readfds argument is not a null pointer, it points to an object of type fd_set that on input specifies the
file descriptors to be checked for being ready to read, and on output indicates which file descriptors are ready to read.
If the writefds argument is not a null pointer, it points to an object of type fd_set that on input specifies the
file descriptors to be checked for being ready to write, and on output indicates which file descriptors are ready to write.
If the errorfds argument is not a null pointer, it points to an object of type fd_set that on input specifies the
file descriptors to be checked for error conditions pending, and on output indicates which file descriptors have error conditions
pending.
Upon successful completion, the pselect() or select() function shall modify the objects pointed to by the
readfds, writefds, and errorfds arguments to indicate which file descriptors are ready for reading, ready for
writing, or have an error condition pending, respectively, and shall return the total number of ready descriptors in all the output
sets. For each file descriptor less than nfds, the corresponding bit shall be set upon successful completion if it was set
on input and the associated condition is true for that file descriptor.
If none of the selected descriptors are ready for the requested operation, the pselect() or select() function
shall block until at least one of the requested operations becomes ready, until the timeout occurs, or until interrupted by
a signal. The timeout parameter controls how long the pselect() or select() function shall take before timing
out. If the timeout parameter is not a null pointer, it specifies a maximum interval to wait for the selection to complete.
If the specified time interval expires without any requested operation becoming ready, the function shall return. If the
timeout parameter is a null pointer, then the call to pselect() or select() shall block indefinitely until at
least one descriptor meets the specified criteria. To effect a poll, the timeout parameter should not be a null pointer, and
should point to a zero-valued timespec structure.
The use of a timeout does not affect any pending timers set up by alarm().
Implementations may place limitations on the maximum timeout interval supported. All implementations shall support a maximum
timeout interval of at least 31 days. If the timeout argument specifies a timeout interval greater than the
implementation-defined maximum value, the maximum value shall be used as the actual timeout value. Implementations may also place
limitations on the granularity of timeout intervals. If the requested timeout interval requires a finer granularity than the
implementation supports, the actual timeout interval shall be rounded up to the next supported value.
If sigmask is not a null pointer, then the pselect() function shall replace the signal mask of the caller by the
set of signals pointed to by sigmask before examining the descriptors, and shall restore the signal mask of the calling
thread before returning. If a signal is unmasked as a result of the signal mask being altered by pselect(), and a
signal-catching function is called for that signal during the execution of the pselect() function, and SA_RESTART is clear
for the interrupting signal, then
If none of the selected file descriptors are ready, pselect() shall immediately fail with the [EINTR] error after the
signal-catching function returns.
If one or more of the selected file descriptors are ready, it is unspecified whether pselect() behaves the same as if
none of the descriptors were ready (failing with [EINTR] as above) or behaves the same as if it was not interrupted (returning the
total number of ready descriptors).
A descriptor shall be considered ready for reading when a call to an input function with O_NONBLOCK clear would not block,
whether or not the function would transfer data successfully. (The function might return data, an end-of-file indication, or an
error other than one indicating that it is blocked, and in each of these cases the descriptor shall be considered ready for
reading.)
A descriptor shall be considered ready for writing when a call to an output function with O_NONBLOCK clear would not block,
whether or not the function would transfer data successfully.
If a socket has a pending error, it shall be considered to have an exceptional condition pending. Otherwise, what constitutes an
exceptional condition is file type-specific. For a file descriptor for use with a socket, it is protocol-specific except as noted
below. For other file types it is implementation-defined. If the operation is meaningless for a particular file type,
pselect() or select() shall indicate that the descriptor is ready for read or write operations, and shall indicate
that the descriptor has no exceptional condition pending.
If a descriptor refers to a socket, the implied input function is the recvmsg()
function with parameters requesting normal and ancillary data, such that the presence of either type shall cause the socket to be
marked as readable. The presence of out-of-band data shall be checked if the socket option SO_OOBINLINE has been enabled, as
out-of-band data is enqueued with normal data. If the socket is currently listening, then it shall be marked as readable if an
incoming connection request has been received, and a call to the accept() or accept4() function shall complete without blocking.
If a descriptor refers to a socket, the implied output function is the sendmsg()
function supplying an amount of normal data equal to the current value of the SO_SNDLOWAT option for the socket. If a non-blocking
call to the connect() function has been made for a socket, and the connection
attempt has either succeeded or failed leaving a pending error, the socket shall be marked as writable.
A socket shall be considered to have an exceptional condition pending if a receive operation with O_NONBLOCK clear for the open
file description and with the MSG_OOB flag set would return out-of-band data without blocking. (It is protocol-specific whether the
MSG_OOB flag would be used to read out-of-band data.) A socket shall also be considered to have an exceptional condition pending if
an out-of-band data mark is present in the receive queue. Other circumstances under which a socket may be considered to have an
exceptional condition pending are protocol-specific and implementation-defined.
If the readfds, writefds, and errorfds arguments are all null pointers and the timeout argument is
not a null pointer, the pselect() or select() function shall block for the time specified, or until interrupted by a
signal. If the readfds, writefds, and errorfds arguments are all null pointers and the timeout argument
is a null pointer, the pselect() or select() function shall block until interrupted by a signal.
File descriptors associated with regular files shall always select true for ready to read, ready to write, and error
conditions.
On failure, the objects pointed to by the readfds, writefds, and errorfds arguments shall not be modified.
If the timeout interval expires without the specified condition being true for any of the specified file descriptors, the objects
pointed to by the readfds, writefds, and errorfds arguments shall have all bits set to 0.
File descriptor masks of type fd_set can be initialized and tested with FD_CLR(), FD_ISSET(),
FD_SET(), and FD_ZERO(). It is unspecified whether each of these is a macro or a function. If a macro definition is
suppressed in order to access an actual function, or a program defines an external identifier with any of these names, the behavior
is undefined.
FD_CLR(fd, fdsetp) shall remove the file descriptor fd from the set pointed to by fdsetp. If
fd is not a member of this set, there shall be no effect on the set, and this shall not be treated as an error.
FD_ISSET(fd, fdsetp) shall evaluate to non-zero if the file descriptor fd is a member of the set
pointed to by fdsetp, and shall evaluate to zero otherwise.
FD_SET(fd, fdsetp) shall add the file descriptor fd to the set pointed to by fdsetp. If the
file descriptor fd is already in this set, there shall be no effect on the set, and this shall not be treated as an
error.
FD_ZERO(fdsetp) shall initialize the descriptor set pointed to by fdsetp to the null set. No error is
returned if the set is not empty at the time FD_ZERO() is invoked.
The behavior of these macros is undefined if the fd argument is less than 0 or greater than or equal to FD_SETSIZE, or if
fd is not a valid file descriptor, or if any of the arguments are expressions with side-effects.
If a thread gets canceled during a pselect() call, the signal mask in effect when executing the registered cleanup
functions is either the original signal mask or the signal mask installed as part of the pselect() call.
RETURN VALUE
Upon successful completion, the pselect() and select() functions shall return the total number of bits set in the
bit masks. Otherwise, -1 shall be returned, and errno shall be set to indicate the error.
FD_CLR(), FD_SET(), and FD_ZERO() do not return a value. FD_ISSET() shall return a non-zero value if
the bit for the file descriptor fd is set in the file descriptor set pointed to by fdset, and 0 otherwise.
ERRORS
Under the following conditions, pselect() and select() shall fail and set errno to:
[EBADF]
One or more of the file descriptor sets specified a file descriptor that is not a valid open file descriptor.
[EINTR]
The function was interrupted by a signal.
If SA_RESTART has been set for the interrupting signal, it is implementation-defined whether the function restarts or returns
with [EINTR].
[EINVAL]
An invalid timeout interval was specified.
[EINVAL]
The nfds argument is less than 0 or greater than FD_SETSIZE.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The use of select() and pselect() requires that the application construct the set of file descriptors to work on
each time through a polling loop, and is inherently limited from operating on file descriptors larger than FD_SETSIZE. Also, the
amount of work to perform scales as nfds increases, even if the number of file descriptors selected within the larger set
remains the same. Thus, applications may wish to consider using poll() and ppoll() instead, for better scaling.
When a pselect() or select() call indicates a file descriptor is ready for reading, this means that if an attempt
to read data had been made at the time that the status of the file descriptor was checked, it would have returned at least one byte
of data, an end-of-file indication, or an error, without blocking (even if O_NONBLOCK is clear). When a pselect() or
select() call indicates that a file descriptor is ready for writing, this means that if an attempt to write one byte of data
had been made at the time that the status of the file descriptor was checked, it would have written that byte or returned an error,
without blocking. However, if an attempt to write more than one byte had been made, it might have blocked (if O_NONBLOCK is clear).
In both cases, by the time the call returns and a subsequent I/O operation is attempted, the state of the file descriptor might
have changed (for example, because another thread read or wrote some data) and, if O_NONBLOCK is clear, there is no guarantee that
the operation will not block (unless it would not block for some other reason, such as setting MIN=0 and TIME=0 for a terminal in
non-canonical mode). Therefore it is recommended that applications always set O_NONBLOCK on file descriptors whose readiness for
I/O they query with pselect() or select().
RATIONALE
In earlier versions of the Single UNIX Specification, the select() function was defined in the  header. This is now changed to . The rationale for this change was as follows: the introduction of
the pselect() function included the  header and the
header defines all the related definitions for the
pselect() and select() functions. Backwards-compatibility to existing XSI implementations is handled by allowing
to include .
Code which wants to avoid the ambiguity of the signal mask for thread cancellation handlers can install an additional
cancellation handler which resets the signal mask to the expected value.
void cleanup(void *arg)
{
sigset_t *ss = (sigset_t *) arg;
pthread_sigmask(SIG_SETMASK, ss, NULL);
}
int call_pselect(int nfds, fd_set *readfds, fd_set *writefds,
fd_set errorfds, const struct timespec *timeout,
const sigset_t *sigmask)
{
sigset_t oldmask;
int result;
pthread_sigmask(SIG_SETMASK, NULL, &oldmask);
pthread_cleanup_push(cleanup, &oldmask);
result = pselect(nfds, readfds, writefds, errorfds, timeout, sigmask);
pthread_cleanup_pop(0);
return result;
}
FUTURE DIRECTIONS
None.
SEE ALSO
accept(), alarm(), connect(), fcntl(), poll(), read(), recvmsg(), sendmsg(), write()
XBD ,
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
In the ERRORS section, the text has been changed to indicate that [EINVAL] is returned when nfds is less than 0 or
greater than FD_SETSIZE. It previously stated less than 0, or greater than or equal to FD_SETSIZE.
Text about timeout is moved from the APPLICATION USAGE section to the DESCRIPTION.
Issue 6
The Open Group Corrigendum U026/6 is applied, changing the occurrences of readfs and writefs in the
select() DESCRIPTION to be readfds and writefds.
Text referring to sockets is added to the DESCRIPTION.
The DESCRIPTION and ERRORS sections are updated so that references to STREAMS are marked as part of the XSI STREAMS Option
Group.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
These functions are now mandatory.
The pselect() function is added for alignment with IEEE Std 1003.1g-2000 and additional detail related to
sockets semantics is added to the DESCRIPTION.
The select() function now requires inclusion of .
The restrict keyword is added to the select() prototype for alignment with the ISO/IEC 9899:1999
standard.
IEEE Std 1003.1-2001/Cor 2-2004, item XSH/TC2/D6/70 is applied, updating the DESCRIPTION to reference the signal
mask in terms of the calling thread rather than the process.
Issue 7
SD5-XSH-ERN-122 is applied, adding text to the DESCRIPTION for when a thread is canceled during a call to pselect(), and
adding example code to the RATIONALE.
Functionality relating to the XSI STREAMS option is marked obsolescent.
Functionality relating to the Threads option is moved to the Base.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0446 [372] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0259 [680] is applied.
Issue 8
Austin Group Defect 220 is applied, adding const to the second parameter of FD_ISSET().
Austin Group Defect 411 is applied, adding accept4().
Austin Group Defect 1186 is applied, clarifying the behavior when the pselect() function is interrupted by a signal.
Austin Group Defect 1263 is applied, changing the APPLICATION USAGE section.
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
Austin Group Defect 1448 is applied, changing the APPLICATION USAGE section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/cabsl.html =====
cabs
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
cabs, cabsf, cabsl — return a complex absolute value
SYNOPSIS
#include
double cabs(double complex z);
float cabsf(float complex z);
long double cabsl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex absolute value (also called norm, modulus, or magnitude) of z.
RETURN VALUE
These functions shall return the complex absolute value.
[MXC]
cabs(x + iy), cabs(y + ix), and cabs(x - iy) shall return exactly
the same value.
If z is ±0 ± i0, +0 shall be returned.
If the real or imaginary part of z is ±Inf, +Inf shall be returned, even if the other part is NaN.
If the real or imaginary part of z is NaN and the other part is not ±Inf, NaN shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/iscntrl.html =====
iscntrl
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
iscntrl, iscntrl_l — test for a control character
SYNOPSIS
#include
int iscntrl(int c);
[CX]  int iscntrl_l(int c, locale_t locale);
DESCRIPTION
For iscntrl(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The iscntrl() [CX]   and iscntrl_l()
functions shall test whether c is a character of class cntrl in the current locale, [CX]   or in the
locale represented by locale,  respectively; see XBD 7. Locale.
The c argument is a type int, the value of which the application shall ensure is a character representable as an
unsigned char or equal to the value of the macro EOF. If the argument has any other value, the behavior is undefined.
[CX]  The
behavior is undefined if the locale argument to iscntrl_l() is the special locale object LC_GLOBAL_LOCALE or is not a
valid locale object handle.
RETURN VALUE
The iscntrl() [CX]   and iscntrl_l()
functions shall return non-zero if c is a control character; otherwise, they shall return 0.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
To ensure applications portability, especially across natural languages, only these functions and the functions in the reference
pages listed in the SEE ALSO section should be used for character classification.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
isalnum(), isalpha(), isblank(), isdigit(), isgraph(), islower(), isprint(), ispunct(), isspace(), isupper(), isxdigit(), setlocale(), uselocale()
XBD 7. Locale, ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 6
The normative text is updated to avoid use of the term "must" for application requirements.
Issue 7
The iscntrl_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0283 [302], XSH/TC1-2008/0284 [283], and XSH/TC1-2008/0285 [283] are
applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/bind.html =====
bind
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
bind — bind a name to a socket
SYNOPSIS
#include
int bind(int socket, const struct sockaddr *address,
socklen_t address_len);
DESCRIPTION
The bind() function shall assign a local socket address address to a socket identified by descriptor socket
that has no local socket address assigned. Sockets created with the socket() function
are initially unnamed; they are identified only by their address family.
The bind() function takes the following arguments:
socket
Specifies the file descriptor of the socket to be bound.
address
Points to a sockaddr structure containing the address to be bound to the socket. The length and format of the address
depend on the address family of the socket.
address_len
Specifies the length of the sockaddr structure pointed to by the address argument.
The socket specified by socket may require the process to have appropriate privileges to use the bind()
function.
If the address family of the socket is AF_UNIX, the application shall ensure that a null terminator after the pathname is
included in the sun_path member of address as a sockaddr_un structure, and that address_len is at least
offsetof(struct sockaddr_un, sun_path) + 1 plus the length of the pathname. If the pathname in the sun_path member
of address names an existing file, including a symbolic link, bind() shall treat the address as already in use; see
ERRORS below.
If the socket address cannot be assigned immediately and O_NONBLOCK is set for the file descriptor for the socket, bind()
shall fail and set errno to [EINPROGRESS], but the assignment request shall not be aborted, and the assignment shall be
completed asynchronously. Subsequent calls to bind() for the same socket, before the assignment is completed, shall fail and
set errno to [EALREADY].
When the assignment has been performed asynchronously, pselect(), select(), poll(), and ppoll() shall indicate that the file descriptor for the socket is ready for reading and
writing.
RETURN VALUE
Upon successful completion, bind() shall return 0; otherwise, -1 shall be returned and errno set to indicate the
error.
ERRORS
The bind() function shall fail if:
[EADDRINUSE]
The specified address is already in use.
[EADDRNOTAVAIL]
The specified address is not available from the local machine.
[EAFNOSUPPORT]
The specified address is not a valid address for the address family of the specified socket.
[EALREADY]
An assignment request is already in progress for the specified socket.
[EBADF]
The socket argument is not a valid file descriptor.
[EINPROGRESS]
O_NONBLOCK is set for the file descriptor for the socket and the assignment cannot be immediately performed; the assignment
shall be performed asynchronously.
[EINVAL]
The socket is already bound to an address, and the protocol does not support binding to a new address; or the socket has been
shut down.
[ENOBUFS]
Insufficient resources were available to complete the call.
[ENOTSOCK]
The socket argument does not refer to a socket.
[EOPNOTSUPP]
The socket type of the specified socket does not support binding to an address.
If the address family of the socket is AF_UNIX, then bind() shall fail if:
[EACCES]
A component of the path prefix denies search permission, or the requested name requires writing in a directory with a mode that
denies write permission.
[EDESTADDRREQ] or [EISDIR]
The address argument is a null pointer.
[EILSEQ]
The last pathname component is not a portable filename, and cannot be created in the target directory.
[EIO]
An I/O error occurred.
[ELOOP]
A loop exists in symbolic links encountered during resolution of the pathname in address.
[ENAMETOOLONG]
The length of a component of a pathname is longer than {NAME_MAX}.
[ENOENT]
A component of the path prefix of the pathname in address does not name an existing file or the pathname is an empty
string.
[ENOENT] or [ENOTDIR]
The pathname in address contains at least one non- character and ends with one or more trailing
characters. If the pathname without the trailing  characters would name an existing file, an [ENOENT] error shall not
occur.
[ENOTDIR]
A component of the path prefix of the pathname in address names an existing file that is neither a directory nor a
symbolic link to a directory, or the pathname in address contains at least one non- character and ends with one
or more trailing  characters and the last pathname component names an existing file that is neither a directory nor a
symbolic link to a directory.
[EROFS]
The name would reside on a read-only file system.
The bind() function may fail if:
[EACCES]
The specified address is protected and the current user does not have permission to bind to it.
[EINVAL]
The address_len argument is not a valid length for the address family.
[EISCONN]
The socket is already connected.
[ELOOP]
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the pathname in address.
[ENAMETOOLONG]
The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a
length that exceeds {PATH_MAX}.
The following sections are informative.
EXAMPLES
The following code segment shows how to create a socket and bind it to a name in the AF_UNIX domain.
#define MY_SOCK_PATH "/somepath"
int sfd;
struct sockaddr_un my_addr;
sfd = socket(AF_UNIX, SOCK_STREAM, 0);
if (sfd == -1)
/* Handle error */;
memset(&my_addr, '\0', sizeof(struct sockaddr_un));
/* Clear structure */
my_addr.sun_family = AF_UNIX;
strncpy(my_addr.sun_path, MY_SOCK_PATH, sizeof(my_addr.sun_path) -1);
if (bind(sfd, (struct sockaddr *) &my_addr,
sizeof(struct sockaddr_un)) == -1)
/* Handle error */;
APPLICATION USAGE
An application program can retrieve the assigned socket name with the getsockname() function.
For AF_UNIX sockets, some implementations support an extension where address_len does not have to include a null
terminator for the pathname stored in sun_path, which in turn allows a pathname to be one byte longer. However, such usage
is not portable, and carries a risk of accessing beyond the intended bounds of the pathname length.
RATIONALE
Implementations are encouraged to have bind() report an [EILSEQ] error if the last component of the address to be bound
to an AF_UNIX family socket contains any bytes that have the encoded value of a  character.
FUTURE DIRECTIONS
None.
SEE ALSO
connect(), getsockname(),
listen(), socket()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the XNS, Issue 5.2 specification.
Issue 7
Austin Group Interpretation 1003.1-2001 #044 is applied, changing the "may fail" [ENOBUFS] error to become a "shall fail"
error.
Austin Group Interpretation 1003.1-2001 #143 is applied.
SD5-XSH-ERN-185 is applied.
An example is added.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0042 [146], XSH/TC1-2008/0043 [146], and XSH/TC1-2008/0044 [324] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0050 [822] is applied.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to disallow the creation of filenames containing any bytes that
have the encoded value of a  character.
Austin Group Defects 293 and 1482 are applied, adding the [EILSEQ] error.
Austin Group Defect 561 is applied, changing the requirements for the sun_path member of the sockaddr_un
structure.
Austin Group Defect 1263 is applied, adding ppoll().
Austin Group Defect 1605 is applied, clarifying how the [EADDRINUSE] error applies to AF_UNIX sockets.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/casinhl.html =====
casinh
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
casinh, casinhf, casinhl — complex arc hyperbolic sine functions
SYNOPSIS
#include
double complex casinh(double complex z);
float complex casinhf(float complex z);
long double complex casinhl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex arc hyperbolic sine of z, with branch cuts outside the interval
[-i, +i] along the imaginary axis.
RETURN VALUE
These functions shall return the complex arc hyperbolic sine value, in the range of a strip mathematically unbounded along the
real axis and in the interval [-iℼ/2, +iℼ/2] along the imaginary axis.
[MXC]
casinh(conj(z)), casinhf(conjf(z)), and casinhl(conjl(z)) shall
return exactly the same value as conj(casinh(z)), conjf(casinhf(z)), and
conjl(casinhl(z)), respectively, and casinh(-z), casinhf(-z), and
casinhl(-z) shall return exactly the same value as -casinh(z), -casinhf(z), and
-casinhl(z), respectively, including for the special values of z below.
If z is +0 + i0, 0 + i0 shall be returned.
If z is x + iInf where x is positive-signed and finite, +Inf + iℼ/2 shall be returned.
If z is x + iNaN where x is finite, NaN + iNaN shall be returned and the invalid
floating-point exception may be raised.
If z is +Inf + iy where y is positive-signed and finite, +Inf + i0 shall be returned.
If z is +Inf + iInf, +Inf + iℼ/4 shall be returned.
If z is +Inf + iNaN, +Inf + iNaN shall be returned.
If z is NaN + i0, NaN + i0 shall be returned.
If z is NaN + iy where y is non-zero and finite, NaN + iNaN shall be returned and the invalid
floating-point exception may be raised.
If z is NaN + iInf, ±Inf + iNaN shall be returned; the sign of the real part of the result is
unspecified.
If z is NaN + iNaN, NaN + iNaN shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
csinh()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/cbrtf.html =====
cbrt
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
cbrt, cbrtf, cbrtl — cube root functions
SYNOPSIS
#include
double cbrt(double x);
float cbrtf(float x);
long double cbrtl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the real cube root of their argument x.
RETURN VALUE
Upon successful completion, these functions shall return the cube root of x.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0 or ±Inf, x shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
For some applications, a true cube root function, which returns negative results for negative arguments, is more appropriate
than pow(x, 1.0/3.0), which returns a NaN for x less than 0.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Issue 6
The cbrt() function is no longer marked as an extension.
The cbrtf() and cbrtl() functions are added for alignment with the ISO/IEC 9899:1999 standard.
The DESCRIPTION, RETURN VALUE, ERRORS, and APPLICATION USAGE sections are revised to align with the ISO/IEC 9899:1999
standard.
IEC 60559:1989 standard floating-point extensions over the ISO/IEC 9899:1999 standard are marked.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/ngettext.html =====
gettext
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
dgettext, dgettext_l, dcgettext, dcgettext_l, gettext, gettext_l, ngettext, ngettext_l, dngettext, dngettext_l,
dcngettext, dcngettext_l — message handling functions
SYNOPSIS
#include
char *dgettext(const char *domainname, const char *msgid);
char *dgettext_l(const char *domainname, const char *msgid,
locale_t locale);
char *dcgettext(const char *domainname, const char *msgid,
int category);
char *dcgettext_l(const char *domainname, const char *msgid,
int category, locale_t locale);
char *dngettext(const char *domainname, const char *msgid,
const char *msgid_plural, unsigned long int n);
char *dngettext_l(const char *domainname, const char *msgid,
const char *msgid_plural, unsigned long int n,
locale_t locale);
char *dcngettext(const char *domainname, const char *msgid,
const char *msgid_plural, unsigned long int n,
int category);
char *dcngettext_l(const char *domainname, const char *msgid,
const char *msgid_plural, unsigned long int n,
int category, locale_t locale);
char *gettext(const char *msgid);
char *gettext_l(const char *msgid, locale_t locale);
char *ngettext(const char *msgid, const char *msgid_plural,
unsigned long int n);
char *ngettext_l(const char *msgid, const char *msgid_plural,
unsigned long int n, locale_t locale);
DESCRIPTION
The gettext() function shall:
attempt to locate a suitable messages object (described in detail below) for the LC_MESSAGES category in the current
locale, and for the current text domain (see bindtextdomain()), containing
the string identified by msgid,
retrieve the string identified by msgid from the messages object,
convert the string to the output codeset if necessary (described in detail below), and
return the result.
If the locale name in effect is "POSIX" or "C" (i.e. the name associated with the LC_MESSAGES locale
category in the current locale), or if no suitable messages object exists, or if no string identified by msgid exists in the
messages object, or if an error occurs, msgid shall be returned.
The dgettext() function shall be equivalent to gettext(), except domainname shall be used instead of the
current text domain to locate the messages object.
The dcgettext() function shall be equivalent to dgettext(), except the locale category identified by
category shall be used instead of LC_MESSAGES .
The ngettext() function shall be equivalent to gettext(), except:
The string to retrieve shall be identified by a combination of msgid and n (see msgfmt).
If the locale name in effect is "POSIX" or "C", or if no suitable messages object exists, or if no string
identified by the combination of msgid and n exists in the messages object, or if an error occurs, the return value
shall be msgid if n is 1, otherwise msgid_plural.
The dngettext() function shall be equivalent to ngettext(), except domainname shall be used instead of the
current text domain to locate the messages object.
The dcngettext() function shall be equivalent to dngettext(), except the locale category identified by
category shall be used instead of LC_MESSAGES .
The *_l() functions shall be equivalent to their counterparts without the _l suffix, except locale shall be
used instead of the current locale. If locale is the special locale object LC_GLOBAL_LOCALE or is not a valid locale object
handle, the behavior is undefined.
The application shall ensure that the msgid and msgid_plural arguments are strings. If either msgid or
msgid_plural is an empty string, or contains characters not in the portable character set, the results are unspecified. If
the category argument is LC_ALL , the results are unspecified.
The location of the messages object shall be determined according to the following criteria, stopping when the first messages
object is found:
[XSI]
If the NLSPATH environment variable is set to a non-empty string, an NLSPATH search shall be performed as described
in XBD 8.2 Internationalization Variables. If NLSPATH identifies
more than one template to use, each template in turn shall be used until a valid messages object is found.
If the LANGUAGE environment variable is set to a non-empty string, a LANGUAGE search shall be performed as
described below. If LANGUAGE identifies more than one directory to search, each directory shall be searched until a valid
messages object is found.
A single-locale search shall be performed as described below.
For [XSI]   the NLSPATH search and   the single-locale search,
the single locale name used to locate the messages object shall be the locale name associated with the selected locale category
from the current locale, or the provided locale object if calling one of the *_l() functions; additional searches of locale
names without .codeset (if present), without _territory (if present), and without @modifier (if present) may
be performed.
For the LANGUAGE search, the value of the LANGUAGE environment variable shall be a list of one or more locale
names separated by a  (':') character. Each locale name shall be tried in the specified order. If a messages
object for the locale does not exist, or cannot be opened, or is unsuitable for implementation-defined reasons (such as security),
the next locale name (if any) shall be tried. If:
a messages object for the locale can be opened but cannot be processed without error, or
the messages object does not contain a string identified by msgid, or msgid and n for the ngettext
functions,
it is unspecified whether the next locale name (if any) is tried. In all other cases, the messages object for the locale shall
be used.
For each locale name in LANGUAGE , or if LANGUAGE is not set or is empty, or no suitable messages object is found
in processing LANGUAGE , the pathname used to locate the messages object shall be
dirname/localename/categoryname/textdomainname.mo, where:
The dirname part is the dirname argument of the most recent successful call to bindtextdomain() that had textdomainname as the domainname argument;
any trailing  characters in dirname shall be discarded. If a successful call to bindtextdomain() has not been made for textdomainname, an
implementation-defined default directory shall be used.
For the LANGUAGE search, the localename part is each locale name from LANGUAGE in turn; if a locale name
has the format language[_territory][.codeset][@modifier], additional
searches of locale names without .codeset (if present), without _territory (if present), and without @modifier
(if present) may be performed; if .codeset is not present, additional searches of locale names with an added .codeset
may be performed. For the single-locale search, the localename part is the name of the current locale, or the locale
specified in an *_l() function call, for the category named by categoryname. Spellings of codeset names are not
standardized, and implementations may attempt to use different commonly known spellings, for example "utf8" and
"UTF-8".
The categoryname part is the string "LC_MESSAGES" if gettext(), dgettext(), ngettext(), or
dngettext() is called, or the locale category name corresponding to the category argument to dcgettext() or
dcngettext(). Likewise for the *_l() variants of all these functions.
For gettext(), gettext_l(), ngettext(), and ngettext_l(), the textdomainname part is the text
domain set by the last successful call to textdomain(). For dgettext(),
dcgettext(), dngettext(), dcngettext(), and the *_l() variants of these functions,
textdomainname is the text domain specified by the domainname argument. The domainname argument shall be
equivalent in syntax and meaning to the domainname argument to textdomain(), except that the selection of the text domain shall affect only the
dgettext(), dcgettext(), dngettext(), and dcngettext() function calls and their *_l() variants.
If the domainname argument is a null pointer, the text domain set by the last successful call to textdomain() shall be used. For all of these functions, if a successful call to textdomain() has not been made the default text domain "messages" shall be
used.
Resolution of the messages object pathname shall be performed the first time one of the gettext family of functions is
called for a given combination of dirname, localename, categoryname, and textdomainname. It is
unspecified whether the pathname is re-resolved if the combination has been used before in a call to one of the gettext
family of functions. If bindtextdomain() performs pathname resolution of its
dirname argument, only the part of the messages object pathname after dirname shall be resolved by the gettext
family of functions.
When one of the gettext family of functions returns a message string that was found in a messages object, it shall
convert the codeset of the message string to the output codeset if a codeset is specified in the messages object (see msgfmt) and the output codeset is not the same as that codeset. If a successful call to
bind_textdomain_codeset() has been made with the text domain of the
messages object as the domainname argument and a non-null codeset argument, the output codeset shall be the
codeset argument from the most recent such call. Otherwise, the output codeset shall be the codeset of characters in the
current locale, or the provided locale object if calling one of the *_l() functions, as specified by the LC_CTYPE
category of the locale. The conversion shall be performed as if by a call to iconv()
using a conversion descriptor returned by iconv_open(, ),
except that if the return value of iconv() would be greater than zero, the
non-identical conversions performed by the gettext family of functions need not be the same as those that such an iconv() call would perform. If an error prevents the codeset conversion from being performed,
the gettext family of functions shall behave as if no message string was found in the messages object. If at least one
non-identical conversion is performed that results in a fallback character (one that does not provide any information about the
character it was converted from, for example, a  or "replacement-character"), the gettext family of
functions may behave as if no message string was found in the messages object.
RETURN VALUE
The gettext(), gettext_l(), dgettext(), dgettext_l(), dcgettext(), and dcgettext_l()
functions shall return the message string described in DESCRIPTION if successful. Otherwise, they shall return msgid.
The ngettext(), ngettext_l(), dngettext(), dngettext_l(), dcngettext(), and
dcngettext_l() functions shall return the message string described in DESCRIPTION if successful. Otherwise, msgid
shall be returned if n is equal to 1, or msgid_plural if n is not equal to 1.
The application shall ensure that it does not modify the returned string. A subsequent call to a gettext family function
shall not overwrite or invalidate the returned string. The returned string may be invalidated by a subsequent call to bind_textdomain_codeset(), bindtextdomain(), setlocale(), or
textdomain() in the same process, except for calls that only query values. The
returned string shall not be invalidated by a subsequent call to uselocale().
ERRORS
The gettext family of functions shall not modify errno. If an error occurs these functions shall return a string
as described in RETURN VALUE.
The following sections are informative.
EXAMPLES
The example code below assumes the following:
The implementation-defined default directory is /system/gettextlib.
The following locales are available on the target system: en_US, en_GB, de_DE. The codeset used for all of these locales is
UTF-8.
The en_AU locale is not available on the target system.
The target system supports conversion from ISO/IEC 8859-1 to UTF-8.
The codeset used for the POSIX locale is ASCII.
The target system does not support conversion from ISO/IEC 8859-1 to ASCII.
Furthermore, the following .mo files (and only the following .mo files) are installed:
/system/gettextlib/en_US/LC_MESSAGES/mail.mo
/messagecatalogs/example/en_US/LC_MESSAGES/mail.mo
These are compiled from a portable messages object source file (dot-po file) with the following ISO/IEC 8859-1 encoded contents
(see the EXTENDED DESCRIPTION of the msgfmt utility for a description of the dot-po
file format):
msgid ""
msgstr ""
"Content-Type: text/plain; charset=ISO_8859-1\n"
"Plural-Forms: nplurals=4; plural= n==1?0: (n>1&&n1&&n1&&n,
XCU gettext, msgfmt,
xgettext
CHANGE HISTORY
First released in Issue 8.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/setpwent.html =====
endpwent
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
endpwent, getpwent, setpwent — user database functions
SYNOPSIS
[XSI]  #include
void endpwent(void);
struct passwd *getpwent(void);
void setpwent(void);
DESCRIPTION
These functions shall retrieve information about users.
The getpwent() function shall return a pointer to a structure containing the broken-out fields of an entry in the user
database. Each entry in the user database contains a passwd structure. If the user database is not already open,
getpwent() shall open it and return a pointer to a passwd structure containing the first entry in the database.
Thereafter, it shall return a pointer to a passwd structure containing the next entry in the user database. Successive calls
can be used to search the entire user database.
If an end-of-file or an error is encountered on reading, getpwent() shall return a null pointer.
An implementation that provides extended security controls may impose further implementation-defined restrictions on accessing
the user database. In particular, the system may deny the existence of some or all of the user database entries associated with
users other than the caller.
The setpwent() function shall rewind the user database so that the next getpwent() call returns the first entry,
allowing repeated searches.
The endpwent() function shall close the user database.
The setpwent() and endpwent() functions shall not change the setting of errno if successful.
On error, the setpwent() and endpwent() functions shall set errno to indicate the error.
Since no value is returned by the setpwent() and endpwent() functions, an application wishing to check for error
situations should set errno to 0, then call the function, then check errno.
These functions need not be thread-safe.
RETURN VALUE
On successful completion, getpwent() shall return a pointer to a passwd structure. On end-of-file,
getpwent() shall return a null pointer and shall not change the setting of errno. On error, getpwent() shall
return a null pointer and errno shall be set to indicate the error.
The application shall not modify the structure to which the return value points, nor any storage areas pointed to by pointers
within the structure. The returned pointer, and pointers within the structure, might be invalidated or the structure or the storage
areas might be overwritten by a subsequent call to getpwuid(), getpwnam(), or getpwent(). The returned pointer, and pointers within the structure,
might also be invalidated if the calling thread is terminated.
ERRORS
These functions may fail if:
[EINTR]
A signal was caught during the operation.
[EIO]
An I/O error has occurred.
In addition, getpwent() and setpwent() may fail if:
[EMFILE]
All file descriptors available to the process are currently open.
[ENFILE]
The maximum allowable number of files is currently open in the system.
The following sections are informative.
EXAMPLES
Searching the User Database
The following example uses the getpwent() function to get successive entries in the user database, returning a pointer to
a passwd structure that contains information about each user. The call to endpwent() closes the user database and
cleans up.
#include
#include
void printname(uid_t uid)
{
struct passwd *pwd;
setpwent();
while((pwd = getpwent()) != NULL) {
if (pwd->pw_uid == uid) {
printf("name=%s\n",pwd->pw_name);
break;
}
}
endpwent();
}
APPLICATION USAGE
These functions are provided due to their historical usage. Applications should avoid dependencies on fields in the password
database, whether the database is a single file, or where in the file system name space the database resides. Applications should
use getpwuid() whenever possible because it avoids these dependencies.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
endgrent(), getlogin(),
getpwnam(), getpwuid()
XBD
CHANGE HISTORY
First released in Issue 4, Version 2.
Issue 5
Moved from X/OPEN UNIX extension to BASE.
Normative text previously in the APPLICATION USAGE section is moved to the RETURN VALUE section.
A note indicating that these functions need not be reentrant is added to the DESCRIPTION.
Issue 6
In the DESCRIPTION, the note about reentrancy is expanded to cover thread-safety.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
SD5-XBD-ERN-4 is applied, changing the definition of the [EMFILE] error.
The EXAMPLES section is revised.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0087 [75] is applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0092 [493], XSH/TC2-2008/0093 [656], and XSH/TC2-2008/0094 [493] are
applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/wcscoll_l.html =====
wcscoll
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
wcscoll, wcscoll_l — wide-character string comparison using collating information
SYNOPSIS
#include
int wcscoll(const wchar_t *ws1, const wchar_t *ws2);
[CX]  int wcscoll_l(const wchar_t *ws1, const wchar_t *ws2,
locale_t locale);
DESCRIPTION
For wcscoll(): [CX]   The functionality described on this reference page is aligned with the ISO C standard. Any
conflict between the requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers
to the ISO C standard.
The wcscoll() [CX]   and wcscoll_l()
functions shall compare the wide-character string pointed to by ws1 to the wide-character string pointed to by
ws2, both interpreted as appropriate to the LC_COLLATE category of the current locale, [CX]   or the locale
represented by locale,   respectively.
The wcscoll() [CX]   and wcscoll_l()
functions shall not change the setting of errno if successful.
An application wishing to check for error situations should set errno to 0 before calling wcscoll() [CX]   or
wcscoll_l().   If errno is non-zero on return, an
error has occurred.
[CX]  The
behavior is undefined if the locale argument to wcscoll_l() is the special locale object LC_GLOBAL_LOCALE or is not a
valid locale object handle.
RETURN VALUE
Upon successful completion, wcscoll() [CX]   and wcscoll_l()   shall return an integer greater than, equal to, or less than 0, according to whether the
wide-character string pointed to by ws1 is greater than, equal to, or less than the wide-character string pointed to by
ws2, when both are interpreted as appropriate to the current locale, [CX]   or to the
locale represented by locale,   respectively. On error,
wcscoll() [CX]   and wcscoll_l()   shall set
errno, but no return value is reserved to indicate an error.
ERRORS
These functions may fail if:
[EINVAL]
[CX]
The ws1 or ws2 arguments contain wide-character codes outside the domain of the collating sequence.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The wcsxfrm() and wcscmp()
functions should be used for sorting large lists.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
wcscmp(), wcsxfrm()
XBD
CHANGE HISTORY
First released in Issue 4. Derived from the MSE working draft.
Issue 5
Moved from ENHANCED I18N to BASE and the [ENOSYS] error is removed.
The DESCRIPTION is updated to indicate that errno is not changed if the function is successful.
Issue 7
The wcscoll_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0719 [302], XSH/TC1-2008/0720 [283], and XSH/TC1-2008/0721 [283] are
applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/fork.html =====
fork
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fork — create a new process
SYNOPSIS
#include
pid_t fork(void);
pid_t _Fork(void);
DESCRIPTION
The fork() function shall create a new process. The new process (child process) shall be an exact copy of the calling
process (parent process) except as detailed below:
The child process shall have a unique process ID.
The child process ID also shall not match any active process group ID.
The child process shall have a different parent process ID, which shall be the process ID of the calling process.
The child process shall have its own copy of the parent's file descriptors, except for those whose FD_CLOFORK flag is set (see
fcntl()). Each of the child's file descriptors shall refer to the same open file
description with the corresponding file descriptor of the parent.
The child process shall have its own copy of the parent's open directory streams. Each open directory stream in the child
process may share directory stream positioning with the corresponding directory stream of the parent.
The child process shall have its own copy of the parent's message catalog descriptors.
The child process values of tms_utime, tms_stime, tms_cutime, and tms_cstime shall be set to 0.
The time left until an alarm clock signal shall be reset to zero, and the alarm, if any, shall be canceled; see alarm().
[XSI]
All semadj values shall be cleared.
Process-owned file locks set by the parent process shall not be inherited by the child process.
The set of signals pending for the child process shall be initialized to the empty set.
[XSI]
Interval timers shall be reset in the child process.
Any semaphores that are open in the parent process shall also be open in the child process.
[ML]  The
child process shall not inherit any address space memory locks established by the parent process via calls to mlockall() or mlock().
Memory mappings created in the parent shall be retained in the child process. MAP_PRIVATE mappings inherited from the parent
shall also be MAP_PRIVATE mappings in the child, and any modifications to the data in these mappings made by the parent prior to
calling fork() shall be visible to the child. Any modifications to the data in MAP_PRIVATE mappings made by the parent after
fork() returns shall be visible only to the parent. Modifications to the data in MAP_PRIVATE mappings made by the child
shall be visible only to the child.
[PS]  For
the SCHED_FIFO and SCHED_RR scheduling policies, the child process shall inherit the policy and priority settings of the parent
process during a fork() function. For other scheduling policies, the policy and priority settings on fork() are
implementation-defined.
Per-process timers created by the parent shall not be inherited by the child process.
[MSG]
The child process shall have its own copy of the message queue descriptors of the parent. Each of the message descriptors of the
child shall refer to the same open message queue description as the corresponding message descriptor of the parent.
No asynchronous input or asynchronous output operations shall be inherited by the child process. Any use of asynchronous control
blocks created by the parent produces undefined behavior.
A process shall be created with a single thread. If a multi-threaded process calls fork(), the new process shall contain
a replica of the calling thread and its entire address space, possibly including the states of mutexes and other resources.
Consequently, the application shall ensure that the child process only executes async-signal-safe operations until such time as one
of the exec functions is successful.
Any locks held by any thread in the calling process that have been set to be process-shared shall not be held by the child
process. For locks held by any thread in the calling process that have not been set to be process-shared, any attempt by the child
process to perform any operation on the lock results in undefined behavior (regardless of whether the calling process is
single-threaded or multi-threaded).
[CPT]
The initial value of the CPU-time clock of the child process shall be set to zero.
[TCT]
The initial value of the CPU-time clock of the single thread of the child process shall be set to zero.
All other process characteristics defined by POSIX.1-2024 shall be the same in the parent and child processes. The inheritance
of process characteristics not defined by POSIX.1-2024 is unspecified by POSIX.1-2024.
After fork(), both the parent and the child processes shall be capable of executing independently before either one
terminates.
The _Fork() function shall be equivalent to fork(), except that fork handlers established by means of the pthread_atfork() function shall not be called and _Fork() shall be
async-signal-safe.
RETURN VALUE
Upon successful completion, fork() shall return 0 to the child process and shall return the process ID of the child
process to the parent process. Both processes shall continue to execute from the fork() function. Otherwise, -1 shall be
returned to the parent process, no child process shall be created, and errno shall be set to indicate the error.
ERRORS
These functions shall fail if:
[EAGAIN]
The system lacked the necessary resources to create another process, or the system-imposed limit on the total number of
processes under execution system-wide or by a single user {CHILD_MAX} would be exceeded.
These functions may fail if:
[ENOMEM]
Insufficient storage space is available.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
When a multi-threaded process calls fork() or _Fork(), there is no guarantee that thread-specific memory, such as
stacks or thread-local storage, associated with threads in the parent other than the calling thread will still be available in the
child. This is because threads in the parent other than the calling thread do not exist in the child. Consequently, the
implementation of fork() or _Fork() could remove that memory from the address space in the child, or reuse it for
other purposes before returning or (in the case of fork()) calling any of the fork handlers registered by pthread_atfork(). Therefore, applications should avoid using any pointers to
thread-specific memory in the child that were passed to the calling thread from other threads in the parent.
RATIONALE
Many historical implementations have timing windows where a signal sent to a process group (for example, an interactive SIGINT)
just prior to or during execution of fork() is delivered to the parent following the fork() but not to the child
because the fork() code clears the child's set of pending signals. This volume of POSIX.1-2024 does not require, or even
permit, this behavior. However, it is pragmatic to expect that problems of this nature may continue to exist in implementations
that appear to conform to this volume of POSIX.1-2024 and pass available verification suites. This behavior is only a consequence
of the implementation failing to make the interval between signal generation and delivery totally invisible. From the application's
perspective, a fork() call should appear atomic. A signal that is generated prior to the fork() should be delivered
prior to the fork(). A signal sent to the process group after the fork() should be delivered to both parent and
child. The implementation may actually initialize internal data structures corresponding to the child's set of pending signals to
include signals sent to the process group during the fork(). Since the fork() call can be considered as atomic from
the application's perspective, the set would be initialized as empty and such signals would have arrived after the fork();
see also .
One approach that has been suggested to address the problem of signal inheritance across fork() is to add an [EINTR]
error, which would be returned when a signal is detected during the call. While this is preferable to losing signals, it was not
considered an optimal solution. Although it is not recommended for this purpose, such an error would be an allowable extension for
an implementation.
The [ENOMEM] error value is reserved for those implementations that detect and distinguish such a condition. This condition
occurs when an implementation detects that there is not enough memory to create the process. This is intended to be returned when
[EAGAIN] is inappropriate because there can never be enough memory (either primary or secondary storage) to perform the operation.
Since fork() duplicates an existing process, this must be a condition where there is sufficient memory for one such process,
but not for two. Many historical implementations actually return [ENOMEM] due to temporary lack of memory, a case that is not
generally distinct from [EAGAIN] from the perspective of a conforming application.
Part of the reason for including the optional error [ENOMEM] is because the SVID specifies it and it should be reserved for the
error condition specified there. The condition is not applicable on many implementations.
IEEE Std 1003.1-1988 neglected to require concurrent execution of the parent and child of fork(). A system that
single-threads processes was clearly not intended and is considered an unacceptable "toy implementation" of this volume of
POSIX.1-2024. The only objection anticipated to the phrase "executing independently" is testability, but this assertion should be
testable. Such tests require that both the parent and child can block on a detectable action of the other, such as a write to a
pipe or a signal. An interactive exchange of such actions should be possible for the system to conform to the intent of this volume
of POSIX.1-2024.
The [EAGAIN] error exists to warn applications that such a condition might occur. Whether it occurs or not is not in any
practical sense under the control of the application because the condition is usually a consequence of the user's use of the
system, not of the application's code. Thus, no application can or should rely upon its occurrence under any circumstances, nor
should the exact semantics of what concept of "user" is used be of concern to the application developer. Validation writers
should be cognizant of this limitation.
There are two reasons why POSIX programmers call fork(). One reason is to create a new thread of control within the same
program (which was originally only possible in POSIX by creating a new process); the other is to create a new process running a
different program. In the latter case, the call to fork() is soon followed by a call to one of the exec functions.
The general problem with making fork() work in a multi-threaded world is what to do with all of the threads. There are
two alternatives. One is to copy all of the threads into the new process. This causes the programmer or implementation to deal with
threads that are suspended on system calls or that might be about to execute system calls that should not be executed in the new
process. The other alternative is to copy only the thread that calls fork(). This creates the difficulty that the state of
process-local resources is usually held in process memory. If a thread that is not calling fork() holds a resource, that
resource is never released in the child process because the thread whose job it is to release the resource does not exist in the
child process.
When a programmer is writing a multi-threaded program, the first described use of fork(), creating new threads in the
same program, is provided by the pthread_create() function. The fork()
function is thus used only to run new programs, and the effects of calling functions that require certain resources between the
call to fork() and the call to an exec function are undefined.
The addition of the forkall() function to the standard was considered and rejected. The forkall() function lets
all the threads in the parent be duplicated in the child. This essentially duplicates the state of the parent in the child. This
allows threads in the child to continue processing and allows locks and the state to be preserved without explicit pthread_atfork() code. The calling process has to ensure that the threads processing
state that is shared between the parent and child (that is, file descriptors or MAP_SHARED memory) behaves properly after
forkall(). For example, if a thread is reading a file descriptor in the parent when forkall() is called, then two
threads (one in the parent and one in the child) are reading the file descriptor after the forkall(). If this is not desired
behavior, the parent process has to synchronize with such threads before calling forkall().
When forkall() is called, threads, other than the calling thread, that are in functions that can return with an [EINTR]
error may have those functions return [EINTR] if the implementation cannot ensure that the function behaves correctly in the parent
and child. In particular, pthread_cond_clockwait(), pthread_cond_timedwait(), and pthread_cond_wait() need to return in order to ensure that the condition has not
changed. These functions can be awakened by a spurious condition wakeup rather than returning [EINTR].
FUTURE DIRECTIONS
None.
SEE ALSO
alarm(), exec, fcntl(), pthread_atfork(), semop(), signal(), times()
XBD 4.15.2 Memory Synchronization, ,
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
The DESCRIPTION is changed for alignment with the POSIX Realtime Extension and the POSIX Threads Extension.
Issue 6
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The requirement to include  has been removed. Although
was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.
The following changes were made to align with the IEEE P1003.1a draft standard:
The effect of fork() on a pending alarm call in the child process is clarified.
The description of CPU-time clock semantics is added for alignment with IEEE Std 1003.1d-1999.
The description of tracing semantics is added for alignment with IEEE Std 1003.1q-2000.
IEEE Std 1003.1-2001/Cor 1-2002, item XSH/TC1/D6/17 is applied, adding text to the DESCRIPTION and RATIONALE
relating to fork handlers registered by the pthread_atfork() function and
async-signal safety.
Issue 7
Austin Group Interpretation 1003.1-2001 #080 is applied, clarifying the status of asynchronous input and asynchronous output
operations and asynchronous control lists in the DESCRIPTION.
Functionality relating to the Asynchronous Input and Output, Memory Mapped Files, Timers, and Threads options is moved to the
Base.
Functionality relating to message catalog descriptors is moved from the XSI option to the Base.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0123 [858] is applied.
Issue 8
Austin Group Defects 62, 1361, and 1383 are applied, adding the _Fork() function and removing the requirement for
fork() to be async-signal-safe.
Austin Group Defect 768 is applied, adding OFD-owned file locks.
Austin Group Defect 1112 is applied, clarifying the requirements for a child of a multi-threaded process and for process-shared
and non-process-shared locks held by any thread in the calling process.
Austin Group Defect 1114 is applied, changing the APPLICATION USAGE section.
Austin Group Defect 1216 is applied, adding pthread_cond_clockwait().
Austin Group Defect 1318 is applied, adding FD_CLOFORK.
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/optind.html =====
getopt
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getopt, optarg, opterr, optind, optopt — command option parsing
SYNOPSIS
#include
int getopt(int argc, char * const argv[], const char *optstring);
extern char *optarg;
extern int opterr, optind, optopt;
DESCRIPTION
The getopt() function is a command-line parser that shall follow Utility Syntax Guidelines 3, 4, 5, 6, 7, 9, and 10 in
XBD 12.2 Utility Syntax Guidelines.
The parameters argc and argv are the argument count and argument array as passed to main() (see exec()). The argument optstring is a string of recognized option characters; if a
character is followed by a , the option takes an argument. All option characters allowed by Utility Syntax Guideline 3
are allowed in optstring. The optstring argument can optionally start with a  ('+'), which
shall have no effect on behavior in a conforming environment. If a  occurs anywhere besides the first character of
optstring, the behavior is unspecified. The implementation may accept other characters as an extension.
The variable optind is the index of the next element of the argv[] vector to be processed. It shall be initialized
to 1 by the system, and getopt() shall update it when it finishes with each element of argv[]. If the application
sets optind to zero before calling getopt(), the behavior is unspecified. When an element of argv[] contains
multiple option characters, it is unspecified how getopt() determines which options have already been processed.
The getopt() function shall return the next option character (if one is found) from argv that matches a character
in optstring (excluding an optional leading ), if there is one that matches. If the option takes an
argument, getopt() shall set the variable optarg to point to the option-argument as follows:
If the option was the last character in the string pointed to by an element of argv, then optarg shall contain the
next element of argv, and optind shall be incremented by 2. If the resulting value of optind is greater than
argc, this indicates a missing option-argument, and getopt() shall return an error indication.
Otherwise, optarg shall point to the string following the option character in that element of argv, and
optind shall be incremented by 1.
If, when getopt() is called, any of the following is true:
argv[optind]  is a null pointer
*argv[optind]  is not the character '-'
argv[optind]  points to the string "-"
getopt() shall return -1 without changing optind. If:
argv[optind]   points to the string "--"
getopt() shall return -1 after incrementing optind.
If getopt() encounters a  as an option character, or an option character that is not contained in
optstring after an optional leading , it shall return the  ('?') character.
If it detects a missing option-argument, it shall return the  character (':') if the first character of
optstring after an optional  was a , or a  character ('?')
otherwise. In either case, getopt() shall set the variable optopt to the option character that caused the error. If
the application has not set the variable opterr to 0, and the first character of optstring after an optional
is not a , getopt() shall also print a diagnostic message to stderr in the format
specified for the getopts utility, unless the stderr stream has wide
orientation, in which case the behavior is undefined.
The getopt() function need not be thread-safe.
RETURN VALUE
The getopt() function shall return the next option character specified on the command line.
A  (':') shall be returned if getopt() detects a missing argument and the first character of
optstring after an optional  was a  (':').
A  ('?') shall be returned if getopt() encounters a  as an option character,
encounters an option character not in optstring, or detects a missing argument and the first character of optstring
after an optional  was not a  (':').
Otherwise, getopt() shall return -1 when all command line options are parsed.
ERRORS
If the application has not set the variable opterr to 0, the first character of optstring is not a ,
and a write error occurs while getopt() is printing a diagnostic message to stderr, then the error indicator for
stderr shall be set; but getopt() shall still succeed and the value of errno after getopt() is
unspecified.
The following sections are informative.
EXAMPLES
Parsing Command Line Options
The following code fragment shows how you might process the arguments for a utility that can take the mutually-exclusive options
a and b and the options f and o, both of which require arguments:
#include
#include
#include
int
main(int argc, char *argv[ ])
{
int c;
int bflg = 0, aflg = 0, errflg = 0;
char *ifile;
char *ofile;
. . .
while ((c = getopt(argc, argv, ":abf:o:")) != -1) {
switch(c) {
case 'a':
if (bflg)
errflg++;
else
aflg++;
break;
case 'b':
if (aflg)
errflg++;
else
bflg++;
break;
case 'f':
ifile = optarg;
break;
case 'o':
ofile = optarg;
break;
case ':':       /* -f or -o without operand */
fprintf(stderr,
"Option -%c requires an operand\n", optopt);
errflg++;
break;
case '?':
fprintf(stderr,
"Unrecognized option: '-%c'\n", optopt);
errflg++;
}
}
if (errflg) {
fprintf(stderr, "usage: . . . ");
exit(2);
}
for ( ; optind
#include
...
const char *Options = "hdbtl";
...
int dbtype, c;
char *st;
...
dbtype = 0;
while ((c = getopt(argc, argv, Options)) != -1) {
if ((st = strchr(Options, c)) != NULL) {
dbtype = st - Options;
break;
}
}
APPLICATION USAGE
The getopt() function is only required to support option characters included in Utility Syntax Guideline 3. Many
historical implementations of getopt() support other characters as options. This is an allowed extension, but applications
that use extensions are not maximally portable. Note that support for multi-byte option characters is only possible when such
characters can be represented as type int.
Applications which use wide-character output functions with stderr should ensure that any calls to getopt() do not
write to stderr, either by setting opterr to 0 or by ensuring the first character of optstring is always a
.
While ferror(stderr) may be used to detect failures to write a diagnostic to stderr when getopt()
returns '?', the value of errno is unspecified in such a condition. Applications desiring more control over
handling write failures should set opterr to 0 and independently perform output to stderr, rather than relying on
getopt() to do the output.
RATIONALE
The optopt variable represents historical practice and allows the application to obtain the identity of the invalid
option.
The description has been written to make it clear that getopt(), like the getopts utility, deals with option-arguments whether separated from the option by
characters or not. Note that the requirements on getopt() and getopts are more stringent than the Utility Syntax Guidelines.
The getopt() function shall return -1, rather than EOF, so that  is not required.
The special significance of a  as the first character of optstring makes getopt() consistent with the
getopts utility. It allows an application to make a distinction between a missing
argument and an incorrect option letter without having to examine the option letter. It is true that a missing argument can only be
detected in one case, but that is a case that has to be considered.
In some non-conforming environments, the use of a leading  in optstring forces getopt() to behave
in a conforming way, when it would otherwise have non-conforming behavior. Its use has been standardized to allow applications to
be written that can guarantee behavior consistent with this specification even in an otherwise non-conforming environment. If both
and  are used at the beginning of optstring, the  must be first.
Note that the use of a leading  in optstring is only standardized for getopt(). Use of a
is intentionally left unspecified for the getopts utility, where
historical implementations did not require a leading  for conforming behavior, and because some historical
getopts implementations used a leading  for a different
extension.
FUTURE DIRECTIONS
None.
SEE ALSO
exec
XBD 12.2 Utility Syntax Guidelines,
XCU getopts
CHANGE HISTORY
First released in Issue 1. Derived from Issue 1 of the SVID.
Issue 5
A note indicating that the getopt() function need not be reentrant is added to the DESCRIPTION.
Issue 6
IEEE PASC Interpretation 1003.2 #150 is applied.
Austin Group Interpretation 1003.1-2001 #156 is applied.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0248 [318], XSH/TC1-2008/0249 [460], XSH/TC1-2008/0250 [189],
XSH/TC1-2008/0251 [189], XSH/TC1-2008/0252 [189], and XSH/TC1-2008/0253 [460] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0169 [608] is applied.
Issue 8
Austin Group Defect 191 is applied, allowing a leading  in optstring.
Austin Group Defect 1179 is applied, adding some missing '}' characters at the end of the example code.
Austin Group Defect 1523 is applied, clarifying the conditions under which getopt() returns -1 without changing
optind.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/nearbyint.html =====
nearbyint
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
nearbyint, nearbyintf, nearbyintl — floating-point rounding functions
SYNOPSIS
#include
double nearbyint(double x);
float nearbyintf(float x);
long double nearbyintl(long double x);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall round their argument to an integer value in floating-point format, using the current rounding direction
and without raising the inexact floating-point exception.
RETURN VALUE
Upon successful completion, these functions shall return the rounded integer value. [MX]   The result
shall have the same sign as x.
[MX]  If
x is NaN, a NaN shall be returned.
If x is ±0, ±0 shall be returned.
If x is ±Inf, x shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
The integral value returned by these functions need not be expressible as an intmax_t. The return value should be tested
before assigning it to an integer type to avoid the undefined results of an integer overflow.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
feclearexcept(), fetestexcept()
XBD 4.23 Treatment of Error Conditions for Mathematical Functions,
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0402 [346,428] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/nl_langinfo_l.html =====
nl_langinfo
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
nl_langinfo, nl_langinfo_l — language information
SYNOPSIS
#include
char *nl_langinfo(nl_item item);
char *nl_langinfo_l(nl_item item, locale_t locale);
DESCRIPTION
The nl_langinfo() and nl_langinfo_l() functions shall return a pointer to a string containing information relevant
to the particular language or cultural area defined in the current locale, or in the locale represented by locale,
respectively (see ). The manifest constant names and values of
item are defined in . For example:
nl_langinfo(ABDAY_1)
would return a pointer to the string "Dom" if the identified language was Portuguese, and "Sun" if the
identified language was English.
nl_langinfo_l(ABDAY_1, loc)
would return a pointer to the string "Dom" if the identified language of the locale represented by loc was
Portuguese, and "Sun" if the identified language of the locale represented by loc was English.
The nl_langinfo() function need not be thread-safe.
The behavior is undefined if the locale argument to nl_langinfo_l() is the special locale object LC_GLOBAL_LOCALE
or is not a valid locale object handle.
RETURN VALUE
In a locale where langinfo data is not defined, these functions shall return a pointer to the corresponding string in the
POSIX locale. In all locales, these functions shall return a pointer to an empty string if item contains an invalid
setting.
The application shall not modify the string returned. The pointer returned by nl_langinfo() might be invalidated or the
string content might be overwritten by a subsequent call to nl_langinfo() in any thread or to nl_langinfo_l() in the
same thread or the initial thread, by subsequent calls to setlocale() with a
category corresponding to the category of item (see ) or
the category LC_ALL, or by subsequent calls to uselocale() which change the
category corresponding to the category of item. The pointer returned by nl_langinfo_l() might be invalidated or the
string content might be overwritten by a subsequent call to nl_langinfo_l() in the same thread or to nl_langinfo() in
any thread, or by subsequent calls to freelocale() or newlocale() which free or modify the locale object that was passed to
nl_langinfo_l(). The returned pointer and the string content might also be invalidated if the calling thread is
terminated.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
Getting Date and Time Formatting Information
The following example returns a pointer to a string containing date and time formatting information, as defined in the
LC_TIME category of the current locale.
#include
#include
...
strftime(datestring, sizeof(datestring), nl_langinfo(D_T_FMT), tm);
...
APPLICATION USAGE
The array pointed to by the return value should not be modified by the program, but may be modified by further calls to these
functions.
RATIONALE
The possible interactions between internal data used by nl_langinfo() and nl_langinfo_l() are complicated by the
fact that nl_langinfo_l() must be thread-safe but nl_langinfo() need not be. The various implementation choices
are:
nl_langinfo_l() and nl_langinfo() use separate buffers, or at least one of them does not use an internal string
buffer. In this case there are no interactions.
nl_langinfo_l() and nl_langinfo() share an internal per-thread buffer. There can be interactions, but only in the
same thread.
nl_langinfo_l() uses an internal per-thread buffer, and nl_langinfo() uses (in all threads) the same buffer that
nl_langinfo_l() uses in the initial thread. There can be interactions, but only when nl_langinfo_l() is called in the
initial thread.
FUTURE DIRECTIONS
None.
SEE ALSO
setlocale(), uselocale()
XBD 7. Locale, , ,
CHANGE HISTORY
First released in Issue 2.
Issue 5
The last paragraph of the DESCRIPTION is moved from the APPLICATION USAGE section.
A note indicating that this function need not be reentrant is added to the DESCRIPTION.
Issue 7
Austin Group Interpretation 1003.1-2001 #156 is applied.
The nl_langinfo() function is moved from the XSI option to the Base.
The nl_langinfo_l() function is added from The Open Group Technical Standard, 2006, Extended API Set Part 4.
POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0412 [302], XSH/TC1-2008/0413 [75], XSH/TC1-2008/0414 [283],
XSH/TC1-2008/0415 [75,402], XSH/TC1-2008/0416 [283], and XSH/TC1-2008/0417 [402] are applied.
POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0234 [656] is applied.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/catanhf.html =====
catanh
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
catanh, catanhf, catanhl — complex arc hyperbolic tangent functions
SYNOPSIS
#include
double complex catanh(double complex z);
float complex catanhf(float complex z);
long double complex catanhl(long double complex z);
DESCRIPTION
[CX]  The functionality described on this reference page is aligned with the ISO C standard. Any conflict between the
requirements described here and the ISO C standard is unintentional. This volume of POSIX.1-2024 defers to the ISO C
standard.
These functions shall compute the complex arc hyperbolic tangent of z, with branch cuts outside the interval
[-1, +1] along the real axis.
RETURN VALUE
These functions shall return the complex arc hyperbolic tangent value, in the range of a strip mathematically unbounded along
the real axis and in the interval [-iℼ/2, +iℼ/2] along the imaginary axis.
[MXC]
catanh(conj(z)), catanhf(conjf(z)), and catanhl(conjl(z)) shall
return exactly the same value as conj(catanh(z)), conjf(catanhf(z)), and
conjl(catanhl(z)), respectively, and catanh(-z), catanhf(-z), and
catanhl(-z) shall return exactly the same value as -catanh(z), -catanhf(z), and
-catanhl(z), respectively, including for the special values of z below.
If z is +0 + i0, +0 + i0 shall be returned.
If z is +0 + iNaN, +0 + iNaN shall be returned.
If z is +1 + i0, +Inf + i0 shall be returned and the divide-by-zero floating-point exception shall be
raised.
If z is x + iInf where x is positive-signed and finite, +0 + iℼ/2 shall be returned.
If z is x + iNaN where x is non-zero and finite, NaN + iNaN shall be returned and the invalid
floating-point exception may be raised.
If z is +Inf + iy where y is positive-signed and finite, +0 + iℼ/2 shall be returned.
If z is +Inf + iInf, +0 + iℼ/2 shall be returned.
If z is +Inf + iNaN, +0 + iNaN shall be returned.
If z is NaN + iy where y is finite, NaN + iNaN shall be returned and the invalid floating-point
exception may be raised.
If z is NaN + iInf, ±0 + iℼ/2 shall be returned; the sign of the real part of the result is
unspecified.
If z is NaN + iNaN, NaN + iNaN shall be returned.
ERRORS
No errors are defined.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
ctanh()
XBD
CHANGE HISTORY
First released in Issue 6. Derived from the ISO/IEC 9899:1999 standard.
Issue 8
Austin Group Defect 1302 is applied, aligning these functions with the ISO/IEC 9899:2018 standard.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/functions/accept4.html =====
accept
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
accept, accept4 — accept a new connection on a socket
SYNOPSIS
#include
int accept(int socket, struct sockaddr *restrict address,
socklen_t *restrict address_len);
int accept4(int socket, struct sockaddr *restrict address,
socklen_t *restrict address_len, int flag);
DESCRIPTION
The accept() function shall extract the first connection on the queue of pending connections, create a new socket with
the same socket type protocol and address family as the specified socket, and allocate a new file descriptor for that socket. The
file descriptor shall be allocated as described in 2.6 File Descriptor
Allocation.
The accept() function takes the following arguments:
socket
Specifies a socket that was created with socket(), has been bound to an address
with bind(), and has issued a successful call to listen().
address
Either a null pointer, or a pointer to a sockaddr structure where the address of the connecting socket shall be
returned.
address_len
Either a null pointer, if address is a null pointer, or a pointer to a socklen_t object which on input specifies
the length of the supplied sockaddr structure, and on output specifies the length of the address of the connecting
socket.
If address is not a null pointer, the address of the peer for the accepted connection shall be stored in the
sockaddr structure pointed to by address, and the length of this address shall be stored in the object pointed to by
address_len.
If the actual length of the address is greater than the length of the supplied sockaddr structure, the stored address
shall be truncated.
If the protocol permits connections by unbound clients, and the peer is not bound, then the value stored in the object pointed
to by address is unspecified.
If the listen queue is empty of connection requests and O_NONBLOCK is not set on the file descriptor for the socket,
accept() shall block until a connection is present. If the listen() queue is
empty of connection requests and O_NONBLOCK is set on the file descriptor for the socket, accept() shall fail and set
errno to [EAGAIN] or [EWOULDBLOCK].
The accepted socket cannot itself accept more connections. The original socket remains open and can accept more connections.
If O_NONBLOCK is set on the file description for socket, it is implementation-defined whether O_NONBLOCK will be set on
the file description created by accept(). FD_CLOEXEC and FD_CLOFORK for the new file descriptor shall be clear, regardless
of how they are currently set for socket.
It is implementation-defined which socket options, if any, on the accepted socket will have a default value determined by a
value previously customized by setsockopt() on socket, rather than the
default value used for other new sockets.
The accept4() function shall be equivalent to the accept() function, except that the state of O_NONBLOCK on the
new file description, and FD_CLOEXEC and FD_CLOFORK on the returned file descriptor shall be determined solely by the flag
argument, which can be constructed from a bitwise-inclusive OR of flags from the following list:
SOCK_CLOEXEC
Atomically set the FD_CLOEXEC flag on the new file descriptor.
SOCK_CLOFORK
Atomically set the FD_CLOFORK flag on the new file descriptor.
SOCK_NONBLOCK
Set the O_NONBLOCK file status flag on the new file description.
Implementations may define additional flags.
RETURN VALUE
Upon successful completion, accept() and accept4() shall return the non-negative file descriptor of the accepted
socket. Otherwise, -1 shall be returned, errno shall be set to indicate the error, and any object pointed to by
address_len shall remain unchanged.
ERRORS
The accept() and accept4() functions shall fail if:
[EAGAIN] or [EWOULDBLOCK]
O_NONBLOCK is set for the socket file descriptor and no connections are present to be accepted.
[EBADF]
The socket argument is not a valid file descriptor.
[ECONNABORTED]
A connection has been aborted.
[EINTR]
The accept() function was interrupted by a signal that was caught before a valid connection arrived.
[EINVAL]
The socket is not accepting connections.
[EMFILE]
All file descriptors available to the process are currently open.
[ENFILE]
The maximum number of file descriptors in the system are already open.
[ENOBUFS]
No buffer space is available.
[ENOMEM]
There was insufficient memory available to complete the operation.
[ENOTSOCK]
The socket argument does not refer to a socket.
[EOPNOTSUPP]
The socket type of the specified socket does not support accepting connections.
The accept() and accept4() functions may fail if:
[EPROTO]
A protocol error has occurred.
The accept4() function may fail if:
[EINVAL]
The value of the flag argument is invalid.
The following sections are informative.
EXAMPLES
None.
APPLICATION USAGE