If followed by the erase or kill character, that character shall be inserted into the input line. Otherwise, the
itself shall be inserted into the input line.
However, this is not actually a feature of sh command line editing insert mode, but one of some historical terminal line
drivers. Some conforming implementations continue to do this when the stty
iexten flag is set.
In interactive shells, SIGTERM is ignored so that kill 0 does not kill the shell, and SIGINT is caught so that wait is interruptible. If the shell does not ignore SIGTTIN, SIGTTOU, and SIGTSTP signals when
it is interactive and the -m option is not in effect, these signals suspend the shell if it is not a session leader. If it
is a session leader, the signals are discarded if they would stop the process, as required by XSH 2.4.3 Signal Actions for orphaned process groups.
Earlier versions of this standard required that input files to the shell be text files except that line lengths were unlimited.
However, that was overly restrictive in relation to the fact that shells can parse a script without a trailing newline, and in
relation to a common practice of concatenating a shell script ending with an exit or exec $command with a binary
data payload to form a single-file self-extracting archive.
FUTURE DIRECTIONS
If this utility is directed to create a new directory entry that contains any bytes that have the encoded value of a
character, implementations are encouraged to treat this as an error. A future version of this standard may require
implementations to treat this as an error.
SEE ALSO
2.9.1.4 Command Search and Execution, 2. Shell Command Language, cd,
echo, exit, fc, pwd, read, set, stty, test, trap, umask, vi
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
XSH dup(), exec, exit(), fork(), getrlimit(), open(), pipe(), signal(), system(), umask(), wait()
CHANGE HISTORY
First released in Issue 2.
Issue 5
The FUTURE DIRECTIONS section is added.
Text is added to the DESCRIPTION for the Large File Summit proposal.
Issue 6
The Open Group Corrigendum U029/2 is applied, correcting the second SYNOPSIS.
The Open Group Corrigendum U027/3 is applied, correcting a typographical error.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The option letters derived from the set special built-in are also accepted
with a leading  ('+').
Large file extensions are added:
Pathname expansion does not fail due to the size of a file.
Shell input and output redirections have an implementation-defined offset maximum that is established in the open file
description.
In the ENVIRONMENT VARIABLES section, the text "user's home directory" is updated to "directory referred to by the
HOME environment variable".
Descriptions for the ENV and PWD environment variables are included to align with the IEEE P1003.2b draft
standard.
The normative text is reworded to avoid use of the term "must" for application requirements.
Issue 7
Austin Group Interpretation 1003.1-2001 #098 is applied, changing the definition of IFS .
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
Changes to the pwd utility and PWD environment variable have been made to
match the changes to the getcwd() function made for Austin Group Interpretation
1003.1-2001 #140.
Minor editorial changes are made to the User Portability Utilities option shading. No normative changes are implied.
Minor changes are made to the install script example in the APPLICATION USAGE section.
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0137 [152], XCU/TC1-2008/0138 [347], XCU/TC1-2008/0139 [347],
XCU/TC1-2008/0140 [347], XCU/TC1-2008/0141 [299], and XCU/TC1-2008/0142 [347] are applied.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0175 [584], XCU/TC2-2008/0176 [584], XCU/TC2-2008/0177 [718],
XCU/TC2-2008/0178 [884], XCU/TC2-2008/0179 [809], XCU/TC2-2008/0180 [884], and XCU/TC2-2008/0181 [584] are applied.
Issue 8
Austin Group Defect 51 is applied, changing the EXIT STATUS section.
Austin Group Defect 251 is applied, encouraging implementations to disallow the creation of filenames containing any bytes that
have the encoded value of a  character.
Austin Group Defect 981 is applied, removing a reference to the set
-o nolog option from the RATIONALE section.
Austin Group Defect 1006 is applied, changing the description of the ENV environment variable.
Austin Group Defect 1055 is applied, adding a paragraph about the -n option to the APPLICATION USAGE section.
Austin Group Defect 1063 is applied, adding OB shading to the -h option and adding it to the list of options that are
described as part of the set utility.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
Austin Group Defect 1250 is applied, changing the INPUT FILES section.
Austin Group Defect 1266 is applied, clarifying the circumstances under which the shell is considered to be interactive.
Austin Group Defect 1267 is applied, changing the ENVIRONMENT VARIABLES section to remove the UP shading from HOME and
add it to HISTSIZE .
Austin Group Defect 1519 is applied, making the behavior explicitly unspecified if the -o or +o option is
specified without an option-argument.
Austin Group Defect 1629 is applied, changing the EXIT STATUS section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/realpath.html =====
realpath
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
realpath — resolve a pathname
SYNOPSIS
realpath [-E|-e] file
DESCRIPTION
The realpath utility shall canonicalize the pathname specified by the file operand as follows:
If a call to the realpath() function with the specified pathname as its first
argument would succeed, the canonicalized pathname shall be the pathname that would be returned by that realpath() call. Otherwise:
If the -e option is specified, the canonicalization shall fail.
If the -E option is specified, then if a call to the realpath() function
with the specified pathname as its first argument would encounter an error condition other than [ENOENT], the canonicalization
shall fail; if the call would encounter an [ENOENT] error, realpath shall expand all symbolic links that would be
encountered in an attempt to resolve the specified pathname using the algorithm specified in XBD 4.16 Pathname Resolution, except that any trailing  characters that
are not also leading  characters shall be ignored. If this expansion succeeds and the path prefix of the expanded
pathname resolves to an existing directory, the canonicalized pathname shall be the expanded pathname. In all other cases, the
canonicalization shall fail. If the expanded pathname is not empty, does not begin with a , and has exactly one
pathname component, it shall be treated as if it had a path prefix of "./".
If no options are specified, realpath shall canonicalize the specified pathname in an unspecified manner such that the
resulting absolute pathname does not contain any components that refer to files of type symbolic link and does not contain any
components that are dot or dot-dot.
Upon successful canonicalization, realpath shall write the canonicalized pathname, followed by a
character, to standard output.
If canonicalization fails, or the canonicalized pathname is empty, nothing shall be written to standard output, a diagnostic
message shall be written to standard error, and realpath shall exit with non-zero status.
OPTIONS
The realpath utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following options shall be supported:
-E
Do not treat it as an error if attempting to resolve the last component of the canonicalized form of the file operand
results in an [ENOENT] error condition.
-e
Treat it as an error if attempting to resolve the last component of the canonicalized form of the file operand results
in an [ENOENT] error condition.
Specifying more than one of the mutually-exclusive options -E and -e shall not be considered an error. The last
option specified shall determine the behavior of the utility.
OPERANDS
The following operand shall be supported:
file
A pathname to be canonicalized.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of realpath:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
See DESCRIPTION.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
If neither the -e nor the -E option is specified, some implementations behave as if -e had been specified
and others as if -E had been specified, but there are also implementations where the behavior differs from both of these.
For example, the mksh shell has an internal implementation of realpath that canonicalizes /dir/regular_file/..
to /dir, whereas the realpath() function would return an [ENOTDIR] error in
this case. Portable applications should always specify either -e or -E.
EXAMPLES
None.
RATIONALE
The realpath utility was added in preference to a -f option found in some implementations of the readlink utility because it allows the application to specify whether or not a missing
final component is to be treated as an error.
The behavior with the -E option when file does not resolve (with symbolic links followed) to an existing file is
not the same as simply calling realpath() with the path prefix of the file
operand and writing the resulting pathname, a , and the last component of file to standard output. For example,
if /tmp/nofile does not exist, and file is A/B where A is an existing directory and B is a
symbolic link to /tmp/nofile, realpath with -E will output /tmp/nofile, but if B is a symbolic
link to /tmp/nofile/foo, realpath with -E will treat this as an error. In both cases realpath("A/B")
would fail with errno set to [ENOENT]. Even though realpath("A") would succeed, in neither case is anything ending
/B the result.
Trailing  characters (that follow a non-) are handled differently with -E than with -e.
With -e they are handled as for the realpath() function. With -E they
are sometimes effectively ignored, and they are never included in the output. For example, if /tmp/nofile does not exist and
/tmp/regfile is an existing regular file:
$ realpath -E /tmp/nofile/
/tmp/nofile
$ realpath -E /tmp/regfile/
realpath: /tmp/regfile/: Not a directory
FUTURE DIRECTIONS
If this utility is directed to display a pathname that contains any bytes that have the encoded value of a
character when  is a terminator or separator in the output format being used, implementations are encouraged to
treat this as an error. A future version of this standard may require implementations to treat this as an error.
SEE ALSO
ln, ls, pwd, readlink
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
XSH 2.3 Error Numbers, realpath()
CHANGE HISTORY
First released in Issue 8.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/m4.html =====
m4
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
m4 — macro processor
SYNOPSIS
m4 [-s] [-D name[=val]]...
[-U name]... [file...]
DESCRIPTION
The m4 utility is a macro processor that shall read one or more text files, process them according to their included
macro statements, and write the results to standard output.
OPTIONS
The m4 utility shall conform to XBD 12.2 Utility Syntax
Guidelines, except that the order of the -D and -U options shall be significant, and options can be
interspersed with operands.
The following options shall be supported:
-s
Enable line synchronization output for the c17 preprocessor phase (that is,
#line directives).
-D name[=val]
Define name to val or to null if =val is omitted.
-U name
Undefine name.
OPERANDS
The following operand shall be supported:
file
A pathname of a text file to be processed. If no file is given, or if it is '-', the standard input shall be
read.
STDIN
The standard input shall be a text file that is used if no file operand is given, or if it is '-'.
INPUT FILES
The input file named by the file operand shall be a text file.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of m4:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
The standard output shall be the same as the input files, after being processed for macro expansion.
STDERR
The standard error shall be used to display strings with the errprint macro, macro tracing enabled by the traceon
macro, the defined text for macros written by the dumpdef macro, or for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
The m4 utility shall compare each token from the input against the set of built-in and user-defined macros. If the token
matches the name of a macro, then the token shall be replaced by the macro's defining text, if any, then scanning for tokens shall
resume at the start of the macro's defining text concatenated with the subsequent input. If a token does not match the name of a
macro, it shall be written to standard output. Macros may have arguments, in which case the arguments shall be substituted into the
defining text before it is rescanned.
No special meaning shall be given to characters enclosed between matching left and right quoting strings, other than identifying
nested quoting while finding the matching right quoting string, but the outermost quoting strings shall themselves be discarded. By
default, the left quoting string consists of a grave accent (backquote) and the right quoting string consists of an acute accent
(single-quote); see also the changequote macro.
Comments are written but not scanned for matching macro names; by default, the begin-comment string consists of the
character and the end-comment string consists of a . See also the changecom and
dnl macros.
Name tokens shall consist of the longest possible sequence of letters, digits, and underscores, where the first character is not
a digit. Tokens not of this form shall not be treated as name tokens. A macro call is a name token that matches the name of a
built-in or user-defined macro. Macro calls can have either of the following forms, which shall be distinguished by whether or not
the macro name is immediately followed by a :
name
name(arg1, arg2, ..., argn)
The application shall ensure that the  immediately follows the name of the macro. If a token matching
the name of a macro is not followed by a , it shall be handled as a use of that macro without
arguments.
If a macro name is followed by a , the subsequent text shall be tokenized and expanded until a token is
encountered that is not a quoted string and whose expansion includes a matching unquoted . The expanded
text between the  and the matching unquoted  is the macro's argument text. An
unquoted  character within the macro's argument text shall mark the end of one argument and the beginning of the next
argument unless the unquoted  is enclosed within a nested unquoted ,
pair. The unquoted  characters that separate the arguments, and any unquoted white-space characters at the beginning
of each argument, shall be discarded. All other characters in the macro's argument text, including any white-space characters at
the end of an argument and any nested parenthesized text, shall be retained. The input text containing the macro name, the
following , and all tokens up to and including the token whose expansion contained the matching unquoted
shall be replaced, and tokenization shall resume on the result of performing argument substition on the
macro's defining text followed by any expanded text that followed the matching unquoted . Otherwise, the
macro name was not followed by a , and tokenization shall resume on the result of performing argument
substitution with zero arguments on the macro's defining text.
During argument substitution, arguments shall be positionally defined and referenced. The string "$1" in the defining
text shall be replaced by the first argument. Systems shall support at least nine arguments; only the first nine can be referenced,
using the strings "$1" to "$9", inclusive. The string "$0" shall be replaced with the name of the macro.
The string "$#" shall be replaced by the number of arguments as a minimal string of decimal digits ('0' if the
macro was invoked without being followed by a , otherwise 1 more than the number of unquoted
characters that divided arguments in the macro's argument text). The string "$*" shall be replaced by a list of all of the
arguments, separated by  characters. The string "$@" shall be replaced by a list of all of the arguments
separated by  characters, and each argument shall be quoted using the current left and right quoting strings. The
string "${" produces unspecified behavior.
If fewer arguments are supplied than are in the macro definition, the omitted arguments are taken to be null. It is not an error
if more arguments are supplied than are in the macro definition.
The m4 utility shall make available the following built-in macros. They can be redefined, but once this is done the
original meaning is lost. Their values shall be null unless otherwise stated. In the descriptions below, the term defining
text refers to the value of the macro: the second argument to the define macro, among other things. Except for the first
argument to the eval macro, all numeric arguments to built-in macros shall be interpreted as decimal values. The string
values produced as the defining text of the decr, divnum, incr, index, len, and sysval
built-in macros shall be in the form of a decimal-constant as defined in the C language.
changecom
The changecom macro shall set the begin-comment and end-comment strings. With no arguments, the comment mechanism shall
be disabled. With a single non-null argument, that argument shall become the begin-comment and the  shall become the
end-comment string. With two non-null arguments, the first argument shall become the begin-comment string and the second argument
shall become the end-comment string. The behavior is unspecified if either argument is provided but null, or if either argument
includes letters, digits, underscore, or . Systems shall support comment strings of at least five
characters.
changequote
The changequote macro shall set the begin-quote and end-quote strings. With no arguments, the quote strings shall be set
to the default values (that is, `'). The behavior is unspecified if there is a single argument, or if either argument is
null or includes letters, digits, underscore, or . With two non-null arguments, the first argument shall
become the begin-quote string and the second argument shall become the end-quote string. Systems shall support quote strings of at
least five characters.
decr
The defining text of the decr macro shall be its first argument decremented by 1. It shall be an error to specify an
argument containing any non-numeric characters. The behavior is unspecified if decr is not immediately followed by a
.
define
The second argument shall become the defining text of the macro whose name is the first argument. It is unspecified whether the
define macro deletes all prior definitions of the macro named by its first argument or preserves all but the current
definition of the macro. The behavior is unspecified if define is not immediately followed by a
.
defn
The defining text of the defn macro shall be the quoted definition (using the current quoting strings) of its arguments.
The behavior is unspecified if defn is not immediately followed by a .
divert
The m4 utility maintains nine temporary buffers, numbered 1 to 9, inclusive. When the last of the input has been
processed, any output that has been placed in these buffers shall be written to standard output in buffer-numerical order. The
divert macro shall divert future output to the buffer specified by its argument. Specifying no argument or an argument of 0
shall resume the normal output process. Output diverted to a stream with a negative number shall be discarded. Behavior is
implementation-defined if a stream number larger than 9 is specified. It shall be an error to specify an argument containing any
non-numeric characters.
divnum
The defining text of the divnum macro shall be the number of the current output stream as a string.
dnl
The dnl macro shall cause m4 to discard all input characters up to and including the next .
dumpdef
The dumpdef macro shall write the defined text to standard error for each of the macros specified as arguments, or, if
no arguments are specified, for all macros.
errprint
The errprint macro shall write its arguments to standard error. The behavior is unspecified if errprint is not
immediately followed by a .
eval
The eval macro shall evaluate its first argument as an arithmetic expression, using signed integer arithmetic with at
least 32-bit precision. At least the following C-language operators shall be supported, with precedence, associativity, and
behavior as described in 1.1.2.1 Arithmetic Precision and
Operations:
()
unary +
unary -
~
!
binary *
/
%
binary +
binary -
>
>=
==
!=
binary &
^
|
&&
||
Systems shall support octal and hexadecimal numbers as in the ISO C standard. The second argument, if specified, shall set
the radix for the result; if the argument is blank or unspecified, the default is 10. Behavior is unspecified if the radix falls
outside the range 2 to 36, inclusive. The third argument, if specified, sets the minimum number of digits in the result. Behavior
is unspecified if the third argument is less than zero. It shall be an error to specify the second or third argument containing any
non-numeric characters. The behavior is unspecified if eval is not immediately followed by a .
ifdef
If the first argument to the ifdef macro is defined, the defining text shall be the second argument. Otherwise, the
defining text shall be the third argument, if specified, or the null string, if not. The behavior is unspecified if ifdef is
not immediately followed by a .
ifelse
The ifelse macro takes three or more arguments. If the first two arguments compare as equal strings, the defining text
shall be the third argument. If the first two arguments do not compare as equal strings and there are three arguments, the defining
text shall be null. If the first two arguments do not compare as equal strings and there are four or five arguments, the defining
text shall be the fourth argument. If the first two arguments do not compare as equal strings and there are six or more arguments,
the first three arguments shall be discarded and processing shall restart with the remaining arguments. The behavior is unspecified
if ifelse is not immediately followed by a .
include
The defining text for the include macro shall be the contents of the file named by the first argument. It shall be an
error if the file cannot be read. The behavior is unspecified if include is not immediately followed by a
.
incr
The defining text of the incr macro shall be its first argument incremented by 1. It shall be an error to specify an
argument containing any non-numeric characters. The behavior is unspecified if incr is not immediately followed by a
.
index
The defining text of the index macro shall be the first character position (as a string) in the first argument where a
string matching the second argument begins (zero origin), or -1 if the second argument does not occur. The behavior is unspecified
if index is not immediately followed by a .
len
The defining text of the len macro shall be the length (as a string) of the first argument. The behavior is unspecified
if len is not immediately followed by a .
m4exit
Exit from the m4 utility. If the first argument is specified, it shall be the exit code. If no argument is specified,
the exit code shall be zero. It shall be an error to specify an argument containing any non-numeric characters. If the first
argument is zero or no argument is specified, and an error has previously occurred (for example, a file operand that could
not be opened), the exit status shall be non-zero.
m4wrap
The first argument shall be processed when EOF is reached. If the m4wrap macro is used multiple times, the arguments
specified shall be processed in the order in which the m4wrap macros were processed. The behavior is unspecified if
m4wrap is not immediately followed by a .
mkstemp
The defining text shall be as if it were the resulting pathname after a successful call to the mkstemp() function defined in the System Interfaces volume of POSIX.1-2024 called with the
first argument to the macro invocation. If a file is created, that file shall be closed. If a file could not be created, the
m4 utility shall write a diagnostic message to standard error and shall continue processing input but its final exit status
shall be non-zero; the defining text of the macro shall be the empty string. The behavior is unspecified if mkstemp is not
immediately followed by a .
popdef
The popdef macro shall delete the current definition of its arguments, replacing that definition with the previous one.
If there is no previous definition, the macro is undefined. The behavior is unspecified if popdef is not immediately
followed by a .
pushdef
The pushdef macro shall be equivalent to the define macro with the exception that it shall preserve any current
definition for future retrieval using the popdef macro. The behavior is unspecified if pushdef is not immediately
followed by a .
shift
The defining text for the shift macro shall be a comma-separated list of its arguments except the first one. Each
argument shall be quoted using the current quoting strings. The behavior is unspecified if shift is not immediately followed
by a .
sinclude
The sinclude macro shall be equivalent to the include macro, except that it shall not be an error if the file is
inaccessible. The behavior is unspecified if sinclude is not immediately followed by a .
substr
The defining text for the substr macro shall be the substring of the first argument beginning at the zero-offset
character position specified by the second argument. The third argument, if specified, shall be the number of characters to select;
if not specified, the characters from the starting point to the end of the first argument shall become the defining text. It shall
not be an error to specify a starting point beyond the end of the first argument and the defining text shall be null. It shall be
an error to specify an argument containing any non-numeric characters. The behavior is unspecified if substr is not
immediately followed by a .
syscmd
The syscmd macro shall interpret its first argument as a shell command line. The defining text shall be the string
result of that command. The string result shall not be rescanned for macros while setting the defining text. No output redirection
shall be performed by the m4 utility. The exit status value from the command can be retrieved using the sysval macro.
The behavior is unspecified if syscmd is not immediately followed by a .
sysval
The defining text of the sysval macro shall be the exit value of the utility last invoked by the syscmd macro (as
a string).
traceon
The traceon macro shall enable tracing for the macros specified as arguments, or, if no arguments are specified, for all
macros. The trace output shall be written to standard error in an unspecified format.
traceoff
The traceoff macro shall disable tracing for the macros specified as arguments, or, if no arguments are specified, for
all macros.
translit
The defining text of the translit macro shall be the first argument with every character that occurs in the second
argument replaced with the corresponding character from the third argument. If no replacement character is specified for some
source character because the second argument is longer than the third argument, that character shall be deleted from the first
argument in translit's defining text. The behavior is unspecified if the '-' character appears within the second or
third argument anywhere besides the first or last character. The behavior is unspecified if the same character appears more than
once in the second argument. The behavior is unspecified if translit is not immediately followed by a
.
undefine
The undefine macro shall delete all definitions (including those preserved using the pushdef macro) of the macros
named by its arguments. The behavior is unspecified if undefine is not immediately followed by a
.
undivert
The undivert macro shall cause immediate output of any text in temporary buffers named as arguments, or all temporary
buffers if no arguments are specified. Buffers can be undiverted into other temporary buffers. Undiverting shall discard the
contents of the temporary buffer. The behavior is unspecified if an argument contains any non-numeric characters.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred
If the m4exit macro is used, the exit value can be specified by the input file.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
The defn macro is useful for renaming macros, especially built-ins.
Since eval defers to the ISO C standard, some operations have undefined behavior. In some implementations, division
or remainder by zero cause a fatal signal, even if the division occurs on the short-circuited branch of "&&" or
"||". Any operation that overflows in signed arithmetic produces undefined behavior. Likewise, using the shift
operators with a shift amount that is not positive and smaller than the precision is undefined, as is shifting a negative number to
the right. Historically, not all implementations obeyed C-language precedence rules: '~' and '!' were lower than
'=='; '==' and '!=' were not lower than '
character when  is a terminator or separator in the output format being used, implementations are encouraged to
treat this as an error. A future version of this standard may require implementations to treat this as an error.
SEE ALSO
c17
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 2.
Issue 5
The phrase "the defined text for macros written by the dumpdef macro" is added to the description of STDERR, and the
description of dumpdef is updated to indicate that output is written to standard error. The description of eval is
updated to indicate that the list of excluded C operators excludes unary '&' and '.'. In the description of
ifdef, the phrase "and it is not defined to be zero" is deleted.
Issue 6
In the EXTENDED DESCRIPTION, the eval text is updated to include a '&' character in the excepted list.
The EXTENDED DESCRIPTION of divert is updated to clarify that there are only nine diversion buffers.
The normative text is reworded to avoid use of the term "must" for application requirements.
The Open Group Base Resolution bwg2000-006 is applied.
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/31 is applied, replacing the EXAMPLES section.
Issue 7
Austin Group Interpretation 1003.1-2001 #117 is applied, marking the maketemp macro obsolescent and adding a new
mkstemp macro.
Austin Group Interpretation 1003.1-2001 #207 is applied, clarifying the handling of white-space characters that precede or trail
any macro arguments.
SD5-XCU-ERN-6 is applied, clarifying that Guideline 9 of the Utility Syntax Guidelines does not apply (options can be
interspersed with operands).
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
SD5-XCU-ERN-99 is applied, clarifying the definition of the divert macro in the EXTENDED DESCRIPTION.
SD5-XCU-ERN-100 is applied, clarifying the definition of the syscmd macro in the EXTENDED DESCRIPTION.
SD5-XCU-ERN-101 is applied, clarifying the definition of the undivert macro in the EXTENDED DESCRIPTION.
SD5-XCU-ERN-111 is applied to the EXTENDED DESCRIPTION, clarifying that the string "${" produces unspecified
behavior.
SD5-XCU-ERN-112 is applied, updating the changequote macro.
SD5-XCU-ERN-118 is applied, clarifying the definition of the define macro in the EXTENDED DESCRIPTION and APPLICATION
USAGE sections.
SD5-XCU-ERN-119 is applied, clarifying the definition of the translit macro in the EXTENDED DESCRIPTION and RATIONALE
sections.
SD5-XCU-ERN-130, SD5-XCU-ERN-131, and SD5-XCU-ERN-137 are applied.
The m4 utility is moved from the XSI option to the Base.
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0117 [241], XCU/TC1-2008/0118 [242,431], XCU/TC1-2008/0119 [242,431], and
XCU/TC1-2008/0120 [325,430] are applied.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0117 [964], XCU/TC2-2008/0118 [970], and XCU/TC2-2008/0119 [964] are
applied.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to report an error if a utility is directed to display a
pathname that contains any bytes that have the encoded value of a  character when  is a terminator or
separator in the output format being used.
Austin Group Defect 984 is applied, requiring that the exit status of m4 is non-zero when m4exit is called with a
first argument of zero or with no arguments after an error has occurred.
Austin Group Defect 1072 is applied, clarifying the handling of macro arguments.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
Austin Group Defect 1330 is applied, removing the obsolescent maketemp macro.
Austin Group Defect 1514 is applied, changing the RATIONALE section to use the same terminology as the normative text to which
it refers.
Austin Group Defect 1570 is applied, removing extra spacing in "==".
Austin Group Defect 1658 is applied, changing "whitespace characters" to "white-space characters".
Austin Group Defect 1730 is applied, adding square brackets around file... in the SYNOPSIS.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/yacc.html =====
yacc
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
yacc — yet another compiler compiler (DEVELOPMENT)
SYNOPSIS
[CD]  yacc [-dltv] [-b file_prefix] [-p
sym_prefix] grammar
DESCRIPTION
The yacc utility shall read a description of a context-free grammar in grammar and write C source code, conforming
to the ISO C standard, to a code file, and optionally header information into a header file, in the current directory. The
generated source code shall not depend on any undefined, unspecified, or implementation-defined behavior, except in cases where it
is copied directly from the supplied grammar, or in cases that are documented by the implementation. The C code shall define a
function and related routines and macros for an automaton that executes a parsing algorithm meeting the requirements in Algorithms.
The form and meaning of the grammar are described in the EXTENDED DESCRIPTION section.
The C source code and header file shall be produced in a form suitable as input for the C compiler (see c17).
OPTIONS
The yacc utility shall conform to XBD 12.2 Utility Syntax
Guidelines, except for Guideline 9.
The following options shall be supported:
-b file_prefix
Use file_prefix instead of y as the prefix for all output filenames. The code file y.tab.c, the header
file y.tab.h (created when -d is specified), and the description file y.output (created when -v is
specified), shall be changed to file_prefix.tab.c, file_prefix.tab.h, and
file_prefix.output, respectively.
-d
Write the header file; by default only the code file is written. See the OUTPUT FILES section.
-l
Produce a code file that does not contain any #line constructs. If this option is not present, it is unspecified whether
the code file or header file contains #line directives. This should only be used after the grammar and the associated
actions are fully debugged.
-p sym_prefix
Use sym_prefix instead of yy as the prefix for all external names produced by yacc. The names affected shall
include the functions yyparse(), yylex(), and yyerror(), and the variables yylval, yychar, and
yydebug. (In the remainder of this section, the six symbols cited are referenced using their default names only as a
notational convenience.) Local names may also be affected by the -p option; however, the -p option shall not affect
#define symbols generated by yacc.
-t
Modify conditional compilation directives to permit compilation of debugging code in the code file. Runtime debugging
statements shall always be contained in the code file, but by default conditional compilation directives prevent their
compilation.
-v
Write a file containing a description of the parser and a report of conflicts generated by ambiguities in the grammar.
OPERANDS
The following operand is required:
grammar
A pathname of a file containing instructions, hereafter called grammar, for which a parser is to be created. The format
for the grammar is described in the EXTENDED DESCRIPTION section.
STDIN
Not used.
INPUT FILES
The file grammar shall be a text file formatted as specified in the EXTENDED DESCRIPTION section.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of yacc:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
The LANG and LC_* variables affect the execution of the yacc utility as stated. The main() function
defined in Yacc Library shall call:
setlocale(LC_ALL, "")
and thus the program generated by yacc shall also be affected by the contents of these variables at runtime.
ASYNCHRONOUS EVENTS
Default.
STDOUT
Not used.
STDERR
If shift/reduce or reduce/reduce conflicts are detected in grammar, yacc shall write a report of those conflicts
to the standard error in an unspecified format.
Standard error shall also be used for diagnostic messages.
OUTPUT FILES
The code file, the header file, and the description file shall be text files. All are described in the following sections.
Code File
This file shall contain the C source code for the yyparse() function. It shall contain code for the various semantic
actions with macro substitution performed on them as described in the EXTENDED DESCRIPTION section. Preceding this code it shall
contain an extern int yychar declaration or int yychar definition, and #define statements for the
following macros:
YYEMPTY
Token number indicating there is no lookahead token. This macro shall expand to an integer constant with a value less than
zero, protected by parentheses.
YYEOF
Token number indicating the end of input. This macro shall expand to the value 0.
It also shall contain a copy of the #define statements in the header file, prior to any code copied from semantic actions
in grammar, and the following function prototypes for the yyerror(), yylex(), and yyparse() functions,
after any code copied from within %{ and %} in the declarations section in grammar and before any code copied
from semantic actions in grammar:
void yyerror(const char *);
int  yylex(void);
int  yyparse(void);
The declarations of yyerror() and yylex() shall be protected by #ifndef or #if preprocessor
statements such that each is only visible if a preprocessor macro with the name yyerror or yylex, respectively, is not already
defined, where the yy in the macro names is replaced by sym_prefix if the -p sym_prefix option is used.
If a %union declaration is used, the declaration for YYSTYPE and an extern YYSTYPE yylval declaration or
YYSTYPE yylval definition shall also be included in this file.
The code file shall not contain a declaration of the main() function, unless one is present within %{ and
%} in the declarations section in grammar.
Header File
The header file shall contain #define statements that associate the token numbers with the token names. This allows
source files other than the code file to access the token codes. If a %union declaration is used, the declaration for
YYSTYPE and an extern YYSTYPE yylval declaration shall also be included in this file. The header file may also declare the
yyparse() function, using a function prototype. It shall not declare the yyerror() and yylex() functions.
Description File
The description file shall be a text file containing a description of the state machine corresponding to the parser, using an
unspecified format. Limits for internal tables (see Limits) shall also be reported, in an
implementation-defined manner. (Some implementations may use dynamic allocation techniques and have no specific limit values to
report.)
EXTENDED DESCRIPTION
The yacc command accepts a language that is used to define a grammar for a target language to be parsed by the tables and
code generated by yacc. The language accepted by yacc as a grammar for the target language is described below using
the yacc input language itself.
The input grammar includes rules describing the input structure of the target language and code to be invoked when these
rules are recognized to provide the associated semantic action. The code to be executed shall appear as bodies of text that are
intended to be C-language code. These bodies of text shall not contain C-language trigraphs. The C-language inclusions are presumed
to form a correct function when processed by yacc into its output files. The code included in this way shall be executed
during the recognition of the target language.
Given a grammar, the yacc utility generates the files described in the OUTPUT FILES section. The code file can be
compiled and linked using c17. If the declaration and programs sections of the grammar
file did not include definitions of main(), yylex(), and yyerror(), the compiled output requires linking with
externally supplied versions of those functions. Default versions of main() and yyerror() are supplied in the
yacc library and can be linked in by using the -l y operand to c17.
The yacc library interfaces need not support interfaces with other than the default yy symbol prefix. The application
provides the lexical analyzer function, yylex(); the lex utility is specifically
designed to generate such a routine.
Input Language
The application shall ensure that every specification file consists of three sections in order: declarations, grammar
rules, and programs, separated by double  characters ("%%"). The declarations and programs
sections can be empty. If the latter is empty, the preceding "%%" mark separating it from the rules section can be
omitted.
The input is free form text following the structure of the grammar defined below.
Lexical Structure of the Grammar
The , , and  character shall be ignored, except that the application shall ensure
that they do not appear in names or multi-character reserved symbols. Comments shall be enclosed in "/* ... */",
and can appear wherever a name is valid.
Names are of arbitrary length, made up of letters, periods ('.'), underscores ('_'), and non-initial digits.
Uppercase and lowercase letters are distinct. Conforming applications shall not use names beginning in yy or YY since
the yacc parser uses such names. Many of the names appear in the final output of yacc, and thus they should be chosen
to conform with any additional rules created by the C compiler to be used. In particular they appear in #define
statements.
A literal shall consist of a single character enclosed in single-quote characters. All of the escape sequences supported for
character constants by the ISO C standard shall be supported by yacc.
The relationship with the lexical analyzer is discussed in detail below.
The application shall ensure that the NUL character is not used in grammar rules or literals.
Declarations Section
The declarations section is used to define the symbols used to define the target language and their relationship with each
other. In particular, much of the additional information required to resolve ambiguities in the context-free grammar for the target
language is provided here.
Usually yacc assigns the relationship between the symbolic names it generates and their underlying numeric value. The
declarations section makes it possible to control the assignment of these values.
It is also possible to keep semantic information associated with the tokens currently on the parse stack in a user-defined
C-language union, if the members of the union are associated with the various names in the grammar. The declarations section
provides for this as well.
The first group of declarators below all take a list of names as arguments. That list can optionally be preceded by the name of
a C union member (called a tag below) appearing within ''. (As an exception to the
typographical conventions of the rest of this volume of POSIX.1-2024, in this case  does not represent a
metavariable, but the literal angle bracket characters surrounding a symbol.) The use of tag specifies that the tokens named
on this line shall be of the same C type as the union member referenced by tag. This is discussed in more detail below.
For lists used to define tokens, the first appearance of a given token can be followed by a positive integer (as a string of
decimal digits). If this is done, the underlying value assigned to it for lexical purposes shall be taken to be that number.
The following declares name to be a token:
%token [] name [number] [name [number]]...
If tag is present, the C type for all tokens on this line shall be declared to be the type referenced by tag. If a
positive integer, number, follows a name, that value shall be assigned to the token.
The following declares name to be a token, and assigns precedence to it:
%left [] name [number] [name [number]]...
%right [] name [number] [name [number]]...
One or more lines, each beginning with one of these symbols, can appear in this section. All tokens on the same line have the
same precedence level and associativity; the lines are in order of increasing precedence or binding strength. %left denotes
that the operators on that line are left associative, and %right similarly denotes right associative operators. If
tag is present, it shall declare a C type for names as described for %token.
The following declares name to be a token, and indicates that this cannot be used associatively:
%nonassoc [] name [number] [name [number]]...
If the parser encounters associative use of this token it reports an error. If tag is present, it shall declare a C type
for names as described for %token.
The following declares that union member names are non-terminals, and thus it is required to have a tag field at
its beginning:
%type  name...
Because it deals with non-terminals only, assigning a token number or using a literal is also prohibited. If this construct is
present, yacc shall perform type checking; if this construct is not present, the parse stack shall hold only the int
type.
Every name used in grammar not defined by a %token, %left, %right, or %nonassoc declaration
is assumed to represent a non-terminal symbol. The yacc utility shall report an error for any non-terminal symbol that does
not appear on the left side of at least one grammar rule.
Once the type, precedence, or token number of a name is specified, it shall not be changed. If the first declaration of a token
does not assign a token number, yacc shall assign a token number. Once this assignment is made, the token number shall not
be changed by explicit assignment.
The following declarators do not follow the previous pattern.
The following declares the non-terminal name to be the start symbol, which represents the largest, most general
structure described by the grammar rules:
%start name
By default, it is the left-hand side of the first grammar rule; this default can be overridden with this declaration.
The following declares the yacc value stack to be a union of the various types of values desired.
%union { body of union (in C) }
The body of the union shall not contain unbalanced curly brace preprocessing tokens.
By default, the values returned by actions (see below) and the lexical analyzer shall be of type int. The yacc
utility keeps track of types, and it shall insert corresponding union member names in order to perform strict type checking of the
resulting parser.
Alternatively, given that at least one  construct is used, the union can be declared in a header file (which
shall be included in the declarations section by using a #include construct within %{ and %}), and a
typedef used to define the symbol YYSTYPE to represent this union. The effect of %union is to provide the declaration
of YYSTYPE directly from the yacc input.
C-language declarations and definitions can appear in the declarations section, enclosed by the following marks:
%{ ... %}
These statements shall be copied into the code file, and have global scope within it so that they can be used in the rules and
program sections. The statements shall not contain "%}" outside a comment, string literal, or multi-character
constant.
The application shall ensure that the declarations section is terminated by the token %%.
Grammar Rules in yacc
The rules section defines the context-free grammar to be accepted by the function yacc generates, and associates with
those rules C-language actions and additional precedence information. The grammar is described below, and a formal definition
follows.
The rules section is comprised of one or more grammar rules. A grammar rule has the form:
A : BODY ;
The symbol A represents a non-terminal name, and BODY represents a sequence of zero or more names,
literals, and semantic actions that can then be followed by optional precedence rules. Only the names and
literals participate in the formation of the grammar; the semantic actions and precedence rules are used in other ways. The
and the  are yacc punctuation. If there are several successive grammar rules with the same
left-hand side, the  ('|') can be used to avoid rewriting the left-hand side; in this case the
appears only after the last rule. The BODY part can be empty (or empty of names and literals) to indicate that
the non-terminal symbol matches the empty string.
The yacc utility assigns a unique number to each rule. Rules using the vertical bar notation are distinct rules. The
number assigned to the rule appears in the description file.
The elements comprising a BODY are:
name, literal
These form the rules of the grammar: name is either a token or a non-terminal; literal stands for
itself (less the lexically required quotation marks).
semantic action
With each grammar rule, the user can associate actions to be performed each time the rule is recognized in the input process. (Note
that the word "action" can also refer to the actions of the parser—shift, reduce, and so on.)
These actions can return values and can obtain the values returned by previous actions. These values are kept in objects of type
YYSTYPE (see %union). The result value of the action shall be kept on the parse stack with the left-hand side of the rule,
to be accessed by other reductions as part of their right-hand side. By using the  information provided in the
declarations section, the code generated by yacc can be strictly type checked and contain arbitrary information. In
addition, the lexical analyzer can provide the same kinds of values for tokens, if desired.
An action is an arbitrary C statement and as such can do input or output, call subprograms, and alter external variables. An
action is one or more C statements enclosed in curly braces '{' and '}'. The statements shall not contain
unbalanced curly brace preprocessing tokens.
Certain pseudo-variables can be used in the action. These are macros for access to data structures known internally to
yacc.
$$
The value of the action can be set by assigning it to $$. If type checking is enabled and the type of the value to be assigned
cannot be determined, a diagnostic message may be generated.
$number
This refers to the value returned by the component specified by the token number in the right side of a rule, reading
from left to right; number can be zero or negative. If number is zero or negative, it refers to the data associated
with the name on the parser's stack preceding the leftmost symbol of the current rule. (That is, "$0" refers to the name
immediately preceding the leftmost name in the current rule to be found on the parser's stack and "$-1" refers to the
symbol to its left.) If number refers to an element past the current point in the rule, or beyond the bottom of the
stack, the result is undefined. If type checking is enabled and the type of the value to be assigned cannot be determined, a
diagnostic message may be generated.
$number
These correspond exactly to the corresponding symbols without the tag inclusion, but allow for strict type checking (and
preclude unwanted type conversions). The effect is that the macro is expanded to use tag to select an element from the
YYSTYPE union (using dataname.tag). This is particularly useful if number is not positive.
$$
This imposes on the reference the type of the union member referenced by tag. This construction is applicable when a
reference to a left context value occurs in the grammar, and provides yacc with a means for selecting a type.
Actions can occur anywhere in a rule (not just at the end); an action can access values returned by actions to its left, and in
turn the value it returns can be accessed by actions to its right. An action appearing in the middle of a rule shall be equivalent
to replacing the action with a new non-terminal symbol and adding an empty rule with that non-terminal symbol on the left-hand
side. The semantic action associated with the new rule shall be equivalent to the original action. The use of actions within rules
might introduce conflicts that would not otherwise exist.
By default, the value of a rule shall be the value of the first element in it. If the first element does not have a type
(particularly in the case of a literal) and type checking is turned on by %type, an error message shall result.
precedence
The keyword %prec can be used to change the precedence level associated with a particular grammar rule. Examples of this
are in cases where a unary and binary operator have the same symbolic representation, but need to be given different precedences,
or where the handling of an ambiguous if-else construction is necessary. The reserved symbol %prec can appear immediately
after the body of the grammar rule and can be followed by a token name or a literal. It shall cause the precedence of the grammar
rule to become that of the following token name or literal. The action for the rule as a whole can follow %prec.
If a program section follows, the application shall ensure that the grammar rules are terminated by %%.
Programs Section
The programs section can include the definition of the lexical analyzer yylex(), and any other functions; for
example, those used in the actions specified in the grammar rules. It is unspecified whether the programs section precedes or
follows the semantic actions in the output file; therefore, if the application contains any macro definitions and declarations
intended to apply to the code in the semantic actions, it shall place them within "%{ ... %}" in the
declarations section.
Input Grammar
The following input to yacc yields a parser for the input to yacc. This formal syntax takes precedence over the
preceding text syntax description.
The lexical structure is defined less precisely; Lexical Structure of the Grammar defines most
terms. The correspondence between the previous terms and the tokens below is as follows.
IDENTIFIER
This corresponds to the concept of name, given previously. It also includes literals as defined previously.
C_IDENTIFIER
This is a name, and additionally it is known to be followed by a . A literal cannot yield this token.
NUMBER
A string of digits (a non-negative decimal integer).
TYPE, LEFT, MARK, LCURL, RCURL
These correspond directly to %type, %left, %%, %{, and %}.
{ ... }
This indicates C-language source code, with the possible inclusion of '$' macros as discussed previously.
/* Grammar for the input to yacc. */
/* Basic entries. */
/* The following are recognized by the lexical analyzer. */
%token    IDENTIFIER      /* Includes identifiers and literals */
%token    C_IDENTIFIER    /* identifier (but not literal)
followed by a :. */
%token    NUMBER          /* [0-9][0-9]* */
/* Reserved words : %type=>TYPE %left=>LEFT, and so on */
%token    LEFT RIGHT NONASSOC TOKEN PREC TYPE START UNION
%token    MARK            /* The %% mark. */
%token    LCURL           /* The %{ mark. */
%token    RCURL           /* The %} mark. */
/* 8-bit character literals stand for themselves; */
/* tokens have to be defined for multi-byte characters. */
%start    spec
%%
spec  : defs MARK rules tail
;
tail  : MARK
{
/* In this action, set up the rest of the file. */
}
| /* Empty; the second MARK is optional. */
;
defs  : /* Empty. */
|    defs def
;
def   : START IDENTIFIER
|    UNION
{
/* Copy union definition to output. */
}
|    LCURL
{
/* Copy C code to output file. */
}
RCURL
|    rword tag nlist
;
rword : TOKEN
| LEFT
| RIGHT
| NONASSOC
| TYPE
;
tag   : /* Empty: union tag ID optional. */
| ''
;
nlist : nmno
| nlist nmno
;
nmno  : IDENTIFIER         /* Note: literal invalid with % type. */
| IDENTIFIER NUMBER  /* Note: invalid with % type. */
;
/* Rule section */
rules : C_IDENTIFIER rbody prec
| rules  rule
;
rule  : C_IDENTIFIER rbody prec
| '|' rbody prec
;
rbody : /* empty */
| rbody IDENTIFIER
| rbody act
;
act   : '{'
{
/* Copy action, translate $$, and so on. */
}
'}'
;
prec  : /* Empty */
| PREC IDENTIFIER
| PREC IDENTIFIER act
| prec ';'
;
Conflicts
The parser produced for an input grammar may contain states in which conflicts occur. The conflicts occur because the grammar is
not LALR(1). An ambiguous grammar always contains at least one LALR(1) conflict. The yacc utility shall resolve all
conflicts, using either default rules or user-specified precedence rules.
Conflicts are either shift/reduce conflicts or reduce/reduce conflicts. A shift/reduce conflict is where, for a given state and
lookahead symbol, both a shift action and a reduce action are possible. A reduce/reduce conflict is where, for a given state and
lookahead symbol, reductions by two different rules are possible.
The rules below describe how to specify what actions to take when a conflict occurs. Not all shift/reduce conflicts can be
successfully resolved this way because the conflict may be due to something other than ambiguity, so incautious use of these
facilities can cause the language accepted by the parser to be much different from that which was intended. The description file
shall contain sufficient information to understand the cause of the conflict. Where ambiguity is the reason either the default or
explicit rules should be adequate to produce a working parser.
The declared precedences and associativities (see Declarations Section) are used to resolve
parsing conflicts as follows:
A precedence and associativity is associated with each grammar rule; it is the precedence and associativity of the last token or
literal in the body of the rule. If the %prec keyword is used, it overrides this default. Some grammar rules might not have
both precedence and associativity.
If there is a shift/reduce conflict, and both the grammar rule and the input symbol have precedence and associativity associated
with them, then the conflict is resolved in favor of the action (shift or reduce) associated with the higher precedence. If the
precedences are the same, then the associativity is used; left associative implies reduce, right associative implies shift, and
non-associative implies an error in the string being parsed.
When there is a shift/reduce conflict that cannot be resolved by rule 2, the shift is done. Conflicts resolved this way are
counted in the diagnostic output described in Error Handling.
When there is a reduce/reduce conflict, a reduction is done by the grammar rule that occurs earlier in the input sequence.
Conflicts resolved this way are counted in the diagnostic output described in Error Handling.
Conflicts resolved by precedence or associativity shall not be counted in the shift/reduce and reduce/reduce conflicts reported
by yacc on either standard error or in the description file.
Error Handling
The token error shall be reserved for error handling. The name error can be used in grammar rules. It indicates
places where the parser can recover from a syntax error. The default value of error shall be 256. Its value can be changed
using a %token declaration. The lexical analyzer should not return the value of error.
The parser shall detect a syntax error when it is in a state where the action associated with the lookahead symbol is
error. A semantic action can cause the parser to initiate error handling by executing the macro YYERROR. When YYERROR is
executed, the semantic action passes control back to the parser. YYERROR cannot be used outside of semantic actions.
When the parser detects a syntax error, it normally calls yyerror() with the character string
"syntax error" as its argument. The call shall not be made if the parser is still recovering from a previous error
when the error is detected. The parser is considered to be recovering from a previous error until the parser has shifted over at
least three normal input symbols since the last error was detected or a semantic action has executed the macro yyerrok. The
parser shall not call yyerror() when YYERROR is executed.
The macro function YYRECOVERING shall return 1 if a syntax error has been detected and the parser has not yet fully recovered
from it. Otherwise, zero shall be returned.
When a syntax error is detected by the parser, the parser shall check if a previous syntax error has been detected. If a
previous error was detected, and if no normal input symbols have been shifted since the preceding error was detected, the parser
checks if the lookahead symbol is an endmarker (see Interface to the Lexical Analyzer). If it is,
the parser shall return with a non-zero value. Otherwise, the lookahead symbol shall be discarded and normal parsing shall
resume.
When YYERROR is executed or when the parser detects a syntax error and no previous error has been detected, or at least one
normal input symbol has been shifted since the previous error was detected, the parser shall pop back one state at a time until the
parse stack is empty or the current state allows a shift over error. If the parser empties the parse stack, it shall return
with a non-zero value. Otherwise, it shall shift over error and then resume normal parsing. If the parser reads a lookahead
symbol before the error was detected, that symbol shall still be the lookahead symbol when parsing is resumed.
The macro yyerrok in a semantic action shall cause the parser to act as if it has fully recovered from any previous
errors. The macro yyclearin shall cause the parser to discard the current lookahead token. If the current lookahead token
has not yet been read, yyclearin shall have no effect.
The macro YYACCEPT shall cause the parser to return with the value zero. The macro YYABORT shall cause the parser to return with
a non-zero value.
Interface to the Lexical Analyzer
The application shall ensure that the yylex() function is an integer-valued function that returns a token number
greater than zero representing the kind of token read, or a value less than or equal to zero when the end of input is reached. When
the parser generated by yacc calls yylex(), it shall assign the returned value, if greater than zero, to the external
variable yychar. If there is a value associated with the returned token (see the discussion of tag above), it shall
be assigned to the external variable yylval. If the return value from yylex() is less than or equal to zero, the
parser shall assign the value YYEOF to yychar.
If the parser and yylex() do not agree on these token numbers, reliable communication between them cannot occur. For
(single-byte character) literals, the token is simply the numeric value of the character in the current character set. The numbers
for other tokens can either be chosen by yacc, or chosen by the user. In either case, the #define construct of C is
used to allow yylex() to return these numbers symbolically. The #define statements are put into the code file, and
the header file if that file is requested. The set of characters permitted by yacc in an identifier is larger than that
permitted by C. Token names found to contain such characters shall not be included in the #define declarations.
If the token numbers are chosen by yacc, the tokens other than literals shall be assigned numbers greater than 256,
although no order is implied. A token can be explicitly assigned a number by following its first appearance in the declarations
section with a number. Names and literals not defined this way retain their default definition. All token numbers assigned by
yacc shall be unique and distinct from the token numbers used for literals and user-assigned tokens. If duplicate token
numbers cause conflicts in parser generation, yacc shall report an error; otherwise, it is unspecified whether the token
assignment is accepted or an error is reported.
When a parser action is executed, yychar shall hold either the token number of the lookahead token, or YYEMPTY indicating
that there is no lookahead token, or YYEOF indicating the end of input. If yychar holds the token number of the lookahead
token, yylval shall hold the value associated with that token, if any.
The application shall ensure that when the end of input is reached, the yylex() function returns a value that is zero or
negative. The parser shall treat this as the token number YYEOF for a special token called the endmarker. If the tokens up
to, but excluding, the endmarker form a structure that matches the start symbol, the parser shall accept the input. If the
endmarker is seen in any other context, it shall be considered an error.
Completing the Program
In addition to yyparse() and yylex(), the functions yyerror() and main() are required to make a
complete program. The application can supply main() and yyerror(), or those routines can be obtained from the
yacc library.
Yacc Library
The following functions shall appear only in the yacc library accessible through the -l y operand to c17; they can therefore be redefined by a conforming application:
int main(void)
This function shall call yyparse() and exit with an unspecified value. Other actions within this function are
unspecified.
void yyerror(const char *s)
This function shall write the NUL-terminated argument to standard error, followed by a .
The order of the -l y and -l l operands given to c17 is
significant; the application shall either provide its own main() function or ensure that -l y precedes
-l l.
Debugging the Parser
The parser generated by yacc shall have diagnostic facilities in it that can be optionally enabled at either compile time
or at runtime (if enabled at compile time). The compilation of the runtime debugging code is under the control of YYDEBUG, a
preprocessor symbol. If YYDEBUG has a non-zero value, the debugging code shall be included. If its value is zero, the code shall
not be included.
In parsers where the debugging code has been included, the external int yydebug can be used to turn debugging on
(with a non-zero value) and off (zero value) at runtime. The initial value of yydebug shall be zero.
When -t is specified, the code file shall be built such that, if YYDEBUG is not already defined at compilation time
(using the c17 -D YYDEBUG option, for example), YYDEBUG shall be set explicitly
to 1. When -t is not specified, the code file shall be built such that, if YYDEBUG is not already defined, it shall be set
explicitly to zero.
The format of the debugging output is unspecified but includes at least enough information to determine the shift and reduce
actions, and the input symbols. It also provides information about error recovery.
Algorithms
The parser constructed by yacc implements an LALR(1) parsing algorithm as documented in the literature. It is unspecified
whether the parser is table-driven or direct-coded.
A parser generated by yacc shall never request an input symbol from yylex() while in a state where the only
actions other than the error action are reductions by a single rule.
The literature of parsing theory defines these concepts.
Limits
The yacc utility may have several internal tables. The minimum maximums for these tables are shown in the following
table. The exact meaning of these values is implementation-defined. The implementation shall define the relationship between these
values and between them and any error messages that the implementation may generate should it run out of space for any internal
structure. An implementation may combine groups of these resources into a single pool as long as the total available to the user
does not fall below the sum of the sizes specified by this section.
Table: Internal Limits in yacc
Limit
Minimum Maximum
Description
{NTERMS}
126
Number of tokens.
{NNONTERM}
200
Number of non-terminals.
{NPROD}
300
Number of rules.
{NSTATES}
600
Number of states.
{MEMSIZE}
5200
Length of rules. The total length, in names (tokens and non-terminals), of all the rules of the grammar. The
left-hand side is counted for each rule, even if it is not explicitly repeated, as specified in Grammar
Rules in yacc.
{ACTSIZE}
4000
Number of actions. "Actions" here (and in the description file) refer to parser actions (shift, reduce, and so
on) not to semantic actions defined in Grammar Rules in yacc.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
If any errors are encountered, the run is aborted and yacc exits with a non-zero status. Partial code files and header
files may be produced. The summary information in the description file shall always be produced if the -v flag is
present.
The following sections are informative.
APPLICATION USAGE
Historical implementations experience name conflicts on the names yacc.tmp, yacc.acts, yacc.debug,
y.tab.c, y.tab.h, and y.output if more than one copy of yacc is running in a single directory at one
time. The -b option was added to overcome this problem. The related problem of allowing multiple yacc parsers to be
placed in the same file was addressed by adding a -p option to override the previously hard-coded yy variable
prefix.
The description of the -p option specifies the minimal set of function and variable names that cause
conflict when multiple parsers are linked together. YYSTYPE does not need to be changed. Instead, the programmer can use -b
to give the header files for different parsers different names, and then the file with the yylex() for a given parser can
include the header for that parser. Names such as yyclearerr do not need to be changed because they are used only in the
actions; they do not have linkage. It is possible that an implementation has other names, either internal ones for implementing
things such as yyclearerr, or providing non-standard features that it wants to change with -p.
Unary operators that are the same token as a binary operator in general need their precedence adjusted. This is
handled by the %prec advisory symbol associated with the particular grammar rule defining that unary operator. (See Grammar Rules in yacc.) Applications are not required to use this operator for unary operators, but the
grammars that do not require it are rare.
If yyerror() and yylex() are not defined within %{ and %} in the declarations section
as functions or macros, nor in the programs section as functions, recommended practice is to declare them as functions in a
separate header file and include that file in the declarations section, followed by #define yyerror yyerror and
#define yylex yylex. This lets the separate header file be the definitive API for all code defining or using these
functions.
EXAMPLES
Access to the yacc library is obtained with library search operands to c17. To
use the yacc library main():
c17 y.tab.c -l y
Both the lex library and the yacc library contain main().
To access the yacc main():
c17 y.tab.c lex.yy.c -l y -l l
This ensures that the yacc library is searched first, so that its main() is used.
The historical yacc libraries have contained two simple functions that are normally coded by the application
programmer. These functions are similar to the following code:
#include
int main(void)
{
extern int yyparse();
setlocale(LC_ALL, "");
/* If the following parser is one created by lex, the
application must be careful to ensure that LC_CTYPE
and LC_COLLATE are set to the POSIX locale. */
(void) yyparse();
return (0);
}
#include
void yyerror(const char *msg)
{
(void) fprintf(stderr, "%s\n", msg);
return (0);
}
RATIONALE
The references in Referenced Documents may be helpful in constructing the parser generator. The referenced DeRemer and
Pennello article (along with the works it references) describes a technique to generate parsers that conform to this volume of
POSIX.1-2024. Work in this area continues to be done, so implementors should consult current literature before doing any new
implementations. The original Knuth article is the theoretical basis for this kind of parser, but the tables it generates are
impractically large for reasonable grammars and should not be used. The "equivalent to" wording is intentional to assure that the
best tables that are LALR(1) can be generated.
There has been confusion between the class of grammars, the algorithms needed to generate parsers, and the
algorithms needed to parse the languages. They are all reasonably orthogonal. In particular, a parser generator that accepts the
full range of LR(1) grammars need not generate a table any more complex than one that accepts SLR(1) (a relatively weak class of LR
grammars) for a grammar that happens to be SLR(1). Such an implementation need not recognize the case, either; table compression
can yield the SLR(1) table (or one even smaller than that) without recognizing that the grammar is SLR(1). The speed of an LR(1)
parser for any class is dependent more upon the table representation and compression (or the code generation if a direct parser is
generated) than upon the class of grammar that the table generator handles.
The speed of the parser generator is somewhat dependent upon the class of grammar it handles. However, the original
Knuth article algorithms for constructing LR parsers were judged by its author to be impractically slow at that time. Although full
LR is more complex than LALR(1), as computer speeds and algorithms improve, the difference (in terms of acceptable wall-clock
execution time) is becoming less significant.
Potential authors are cautioned that the referenced DeRemer and Pennello article previously cited identifies a bug
(an over-simplification of the computation of LALR(1) lookahead sets) in some of the LALR(1) algorithm statements that preceded it
to publication. They should take the time to seek out that paper, as well as current relevant work, particularly Aho's.
The -b option was added to provide a portable method for permitting yacc to work on multiple separate
parsers in the same directory. If a directory contains more than one yacc grammar, and both grammars are constructed at the
same time (by, for example, a parallel make program), conflict results. While the
solution is not historical practice, it corrects a known deficiency in historical implementations. Corresponding changes were made
to all sections that referenced the filenames y.tab.c (now "the code file"), y.tab.h (now "the header file"), and
y.output (now "the description file").
The grammar for yacc input is based on System V documentation. The textual description shows there that the
';' is required at the end of the rule. The grammar and the implementation do not require this. (The use of
C_IDENTIFIER causes a reduce to occur in the right place.)
Also, in that implementation, the constructs such as %token can be terminated by a , but
this is not permitted by the grammar. The keywords such as %token can also appear in uppercase, which is again not
discussed. In most places where '%' is used,  can be substituted, and there are alternate spellings for
some of the symbols (for example, %LEFT can be "% can contain any characters except '>', including white space, in the
implementation. However, since the tag must reference an ISO C standard union member, in practice conforming
implementations need to support only the set of characters for ISO C standard identifiers in this context.
Some historical implementations are known to accept actions that are terminated by a period. Historical
implementations often allow '$' in names. A conforming implementation does not need to support either of these
behaviors.
Deciding when to use %prec illustrates the difficulty in specifying the behavior of yacc. There may
be situations in which the grammar is not, strictly speaking, in error, and yet yacc cannot interpret it
unambiguously. The resolution of ambiguities in the grammar can in many instances be resolved by providing additional information,
such as using %type or %union declarations. It is often easier and it usually yields a smaller parser to take this
alternative when it is appropriate.
The size and execution time of a program produced without the runtime debugging code is usually smaller and
slightly faster in historical implementations.
Statistics messages from several historical implementations include the following types of information:
n/512 terminals, n/300 non-terminals
n/600 grammar rules, n/1500 states
n shift/reduce, n reduce/reduce conflicts reported
n/350 working sets used
Memory: states, etc. n/15000, parser n/15000
n/600 distinct lookahead sets
n extra closures
n shift entries, n exceptions
n goto entries
n entries saved by goto default
Optimizer space used: input n/15000, output n/15000
n table entries, n zero
Maximum spread: n, Maximum offset: n
The report of internal tables in the description file is left implementation-defined because all aspects of these
limits are also implementation-defined. Some implementations may use dynamic allocation techniques and have no specific limit
values to report.
The format of the y.output file is not given because specification of the format was not seen to enhance
applications portability. The listing is primarily intended to help human users understand and debug the parser; use of
y.output by a conforming application script would be unusual. Furthermore, implementations have not produced consistent
output and no popular format was apparent. The format selected by the implementation should be human-readable, in addition to the
requirement that it be a text file.
Standard error reports are not specifically described because they are seldom of use to conforming applications and
there was no reason to restrict implementations.
Some implementations recognize "={" as equivalent to '{' because it appears in historical
documentation. This construction was recognized and documented as obsolete as long ago as 1978, in the referenced Yacc: Yet
Another Compiler-Compiler. This volume of POSIX.1-2024 chose to leave it as obsolete and omit it.
Multi-byte characters should be recognized by the lexical analyzer and returned as tokens. They should not be
returned as multi-byte character literals. The token error that is used for error recovery is normally assigned the value
256 in the historical implementation. Thus, the token value 256, which is used in many multi-byte character sets, is not available
for use as the value of a user-defined token.
Earlier versions of this standard did not require the code file created by yacc to contain declarations of
yyerror(), yylex(), and yyparse(). This meant that portable applications that did not define them had to
declare them in the grammar file, to ensure they would not be diagnosed by the compiler as being called without being
declared, but this was not stated in those versions of the standard either. The standard developers decided it was preferable for
yacc to include the declarations in the code file and this is now a requirement. However, the declarations of
yyerror() and yylex() are only visible if a macro of the same name is not defined, which provides application writers
with a way to suppress the declaration if desired (for example, in order to provide their own declaration that would conflict with
the one written by yacc). These functions are not declared in the header file because a macro definition in the declaration
section would not be be able to suppress them there.
Earlier versions of this standard were also silent about a declaration of main(). However, the equivalent
solution was not adopted because a declaration of main() would only be needed if it is called recursively by an application.
Although in theory an application could call the yacc library version of main() from code in a grammar file,
it is questionable why any application (other than a test suite) would do so, in particular because that version of main()
does not accept any arguments and it calls exit()—it does not return—and therefore is
of little use recursively. An application that includes its own definition of main() could call it recursively, but can
reasonably be expected to ensure it does not call main() without previously defining or declaring it. An additional
complication is that main() has multiple different allowed prototypes. The standard developers decided the simplest solution
was to disallow yacc from providing a declaration of main() in the code file.
FUTURE DIRECTIONS
If this utility is directed to create a new directory entry that contains any bytes that have the encoded value of a
character, implementations are encouraged to treat this as an error. A future version of this standard may require
implementations to treat this as an error.
SEE ALSO
c17, lex
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 2.
Issue 5
The FUTURE DIRECTIONS section is added.
Issue 6
This utility is marked as part of the C-Language Development Utilities option.
Minor changes have been added to align with the IEEE P1003.2b draft standard.
The normative text is reworded to avoid use of the term "must" for application requirements.
IEEE PASC Interpretation 1003.2 #177 is applied, changing the comment on RCURL from the }% token to
the %}.
Issue 7
Austin Group Interpretation 1003.1-2001 #190 is applied, clarifying the requirements for generated code to conform to the
ISO C standard.
Austin Group Interpretation 1003.1-2001 #191 is applied, clarifying the handling of C-language trigraphs and curly
brace preprocessing tokens.
SD5-XCU-ERN-6 is applied, clarifying that Guideline 9 of the Utility Syntax Guidelines does not apply.
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0204 [977] is applied.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to disallow the creation of filenames containing any bytes that
have the encoded value of a  character.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
Austin Group Defect 1269 is applied, changing the required contents of the code file (including #define
statements for YYEMPTY and YYEOF) and adding new requirements for the interface to the lexical analyzer.
Austin Group Defect 1388 is applied, changing the requirements relating to declarations of yyerror(),
yylex(), yyparse(), and main().
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/uncompress.html =====
compress
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
compress, uncompress, zcat — compress and decompress data
SYNOPSIS
[XSI]
compress [-fv] [-b value] [-g | -m algo] [file...]
compress -c [-fv] [-b value] [-g | -m algo] [file]
compress -d [-cfv] [file...]
uncompress [-cfv] [file...]
zcat [file...]
DESCRIPTION
The
compress
utility, when the
-d
option is not specified, shall apply the compression algorithm identified
by the
-g
option or the
-m
algo
option to the named files to attempt to reduce their size without loss
of information. The compress utility with the
-d
option shall apply the appropriate decompression algorithm to the
named files to restore the data to their original state.
The
uncompress
utility shall be equivalent to
compress
-d.
The
zcat
utility shall be equivalent to
compress
-c -d.
If multiple
file
operands are specified, the decompressed data from each input file
shall be concatenated to standard output.
When compressing data, unless the
-c
option is specified, after an input file other than standard input has
been compressed, the compressed data from the input file shall be
stored in a file with the same pathname as the input file but with an
added suffix. The added suffix shall be the suffix associated with the
algorithm (see the algorithms in
Compression algorithms, algo option-argument values, and suffixes
).
If appending the suffix would make the size of the last component of
the output file's pathname exceed
{NAME_MAX}
bytes, the command shall fail. If appending the suffix would make the
size of the pathname exceed
{PATH_MAX}
bytes, the command may fail.
When decompressing data, unless the
-c
option is specified, after an input file other than standard input has
been decompressed, the decompressed data from the input file shall be
stored in a file with the same pathname as the input file but with the
suffix associated with the algorithm removed.
[OB]
If
file
has no suffix associated with a known compression algorithm or
file
does not exist and does not have a
.Z
suffix,
file
shall be used as the name of the output file, and the default suffix
.Z
shall be appended to
file
to form the input pathname.
The behavior is unspecified if the input pathname ends with a suffix
other than the suffix associated with the algorithm used to compress
the data. When the
-c
option is specified,
file
can have any suffix, or no suffix, and the utility shall use
file
as the input file and examine the file's contents to determine which
algorithm to use to decompress the data (it is not an error if
file
does not have a suffix that matches the suffix associated with the
compression algorithm).
When compressing or decompressing a file other than standard input and the
-c
option is not specified, if the invoking process has sufficient privilege,
the ownership, modes, access time, and modification time of the output
file shall match the ownership, modes, access time, and modification
time of the input file. After the output file has been successfully
created, the input file shall be removed if the invoking process has
sufficient privileges. If the invoking process does not have sufficient
privileges to remove the input file (for example, if the directory has
the S_ISVTX bit set) the behavior depends on whether the
-f
option is specified: if
-f
is not specified, the output file shall be removed, a diagnostic
message shall be written and the utility shall continue processing
other files but the final exit status shall be non-zero; if
-f
is specified, the output file shall not be removed and it is
unspecified whether the inability to remove the input file is treated
as an error. If it is not treated as an error, a warning message may
be written to standard error
If no
file
operands are specified, standard input shall be compressed or
decompressed to standard output.
[OB]
If an input file that is to be removed after processing has multiple
hard links, the
compress
and
uncompress
utilities may write a diagnostic message to standard error and do
nothing with the file; this behavior may depend on whether the
-f
option is specified. If a diagnostic message is written, the final
exit status shall be non-zero.
OPTIONS
The
compress,
uncompress,
and
zcat
utilities shall conform to XBD
12.2 Utility Syntax Guidelines
,
except that Guideline 1 does not apply to
uncompress
since the utility name has ten letters.
The following options shall be supported:
-b valueIf the compression algorithm is LZW,
value
specifies the maximum number of bits to use in a code. For a
conforming application, the
value
argument shall be:
9 2An error occurred.
The following exit values shall be returned for
uncompress
and
zcat:
0Successful completion.
>0An error occurred.
CONSEQUENCES OF ERRORS
If an error occurs while compressing or decompressing an input file
other than standard input, the input file shall remain unmodified.
The following sections are informative.
APPLICATION USAGE
The amount of compression obtained depends on the size of the input,
the number of bits
per code, and the distribution of common substrings. Typically, text
such as source code or English is reduced by 50-60%. Compression is
generally much better than that achieved by Huffman coding
or adaptive Huffman coding (compact),
and takes less time to compute.
Although
compress
strictly follows the default actions upon receipt of a signal or when
an error occurs, some unexpected results may occur. In some
implementations it is likely that a partially compressed file is left
in place, alongside its uncompressed input file. Since the general
operation of
compress
is to delete the uncompressed file only after the
.Z
file has been successfully filled, an application should always
carefully check the exit status of
compress
before arbitrarily deleting files that have like-named neighbors with
.Z
suffixes.
In addition to trying
file
and
file.Z
when looking for a file to decompress, some implementations of
uncompress
and
zcat
also try suffixes for other known compression algorithms if neither
file
nor
file.Z
is found. This version of the standard allows, but does not require
this behavior. Portable applications should always specify the full
pathname (including the suffix) of files to be decompressed.
EXAMPLES
None.
RATIONALE
Earlier versions of this standard limited the number of bits used by
conforming applications for the
lzw
algorithm to 14 due to address space limitations on 16-bit
architectures. Using 15 or 16 is a much more common default when using
current hardware.
Earlier versions of this standard only supported LZW compression. The
standard developers noted that existing implementations added other
compression utilities, such as
gzip,
and found it desirable to support this widespread usage. Some
implementations had extended the
compress
utility to support such other schemes. The standard developers
generalized this practice by the addition of the
-m
option, even though this was not previous practice.
The
uncompress
-d
option is added to match undocumented existing practice of tested
implementations.
FUTURE DIRECTIONS
If this utility is directed to create a new directory entry that
contains any bytes that have the encoded value of a
character, implementations are encouraged to treat this as an error.
A future version of this standard may require implementations to treat
this as an error.
When decompressing a file, the requirement to add
.Z
to a
file
operand if the given pathname does not include a suffix associated
with a known compression algorithm or if
file
does not exist and does not already have a
.Z
extension is an obsolescent feature and may be removed in a future version.
SEE ALSO
XBD
8. Environment Variables
,
12.2 Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 4.
Issue 6
The normative text is reworded to avoid use of the term "must"
for application requirements.
An error case is added for systems not supporting adaptive Lempel-Ziv
coding.
Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
Austin Group Interpretation 1003.1-2001 #125 is applied, revising
the ENVIRONMENT VARIABLES section.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to
disallow the creation of filenames containing any bytes that have the
encoded value of a
character.
Austin Group Defect 1041 is applied, combining the
compress,
uncompress
and
zcat
pages into one and extensively modifying most sections.
Austin Group Defect 1122 is applied, changing the description of
NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index |
XBD |
XSH |
XCU |
XRAT ]
>>
===== susv5-html/utilities/iconv.html =====
iconv
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
iconv — codeset conversion
SYNOPSIS
iconv [-cs] -f frommap -t tomap
[file...]
iconv -f fromcode [-cs] [-t tocode] [file...]
iconv -t tocode [-cs] [-f fromcode] [file...]
iconv -l
DESCRIPTION
The iconv utility shall convert the encoding of characters in file from one codeset to another and write the
results to standard output.
When the options indicate that charmap files are used to specify the codesets (see OPTIONS), the codeset conversion shall be
accomplished by performing a logical join on the symbolic character names in the two charmaps. The implementation need not support
the use of charmap files for codeset conversion unless the POSIX2_LOCALEDEF symbol is defined on the system.
OPTIONS
The iconv utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following options shall be supported:
-c
Omit any characters that are invalid in the codeset of the input file from the output. When -c is not used, the results
of encountering invalid characters in the input stream (either those that are not characters in the codeset of the input file or
that have no corresponding character in the codeset of the output file) shall be specified in the system documentation. The
presence or absence of -c shall not affect the exit status of iconv.
-f fromcodeset
Identify the codeset of the input file. The implementation shall recognize the following two forms of the fromcodeset
option-argument:
fromcode
The fromcode option-argument can not contain a  character. It shall be interpreted as the name of one of
the codeset descriptions provided by the implementation in an unspecified format. Valid values of fromcode are
implementation-defined.
frommap
The frommap option-argument needs to contain a  character. It shall be interpreted as the pathname of a
charmap file as defined in XBD 6.4 Character Set Description File. If
the pathname does not represent a valid, readable charmap file, the results are undefined.
If this option is omitted, the codeset of the current locale shall be used.
-l
Write all supported fromcode and tocode values to standard output in an unspecified format.
-s
Suppress any messages written to standard error concerning invalid characters. When -s is not used, the results of
encountering invalid characters in the input stream (either those that are not valid characters in the codeset of the input file or
that have no corresponding character in the codeset of the output file) shall be specified in the system documentation. The
presence or absence of -s shall not affect the exit status of iconv.
-t tocodeset
Identify the codeset to be used for the output file. The implementation shall recognize the following two forms of the
tocodeset option-argument:
tocode
The semantics shall be equivalent to the -f fromcode option.
tomap
The semantics shall be equivalent to the -f frommap option.
If this option is omitted, the codeset of the current locale shall be used.
If either -f or -t represents a charmap file, but the other does not (or is omitted), or both -f and
-t are omitted, the results are undefined.
OPERANDS
The following operand shall be supported:
file
A pathname of an input file. If no file operands are specified, or if a file operand is '-', the
standard input shall be used.
STDIN
The standard input shall be used only if no file operands are specified, or if a file operand is '-'.
INPUT FILES
The input file shall be a text file.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of iconv:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments). During translation of the file, this variable is superseded by the use of the
fromcode option-argument.
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
When the -l option is used, the standard output shall contain all supported fromcode and tocode values,
written in an unspecified format.
When the -l option is not used, the standard output shall contain the sequence of characters read from the input files,
translated to the specified codeset. Nothing else shall be written to the standard output.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
The user must ensure that both charmap files use the same symbolic names for characters the two codesets have in common.
EXAMPLES
The following example converts the contents of file mail.x400 from the ISO/IEC 6937:2001 standard codeset to the
ISO/IEC 8859-1:1998 standard codeset, and stores the results in file mail.local:
iconv -f IS6937 -t IS8859 mail.x400 > mail.local
RATIONALE
The iconv utility can be used portably only when the user provides two charmap files as option-arguments. This is because
a single charmap provided by the user cannot reliably be joined with the names in a system-provided character set description. The
valid values for fromcode and tocode are implementation-defined and do not have to have any relation to the charmap
mechanisms. As an aid to interactive users, the -l option was adopted from the Plan 9 operating system. It writes
information concerning these implementation-defined values. The format is unspecified because there are many possible useful
formats that could be chosen, such as a matrix of valid combinations of fromcode and tocode. The -l option is
not intended for shell script usage; conforming applications will have to use charmaps.
The iconv utility may support the conversion between ASCII and EBCDIC-based encodings, but is not required to do so. In
an XSI-compliant implementation, the dd utility is the only method guaranteed to support
conversion between these two character sets.
FUTURE DIRECTIONS
None.
SEE ALSO
dd, gencat
XBD 6.4 Character Set Description File, 8. Environment Variables, 12.2
Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 3.
Issue 6
This utility has been rewritten to align with the IEEE P1003.2b draft standard. Specifically, the ability to use charmap
files for conversion has been added.
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/29 is applied, making changes to address inconsistencies with
the iconv() function in the System Interfaces volume of POSIX.1-2024.
Issue 7
Austin Group Interpretation 1003.1-2001 #206 is applied, correcting the tomap option.
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0094 [291] and XCU/TC1-2008/0095 [291] are applied.
Issue 8
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/ex.html =====
ex
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ex — text editor
SYNOPSIS
[UP]  ex [-rR] [-s|-v] [-c command]
[-t tagstring] [-w size] [file...]
DESCRIPTION
The ex utility is a line-oriented text editor. There are two other modes of the editor—open and visual—in which
screen-oriented editing is available. This is described more fully by the ex open and visual commands and in
vi.
If an operand is '-', the results are unspecified.
This section uses the term edit buffer to describe the current working text. No specific implementation is implied by
this term. All editing changes are performed on the edit buffer, and no changes to it shall affect any file until an editor command
writes the file.
Certain terminals do not have all the capabilities necessary to support the complete ex definition, such as the
full-screen editing commands (visual mode or open mode). When these commands cannot be supported on such terminals,
this condition shall not produce an error message such as "not an editor command" or report a syntax error. The implementation
may either accept the commands and produce results on the screen that are the result of an unsuccessful attempt to meet the
requirements of this volume of POSIX.1-2024 or report an error describing the terminal-related deficiency.
OPTIONS
The ex utility shall conform to XBD 12.2 Utility Syntax
Guidelines, except for the unspecified usage of '-', and that '+' may be recognized as an option
delimiter as well as '-'.
The following options shall be supported:
-c command
Specify an initial command to be executed in the first edit buffer loaded from an existing file (see the EXTENDED DESCRIPTION
section). Implementations may support more than a single -c option. In such implementations, the specified commands shall be
executed in the order specified on the command line.
-r
Recover the named files (see the EXTENDED DESCRIPTION section). Recovery information for a file shall be saved during an editor
or system crash (for example, when the editor is terminated by a signal which the editor can catch), or after the use of an
ex preserve command.
A crash in this context is an unexpected failure of the system or utility that requires restarting the failed system or
utility. A system crash implies that any utilities running at the time also crash. In the case of an editor or system crash, the
number of changes to the edit buffer (since the most recent preserve command) that will be recovered is unspecified.
If no file operands are given and the -t option is not specified, all other options, the EXINIT variable,
and any .exrc files shall be ignored; a list of all recoverable files available to the invoking user shall be written, and
the editor shall exit normally without further action.
-R
Set readonly edit option.
-s
Prepare ex for batch use by taking the following actions:
Suppress writing prompts and informational (but not diagnostic) messages.
Ignore the value of TERM and any implementation default terminal type and assume the terminal is a type incapable of
supporting open or visual modes; see the visual command and the description of vi
.
Suppress the use of the EXINIT environment variable and the reading of any .exrc file; see the EXTENDED
DESCRIPTION section.
Suppress autoindentation, ignoring the value of the autoindent edit option.
-t tagstring
Edit the file containing the specified tagstring; see ctags. The tags
feature represented by -t tagstring and the tag command is optional. It shall be provided on any system that
also provides a conforming implementation of ctags; otherwise, the use of -t
produces undefined results. On any system, it shall be an error to specify more than a single -t option.
-v
Begin in visual mode (see vi).
-w size
Set the value of the window editor option to size.
OPERANDS
The following operand shall be supported:
file
A pathname of a file to be edited.
STDIN
The standard input consists of a series of commands and input text, as described in the EXTENDED DESCRIPTION section. The
implementation may limit each line of standard input to a length of {LINE_MAX}.
If the standard input is not a terminal device, it shall be as if the -s option had been specified.
If a read from the standard input returns an error, or if the editor detects an end-of-file condition from the standard input,
it shall be equivalent to a SIGHUP asynchronous event.
INPUT FILES
Input files shall be text files or files that would be text files except for an incomplete last line that is not longer than
{LINE_MAX}-1 bytes in length and contains no NUL characters. By default, any incomplete last line shall be treated as if it had a
trailing . The editing of other forms of files may optionally be allowed by ex implementations.
The .exrc files and source files shall be text files consisting of ex commands; see the EXTENDED DESCRIPTION
section.
By default, the editor shall read lines from the files to be edited without interpreting any of those lines as any form of
editor command.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of ex:
COLUMNS
Override the system-selected horizontal screen size. See XBD 8. Environment
Variables for valid values and results when it is unset or null.
EXINIT
Determine a list of ex commands that are executed on editor start-up. See the EXTENDED DESCRIPTION section for more
details of the initialization phase.
HOME
Determine a pathname of a directory that shall be searched for an editor start-up file named .exrc; see the EXTENDED
DESCRIPTION section.
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_COLLATE
Determine the locale for the behavior of ranges, equivalence classes, and multi-character collating elements within regular
expressions.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files), the behavior of character classes within regular expressions, the
classification of characters as uppercase or lowercase letters, the case conversion of letters, and the detection of word
boundaries.
LC_MESSAGES
Determine the locale used to process affirmative responses, and the locale that should be used to affect the format and contents of
diagnostic messages written to standard error.
LINES
Override the system-selected vertical screen size, used as the number of lines in a screenful and the vertical screen size in
visual mode. See XBD 8. Environment Variables for valid values and results
when it is unset or null.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
PATH
Determine the search path for the shell command specified in the ex editor commands !, shell, read,
and write, and the open and visual mode command !; see the description of command search and execution in 2.9.1.4 Command Search and Execution.
SHELL
Determine the preferred command line interpreter for use as the default value of the shell edit option.
TERM
Determine the name of the terminal type. If this variable is unset or null, an unspecified default terminal type shall be
used.
ASYNCHRONOUS EVENTS
The following term is used in this and following sections to specify command and asynchronous event actions:
complete write
A complete write is a write of the entire contents of the edit buffer to a file of a type other than a terminal device, or the
saving of the edit buffer caused by the user executing the ex preserve command. Writing the contents of the edit
buffer to a temporary file that will be removed when the editor exits shall not be considered a complete write.
The following actions shall be taken upon receipt of signals:
SIGINT
If the standard input is not a terminal device, ex shall not write the file or return to command or text input mode, and
shall exit with a non-zero exit status.
Otherwise, if executing an open or visual text input mode command, ex in receipt of SIGINT shall behave identically to
its receipt of the  character.
Otherwise:
If executing an ex text input mode command, all input lines that have been completely entered shall be resolved into the
edit buffer, and any partially entered line shall be discarded.
If there is a currently executing command, it shall be aborted and a message displayed. Unless otherwise specified by the
ex or vi command descriptions, it is unspecified whether any lines modified by the
executing command appear modified, or as they were before being modified by the executing command, in the buffer.
If the currently executing command was a motion command, its associated command shall be discarded.
If in open or visual command mode, the terminal shall be alerted.
The editor shall then return to command mode.
SIGCONT
If ex is in open mode or visual mode, the actions described below for SIGWINCH shall be taken, except that the screen
shall always be refreshed (regardless of whether the terminal window size changed).
SIGHUP
If the edit buffer has been modified since the last complete write, ex shall attempt to save the edit buffer so that it
can be recovered later using the -r option or the ex recover command. The editor shall not write the file or
return to command or text input mode, and shall terminate with a non-zero exit status.
SIGTERM
Refer to SIGHUP.
SIGWINCH
If ex is in open mode or visual mode, the current terminal window size associated with the terminal on standard output
shall be obtained, as if by a call to XSH tcgetwinsize(). If the terminal
window size is successfully obtained, it shall be used as follows:
If the COLUMNS environment variable is unset or does not contain a number, the horizontal screen size shall be set to the
number of columns in the obtained terminal window size.
If ex is in visual mode, the -w option was not specified and the LINES environment variable is unset or
does not contain a number, the vertical screen size shall be set to the number of rows in the obtained terminal window size.
If the above resulted in either the vertical screen size or the horizontal screen size (or both) changing to a different value,
ex shall update the values it has for the number of lines and columns in the display and shall adjust the window edit
option and the column number at which the wrapmargin edit option takes effect (if non-zero) accordingly (see Edit Options in ex) and refresh the screen; otherwise, ex may refresh the screen.
The action taken for all other signals is unspecified.
STDOUT
The standard output shall be used only for writing prompts to the user, for informational messages, and for writing lines from
the file.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
The output from ex shall be text files.
EXTENDED DESCRIPTION
Only the ex mode of the editor is described in this section. See vi for
additional editing capabilities available in ex.
When an error occurs, ex shall write a message. If the terminal supports a standout mode (such as inverse video), the
message shall be written in standout mode. If the terminal does not support a standout mode, and the edit option errorbells
is set, an alert action shall precede the error message.
By default, ex shall start in command mode, which shall be indicated by a : prompt; see the prompt command.
Text input mode can be entered by the append, insert, or change commands; it can be exited (and command mode
re-entered) by typing a  ('.') alone at the beginning of a line.
Initialization in ex and vi
The following symbols are used in this and following sections to specify locations in the edit buffer:
alternate and current pathnames
Two pathnames, named current and alternate, are maintained by the editor. Any ex commands that take filenames
as arguments shall set them as follows:
If a file argument is specified to the ex edit, ex, or recover commands, or if an ex
tag command replaces the contents of the edit buffer.
If the command replaces the contents of the edit buffer, the current pathname shall be set to the file argument or the
file indicated by the tag, and the alternate pathname shall be set to the previous value of the current pathname.
Otherwise, the alternate pathname shall be set to the file argument.
If a file argument is specified to the ex next command:
If the command replaces the contents of the edit buffer, the current pathname shall be set to the first file argument,
and the alternate pathname shall be set to the previous value of the current pathname.
If a file argument is specified to the ex file command, the current pathname shall be set to the
file argument, and the alternate pathname shall be set to the previous value of the current pathname.
If a file argument is specified to the ex read and write commands (that is, when reading or writing
a file, and not to the program named by the shell edit option), or a file argument is specified to the ex
xit command:
If the current pathname has no value, the current pathname shall be set to the file argument.
Otherwise, the alternate pathname shall be set to the file argument.
If the alternate pathname is set to the previous value of the current pathname when the current pathname had no previous value,
then the alternate pathname shall have no value as a result.
current line
The line of the edit buffer referenced by the cursor. Each command description specifies the current line after the command has
been executed, as the current line value. When the edit buffer contains no lines, the current line shall be zero; see
Addressing in ex.
current column
The current display line column occupied by the cursor. (The columns shall be numbered beginning at 1.) Each command description
specifies the current column after the command has been executed, as the current column value. This column is an
ideal column that is remembered over the lifetime of the editor. The actual display line column upon which the cursor rests
may be different from the current column; see the cursor positioning discussion in Command Descriptions in vi.
set to non-
A description for a current column value, meaning that the current column shall be set to the last display line column on which is
displayed any part of the first non- of the line. If the line has no non- non- characters,
the current column shall be set to the last display line column on which is displayed any part of the last non-
character in the line. If the line is empty, the current column shall be set to column position 1.
The length of lines in the edit buffer may be limited to {LINE_MAX} bytes. In open and visual mode, the length of lines in the
edit buffer may be limited to the number of characters that will fit in the display. If either limit is exceeded during editing, an
error message shall be written. If either limit is exceeded by a line read in from a file, an error message shall be written and
the edit session may be terminated.
If the editor stops running due to any reason other than a user command, and the edit buffer has been modified since the last
complete write, it shall be equivalent to a SIGHUP asynchronous event. If the system crashes, it shall be equivalent to a SIGHUP
asynchronous event.
During initialization (before the first file is copied into the edit buffer or any user commands from the terminal are
processed) the following shall occur:
If the environment variable EXINIT is set, the editor shall execute the ex commands contained in that
variable.
If the EXINIT variable is not set, and all of the following are true:
The HOME environment variable is not null and not empty.
The file .exrc in the directory referred to by the HOME environment variable:
Exists
Is owned by the same user ID as the real user ID of the process or the process has appropriate privileges
Is not writable by anyone other than the owner
the editor shall execute the ex commands contained in that file.
If and only if all of the following are true:
The current directory is not referred to by the HOME environment variable.
A command in the EXINIT environment variable or a command in the .exrc file in the directory referred to by the
HOME environment variable sets the editor option exrc.
The .exrc file in the current directory:
Exists
Is owned by the same user ID as the real user ID of the process, or by one of a set of implementation-defined user IDs
Is not writable by anyone other than the owner
the editor shall attempt to execute the ex commands contained in that file.
Lines in any .exrc file that are blank lines shall be ignored. If any .exrc file exists, but is not read for
ownership or permission reasons, it shall be an error.
After the EXINIT variable and any .exrc files are processed, the first file specified by the user shall be edited,
as follows:
If the user specified the -t option, the effect shall be as if the ex tag command was entered with the
specified argument, with the exception that if tag processing does not result in a file to edit, the effect shall be as described
in step 3. below.
Otherwise, if the user specified any command line file arguments, the effect shall be as if the ex edit
command was entered with the first of those arguments as its file argument.
Otherwise, the effect shall be as if the ex edit command was entered with a nonexistent filename as its
file argument. It is unspecified whether this action shall set the current pathname. In an implementation where this action
does not set the current pathname, any editor command using the current pathname shall fail until an editor command sets the
current pathname.
If the -r option was specified, the first time a file in the initial argument list or a file specified by the -t
option is edited, if recovery information has previously been saved about it, that information shall be recovered and the editor
shall behave as if the contents of the edit buffer have already been modified. If there are multiple instances of the file to be
recovered, the one most recently saved shall be recovered, and an informational message that there are previous versions of the
file that can be recovered shall be written. If no recovery information about a file is available, an informational message to this
effect shall be written, and the edit shall proceed as usual.
If the -c option was specified, the first time a file that already exists (including a file that might not exist but for
which recovery information is available, when the -r option is specified) replaces or initializes the contents of the edit
buffer, the current line shall be set to the last line of the edit buffer, the current column shall be set to non-,
and the ex commands specified with the -c option shall be executed. In this case, the current line and current column
shall not be set as described for the command associated with the replacement or initialization of the edit buffer contents.
However, if the -t option or a tag command is associated with this action, the -c option commands shall be
executed and then the movement to the tag shall be performed.
The current argument list shall initially be set to the filenames specified by the user on the command line. If no filenames are
specified by the user, the current argument list shall be empty. If the -t option was specified, it is unspecified whether
any filename resulting from tag processing shall be prepended to the current argument list. In the case where the filename is added
as a prefix to the current argument list, the current argument list reference shall be set to that filename. In the case where the
filename is not added as a prefix to the current argument list, the current argument list reference shall logically be located
before the first of the filenames specified on the command line (for example, a subsequent ex next command shall edit
the first filename from the command line). If the -t option was not specified, the current argument list reference shall be
to the first of the filenames on the command line.
Addressing in ex
Addressing in ex relates to the current line and the current column; the address of a line is its 1-based line number,
the address of a column is its 1-based count from the beginning of the line. Generally, the current line is the last line affected
by a command. The current line number is the address of the current line. In each command description, the effect of the command on
the current line number and the current column is described.
Addresses are constructed as follows:
The character '.' (period) shall address the current line.
The character '$' shall address the last line of the edit buffer.
The positive decimal number n shall address the nth line of the edit buffer.
The address "'x" refers to the line marked with the mark name character 'x', which shall be a lowercase letter
from the portable character set, the backquote character, or the single-quote character. It shall be an error if the line that was
marked is not currently present in the edit buffer or the mark has not been set. Lines can be marked with the ex mark
or k commands, or the vi m command.
A regular expression enclosed by  characters ('/') shall address the first line found by searching
forwards from the line following the current line toward the end of the edit buffer and stopping at the first line for which the
line excluding the terminating  matches the regular expression. As stated in Regular
Expressions in ex, an address consisting of a null regular expression delimited by  characters ("//")
shall address the next line for which the line excluding the terminating  matches the last regular expression
encountered. In addition, the second  can be omitted at the end of a command line. If the wrapscan edit option
is set, the search shall wrap around to the beginning of the edit buffer and continue up to and including the current line, so that
the entire edit buffer is searched. Within the regular expression, the sequence "\/" shall represent a literal
instead of the regular expression delimiter.
A regular expression enclosed in  characters ('?') shall address the first line found by searching
backwards from the line preceding the current line toward the beginning of the edit buffer and stopping at the first line for which
the line excluding the terminating  matches the regular expression. An address consisting of a null regular
expression delimited by  characters ("??") shall address the previous line for which the line
excluding the terminating  matches the last regular expression encountered. In addition, the second
can be omitted at the end of a command line. If the wrapscan edit option is set, the search shall wrap
around from the beginning of the edit buffer to the end of the edit buffer and continue up to and including the current line, so
that the entire edit buffer is searched. Within the regular expression, the sequence "\?" shall represent a literal
instead of the RE delimiter.
A  ('+') or a  ('-') followed by a decimal number shall address the
current line plus or minus the number. A '+' or '-' not followed by a decimal number shall address the current
line plus or minus 1.
Addresses can be followed by zero or more address offsets, optionally -separated. Address offsets are constructed
as follows:
A '+' or '-' immediately followed by a decimal number shall add (subtract) the indicated number of lines to
(from) the address. A '+' or '-' not followed by a decimal number shall add (subtract) 1 to (from) the
address.
A decimal number shall add the indicated number of lines to the address.
It shall not be an error for an intermediate address value to be less than zero or greater than the last line in the edit
buffer. It shall be an error for the final address value to be less than zero or greater than the last line in the edit buffer.
Commands take zero, one, or two addresses; see the descriptions of 1addr and 2addr in Command Descriptions in ex. If more than the required number of addresses are provided to a command that
requires zero addresses, it shall be an error. Otherwise, if more than the required number of addresses are provided to a command,
the addresses specified first shall be evaluated and then discarded until the maximum number of valid addresses remain.
Addresses shall be separated from each other by a  (',') or a  (';'). If no
address is specified before or after a  or  separator, it shall be as if the address of the current
line was specified before or after the separator. In the case of a  separator, the current line ('.')
shall be set to the first address, and only then shall the next address be calculated. This feature can be used to determine the
starting line for forwards and backwards searches (see rules 5. and 6.).
A  ('%') shall be equivalent to entering the two addresses "1,$".
Any delimiting  characters between addresses, address separators, or address offsets shall be discarded.
Command Line Parsing in ex
The following symbol is used in this and following sections to describe parsing behavior:
escape
If a character is referred to as "-escaped" or "-V-escaped", it shall mean that the
character acquired or lost a special meaning by virtue of being preceded, respectively, by a  or -V
character. Unless otherwise specified, the escaping character shall be discarded at that time and shall not be further considered
for any purpose.
Command-line parsing shall be done in the following steps. For each step, characters already evaluated shall be ignored; that
is, the phrase "leading character" refers to the next character that has not yet been evaluated.
Leading  characters shall be skipped.
Leading  characters shall be skipped.
If the leading character is a double-quote character, the characters up to and including the next non--escaped
shall be discarded, and any subsequent characters shall be parsed as a separate command.
Leading characters that can be interpreted as addresses shall be evaluated; see Addressing in ex
.
Leading  characters shall be skipped.
If the next character is a  character or a :
If the next character is a :
If ex is in open or visual mode, the current line shall be set to the last address specified, if any.
Otherwise, if the last command was terminated by a  character, no action shall be taken; for example, the
command "||" shall execute two implied commands, not three.
Otherwise, step 6.b. shall apply.
Otherwise, the implied command shall be the print command. The last #, p, and l flags specified to
any ex command shall be remembered and shall apply to this implied command. Executing the ex number,
print, or list command shall set the remembered flags to #, nothing, and l, respectively, plus any
other flags specified for that execution of the number, print, or list command.
If ex is not currently performing a global or v command, and no address or count is specified, the current
line shall be incremented by 1 before the command is executed. If incrementing the current line would result in an address past the
last line in the edit buffer, the command shall fail, and the increment shall not happen.
The  or  character shall be discarded and any subsequent characters shall be parsed as a
separate command.
The command name shall be comprised of the next character (if the character is not alphabetic), or the next character and any
subsequent alphabetic characters (if the character is alphabetic), with the following exceptions:
Commands that consist of any prefix of the characters in the command name delete, followed immediately by any of the
characters 'l', 'p', '+', '-', or '#' shall be interpreted as a delete command,
followed by a , followed by the characters that were not part of the prefix of the delete command. The maximum
number of characters shall be matched to the command name delete; for example, "del" shall not be treated as
"de" followed by the flag l.
Commands that consist of the character 'k', followed by a character that can be used as the name of a mark, shall be
equivalent to the mark command followed by a , followed by the character that followed the 'k'.
Commands that consist of the character 's', followed by characters that could be interpreted as valid options to the
s command, shall be the equivalent of the s command, without any pattern or replacement values, followed by a
, followed by the characters after the 's'.
The command name shall be matched against the possible command names, and a command name that contains a prefix matching the
characters specified by the user shall be the executed command. In the case of commands where the characters specified by the user
could be ambiguous, the executed command shall be as follows:
a
append
n
next
t
t
c
change
p
print
u
undo
ch
change
pr
print
un
undo
e
edit
r
read
v
v
m
move
re
read
w
write
ma
mark
s
s
Implementation extensions with names causing similar ambiguities shall not be checked for a match until all
possible matches for commands specified by POSIX.1-2024 have been checked.
If the command is a ! command, or if the command is a read command followed by zero or more
characters and a !, or if the command is a write command followed by one or more
characters and a !, the rest of the command shall include all characters up to a non--escaped
. The  shall be discarded and any subsequent characters shall be parsed as a separate ex
command.
Otherwise, if the command is an edit, ex, or next command, or a visual command while
in open or visual mode, the next part of the command shall be parsed as follows:
Any '!' character immediately following the command shall be skipped and be part of the command.
Any leading  characters shall be skipped and be part of the command.
If the next character is a '+', characters up to the first non--escaped
or non--escaped  shall be skipped and be part of the command.
The rest of the command shall be determined by the steps specified in paragraph 12.
Otherwise, if the command is a global, open, s, or v command, the next part of the
command shall be parsed as follows:
Any leading  characters shall be skipped and be part of the command.
If the next character is not an alphanumeric, double-quote, , , or
character:
The next character shall be used as a command delimiter.
If the command is a global, open, or v command, characters up to the first
non--escaped , or first non--escaped delimiter character, shall be skipped and be
part of the command.
If the command is an s command, characters up to the first non--escaped ,
or second non--escaped delimiter character, shall be skipped and be part of the command.
If the command is a global or v command, characters up to the first non--escaped
shall be skipped and be part of the command.
Otherwise, the rest of the command shall be determined by the steps specified in paragraph 12.
Otherwise:
If the command was a map, unmap, abbreviate, or unabbreviate command, characters up to
the first non--V-escaped , , or double-quote character shall be skipped and be
part of the command.
Otherwise, characters up to the first non--escaped , , or
double-quote character shall be skipped and be part of the command.
If the command was an append, change, or insert command, and the step 12.b. ended at a
character, any subsequent characters, up to the next non--escaped  shall be
used as input text to the command.
If the command was ended by a double-quote character, all subsequent characters, up to the next
non--escaped , shall be discarded.
The terminating  or  character shall be discarded and any subsequent
characters shall be parsed as a separate ex command.
Command arguments shall be parsed as described by the Synopsis and Description of each individual ex
command. This parsing shall not be -sensitive, except for the ! argument, which has to follow the command name
without intervening  characters, and where it would otherwise be ambiguous. For example, count and flag
arguments need not be -separated because "d22p" is not ambiguous, but file arguments to the ex
next command need to be separated by one or more  characters. Any  in command arguments for the
abbreviate, unabbreviate, map, and unmap commands can be -V-escaped, in which case the
shall not be used as an argument delimiter. Any  in the command argument for any other command can be
-escaped, in which case that  shall not be used as an argument delimiter.
Within command arguments for the abbreviate, unabbreviate, map, and unmap commands, any
character can be -V-escaped. All such escaped characters shall be treated literally and shall have no special
meaning. Within command arguments for all other ex commands that are not regular expressions or replacement strings, any
character that would otherwise have a special meaning can be -escaped. Escaped characters shall be treated
literally, without special meaning as shell expansion characters or '!', '%', and '#' expansion
characters. See Regular Expressions in ex and Replacement Strings in
ex for descriptions of command arguments that are regular expressions or replacement strings.
Non--escaped '%' characters appearing in file arguments to any ex command
shall be replaced by the current pathname; unescaped '#' characters shall be replaced by the alternate pathname. It shall
be an error if '%' or '#' characters appear unescaped in an argument and their corresponding values are not
set.
Non--escaped '!' characters in the arguments to either the ex ! command or
the open and visual mode ! command, or in the arguments to the ex read command, where the first
non- after the command name is a '!' character, or in the arguments to the ex write command
where the command name is followed by one or more  characters and the first non- after the command name
is a '!' character, shall be replaced with the arguments to the last of those three commands as they appeared after all
unescaped '%', '#', and '!' characters were replaced. It shall be an error if '!' characters
appear unescaped in one of these commands and there has been no previous execution of one of these commands.
If an error occurs during the parsing or execution of an ex command:
An informational message to this effect shall be written. Execution of the ex command shall stop, and the
cursor (for example, the current line and column) shall not be further modified.
If the ex command resulted from a map expansion, all characters from that map expansion shall be discarded,
except as otherwise specified by the map command.
Otherwise, if the ex command resulted from the processing of an EXINIT environment variable, a
.exrc file, a :source command, a -c option, or a +command specified to an ex edit,
ex, next, or visual command, no further commands from the source of the commands shall be executed.
Otherwise, if the ex command resulted from the execution of a buffer or a global or v
command, no further commands caused by the execution of the buffer or the global or v command shall be executed.
Otherwise, if the ex command was not terminated by a , all characters up to and including
the next non--escaped  shall be discarded.
Input Editing in ex
The following symbol is used in this and the following sections to specify command actions:
word
In the POSIX locale, a word consists of a maximal sequence of letters, digits, and underscores, delimited at both ends by
characters other than letters, digits, or underscores, or by the beginning or end of a line or the edit buffer.
When accepting input characters from the user, in either ex command mode or ex text input mode,
ex shall enable canonical mode input processing, as defined in the System Interfaces volume of POSIX.1-2024.
If in ex text input mode:
If the number edit option is set, ex shall prompt for input using the line number that would be
assigned to the line if it is entered, in the format specified for the ex number command.
If the autoindent edit option is set, ex shall prompt for input using autoindent characters,
as described by the autoindent edit option. autoindent characters shall follow the line number, if any.
If in ex command mode:
If the prompt edit option is set, input shall be prompted for using a single ':' character;
otherwise, there shall be no prompt.
The input characters in the following sections shall have the following effects on the input line.
Scroll
Synopsis:
eof
See the description of the stty eof character in stty.
If in ex command mode:
If the eof character is the first character entered on the line, the line shall be evaluated as if it contained
two characters: a -D and a .
Otherwise, the eof character shall have no special meaning.
If in ex text input mode:
If the cursor follows an autoindent character, the autoindent characters in the line shall be modified so
that a part of the next text input character is displayed on the first column in the line after the previous shiftwidth edit
option column boundary, and the user shall be prompted again for input for the same line.
Otherwise, if the cursor follows a '0', which follows an autoindent character, and the '0'
was the previous text input character, the '0' and all autoindent characters in the line shall be discarded, and
the user shall be prompted again for input for the same line.
Otherwise, if the cursor follows a '^', which follows an autoindent character, and the '^'
was the previous text input character, the '^' and all autoindent characters in the line shall be discarded, and
the user shall be prompted again for input for the same line. In addition, the autoindent level for the next input line
shall be derived from the same line from which the autoindent level for the current input line was derived.
Otherwise, if there are no autoindent or text input characters in the line, the eof character shall
be discarded.
Otherwise, the eof character shall have no special meaning.
Synopsis:
-J
If in ex command mode:
Cause the command line to be parsed; -J shall be mapped to the  for this
purpose.
If in ex text input mode:
Terminate the current line. If there are no characters other than autoindent characters on the line, all
characters on the line shall be discarded.
Prompt for text input on a new line after the current line. If the autoindent edit option is set, an
appropriate number of autoindent characters shall be added as a prefix to the line as described by the ex
autoindent edit option.
Synopsis:
Allow the entry of a subsequent  or -J as a literal character, removing any special
meaning that it may have to the editor during text input mode. The  character shall be retained and evaluated when
the command line is parsed, or retained and included when the input text becomes part of the edit buffer.
-V
Synopsis:
-V
Allow the entry of any subsequent character as a literal character, removing any special meaning that it may have
to the editor during text input mode. The -V character shall be discarded before the command line is parsed or the
input text becomes part of the edit buffer.
If the "literal next" functionality is performed by the underlying system, it is implementation-defined whether a
character other than -V performs this function.
-W
Synopsis:
-W
Discard the -W, and the word previous to it in the input line, including any
characters following the word and preceding the -W. If the "word erase" functionality is performed by the
underlying system, it is implementation-defined whether a character other than -W performs this function.
Command Descriptions in ex
The following symbols are used in this section to represent command modifiers. Some of these modifiers can be
omitted, in which case the specified defaults shall be used.
1addr
A single line address, given in any of the forms described in Addressing in ex; the default
shall be the current line ('.'), unless otherwise specified.
If the line address is zero, it shall be an error, unless otherwise specified in the following command
descriptions.
If the edit buffer is empty, and the address is specified with a command other than =, append,
insert, open, put, read, or visual, or the address is not zero, it shall be an error.
2addr
Two addresses specifying an inclusive range of lines. If no addresses are specified, the default for 2addr shall be the
current line only (".,."), unless otherwise specified in the following command descriptions. If one address is specified,
2addr shall specify that line only, unless otherwise specified in the following command descriptions.
It shall be an error if the first address is greater than the second address.
If the edit buffer is empty, and the two addresses are specified with a command other than the !,
write, wq, or xit commands, or either address is not zero, it shall be an error.
count
A positive decimal number. If count is specified, it shall be equivalent to specifying an additional address to the
command, unless otherwise specified by the following command descriptions. The additional address shall be equal to the last
address specified to the command (either explicitly or by default) plus count-1.
If this would result in an address greater than the last line of the edit buffer, it shall be corrected to equal
the last line of the edit buffer.
flags
One or more of the characters '+', '-', '#', 'p', or 'l' (ell). The flag
characters can be -separated, and in any order or combination. The characters '#', 'p', and
'l' shall cause lines to be written in the format specified by the print command with the specified flags.
The lines to be written are as follows:
All edit buffer lines written during the execution of the ex &, ~, list,
number, open, print, s, visual, and z commands shall be written as specified by
flags.
After the completion of an ex command with a flag as an argument, the current line shall be written as
specified by flags, unless the current line was the last line written by the command.
The characters '+' and '-' cause the value of the current line after the execution of the
ex command to be adjusted by the offset address as described in Addressing in ex. This
adjustment shall occur before the current line is written as described in 2. above.
The default for flags shall be none.
buffer
One of a number of named areas for holding text. The named buffers are specified by the alphanumeric characters of the POSIX
locale. There shall also be one "unnamed" buffer. When no buffer is specified for editor commands that use a buffer, the unnamed
buffer shall be used. Commands that store text into buffers shall store the text as it was before the command took effect, and
shall store text occurring earlier in the file before text occurring later in the file, regardless of how the text region was
specified. Commands that store text into buffers shall store the text into the unnamed buffer as well as any specified buffer.
In ex commands, buffer names are specified as the name by itself. In open or visual mode commands the name
is preceded by a double-quote ('"' ) character.
If the specified buffer name is an uppercase character, and the buffer contents are to be modified, the buffer
shall be appended to rather than being overwritten. If the buffer is not being modified, specifying the buffer name in lowercase
and uppercase shall have identical results.
There shall also be buffers named by the numbers 1 through 9. In open and visual mode, if a region of text
including characters from more than a single line is being modified by the vi c or
d commands, the motion character associated with the c or d commands specifies that the buffer text shall be
in line mode, or the commands %, `, /, ?, (, ), N, n, {, or }
are used to define a region of text for the c or d commands, the contents of buffers 1 through 8 shall be moved into
the buffer named by the next numerically greater value, the contents of buffer 9 shall be discarded, and the region of text shall
be copied into buffer 1. This shall be in addition to copying the text into a user-specified buffer or unnamed buffer, or both.
Numeric buffers can be specified as a source buffer for open and visual mode commands; however, specifying a numeric buffer as the
write target of an open or visual mode command shall have unspecified results.
The text of each buffer shall have the characteristic of being in either line or character mode. Appending text to
a non-empty buffer shall set the mode to match the characteristic of the text being appended. Appending text to a buffer shall
cause the creation of at least one additional line in the buffer. All text stored into buffers by ex commands shall be in
line mode. The ex commands that use buffers as the source of text specify individually how buffers of different modes are
handled. Each open or visual mode command that uses buffers for any purpose specifies individually the mode of the text stored into
the buffer and how buffers of different modes are handled.
file
Command text used to derive a pathname. The default shall be the current pathname, as defined previously, in which case, if no
current pathname has yet been established it shall be an error, except where specifically noted in the individual command
descriptions that follow. If the command text contains any of the characters '~', '{', '[',
'*', '?', '$', '"', backquote, single-quote, and , it shall be subjected to
the process of "shell expansions", as described below; if more than a single pathname results and the command expects only one,
it shall be an error.
The process of shell expansions in the editor shall be done as follows. The ex utility shall pass two
arguments to the program named by the shell edit option; the first shall be -c, and the second shall be the string
"echo" and the command text as a single argument. The standard output and standard error of that command shall replace the
command text.
!
A character that can be appended to the command name to modify its operation, as detailed in the individual command
descriptions. With the exception of the ex read, write, and ! commands, the '!' character
shall only act as a modifier if there are no  characters between it and the command name.
remembered search direction
The vi commands N and n begin searching in a forwards or backwards
direction in the edit buffer based on a remembered search direction, which is initially unset, and is set by the ex
global, v, s, and tag commands, and the vi / and
? commands.
Abbreviate
Synopsis:
ab[breviate][lhs rhs]
If lhs and rhs are not specified, write the current list of abbreviations and do nothing more.
Implementations may restrict the set of characters accepted in lhs or rhs, except that printable
characters and  characters shall not be restricted. Additional restrictions shall be implementation-defined.
In both lhs and rhs, any character may be escaped with a -V, in which case the
character shall not be used to delimit lhs from rhs, and the escaping -V shall be discarded.
In open and visual text input mode, if a non-word or  character that is not escaped by a
-V character is entered after a word character, a check shall be made for a set of characters matching lhs,
in the text input entered during this command. If it is found, the effect shall be as if rhs was entered instead of
lhs.
The set of characters that are checked is defined as follows:
If there are no characters inserted before the word and non-word or  characters that triggered the
check, the set of characters shall consist of the word character.
If the character inserted before the word and non-word or  characters that triggered the check is a
word character, the set of characters shall consist of the characters inserted immediately before the triggering characters that
are word characters, plus the triggering word character.
If the character inserted before the word and non-word or  characters that triggered the check is not a
word character, the set of characters shall consist of the characters that were inserted before the triggering characters that are
neither  characters nor word characters, plus the triggering word character.
It is unspecified whether the lhs argument entered for the ex abbreviate and
unabbreviate commands is replaced in this fashion. Regardless of whether or not the replacement occurs, the effect of the
command shall be as if the replacement had not occurred.
Current line: Unchanged.
Current column: Unchanged.
Append
Synopsis:
[1addr] a[ppend][!]
Enter ex text input mode; the input text shall be placed after the specified line. If line zero is
specified, the text shall be placed at the beginning of the edit buffer.
This command shall be affected by the number and autoindent edit options; following the command name
with '!' shall cause the autoindent edit option setting to be toggled for the duration of this command only.
Current line: Set to the last input line; if no lines were input, set to the specified line, or to the first
line of the edit buffer if a line of zero was specified, or zero if the edit buffer is empty.
Current column: Set to non-.
Arguments
Synopsis:
ar[gs]
Write the current argument list, with the current argument-list entry, if any, between '[' and
']' characters.
Current line: Unchanged.
Current column: Unchanged.
Change
Synopsis:
[2addr] c[hange][!][count]
Enter ex text input mode; the input text shall replace the specified lines. The specified lines shall be
copied into the unnamed buffer, which shall become a line mode buffer.
This command shall be affected by the number and autoindent edit options; following the command name
with '!' shall cause the autoindent edit option setting to be toggled for the duration of this command only.
Current line: Set to the last input line; if no lines were input, set to the line before the first address,
or to the first line of the edit buffer if there are no lines preceding the first address, or to zero if the edit buffer is
empty.
Current column: Set to non-.
Change Directory
Synopsis:
chd[ir][!][directory]
cd[!][directory]
Change the current working directory to directory.
If no directory argument is specified, and the HOME environment variable is set to a non-null and
non-empty value, directory shall default to the value named in the HOME environment variable. If the HOME
environment variable is empty or is undefined, the default value of directory is implementation-defined.
If no '!' is appended to the command name, and the edit buffer has been modified since the last complete
write, and the current pathname does not begin with a '/', it shall be an error.
Current line: Unchanged.
Current column: Unchanged.
Copy
Synopsis:
[2addr] co[py] 1addr [flags]
[2addr] t 1addr [flags]
Copy the specified lines after the specified destination line; line zero specifies that the lines shall be placed
at the beginning of the edit buffer.
Current line: Set to the last line copied.
Current column: Set to non-.
Delete
Synopsis:
[2addr] d[elete][ buffer][count][flags]
Delete the specified lines into a buffer (defaulting to the unnamed buffer), which shall become a line-mode
buffer.
Flags can immediately follow the command name; see Command Line Parsing in ex.
Current line: Set to the line following the deleted lines, or to the last line in the edit buffer if that
line is past the end of the edit buffer, or to zero if the edit buffer is empty.
Current column: Set to non-.
Edit
Synopsis:
e[dit][!][+command][file]
ex[!][+command][file]
If no '!' is appended to the command name, and the edit buffer has been modified since the last complete
write, it shall be an error.
If file is specified, replace the current contents of the edit buffer with the current contents of
file, and set the current pathname to file. If file is not specified, replace the current contents of the edit
buffer with the current contents of the file named by the current pathname. If for any reason the current contents of the file
cannot be accessed, the edit buffer shall be empty.
The +command option shall be -delimited;  characters within the
+command can be escaped by preceding them with a  character. The +command shall be
interpreted as an ex command immediately after the contents of the edit buffer have been replaced and the current line and
column have been set.
If the edit buffer is empty:
Current line: Set to 0.
Current column: Set to 1.
Otherwise, if executed while in ex command mode or if the +command argument is specified:
Current line: Set to the last line of the edit buffer.
Current column: Set to non-.
Otherwise, if file is omitted or results in the current pathname:
Current line: Set to the first line of the edit buffer.
Current column: Set to non-.
Otherwise, if file is the same as the last file edited, the line and column shall be set as follows; if the
file was previously edited, the line and column may be set as follows:
Current line: Set to the last value held when that file was last edited. If this value is not a valid line
in the new edit buffer, set to the first line of the edit buffer.
Current column: If the current line was set to the last value held when the file was last edited, set to the
last value held when the file was last edited. Otherwise, or if the last value is not a valid column in the new edit buffer, set to
non-.
Otherwise:
Current line: Set to the first line of the edit buffer.
Current column: Set to non-.
File
Synopsis:
f[ile][file]
If a file argument is specified, the alternate pathname shall be set to the current pathname, and the
current pathname shall be set to file.
Write an informational message. If the file has a current pathname, it shall be included in this message;
otherwise, the message shall indicate that there is no current pathname. If the edit buffer contains lines, the current line number
and the number of lines in the edit buffer shall be included in this message; otherwise, the message shall indicate that the edit
buffer is empty. If the edit buffer has been modified since the last complete write, this fact shall be included in this message.
If the readonly edit option is set, this fact shall be included in this message. The message may contain other unspecified
information.
Current line: Unchanged.
Current column: Unchanged.
Global
Synopsis:
[2addr] g[lobal] /pattern/ [commands]
[2addr] v /pattern/ [commands]
The optional '!' character after the global command shall be the same as executing the v
command.
If pattern is empty (for example, "//") or not specified, the last regular expression used in the
editor command shall be used as the pattern. The pattern can be delimited by  characters (shown in the
Synopsis), as well as any non-alphanumeric or non- other than , ,
, or double-quote. Within the pattern, in certain circumstances the delimiter can be used as a literal character;
see Regular Expressions in ex.
If no lines are specified, the lines shall default to the entire file.
The global and v commands are logically two-pass operations. First, mark the lines within the
specified lines for which the line excluding the terminating  matches (global) or does not match (v or
global!) the specified pattern. Second, execute the ex commands given by commands, with the current line
('.') set to each marked line. If an error occurs during this process, or the contents of the edit buffer are replaced
(for example, by the ex :edit command) an error message shall be written and no more commands resulting from the
execution of this command shall be processed.
Multiple ex commands can be specified by entering multiple commands on a single line using a
to delimit them, or one per line, by escaping each  with a .
If no commands are specified:
If in ex command mode, it shall be as if the print command were specified.
Otherwise, no command shall be executed.
For the append, change, and insert commands, the input text shall be included as part of the
command, and the terminating  can be omitted if the command ends the list of commands. The open and
visual commands can be specified as one of the commands, in which case each marked line shall cause the editor to enter open
or visual mode. If open or visual mode is exited using the vi Q command, the
current line shall be set to the next marked line, and open or visual mode reentered, until the list of marked lines is
exhausted.
The global, v, and undo commands cannot be used in commands. Marked lines may be
deleted by commands executed for lines occurring earlier in the file than the marked lines. In this case, no commands shall be
executed for the deleted lines.
If the remembered search direction is not set, the global and v commands shall set it to forward.
The autoprint and autoindent edit options shall be inhibited for the duration of the g or
v command.
Current line: If no commands executed, set to the last marked line. Otherwise, as specified for the executed
ex commands.
Current column: If no commands are executed, set to non-; otherwise, as specified for the
individual ex commands.
Insert
Synopsis:
[1addr] i[nsert][!]
Enter ex text input mode; the input text shall be placed before the specified line. If the line is zero or
1, the text shall be placed at the beginning of the edit buffer.
This command shall be affected by the number and autoindent edit options; following the command name
with '!' shall cause the autoindent edit option setting to be toggled for the duration of this command only.
Current line: Set to the last input line; if no lines were input, set to the line before the specified line,
or to the first line of the edit buffer if there are no lines preceding the specified line, or zero if the edit buffer is
empty.
Current column: Set to non-.
Join
Synopsis:
[2addr] j[oin][!][count][flags]
If count is specified:
If no address was specified, the join command shall behave as if 2addr were the current line and the
current line plus count (.,. + count).
If one address was specified, the join command shall behave as if 2addr were the specified address
and the specified address plus count (addr,addr + count).
If two addresses were specified, the join command shall behave as if an additional address, equal to the
last address plus count -1 (addr1,addr2,addr2 + count -1), was specified.
If this would result in a second address greater than the last line of the edit buffer, it shall be corrected to be
equal to the last line of the edit buffer.
If no count is specified:
If no address was specified, the join command shall behave as if 2addr were the current line and the next
line (.,. +1).
If one address was specified, the join command shall behave as if 2addr were the specified address
and the next line (addr,addr +1).
Join the text from the specified lines together into a single line, which shall replace the specified lines.
If a '!' character is appended to the command name, the join shall be without modification of any
line, independent of the current locale.
Otherwise, in the POSIX locale, set the current line to the first of the specified lines, and then, for each
subsequent line, proceed as follows:
Discard leading  characters from the line to be joined.
If the line to be joined is now empty, delete it, and skip steps 3 through 5.
If the current line ends in a , or the first character of the line to be joined is a ')'
character, join the lines without further modification.
If the last character of the current line is a '.', join the lines with two  characters
between them.
Otherwise, join the lines with a single  between them.
Current line: Set to the first line specified.
Current column: Set to non-.
List
Synopsis:
[2addr] l[ist][count][flags]
This command shall be equivalent to the ex command:
[2addr] p[rint][count] l[flags]
See Print.
Map
Synopsis:
map[!][lhs rhs]
If lhs and rhs are not specified:
If '!' is specified, write the current list of text input mode maps.
Otherwise, write the current list of command mode maps.
Do nothing more.
Implementations may restrict the set of characters accepted in lhs or rhs, except that printable
characters and  characters shall not be restricted. Additional restrictions shall be implementation-defined. In both
lhs and rhs, any character can be escaped with a -V, in which case the character shall not be used to
delimit lhs from rhs, and the escaping -V shall be discarded.
If the character '!' is appended to the map command name, the mapping shall be effective during
open or visual text input mode rather than open or visual command mode. This allows lhs to have two different
map definitions at the same time: one for command mode and one for text input mode.
For command mode mappings:
When the lhs is entered as any part of a vi command in open or visual
mode (but not as part of the arguments to the command), the action shall be as if the corresponding rhs had been entered.
If any character in the command, other than the first, is escaped using a -V character, that
character shall not be part of a match to an lhs.
It is unspecified whether implementations shall support map commands where the lhs is more than a
single character in length, where the first character of the lhs is printable.
If lhs contains more than one character and the first character is '#', followed by a sequence of
digits corresponding to a numbered function key, then when this function key is typed it shall be mapped to rhs. Characters
other than digits following a '#' character also represent the function key named by the characters in the lhs
following the '#' and may be mapped to rhs. It is unspecified how function keys are named or what function keys are
supported.
For text input mode mappings:
When the lhs is entered as any part of text entered in open or visual text input modes, the action shall be as
if the corresponding rhs had been entered.
If any character in the input text is escaped using a -V character, that character shall not be part
of a match to an lhs.
It is unspecified whether the lhs text entered for subsequent map or unmap commands is
replaced with the rhs text for the purposes of the screen display; regardless of whether or not the display appears as if
the corresponding rhs text was entered, the effect of the command shall be as if the lhs text was entered.
If only part of the lhs is entered, it is unspecified how long the editor will wait for additional, possibly
matching characters before treating the already entered characters as not matching the lhs.
The rhs characters shall themselves be subject to remapping, unless otherwise specified by the remap
edit option, except that if the characters in lhs occur as prefix characters in rhs, those characters shall not be
remapped.
On block-mode terminals, the mapping need not occur immediately (for example, it may occur after the terminal
transmits a group of characters to the system), but it shall achieve the same results as if it occurred immediately.
Current line: Unchanged.
Current column: Unchanged.
Mark
Synopsis:
[1addr] ma[rk] character
[1addr] k character
Implementations shall support character values of a single lowercase letter of the POSIX locale and the
backquote and single-quote characters; support of other characters is implementation-defined.
If executing the vi m command, set the specified mark to the
current line and 1-based numbered character referenced by the current column, if any; otherwise, column position 1.
Otherwise, set the specified mark to the specified line and 1-based numbered first non-
non- in the line, if any; otherwise, the last non- in the line, if any; otherwise, column position
1.
The mark shall remain associated with the line until the mark is reset or the line is deleted. If a deleted line is
restored by a subsequent undo command, any marks previously associated with the line, which have not been reset, shall be
restored as well. Any use of a mark not associated with a current line in the edit buffer shall be an error.
The marks ` and ' shall be set as described previously, immediately before the following events occur
in the editor:
The use of '$' as an ex address
The use of a positive decimal number as an ex address
The use of a search command as an ex address
The use of a mark reference as an ex address
The use of the following open and visual mode commands: -], %, (, ), [,
], {, }
The use of the following open and visual mode commands: ', G, H, L, M, z
if the current line will change as a result of the command
The use of the open and visual mode commands: /, ?, N, `, n if the current line
or column will change as a result of the command
The use of the ex mode commands: z, undo, global, v
For rules 1., 2., 3., and 4., the ` and ' marks shall not be set if the ex command is parsed
as specified by rule 6.a. in Command Line Parsing in ex.
For rules 5., 6., and 7., the ` and ' marks shall not be set if the commands are used as motion
commands in open and visual mode.
For rules 1., 2., 3., 4., 5., 6., 7., and 8., the ` and ' marks shall not be set if the command
fails.
The ` and ' marks shall be set as described previously, each time the contents of the edit buffer are
replaced (including the editing of the initial buffer), if in open or visual mode, or if in ex mode and the edit buffer is
not empty, before any commands or movements (including commands or movements specified by the -c or -t options or the
+command argument) are executed on the edit buffer. If in open or visual mode, the marks shall be set as if executing
the vi m command; otherwise, as if executing the ex mark
command.
When changing from ex mode to open or visual mode, if the ` and ' marks are not already set,
the ` and ' marks shall be set as described previously.
Current line: Unchanged.
Current column: Unchanged.
Move
Synopsis:
[2addr] m[ove] 1addr [flags]
Move the specified lines after the specified destination line. A destination of line zero specifies that the lines
shall be placed at the beginning of the edit buffer. It shall be an error if the destination line is within the range of lines to
be moved.
Current line: Set to the last of the moved lines.
Current column: Set to non-.
Synopsis:
n[ext][!][+command][file ...]
If no '!' is appended to the command name, and the edit buffer has been modified since the last complete
write, it shall be an error, unless the file is successfully written as specified by the autowrite option.
If one or more files is specified:
Set the argument list to the specified filenames.
Set the current argument list reference to be the first entry in the argument list.
Set the current pathname to the first filename specified.
Otherwise:
It shall be an error if there are no more filenames in the argument list after the filename currently
referenced.
Set the current pathname and the current argument list reference to the filename after the filename currently
referenced in the argument list.
Replace the contents of the edit buffer with the contents of the file named by the current pathname. If for any
reason the contents of the file cannot be accessed, the edit buffer shall be empty.
This command shall be affected by the autowrite and writeany edit options.
The +command option shall be -delimited;  characters can be escaped by
preceding them with a  character. The +command shall be interpreted as an ex command
immediately after the contents of the edit buffer have been replaced and the current line and column have been set.
Current line: Set as described for the edit command.
Current column: Set as described for the edit command.
Number
Synopsis:
[2addr] nu[mber][count][flags]
[2addr] #[count][flags]
These commands shall be equivalent to the ex command:
[2addr] p[rint][count] #[flags]
See Print.
Open
Synopsis:
[1addr] o[pen] /pattern/ [flags]
This command need not be supported on block-mode terminals or terminals with insufficient capabilities. If standard
input, standard output, or standard error are not terminal devices, the results are unspecified.
Enter open mode.
The trailing delimiter can be omitted from pattern at the end of the command line. If pattern is
empty (for example, "//") or not specified, the last regular expression used in the editor shall be used as the pattern.
The pattern can be delimited by  characters (shown in the Synopsis), as well as any alphanumeric, or non-
other than , , , or double-quote.
Current line: Set to the specified line.
Current column: Set to non-.
Preserve
Synopsis:
pre[serve]
Save the edit buffer in a form that can later be recovered by using the -r option or by using the ex
recover command. After the file has been preserved, a mail message shall be sent to the user. This message shall be readable
by invoking the mailx utility. The message shall contain the name of the file, the
time of preservation, and an ex command that could be used to recover the file. Additional information may be included in
the mail message.
Current line: Unchanged.
Current column: Unchanged.
Print
Synopsis:
[2addr] p[rint][count][flags]
Write the addressed lines. The behavior is unspecified if the number of columns on the display is less than the
number of columns required to write any single character in the lines being written.
Non-printable characters, except for the , shall be written as implementation-defined multi-character
sequences.
If the # flag is specified or the number edit option is set, each line shall be preceded by its line
number in the following format:
"%6dΔΔ",
If the l flag is specified or the list edit option is set:
The characters listed in XBD Escape Sequences and Associated
Actions shall be written as the corresponding escape sequence.
Non-printable characters not in XBD Escape Sequences and
Associated Actions shall be written as one three-digit octal number (with a preceding ) for each byte in
the character (most significant byte first).
The end of each line shall be marked with a '$', and literal '$' characters within the line
shall be written with a preceding .
Long lines shall be folded; the length at which folding occurs is unspecified, but should be appropriate for the
output terminal, considering the number of columns of the terminal.
If a line is folded, and the l flag is not specified and the list edit option is not set, it is
unspecified whether a multi-column character at the folding position is separated; it shall not be discarded.
Current line: Set to the last written line.
Current column: Unchanged if the current line is unchanged; otherwise, set to non-.
Put
Synopsis:
[1addr] pu[t][ buffer]
Append text from the specified buffer (by default, the unnamed buffer) to the specified line; line zero specifies
that the text shall be placed at the beginning of the edit buffer. Each portion of a line in the buffer shall become a new line in
the edit buffer, regardless of the mode of the buffer.
Current line: Set to the last line entered into the edit buffer.
Current column: Set to non-.
Quit
Synopsis:
q[uit][!]
If no '!' is appended to the command name:
If the edit buffer has been modified since the last complete write, it shall be an error.
If there are filenames in the argument list after the filename currently referenced, and the last command was not
a quit, wq, xit, or ZZ (see Exit) command,
it shall be an error.
Otherwise, terminate the editing session.
Read
Synopsis:
[1addr] r[ead][!][file]
If '!' is not the first non- to follow the command name, a copy of the specified file shall
be appended into the edit buffer after the specified line; line zero specifies that the copy shall be placed at the beginning of
the edit buffer. The number of lines and bytes read shall be written. If no file is named, the current pathname shall be the
default. If there is no current pathname, then file shall become the current pathname. If there is no current pathname or
file operand, it shall be an error. Specifying a file that is not of type regular shall have unspecified results.
Otherwise, if file is preceded by '!', the rest of the line after the '!' shall have
'%', '#', and '!' characters expanded as described in Command Line Parsing in
ex.
The ex utility shall then pass two arguments to the program named by the shell edit option; the first shall
be -c and the second shall be the expanded arguments to the read command as a single argument. The standard input of
the program shall be set to the standard input of the ex program when it was invoked. The standard error and standard output
of the program shall be appended into the edit buffer after the specified line.
Each line in the copied file or program output (as delimited by  characters or the end of the file
or output if it is not immediately preceded by a ), shall be a separate line in the edit buffer. Any occurrences of
and  pairs in the output shall be treated as single  characters.
The special meaning of the '!' following the read command can be overridden by escaping it with a
character.
Current line: If no lines are added to the edit buffer, unchanged. Otherwise, if in open or visual mode, set
to the first line entered into the edit buffer. Otherwise, set to the last line entered into the edit buffer.
Current column: Set to non-.
Recover
Synopsis:
rec[over][!] file
If no '!' is appended to the command name, and the edit buffer has been modified since the last complete
write, it shall be an error.
If no file operand is specified, then the current pathname shall be used. If there is no current pathname or
file operand, it shall be an error.
If no recovery information has previously been saved about file, the recover command shall behave
identically to the edit command, and an informational message to this effect shall be written.
Otherwise, set the current pathname to file, and replace the current contents of the edit buffer with the
recovered contents of file. If there are multiple instances of the file to be recovered, the one most recently saved shall
be recovered, and an informational message that there are previous versions of the file that can be recovered shall be written. The
editor shall behave as if the contents of the edit buffer have already been modified.
Current file: Set as described for the edit command.
Current column: Set as described for the edit command.
Rewind
Synopsis:
rew[ind][!]
If no '!' is appended to the command name, and the edit buffer has been modified since the last complete
write, it shall be an error, unless the file is successfully written as specified by the autowrite option.
If the argument list is empty, it shall be an error.
The current argument list reference and the current pathname shall be set to the first filename in the argument
list.
Replace the contents of the edit buffer with the contents of the file named by the current pathname. If for any
reason the contents of the file cannot be accessed, the edit buffer shall be empty.
This command shall be affected by the autowrite and writeany edit options.
Current line: Set as described for the edit command.
Current column: Set as described for the edit command.
Set
Synopsis:
se[t][ option[=[value]] ...][ nooption ...][ option? ...][ all]
When no arguments are specified, write the value of the term edit option and those options whose values have
been changed from the default settings; when the argument all is specified, write all of the option values.
Giving an option name followed by the character '?' shall cause the current value of that option to be
written. The '?' can be separated from the option name by zero or more  characters. The '?' shall be
necessary only for Boolean valued options. Boolean options can be given values by the form set option to turn them on
or set nooption to turn them off; string and numeric options can be assigned by the form set
option=value. Any  characters in strings can be included as is by preceding each  with an
escaping . More than one option can be set or listed by a single set command by specifying multiple arguments,
each separated from the next by one or more  characters. Arguments can appear in any order and shall be processed in
the specified order.
See Edit Options in ex for details about specific options.
Current line: Unchanged.
Current column: Unchanged.
Shell
Synopsis:
sh[ell]
Invoke the program named in the shell edit option with the single argument -i (interactive mode).
Editing shall be resumed when the program exits.
Current line: Unchanged.
Current column: Unchanged.
Source
Synopsis:
so[urce] file
Read and execute ex commands from file. Lines in the file that are blank lines shall be ignored.
Current line: As specified for the individual ex commands.
Current column: As specified for the individual ex commands.
Substitute
Synopsis:
[2addr] s[ubstitute][/pattern/repl/][options][count][flags]
[2addr] &[options][count][flags]
[2addr] ~[options][count][flags]
Replace the first instance of the pattern pattern by the string repl on each specified line. (See
Regular Expressions in ex and Replacement Strings in ex.) Any
non-alphabetic, non- delimiter other than , '|', , or double-quote can be
used instead of '/'. Within the pattern, in certain circumstances the delimiter can be used as a literal character; see
Regular Expressions in ex. Within the replacement, the delimiter shall not terminate the
replacement if it is the second character of an escape sequence (see XBD 9.1
Regular Expression Definitions) and the escaped delimiter shall be treated as that literal character in the replacement
(losing any special meaning it would have had if it was not used as the delimiter and was not escaped). It shall be an error if the
substitution fails on every addressed line.
The trailing delimiter can be omitted from pattern or from repl at the end of the command line. If
both pattern and repl are not specified or are empty (for example, "//"), the last s command shall be
repeated. If only pattern is not specified or is empty, the last regular expression used in the editor shall be used as the
pattern. If only repl is not specified or is empty, the pattern shall be replaced by nothing. If the entire replacement
pattern is '%', the last replacement pattern to an s command shall be used.
Entering a  in repl (which requires an escaping  in ex mode
and an escaping -V in open or vi mode) shall split the line at that point,
creating a new line in the edit buffer. The  shall be discarded.
If options includes the letter 'g' (global), all non-overlapping instances of the pattern in
the line shall be replaced.
If options includes the letter 'c' (confirm), then before each substitution the line shall
be written; the written line shall reflect all previous substitutions. On the following line,  characters shall be
written beneath the characters from the line that are before the pattern to be replaced, and '^' characters written
beneath the characters included in the pattern to be replaced. The ex utility shall then wait for a response from the
user. An affirmative response shall cause the substitution to be done, while any other input shall not make the substitution. An
affirmative response shall consist of a line with the affirmative response (as defined by the current locale) at the beginning of
the line. This line shall be subject to editing in the same way as the ex command line.
If interrupted (see the ASYNCHRONOUS EVENTS section), any modifications confirmed by the user shall be preserved in
the edit buffer after the interrupt.
If the remembered search direction is not set, the s command shall set it to forward.
In the second Synopsis, the & command shall repeat the previous substitution, as if the & command
were replaced by:
s/pattern/repl/
where pattern and repl are as specified in the previous s, &, or ~ command.
In the third Synopsis, the ~ command shall repeat the previous substitution, as if the '~' were
replaced by:
s/pattern/repl/
where pattern shall be the last regular expression specified to the editor, and repl shall be from
the previous substitution (including & and ~) command.
These commands shall be affected by the LC_MESSAGES environment variable.
Current line: Set to the last line in which a substitution occurred, or, unchanged if no substitution
occurred.
Current column: Set to non-.
Suspend
Synopsis:
su[spend][!]
st[op][!]
Allow control to return to the invoking process; ex shall suspend itself as if it had received the SIGTSTP
signal. The suspension shall occur only if job control is enabled in the invoking shell (see the description of set -m).
These commands shall be affected by the autowrite and writeany edit options.
The current susp character (see stty) shall be equivalent to
the suspend command.
Tag
Synopsis:
ta[g][!] tagstring
The results are unspecified if the format of a tags file is not as specified by the ctags utility (see ctags) description.
The tag command shall search for tagstring in the tag files referred to by the tag edit
option, in the order they are specified, until a reference to tagstring is found. Files shall be searched from beginning to
end. If no reference is found, it shall be an error and an error message to this effect shall be written. If the reference is not
found, or if an error occurs while processing a file referred to in the tag edit option, it shall be an error, and an error
message shall be written at the first occurrence of such an error.
Otherwise, if the tags file contained a pattern, the pattern shall be treated as a regular expression used in the
editor; for example, for the purposes of the s command.
If the tagstring is in a file with a different name than the current pathname, set the current pathname to
the name of that file, and replace the contents of the edit buffer with the contents of that file. In this case, if no '!'
is appended to the command name, and the edit buffer has been modified since the last complete write, it shall be an error, unless
the file is successfully written as specified by the autowrite option.
This command shall be affected by the autowrite, tag, taglength, and writeany edit
options.
Current line: If the tags file contained a line number, set to that line number. If the line number is
larger than the last line in the edit buffer, an error message shall be written and the current line shall be set as specified for
the edit command.
If the tags file contained a pattern, set to the first occurrence of the pattern in the file. If no matching
pattern is found, an error message shall be written and the current line shall be set as specified for the edit command.
Current column: If the tags file contained a line-number reference and that line-number was not larger than
the last line in the edit buffer, or if the tags file contained a pattern and that pattern was found, set to non-.
Otherwise, set as specified for the edit command.
Unabbreviate
Synopsis:
una[bbrev] lhs
If lhs is not an entry in the current list of abbreviations (see Abbreviate
), it shall be an error. Otherwise, delete lhs from the list of abbreviations.
Current line: Unchanged.
Current column: Unchanged.
Undo
Synopsis:
u[ndo]
Reverse the changes made by the last command that modified the contents of the edit buffer, including undo.
For this purpose, the global, v, open, and visual commands, and commands resulting from buffer
executions and mapped character expansions, are considered single commands.
If no action that can be undone preceded the undo command, it shall be an error.
If the undo command restores lines that were marked, the mark shall also be restored unless it was reset
subsequent to the deletion of the lines.
Current line:
If lines are added or changed in the file, set to the first line added or changed.
Set to the line before the first line deleted, if it exists.
Set to 1 if the edit buffer is not empty.
Set to zero.
Current column: Set to non-.
Unmap
Synopsis:
unm[ap][!] lhs
If '!' is appended to the command name, and if lhs is not an entry in the list of text input mode
map definitions, it shall be an error. Otherwise, delete lhs from the list of text input mode map definitions.
If no '!' is appended to the command name, and if lhs is not an entry in the list of command mode
map definitions, it shall be an error. Otherwise, delete lhs from the list of command mode map definitions.
Current line: Unchanged.
Current column: Unchanged.
Version
Synopsis:
ve[rsion]
Write a message containing version information for the editor. The format of the message is unspecified.
Current line: Unchanged.
Current column: Unchanged.
Visual
Synopsis:
[1addr] vi[sual][type][count][flags]
If ex is currently in open or visual mode, the Synopsis and behavior of the visual command shall be the same
as the edit command, as specified by Edit.
Otherwise, this command need not be supported on block-mode terminals or terminals with insufficient capabilities.
If standard input, standard output, or standard error are not terminal devices, the results are unspecified.
If count is specified, the value of the window edit option shall be set to count (as described
in window). If the '^' type character was also specified, the window edit option
shall be set before being used by the type character.
Enter visual mode. If type is not specified, it shall be as if a type of '+' was specified.
The type shall cause the following effects:
+
Place the beginning of the specified line at the top of the display.
-
Place the end of the specified line at the bottom of the display.
.
Place the beginning of the specified line in the middle of the display.
^
If the specified line is less than or equal to the value of the window edit option, set the line to 1; otherwise,
decrement the line by the value of the window edit option minus 1. Place the beginning of this line as close to the bottom
of the displayed lines as possible, while still displaying the value of the window edit option number of lines.
Current line: Set to the specified line.
Current column: Set to non-.
Write
Synopsis:
[2addr] w[rite][!][>>][file]
[2addr] w[rite][!][file]
[2addr] wq[!][>>][file]
If no lines are specified, the lines shall default to the entire file.
The command wq shall be equivalent to a write command followed by a quit command; wq!
shall be equivalent to write! followed by quit. In both cases, if the write command fails, the quit
shall not be attempted.
If the command name is not followed by one or more  characters, or file is not preceded by a
'!' character, the write shall be to a file.
If the >> argument is specified, and the file already exists, the lines shall be appended to the file
instead of replacing its contents. If the >> argument is specified, and the file does not already exist, it is
unspecified whether the write shall proceed as if the >> argument had not been specified or if the write shall
fail.
If the readonly edit option is set (see readonly), the write shall
fail.
If file is specified, and is not the current pathname, and the file exists, the write shall
fail.
If file is not specified, the current pathname shall be used. If there is no current pathname, the
write command shall fail.
If the current pathname is used, and the current pathname has been changed by the file or read
commands, and the file exists, the write shall fail. If the write is successful, subsequent writes shall not
fail for this reason (unless the current pathname is changed again).
If the whole edit buffer is not being written, and the file to be written exists, the write shall
fail.
For rules 1., 2., 3., and 5., the write can be forced by appending the character '!' to the command
name.
For rules 2., 3., and 5., the write can be forced by setting the writeany edit option.
Additional, implementation-defined tests may cause the write to fail.
If the edit buffer is empty, a file without any contents shall be written.
An informational message shall be written noting the number of lines and bytes written.
Otherwise, if the command is followed by one or more  characters, and the file is preceded by
'!', the rest of the line after the '!' shall have '%', '#', and '!' characters
expanded as described in Command Line Parsing in ex.
The ex utility shall then pass two arguments to the program named by the shell edit option; the first
shall be -c and the second shall be the expanded arguments to the write command as a single argument. The specified
lines shall be written to the standard input of the command. The standard error and standard output of the program, if any, shall
be written as described for the print command. If the last character in that output is not a , a
shall be written at the end of the output.
The special meaning of the '!' following the write command can be overridden by escaping it with a
character.
Current line: Unchanged.
Current column: Unchanged.
Write and Exit
Synopsis:
[2addr] x[it][!][file]
If the edit buffer has not been modified since the last complete write, xit shall be equivalent to
the quit command, or if a '!' is appended to the command name, to quit!.
Otherwise, xit shall be equivalent to the wq command, or if a '!' is appended to the command
name, to wq!.
Current line: Unchanged.
Current column: Unchanged.
Yank
Synopsis:
[2addr] ya[nk][ buffer][count]
Copy the specified lines to the specified buffer (by default, the unnamed buffer), which shall become a line-mode
buffer.
Current line: Unchanged.
Current column: Unchanged.
Adjust Window
Synopsis:
[1addr] z[!][type ...][count][flags]
If no line is specified, the current line shall be the default; if type is omitted as well, the current line
value shall first be incremented by 1. If incrementing the current line would cause it to be greater than the last line in the edit
buffer, it shall be an error.
If there are  characters between the type argument and the preceding z command name or
optional '!' character, it shall be an error.
If count is specified, the value of the window edit option shall be set to count (as described
in window). If count is omitted, it shall default to 2 times the value of the scroll
edit option, or if ! was specified, the number of lines in the display minus 1.
If type is omitted, then count lines starting with the specified line shall be written. Otherwise,
count lines starting with the line specified by the type argument shall be written.
The type argument shall change the lines to be written. The possible values of type are as
follows:
-
The specified line shall be decremented by the following value:
(((number of '-' characters) x count) -1)
If the calculation would result in a number less than 1, it shall be an error. Write lines from the edit buffer,
starting at the new value of line, until count lines or the last line in the edit buffer has been written.
+
The specified line shall be incremented by the following value:
(((number of '+' characters) -1) x count) +1
If the calculation would result in a number greater than the last line in the edit buffer, it shall be an error.
Write lines from the edit buffer, starting at the new value of line, until count lines or the last line in the edit buffer
has been written.
=,.
If more than a single '.' or '=' is specified, it shall be an error. The following steps shall be taken:
If count is zero, nothing shall be written.
Write as many of the N lines before the current line in the edit buffer as exist. If count or
'!' was specified, N shall be:
(count -1) /2
Otherwise, N shall be:
(count -3) /2
If N is a number less than 3, no lines shall be written.
If '=' was specified as the type character, write a line consisting of the smaller of the number of
columns in the display divided by two, or 40 '-' characters.
Write the current line.
Repeat step 3.
Write as many of the N lines after the current line in the edit buffer as exist. N shall be defined
as in step 2. If N is a number less than 3, no lines shall be written. If count is less than 3, no lines shall be
written.
^
The specified line shall be decremented by the following value:
(((number of '^' characters) +1) x count) -1
If the calculation would result in a number less than 1, it shall be an error. Write lines from the edit buffer,
starting at the new value of line, until count lines or the last line in the edit buffer has been written.
Current line: Set to the last line written, unless the type is =, in which case, set to the specified
line.
Current column: Set to non-.
Escape
Synopsis:
!command
[2addr] !command
The contents of the line after the '!' shall have '%', '#', and '!' characters
expanded as described in Command Line Parsing in ex. If the expansion causes the text of the line
to change, it shall be redisplayed, preceded by a single '!' character.
The ex utility shall execute the program named by the shell edit option. It shall pass two arguments
to the program; the first shall be -c, and the second shall be the expanded arguments to the ! command as a single
argument.
If no lines are specified, the standard input, standard output, and standard error of the program shall be set to
the standard input, standard output, and standard error of the ex program when it was invoked. In addition, a warning
message shall be written if the edit buffer has been modified since the last complete write, and the warn edit option is
set.
If lines are specified, they shall be passed to the program as standard input, and the standard output and standard
error of the program shall replace those lines in the edit buffer. Each line in the program output (as delimited by
characters or the end of the output if it is not immediately preceded by a ), shall be a separate line in the edit
buffer. Any occurrences of  and  pairs in the output shall be treated as single
characters. The specified lines shall be copied into the unnamed buffer before they are replaced, and the unnamed
buffer shall become a line-mode buffer.
If in ex mode, a single '!' character shall be written when the program completes.
This command shall be affected by the shell and warn edit options. If no lines are specified, this
command shall be affected by the autowrite and writeany edit options. If lines are specified, this command shall be
affected by the autoprint edit option.
Current line:
If no lines are specified, unchanged.
Otherwise, set to the last line read in, if any lines are read in.
Otherwise, set to the line before the first line of the lines specified, if that line exists.
Otherwise, set to the first line of the edit buffer if the edit buffer is not empty.
Otherwise, set to zero.
Current column: If no lines are specified, unchanged. Otherwise, set to non-.
Shift Left
Synopsis:
[2addr]  characters shall be
deleted or changed into other  characters in shifting; other characters shall not be affected.
Lines to be shifted shall be copied into the unnamed buffer, which shall become a line-mode buffer.
This command shall be affected by the autoprint edit option.
Current line: Set to the last line in the lines specified.
Current column: Set to non-.
Shift Right
Synopsis:
[2addr] >[> ...][count][flags]
Shift the specified lines away from the start of the line; the number of column positions to be shifted shall be
the number of command characters times the value of the shiftwidth edit option. The shift shall be accomplished by adding
characters as a prefix to the line or changing leading  characters into other  characters.
Empty lines shall not be changed.
Lines to be shifted shall be copied into the unnamed buffer, which shall become a line-mode buffer.
This command shall be affected by the autoprint edit option.
Current line: Set to the last line in the lines specified.
Current column: Set to non-.
-D
Synopsis:
-D
Write the next n lines, where n is the minimum of the values of the scroll edit option and the
number of lines after the current line in the edit buffer. If the current line is the last line of the edit buffer it shall be an
error.
Current line: Set to the last line written.
Current column: Set to non-.
Write Line Number
Synopsis:
[1addr] = [flags]
If line is not specified, it shall default to the last line in the edit buffer. Write the line number of the
specified line.
Current line: Unchanged.
Current column: Unchanged.
Execute
Synopsis:
[2addr] @ buffer
[2addr] * buffer
If no buffer is specified or is specified as '@' or '*', the last buffer executed shall be used.
If no previous buffer has been executed, it shall be an error.
For each line specified by the addresses, set the current line ('.') to the specified line, and execute
the contents of the named buffer (as they were at the time the @ command was executed) as ex commands. For
each line of a line-mode buffer, and all but the last line of a character-mode buffer, the ex command parser shall behave as
if the line was terminated by a .
If an error occurs during this process, or a line specified by the addresses does not exist when the current line
would be set to it, or more than a single line was specified by the addresses, and the contents of the edit buffer are replaced
(for example, by the ex :edit command) an error message shall be written, and no more commands resulting from the
execution of this command shall be processed.
Current line: As specified for the individual ex commands.
Current column: As specified for the individual ex commands.
Regular Expressions in ex
The ex utility shall support regular expressions that are a superset of the basic regular expressions
described in XBD 9.3 Basic Regular Expressions. A null regular
expression ("//") shall be equivalent to the last regular expression encountered.
Regular expressions can be used in addresses to specify lines and, in some commands (for example, the
substitute command), to specify portions of a line to be substituted.
The start and end of a regular expression (RE) are marked by a delimiter character (although in some circumstances
the end delimiter can be omitted). In addresses, the delimiter is either  or . In commands, other
characters can be used as the delimiter, as specified in the description of the command. Within the RE (as an ex extension
to the BRE syntax), the delimiter shall not terminate the RE if it is the second character of an escape sequence (see XBD 9.1 Regular Expression Definitions) and the escaped delimiter shall be treated
as that literal character in the RE (losing any special meaning it would have had if it was not used as the delimiter and was not
escaped). In addition, the delimiter character shall not terminate the RE when it appears within a bracket expression, and shall
have its normal meaning in the bracket expression. For example, the command "g%[%]%p" is equivalent to "g/[%]/p",
and the command "s-[0-9]--g" is equivalent to "s/[0-9]//g".
The following constructs can be used to enhance the basic regular expressions:
\
Match the end of a word.
~
Match the replacement part of the last substitute command. The  ('~') character can be escaped in
a regular expression to become a normal character with no special meaning. The  shall be discarded.
When the editor option magic is not set, the only characters with special meanings shall be '^' at
the beginning of a pattern, '$' at the end of a pattern, and . The characters '.', '*',
'[', and '~' shall be treated as ordinary characters unless preceded by a ; when preceded by a
they shall regain their special meaning, or in the case of , be handled as a single
.  characters used to escape other characters shall be discarded.
Replacement Strings in ex
Certain characters and strings have special meaning in replacement strings when the character, or the first
character of the string, is unescaped.
The character '&' ('\&' if the editor option magic is not set) in the replacement
string shall stand for the text matched by the pattern to be replaced. The character '~' ('\~' if magic is
not set) shall be replaced by the replacement part of the previous substitute command. The sequence '\n', where
n is an integer, shall be replaced by the text matched by the corresponding back-reference expression. If the corresponding
back-reference expression does not match, then the characters '\n' shall be replaced by the empty string.
The strings '\l', '\u', '\L', and '\U' can be used to modify the case of
elements in the replacement string (using the '\&' or "\"digit) notation. The string '\l'
('\u') shall cause the character that follows to be converted to lowercase (uppercase). The string '\L'
('\U') shall cause all characters subsequent to it to be converted to lowercase (uppercase) as they are inserted by the
substitution until the string '\e' or '\E', or the end of the replacement string, is encountered.
Otherwise, any character following an unescaped  shall be treated as that literal character, and
the escaping  shall be discarded.
An example of case conversion with the s command is as follows:
:p
The cat sat on the mat.
:s/\/\u&/gp
The Cat Sat on the Mat.
:s/S\(.*\)M/S\U\1\eM/p
The Cat SAT ON THE Mat.
Edit Options in ex
The ex utility has a number of options that modify its behavior. These options have default settings, which
can be changed using the set command.
Options are Boolean unless otherwise specified.
autoindent, ai
[Default unset]
If autoindent is set, each line in input mode shall be indented (using first as many  characters
as possible, as determined by the editor option tabstop, and then using  characters) to align with another
line, as follows:
If in open or visual mode and the text input is part of a line-oriented command (see the EXTENDED DESCRIPTION in
vi), align to the first column.
Otherwise, if in open or visual mode, indentation for each line shall be set as follows:
If a line was previously inserted as part of this command, it shall be set to the indentation of the last inserted
line by default, or as otherwise specified for the -D character in Input Mode Commands in vi.
Otherwise, it shall be set to the indentation of the previous current line, if any; otherwise, to the first
column.
For the ex a, i, and c commands, indentation for each line shall be set as follows:
If a line was previously inserted as part of this command, it shall be set to the indentation of the last inserted
line by default, or as otherwise specified for the eof character in Scroll.
Otherwise, if the command is the ex a command, it shall be set to the line appended after, if any;
otherwise to the first column.
Otherwise, if the command is the ex i command, it shall be set to the line inserted before, if any;
otherwise to the first column.
Otherwise, if the command is the ex c command, it shall be set to the indentation of the line
replaced.
autoprint, ap
[Default set]
If autoprint is set, the current line shall be written after each ex command that modifies the
contents of the current edit buffer, and after each tag command for which the tag search pattern was found or tag line
number was valid, unless:
The command was executed while in open or visual mode.
The command was executed as part of a global or v command or @ buffer execution.
The command was the form of the read command that reads a file into the edit buffer.
The command was the append, change, or insert command.
The command was not terminated by a .
The current line shall be written by a flag specified to the command; for example, delete # shall write the
current line as specified for the flag modifier to the delete command, and not as specified by the autoprint edit
option.
autowrite, aw
[Default unset]
If autowrite is set, and the edit buffer has been modified since it was last completely written to any file,
the contents of the edit buffer shall be written as if the ex write command had been specified without arguments,
before each command affected by the autowrite edit option is executed. Appending the character '!' to the command
name of any of the ex commands except '!' shall prevent the write. If the write fails, it shall be an error and the
command shall not be executed.
beautify, bf
[XSI]  [Default unset]
If beautify is set, all non-printable characters, other than , , and
characters, shall be discarded from text read in from files.
directory, dir
[Default implementation-defined]
The value of this option specifies the directory in which the editor buffer is to be placed. If this directory is
not writable by the user, the editor shall quit.
edcompatible, ed
[Default unset]
Causes the presence of g and c suffixes on substitute commands to be remembered, and toggled by
repeating the suffixes.
errorbells, eb
[Default unset]
If the editor is in ex mode, and the terminal does not support a standout mode (such as inverse video), and
errorbells is set, error messages shall be preceded by alerting the terminal.
exrc
[Default unset]
If exrc is set, ex shall access any .exrc file in the current directory, as described in
Initialization in ex and vi. If exrc is not set, ex shall ignore any .exrc
file in the current directory during initialization, unless the current directory is that named by the HOME environment
variable.
ignorecase, ic
[Default unset]
If ignorecase is set, characters that have uppercase and lowercase representations shall have those
representations considered as equivalent for purposes of regular expression comparison.
The ignorecase edit option shall affect all remembered regular expressions; for example, unsetting the
ignorecase edit option shall cause a subsequent vi n command to search for
the last basic regular expression in a case-sensitive fashion.
list
[Default unset]
If list is set, edit buffer lines written while in ex command mode shall be written as specified for
the print command with the l flag specified. In open or visual mode, each edit buffer line shall be displayed as
specified for the ex print command with the l flag specified. In open or visual text input mode, when the
cursor does not rest on any character in the line, it shall rest on the '$' marking the end of the line.
magic
[Default set]
If magic is set, modify the interpretation of characters in regular expressions and substitution replacement
strings (see Regular Expressions in ex and Replacement Strings in ex
).
mesg
[Default set]
If mesg is set, the permission for others to use the write or talk commands to write to the
terminal shall be turned on while in open or visual mode. The shell-level command mesg
n shall take precedence over any setting of the ex mesg option; that is, if mesg y was issued before
the editor started (or in a shell escape), such as:
:!mesg y
the mesg option in ex shall suppress incoming messages, but the mesg option shall not enable
incoming messages if mesg n was issued.
number, nu
[Default unset]
If number is set, edit buffer lines written while in ex command mode shall be written with line
numbers, in the format specified by the print command with the # flag specified. In ex text input mode, each
line shall be preceded by the line number it will have in the file.
In open or visual mode, each edit buffer line shall be displayed with a preceding line number, in the format
specified by the ex print command with the # flag specified. This line number shall not be considered part of
the line for the purposes of evaluating the current column; that is, column position 1 shall be the first column position after the
format specified by the print command.
paragraphs, para
[Default in the POSIX locale IPLPPPQPP LIpplpipbp]
The paragraphs edit option shall define additional paragraph boundaries for the open and visual mode
commands. The paragraphs edit option can be set to a character string consisting of zero or more character pairs. It shall
be an error to set it to an odd number of characters.
prompt
[Default set]
If prompt is set, ex command mode input shall be prompted for with a  (':');
when unset, no prompt shall be written.
readonly
[Default see text]
If the readonly edit option is set, read-only mode shall be enabled (see Write). The readonly edit option shall be initialized to set if either of the following conditions
are true:
The command-line option -R was specified.
Performing actions equivalent to the access() function called with
the following arguments indicates that the file lacks write permission:
The current pathname is used as the path argument.
The constant W_OK is used as the amode argument.
The readonly edit option may be initialized to set for other, implementation-defined reasons. The
readonly edit option shall not be initialized to unset based on any special privileges of the user or process. The
readonly edit option shall be reinitialized each time that the contents of the edit buffer are replaced (for example, by an
edit or next command) unless the user has explicitly set it, in which case it shall remain set until the user
explicitly unsets it. Once unset, it shall again be reinitialized each time that the contents of the edit buffer are replaced.
redraw
[Default unset]
If redraw is set and the terminal is a type incapable of supporting open or visual modes, the editor shall
redraw the screen when necessary in order to update its contents. (Since this is likely to require a large amount of output to the
terminal, it is useful only at high transmission speeds.)
remap
[Default set]
If remap is set, map translation shall allow for maps defined in terms of other maps; translation shall
continue until a final product is obtained. If unset, only a one-step translation shall be done.
report
[Default 5]
The value of this report edit option specifies what number of lines being added, copied, deleted, or
modified in the edit buffer will cause an informational message to be written to the user. The following conditions shall cause an
informational message. The message shall contain the number of lines added, copied, deleted, or modified, but is otherwise
unspecified.
An ex or vi editor command, other than open, undo,
or visual, that modifies at least the value of the report edit option number of lines, and which is not part of an
ex global or v command, or ex or vi buffer execution, shall
cause an informational message to be written.
An ex yank or vi y or Y command, that copies
at least the value of the report edit option plus 1 number of lines, and which is not part of an ex global or
v command, or ex or vi buffer execution, shall cause an informational
message to be written.
An ex global, v, open, undo, or visual command or ex or vi buffer execution, that adds or deletes a total of at least the value of the report edit
option number of lines, and which is not part of an ex global or v command, or ex or vi buffer execution, shall cause an informational message to be written. (For example, if 3 lines
were added and 8 lines deleted during an ex visual command, 5 would be the number compared against the report
edit option after the command completed.)
scroll, scr
[Default (number of lines in the display -1)/2]
The value of the scroll edit option shall determine the number of lines scrolled by the ex
-D and z commands. For the vi -D and
-U commands, it shall be the initial number of lines to scroll when no previous -D or
-U command has been executed.
sections
[Default in the POSIX locale NHSHH HUnhsh]
The sections edit option shall define additional section boundaries for the open and visual mode commands.
The sections edit option can be set to a character string consisting of zero or more character pairs; it shall be an error
to set it to an odd number of characters.
shell, sh
[Default from the environment variable SHELL ]
The value of this option shall be a string. The default shall be taken from the SHELL environment variable.
If the SHELL environment variable is null or empty, the sh (see sh) utility shall be the default.
shiftwidth, sw
[Default 8]
The value of this option shall give the width in columns of an indentation level used during autoindentation and by
the shift commands ().
showmatch, sm
[Default unset]
The functionality described for the showmatch edit option need not be supported on block-mode terminals or
terminals with insufficient capabilities.
If showmatch is set, in open or visual mode, when a ')' or '}' is typed, if the matching
'(' or '{' is currently visible on the display, the matching '(' or '{' shall be flagged moving
the cursor to its location for an unspecified amount of time.
showmode
[Default unset]
If showmode is set, in open or visual mode, the current mode that the editor is in shall be displayed on the
last line of the display. Command mode and text input mode shall be differentiated; other unspecified modes and
implementation-defined information may be displayed.
slowopen
[Default unset]
If slowopen is set during open and visual text input modes, the editor shall not update portions of the
display other than those display line columns that display the characters entered by the user (see Input Mode Commands in vi).
tabstop, ts
[Default 8]
The value of this edit option shall specify the column boundary used by a  in the display (see autoprint, ap and Input Mode Commands in vi
).
taglength, tl
[Default zero]
The value of this edit option shall specify the maximum number of characters that are considered significant in the
user-specified tag name and in the tag name from the tags file. If the value is zero, all characters in both tag names shall be
significant.
tags
[Default see text]
The value of this edit option shall be a string of -delimited pathnames of files used by the
tag command. The default value is unspecified.
term
[Default from the environment variable TERM ]
The value of this edit option shall be a string. The default shall be taken from the TERM variable in the
environment. If the TERM environment variable is empty or null, the default is unspecified. The editor shall use the value
of this edit option to determine the type of the display device.
The results are unspecified if the user changes the value of the term edit option after editor initialization.
terse
[Default unset]
If terse is set, error messages may be less verbose. However, except for this caveat, error messages are
unspecified. Furthermore, not all error messages need change for different settings of this option.
warn
[Default set]
If warn is set, and the contents of the edit buffer have been modified since they were last completely
written, the editor shall write a warning message before certain ! commands (see Escape
).
window
[Default see text]
A value used in open and visual mode, by the -B and -F commands, and, in visual mode,
to specify the number of lines displayed when the screen is repainted.
If the -w command-line option is not specified, the default value shall be set to the value of the
LINES environment variable. If the LINES environment variable is empty or null, the default shall be the number of
lines in the display minus 1.
Setting the window edit option to zero or to a value greater than the number of lines in the display minus 1
(either explicitly or based on the -w option or the LINES environment variable) shall cause the window edit
option to be set to the number of lines in the display minus 1.
The baud rate of the terminal line may change the default in an implementation-defined manner.
wrapmargin, wm
[Default 0]
If the value of this edit option is zero, it shall have no effect.
If not in the POSIX locale, the effect of this edit option is implementation-defined.
Otherwise, it shall specify a number of columns from the ending margin of the terminal.
During open and visual text input modes, for each character for which any part of the character is displayed in a
column that is less than wrapmargin columns from the ending margin of the display line, the editor shall behave as
follows:
If the character triggering this event is a , it, and all immediately preceding
characters on the current line entered during the execution of the current text input command, shall be discarded, and the editor
shall behave as if the user had entered a single  instead. In addition, if the next user-entered character is a
, it shall be discarded as well.
Otherwise, if there are one or more  characters on the current line immediately preceding the last
group of inserted non- characters which was entered during the execution of the current text input command, the
characters shall be replaced as if the user had entered a single  instead.
If the autoindent edit option is set, and the events described in 1. or 2. are performed, any
characters at or after the cursor in the current line shall be discarded.
The ending margin shall be determined by the system or overridden by the user, as described for COLUMNS in
the ENVIRONMENT VARIABLES section and XBD 8. Environment Variables.
wrapscan, ws
[Default set]
If wrapscan is set, searches (the ex / or ? addresses, or open and visual mode
/, ?, N, and n commands) shall wrap around the beginning or end of the edit buffer; when unset,
searches shall stop at the beginning or end of the edit buffer.
writeany, wa
[Default unset]
If writeany is set, some of the checks performed when executing the ex write commands shall be
inhibited, as described in editor option autowrite.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
When any error is encountered and the standard input is not a terminal device file, in addition to the default requirements
described in 1.4 Utility Description Defaults, ex shall neither
write the file (if one has been opened) nor return to command or text input mode.
Otherwise, when an unrecoverable error is encountered, it shall be equivalent to a SIGHUP asynchronous event.
Otherwise, when an error is encountered, the editor shall behave as specified in Command
Line Parsing in ex.
The following sections are informative.
APPLICATION USAGE
If a SIGSEGV signal is received while ex is saving a file, the file might not be successfully saved.
The next command can accept more than one file, so usage such as:
next `ls [abc]*`
is valid; it would not be valid for the edit or read commands, for example, because they expect only
one file and unspecified results occur.
Unlike the system() function, ex does not pass "--"
between the "-c" argument and the command string, so that programs for which -c takes an option-argument can be
used in the shell edit option. Users who want to use an escape command to execute a utility whose name starts with
'-' or '+' need to provide a pathname for that utility that does not start with either of those characters, or
precede the utility name with a  character.
EXAMPLES
None.
RATIONALE
The ex/vi specification is based on the historical practice found in the 4 BSD
and System V implementations of ex and vi.
A restricted editor (both the historical red utility and modifications to ex) were considered
and rejected for inclusion. Neither option provided the level of security that users might expect.
It is recognized that ex visual mode and related features would be difficult, if not impossible, to
implement satisfactorily on a block-mode terminal, or a terminal without any form of cursor addressing; thus, it is not a mandatory
requirement that such features should work on all terminals. It is the intention, however, that an ex implementation should
provide the full set of capabilities on all terminals capable of supporting them.
Options
The -c replacement for +command was inspired by the -e option of sed. Historically, all such commands (see edit and next as well) were executed
from the last line of the edit buffer. This meant, for example, that "+/pattern" would fail unless the wrapscan
option was set. POSIX.1-2024 requires conformance to historical practice. The +command option is no longer specified
by POSIX.1-2024 but may be present in some implementations. Historically, some implementations restricted the ex commands
that could be listed as part of the command line arguments. For consistency, POSIX.1-2024 does not permit these restrictions.
In historical implementations of the editor, the -R option (and the readonly edit option) only
prevented overwriting of files; appending to files was still permitted, mapping loosely into the csh noclobber
variable. Some implementations, however, have not followed this semantic, and readonly does not permit appending either.
POSIX.1-2024 follows the latter practice, believing that it is a more obvious and intuitive meaning of readonly.
The -s option suppresses all interactive user feedback and is useful for editing scripts in batch jobs. The
list of specific effects is historical practice. The terminal type "incapable of supporting open and visual modes" has
historically been named "dumb".
The -t option was required because the ctags utility appears in
POSIX.1-2024 and the option is available in all historical implementations of ex.
Historically, the ex and vi utilities accepted a -x option,
which did encryption based on the algorithm found in the historical crypt utility. The -x option for encryption, and
the associated crypt utility, were omitted because the algorithm used was not specifiable and the export control laws of
some nations make it difficult to export cryptographic technology. In addition, it did not historically provide the level of
security that users might expect.
Standard Input
An end-of-file condition is not equivalent to an end-of-file character. A common end-of-file character,
-D, is historically an ex command.
There was no maximum line length in historical implementations of ex. Specifically, as it was parsed in
chunks, the addresses had a different maximum length than the filenames. Further, the maximum line buffer size was declared as
BUFSIZ, which was different lengths on different systems. This version selected the value of {LINE_MAX} to impose a reasonable
restriction on portable usage of ex and to aid test suite writers in their development of realistic tests that exercise this
limit.
Input Files
It was an explicit decision by the standard developers that a  be added to any file lacking one. It
was believed that this feature of ex and vi was relied on by users in order to
make text files lacking a trailing  more portable. It is recognized that this will require a user-specified option
or extension for implementations that permit ex and vi to edit files of type other
than text if such files are not otherwise identified by the system. It was agreed that the ability to edit files of arbitrary type
can be useful, but it was not considered necessary to mandate that an ex or vi
implementation be required to handle files other than text files.
The paragraph in the INPUT FILES section, "By default, ...", is intended to close a long-standing security
problem in ex and vi; that of the "modeline" or "modelines" edit option. This
feature allows any line in the first or last five lines of the file containing the strings "ex:" or "vi:" (and,
apparently, "ei:" or "vx:") to be a line containing editor commands, and ex interprets all the text up to
the next ':' or  as a command. Consider the consequences, for example, of an unsuspecting user using
ex or vi as the editor when replying to a mail message in which a line such
as:
ex:! rm -rf :
appeared in the signature lines. The standard developers believed strongly that an editor should not by default
interpret any lines of a file. Vendors are strongly urged to delete this feature from their implementations of ex and
vi.
Asynchronous Events
The intention of the phrase "complete write" is that the entire edit buffer be written to stable storage. The
note regarding temporary files is intended for implementations that use temporary files to back edit buffers unnamed by the
user.
Historically, SIGQUIT was ignored by ex, but was the equivalent of the Q command in visual mode; that
is, it exited visual mode and entered ex mode. POSIX.1-2024 permits, but does not require, this behavior. Historically,
SIGINT was often used by vi users to terminate text input mode (-C is
often easier to enter than ). Some implementations of vi alerted the terminal
on this event, and some did not. POSIX.1-2024 requires that SIGINT behave identically to , and that the terminal not be
alerted.
Historically, suspending the ex editor during text input mode was similar to SIGINT, as completed lines were
retained, but any partial line discarded, and the editor returned to command mode. POSIX.1-2024 is silent on this issue;
implementations are encouraged to follow historical practice, where possible.
Historically, the vi editor did not treat SIGTSTP as an asynchronous
event, and it was therefore impossible to suspend the editor in visual text input mode. There are two major reasons for this. The
first is that SIGTSTP is a broadcast signal on UNIX systems, and the chain of events where the shell execs an application that then execs vi usually caused confusion for the
terminal state if SIGTSTP was delivered to the process group in the default manner. The second was that most implementations of the
UNIX curses package did not handle SIGTSTP safely, and the receipt of SIGTSTP at the wrong time would cause them to crash.
POSIX.1-2024 is silent on this issue; implementations are encouraged to treat suspension as an asynchronous event if possible.
Historically, modifications to the edit buffer made before SIGINT interrupted an operation were retained; that is,
anywhere from zero to all of the lines to be modified might have been modified by the time the SIGINT arrived. These changes were
not discarded by the arrival of SIGINT. POSIX.1-2024 permits this behavior, noting that the undo command is required to be
able to undo these partially completed commands.
The action taken for signals other than SIGINT, SIGCONT, SIGHUP, and SIGTERM is unspecified because some
implementations attempt to save the edit buffer in a useful state when other signals are received.
Standard Error
For ex/vi, diagnostic messages are those messages reported as a
result of a failed attempt to invoke ex or vi, such as invalid options or
insufficient resources, or an abnormal termination condition. Diagnostic messages should not be confused with the error messages
generated by inappropriate or illegal user commands.
Initialization in ex and vi
If an ex command (other than cd, chdir, or source) has a filename argument, one or both
of the alternate and current pathnames will be set. Informally, they are set as follows:
If the ex command is one that replaces the contents of the edit buffer, and it succeeds, the current
pathname will be set to the filename argument (the first filename argument in the case of the next command) and the
alternate pathname will be set to the previous current pathname, if there was one.
In the case of the file read/write forms of the read and write commands, if there is no current
pathname, the current pathname will be set to the filename argument.
Otherwise, the alternate pathname will be set to the filename argument.
For example, :edit foo and :recover foo, when successful, set the current pathname, and, if there was
a previous current pathname, the alternate pathname. The commands :write, !command, and :edit set neither the
current or alternate pathnames. If the :edit foo command were to fail for some reason, the alternate pathname would be set.
The read and write commands set the alternate pathname to their file argument, unless the current pathname is
not set, in which case they set the current pathname to their file arguments. The alternate pathname was not historically
set by the :source command. POSIX.1-2024 requires conformance to historical practice. Implementations adding commands that
take filenames as arguments are encouraged to set the alternate pathname as described here.
Historically, ex and vi read the .exrc file in the
$HOME directory twice, if the editor was executed in the $HOME directory. POSIX.1-2024 prohibits this behavior.
Historically, the 4 BSD ex and vi read the $HOME and local
.exrc files if they were owned by the real ID of the user, or the sourceany option was set, regardless of other
considerations. This was a security problem because it is possible to put normal UNIX system commands inside a .exrc file.
POSIX.1-2024 does not specify the sourceany option, and historical implementations are encouraged to delete it.
The .exrc files must be owned by the real ID of the user, and not writable by anyone other than the owner.
The appropriate privileges exception is intended to permit users to acquire special privileges, but continue to use the
.exrc files in their home directories.
System V Release 3.2 and later vi implementations added the option
[no]exrc. The behavior is that local .exrc files are read-only if the exrc option is set. The default for the
exrc option was off, so by default, local .exrc files were not read. The problem this was intended to solve was that
System V permitted users to give away files, so there is no possible ownership or writeability test to ensure that the file is
safe. This is still a security problem on systems where users can give away files, but there is nothing additional that
POSIX.1-2024 can do. The implementation-defined exception is intended to permit groups to have local .exrc files that are
shared by users, by creating pseudo-users to own the shared files.
POSIX.1-2024 does not mention system-wide ex and vi start-up
files. While they exist in several implementations of ex and vi, they are not
present in any implementations considered historical practice by POSIX.1-2024. Implementations that have such files should use them
only if they are owned by the real user ID or an appropriate user (for example, root on UNIX systems) and if they are not writable
by any user other than their owner. System-wide start-up files should be read before the EXINIT variable,
$HOME/.exrc, or local .exrc files are evaluated.
Historically, any ex command could be entered in the EXINIT variable or the .exrc file,
although ones requiring that the edit buffer already contain lines of text generally caused historical implementations of the
editor to drop core. POSIX.1-2024 requires that any ex command be permitted in the EXINIT variable and
.exrc files, for simplicity of specification and consistency, although many of them will obviously fail under many
circumstances.
The initialization of the contents of the edit buffer uses the phrase "the effect shall be" with regard to
various ex commands. The intent of this phrase is that edit buffer contents loaded during the initialization phase not be
lost; that is, loading the edit buffer should fail if the .exrc file read in the contents of a file and did not subsequently
write the edit buffer. An additional intent of this phrase is to specify that the initial current line and column is set as
specified for the individual ex commands.
Historically, the -t option behaved as if the tag search were a +command; that is, it was
executed from the last line of the file specified by the tag. This resulted in the search failing if the pattern was a forward
search pattern and the wrapscan edit option was not set. POSIX.1-2024 does not permit this behavior, requiring that the
search for the tag pattern be performed on the entire file, and, if not found, that the current line be set to a more reasonable
location in the file.
Historically, the empty edit buffer presented for editing when a file was not specified by the user was unnamed.
This is permitted by POSIX.1-2024; however, implementations are encouraged to provide users a temporary filename for this buffer
because it permits them the use of ex commands that use the current pathname during temporary edit sessions.
Historically, the file specified using the -t option was not part of the current argument list. This
practice is permitted by POSIX.1-2024; however, implementations are encouraged to include its name in the current argument list for
consistency.
Historically, the -c command was generally not executed until a file that already exists was edited.
POSIX.1-2024 requires conformance to this historical practice. Commands that could cause the -c command to be executed
include the ex commands edit, next, recover, rewind, and tag, and the vi commands -^ and -]. Historically, reading a file into an edit
buffer did not cause the -c command to be executed (even though it might set the current pathname) with the exception that
it did cause the -c command to be executed if: the editor was in ex mode, the edit buffer had no current pathname,
the edit buffer was empty, and no read commands had yet been attempted. For consistency and simplicity of specification,
POSIX.1-2024 does not permit this behavior.
Historically, the -r option was the same as a normal edit session if there was no recovery information
available for the file. This allowed users to enter:
vi -r *.c
and recover whatever files were recoverable. In some implementations, recovery was attempted only on the first file
named, and the file was not entered into the argument list; in others, recovery was attempted for each file named. In addition,
some historical implementations ignored -r if -t was specified or did not support command line file arguments
with the -t option. For consistency and simplicity of specification, POSIX.1-2024 disallows these special cases, and
requires that recovery be attempted the first time each file is edited.
Historically, vi initialized the ` and ' marks, but
ex did not. This meant that if the first command in ex mode was visual or if an ex command was executed
first (for example, vi +10 file), vi was
entered without the marks being initialized. Because the standard developers believed the marks to be generally useful, and for
consistency and simplicity of specification, POSIX.1-2024 requires that they always be initialized if in open or visual mode, or if
in ex mode and the edit buffer is not empty. Not initializing it in ex mode if the edit buffer is empty is historical
practice; however, it has always been possible to set (and use) marks in empty edit buffers in open and visual mode edit
sessions.
Addressing
Historically, ex and vi accepted the additional addressing forms
'\/' and '\?'. They were equivalent to "//" and "??", respectively. They are not required by
POSIX.1-2024, mostly because nobody can remember whether they ever did anything different historically.
Historically, ex and vi permitted an address of zero for several
commands, and permitted the % address in empty files for others. For consistency, POSIX.1-2024 requires support for the
former in the few commands where it makes sense, and disallows it otherwise. In addition, because POSIX.1-2024 requires that
% be logically equivalent to "1,$", it is also supported where it makes sense and disallowed otherwise.
Historically, the % address could not be followed by further addresses. For consistency and simplicity of
specification, POSIX.1-2024 requires that additional addresses be supported.
All of the following are valid addresses:
+++
Three lines after the current line.
/re/-
One line before the next occurrence of re.
-2
Two lines before the current line.
3 ---- 2
Line one (note intermediate negative address).
1 2 3
Line six.
Any number of addresses can be provided to commands taking addresses; for example, "1,2,3,4,5p" prints
lines 4 and 5, because two is the greatest valid number of addresses accepted by the print command. This, in combination
with the  delimiter, permits users to create commands based on ordered patterns in the file. For example, the
command 3;/foo/;+2print will display the first line after line 3 that contains the pattern foo, plus the next two
lines. Note that the address 3; must be evaluated before being discarded because the search origin for the /foo/
command depends on this.
Historically, values could be added to addresses by including them after one or more  characters; for
example, 3 - 5p wrote the seventh line of the file, and /foo/ 5 was the same as /foo/+5.
However, only absolute values could be added; for example, 5 /foo/ was an error. POSIX.1-2024 requires conformance to
historical practice. Address offsets are separately specified from addresses because they could historically be provided to visual
mode search commands.
Historically, any missing addresses defaulted to the current line. This was true for leading and trailing
-delimited addresses, and for trailing -delimited addresses. For consistency, POSIX.1-2024 requires
it for leading  addresses as well.
Historically, ex and vi accepted the '^' character as
both an address and as a flag offset for commands. In both cases it was identical to the '-' character. POSIX.1-2024 does
not require or prohibit this behavior.
Historically, the enhancements to basic regular expressions could be used in addressing; for example, '~',
'\'. POSIX.1-2024 requires conformance to historical practice; that is, that regular expression
usage be consistent, and that regular expression enhancements be supported wherever regular expressions are used.
Command Line Parsing in ex
Historical ex command parsing was even more complex than that described here. POSIX.1-2024 requires the
subset of the command parsing that the standard developers believed was documented and that users could reasonably be expected to
use in a portable fashion, and that was historically consistent between implementations. (The discarded functionality is obscure,
at best.) Historical implementations will require changes in order to comply with POSIX.1-2024; however, users are not expected to
notice any of these changes. Most of the complexity in ex parsing is to handle three special termination cases:
The !, global, v, and the filter versions of the read and write commands are
delimited by  characters (they can contain  characters that are usually shell pipes).
The ex, edit, next, and visual in open and visual mode commands all take ex
commands, optionally containing  characters, as their first arguments.
The s command takes a regular expression as its first argument, and uses the delimiting characters to
delimit the command.
Historically,  characters in the +command argument of the ex,
edit, next, vi, and visual commands, and in the pattern and replacement parts of the
s command, did not delimit the command, and in the filter cases for read and write, and the !,
global, and v commands, they did not delimit the command at all. For example, the following commands are all
valid:
:edit +25 | s/abc/ABC/ file.c
:s/ | /PIPE/
:read !spell % | columnate
:global/pattern/p | l
:s/a/b/ | s/c/d | set
Historically, empty or  filled lines in .exrc files and sourced files (as well as
EXINIT variables and ex command scripts) were treated as default commands; that is, print commands.
POSIX.1-2024 specifically requires that they be ignored when encountered in .exrc and sourced files to eliminate a
common source of new user error.
Historically, ex commands with multiple adjacent (or -separated) vertical lines were handled
oddly when executed from ex mode. For example, the command ||| , when the cursor was on line
1, displayed lines 2, 3, and 5 of the file. In addition, the command | would only display the line after the next line,
instead of the next two lines. The former worked more logically when executed from vi
mode, and displayed lines 2, 3, and 4. POSIX.1-2024 requires the vi behavior; that is, a
single default command and line number increment for each command separator, and trailing  characters after
separators are discarded.
Historically, ex permitted a single extra  as a leading command character; for example,
:g/pattern/:p was a valid command. POSIX.1-2024 generalizes this to require that any number of leading
characters be stripped.
Historically, any prefix of the delete command could be followed without intervening
characters by a flag character because in the command d p, p is interpreted as the buffer p. POSIX.1-2024
requires conformance to historical practice.
Historically, the k command could be followed by the mark name without intervening  characters.
POSIX.1-2024 requires conformance to historical practice.
Historically, the s command could be immediately followed by flag and option characters; for example,
s/e/E/|s|sgc3p was a valid command. However, flag characters could not stand alone; for example, the commands sp and
s l would fail, while the command sgp and s gl would succeed. (Obviously, the '#' flag
character was used as a delimiter character if it followed the command.) Another issue was that option characters had to precede
flag characters even when the command was fully specified; for example, the command s/e/E/pg would fail, while the command
s/e/E/gp would succeed. POSIX.1-2024 requires conformance to historical practice.
Historically, the first command name that had a prefix matching the input from the user was the executed command;
for example, ve, ver, and vers all executed the version command. Commands were in a specific order,
however, so that a matched append, not abbreviate. POSIX.1-2024 requires conformance to historical practice.
The restriction on command search order for implementations with extensions is to avoid the addition of commands such that the
historical prefixes would fail to work portably.
Historical implementations of ex and vi did not correctly handle
multiple ex commands, separated by  characters, that entered or exited visual mode or the editor.
Because implementations of vi exist that do not exhibit this failure mode, POSIX.1-2024
does not permit it.
The requirement that alphabetic command names consist of all following alphabetic characters up to the next
non-alphabetic character means that alphabetic command names must be separated from their arguments by one or more non-alphabetic
characters, normally a  or '!' character, except as specified for the exceptions, the delete,
k, and s commands.
Historically, the repeated execution of the ex default print commands (-D, eof,
, ) erased any prompting character and displayed the next lines without scrolling the
terminal; that is, immediately below any previously displayed lines. This provided a cleaner presentation of the lines in the file
for the user. POSIX.1-2024 does not require this behavior because it may be impossible in some situations; however, implementations
are strongly encouraged to provide this semantic if possible.
Historically, it was possible to change files in the middle of a command, and have the rest of the command executed
in the new file; for example:
:edit +25 file.c | s/abc/ABC/ | 1
was a valid command, and the substitution was attempted in the newly edited file. POSIX.1-2024 requires conformance
to historical practice. The following commands are examples that exercise the ex parser:
echo 'foo | bar' > file1; echo 'foo/bar' > file2;
vi
:edit +1 | s/|/PIPE/ | w file1 | e file2 | 1 | s/\//SLASH/ | wq
Historically, there was no protection in editor implementations to avoid ex global, v,
@, or * commands changing edit buffers during execution of their associated commands. Because this would almost
invariably result in catastrophic failure of the editor, and implementations exist that do exhibit these problems, POSIX.1-2024
requires that changing the edit buffer during a global or v command, or during a @ or * command for
which there will be more than a single execution, be an error. Implementations supporting multiple edit buffers simultaneously are
strongly encouraged to apply the same semantics to switching between buffers as well.
The ex command quoting required by POSIX.1-2024 is a superset of the quoting in historical implementations
of the editor. For example, it was not historically possible to escape a  in a filename; for example,
:edit foo\\\ bar would report that too many filenames had been entered for the edit command, and there was no
method of escaping a  in the first argument of an edit, ex, next, or visual command at
all. POSIX.1-2024 extends historical practice, requiring that quoting behavior be made consistent across all ex commands,
except for the map, unmap, abbreviate, and unabbreviate commands, which historically used
-V instead of  characters for quoting. For those four commands, POSIX.1-2024 requires conformance
to historical practice.
Backslash quoting in ex is non-intuitive. -escapes are ignored unless they escape a special
character; for example, when performing file argument expansion, the string "\\%" is equivalent to '\%',
not "\". This can be confusing for users because  is usually
one of the characters that causes shell expansion to be performed, and therefore shell quoting rules must be taken into
consideration. Generally, quoting characters are only considered if they escape a special character, and a quoting character must
be provided for each layer of parsing for which the character is special. As another example, only a single  is
necessary for the '\l' sequence in substitute replacement patterns, because the character 'l' is not special to
any parsing layer above it.
-V quoting in ex is slightly different from backslash quoting. In the four commands where
-V quoting applies (abbreviate, unabbreviate, map, and unmap), any character may be
escaped by a -V whether it would have a special meaning or not. POSIX.1-2024 requires conformance to historical
practice.
Historical implementations of the editor did not require delimiters within character classes to be escaped; for
example, the command :s/[/]// on the string "xxx/yyy" would delete the '/' from the string. POSIX.1-2024
disallows this historical practice for consistency and because it places a large burden on implementations by requiring that
knowledge of regular expressions be built into the editor parser.
Historically, quoting  characters in ex commands was handled inconsistently. In most cases,
the  character always terminated the command, regardless of any preceding escape character, because
characters did not escape  characters for most ex commands. However, some ex
commands (for example, s, map, and abbreviation) permitted  characters to be escaped (although
in the case of map and abbreviation, -V characters escaped them instead of
characters). This was true in not only the command line, but also .exrc and sourced files. For example, the
command:
map = foobar
would succeed, although it was sometimes difficult to get the -V and the inserted
passed to the ex parser. For consistency and simplicity of specification, POSIX.1-2024 requires that it be possible to
escape  characters in ex commands at all times, using  characters for most ex
commands, and using -V characters for the map and abbreviation commands. For example, the command
printlist is required to be parsed as the single command printlist. While
this differs from historical practice, POSIX.1-2024 developers believed it unlikely that any script or user depended on the
historical behavior.
Historically, an error in a command specified using the -c option did not cause the rest of the -c
commands to be discarded. POSIX.1-2024 disallows this for consistency with mapped keys, the @, global, source,
and v commands, the EXINIT environment variable, and the .exrc files.
Input Editing in ex
One of the common uses of the historical ex editor is over slow network connections. Editors that run in
canonical mode can require far less traffic to and from, and far less processing on, the host machine, as well as more easily
supporting block-mode terminals. For these reasons, POSIX.1-2024 requires that ex be implemented using canonical mode input
processing, as was done historically.
POSIX.1-2024 does not require the historical 4 BSD input editing characters "word erase" or "literal next". For
this reason, it is unspecified how they are handled by ex, although they must have the required effect. Implementations that
resolve them after the line has been ended using a  or -M character, and implementations that rely on
the underlying system terminal support for this processing, are both conforming. Implementations are strongly urged to use the
underlying system functionality, if at all possible, for compatibility with other system text input interfaces.
Historically, when the eof character was used to decrement the autoindent level, the cursor moved to
display the new end of the autoindent characters, but did not move the cursor to a new line, nor did it erase the
-D character from the line. POSIX.1-2024 does not specify that the cursor remain on the same line or that the rest
of the line is erased; however, implementations are strongly encouraged to provide the best possible user interface; that is, the
cursor should remain on the same line, and any -D character on the line should be erased.
POSIX.1-2024 does not require the historical 4 BSD input editing character "reprint", traditionally
-R, which redisplayed the current input from the user. For this reason, and because the functionality cannot be
implemented after the line has been terminated by the user, POSIX.1-2024 makes no requirements about this functionality.
Implementations are strongly urged to make this historical functionality available, if possible.
Historically, -Q did not perform a literal next function in ex, as it did in vi. POSIX.1-2024 requires conformance to historical practice to avoid breaking historical
ex scripts and .exrc files.
eof
Whether the eof character immediately modifies the autoindent characters in the prompt is left
unspecified so that implementations can conform in the presence of systems that do not support this functionality. Implementations
are encouraged to modify the line and redisplay it immediately, if possible.
The specification of the handling of the eof character differs from historical practice only in that
eof characters are not discarded if they follow normal characters in the text input. Historically, they were always
discarded.
Command Descriptions in ex
Historically, several commands (for example, global, v, visual, s, write,
wq, yank, !, , &, and ~) were executable in empty files (that is, the
default address(es) were 0), or permitted explicit addresses of 0 (for example, 0 was a valid address, or 0,0 was a valid range).
Addresses of 0, or command execution in an empty file, make sense only for commands that add new text to the edit buffer or write
commands (because users may wish to write empty files). POSIX.1-2024 requires this behavior for such commands and disallows it
otherwise, for consistency and simplicity of specification.
A count to an ex command has been historically corrected to be no greater than the last line in a file; for
example, in a five-line file, the command 1,6print would fail, but the command 1print300 would succeed. POSIX.1-2024
requires conformance to historical practice.
Historically, the use of flags in ex commands could be obscure. General historical practice was as described
by POSIX.1-2024, but there were some special cases. For instance, the list, number, and print commands ignored
trailing address offsets; for example, 3p +++# would display line 3, and 3 would be the current line after the
execution of the command. The open and visual commands ignored both the trailing offsets and the trailing flags.
Also, flags specified to the open and visual commands interacted badly with the list edit option, and setting
and then unsetting it during the open/visual session would cause vi to stop displaying
lines in the specified format. For consistency and simplicity of specification, POSIX.1-2024 does not permit any of these
exceptions to the general rule.
POSIX.1-2024 uses the word copy in several places when discussing buffers. This is not intended to imply
implementation.
Historically, ex users could not specify numeric buffers because of the ambiguity this would cause; for
example, in the command 3 delete 2, it is unclear whether 2 is a buffer name or a count. POSIX.1-2024
requires conformance to historical practice by default, but does not preclude extensions.
Historically, the contents of the unnamed buffer were frequently discarded after commands that did not explicitly
affect it; for example, when using the edit command to switch files. For consistency and simplicity of specification,
POSIX.1-2024 does not permit this behavior.
The ex utility did not historically have access to the numeric buffers, and, furthermore, deleting lines in
ex did not modify their contents. For example, if, after doing a delete in vi, the
user switched to ex, did another delete, and then switched back to vi, the
contents of the numeric buffers would not have changed. POSIX.1-2024 requires conformance to historical practice. Numeric buffers
are described in the ex utility in order to confine the description of buffers to a single location in POSIX.1-2024.
The metacharacters that trigger shell expansion in file arguments match historical practice, as does the
method for doing shell expansion. Implementations wishing to provide users with the flexibility to alter the set of metacharacters
are encouraged to provide a shellmeta string edit option.
Historically, ex commands executed from vi refreshed the screen
when it did not strictly need to do so; for example, :!date > /dev/null does not require a screen refresh
because the output of the UNIX date command requires only a single line of the screen.
POSIX.1-2024 requires that the screen be refreshed if it has been overwritten, but makes no requirements as to how an
implementation should make that determination. Implementations may prompt and refresh the screen regardless.
Abbreviate
Historical practice was that characters that were entered as part of an abbreviation replacement were subject to
map expansions, the showmatch edit option, further abbreviation expansions, and so on; that is, they were logically
pushed onto the terminal input queue, and were not a simple replacement. POSIX.1-2024 requires conformance to historical practice.
Historical practice was that whenever a non-word character (that had not been escaped by a -V) was entered after a
word character, vi would check for abbreviations. The check was based on the type of the
character entered before the word character of the word/non-word pair that triggered the check. The word character of the
word/non-word pair that triggered the check and all characters entered before the trigger pair that were of that type were included
in the check, with the exception of  characters, which always delimited the abbreviation.
This means that, for the abbreviation to work, the lhs must end with a word character, there can be no
transitions from word to non-word characters (or vice versa) other than between the last and next-to-last characters in the
lhs, and there can be no  characters in the lhs. In addition, because of the historical quoting rules,
it was impossible to enter a literal -V in the lhs. POSIX.1-2024 requires conformance to historical practice.
Historical implementations did not inform users when abbreviations that could never be used were entered; implementations are
strongly encouraged to do so.
For example, the following abbreviations will work:
:ab (p  REPLACE
:ab p   REPLACE
:ab ((p REPLACE
The following abbreviations will not work:
:ab (   REPLACE
:ab (pp REPLACE
Historical practice is that words on the vi colon command line were
subject to abbreviation expansion, including the arguments to the abbrev (and more interestingly) the unabbrev
command. Because there are implementations that do not do abbreviation expansion for the first argument to those commands, this is
permitted, but not required, by POSIX.1-2024. However, the following sequence:
:ab foo bar
:ab foo baz
resulted in the addition of an abbreviation of "baz" for the string "bar" in historical
ex/vi, and the sequence:
:ab foo1 bar
:ab foo2 bar
:unabbreviate foo2
deleted the abbreviation "foo1", not "foo2". These behaviors are not permitted by POSIX.1-2024
because they clearly violate the expectations of the user.
It was historical practice that -V, not , characters be interpreted as escaping
subsequent characters in the abbreviate command. POSIX.1-2024 requires conformance to historical practice; however, it
should be noted that an abbreviation containing a  will never work.
Append
Historically, any text following a  command separator after an append, change,
or insert command became part of the insert text. For example, in the command:
:g/pattern/append|stuff1
a line containing the text "stuff1" would be appended to each line matching pattern. It was also
historically valid to enter:
:append|stuff1
stuff2
.
and the text on the ex command line would be appended along with the text inserted after it. There was an
historical bug, however, that the user had to enter two terminating lines (the '.' lines) to terminate text input mode in
this case. POSIX.1-2024 requires conformance to historical practice, but disallows the historical need for multiple terminating
lines.
Change
See the RATIONALE for the append command. Historical practice for cursor positioning after the change
command when no text is input, is as described in POSIX.1-2024. However, one System V implementation is known to have been modified
such that the cursor is positioned on the first address specified, and not on the line before the first address. POSIX.1-2024
disallows this modification for consistency.
Historically, the change command did not support buffer arguments, although some implementations allow the
specification of an optional buffer. This behavior is neither required nor disallowed by POSIX.1-2024.
Change Directory
A common extension in ex implementations is to use the elements of a cdpath edit option as prefix
directories for path arguments to chdir that are relative pathnames and that do not have '.' or
".." as their first component. Elements in the cdpath edit option are -separated. The initial value of
the cdpath edit option is the value of the shell CDPATH environment variable. This feature was not included in
POSIX.1-2024 because it does not exist in any of the implementations considered historical practice.
Copy
Historical implementations of ex permitted copies to lines inside of the specified range; for example,
:2,5copy3 was a valid command. POSIX.1-2024 requires conformance to historical practice.
Delete
POSIX.1-2024 requires support for the historical parsing of a delete command followed by flags, without any
intervening  characters. For example:
1dp
Deletes the first line and prints the line that was second.
1delep
As for 1dp.
1d
Deletes the first line, saving it in buffer p.
1d p1l
(Pee-one-ell.) Deletes the first line, saving it in buffer p, and listing the line that was second.
Edit
Historically, any ex command could be entered as a +command argument to the edit
command, although some (for example, insert and append) were known to confuse historical implementations. For
consistency and simplicity of specification, POSIX.1-2024 requires that any command be supported as an argument to the edit
command.
Historically, the command argument was executed with the current line set to the last line of the file, regardless
of whether the edit command was executed from visual mode or not. POSIX.1-2024 requires conformance to historical
practice.
Historically, the +command specified to the edit and next commands was delimited by the
first , and there was no way to quote them. For consistency, POSIX.1-2024 requires that the usual ex backslash
quoting be provided.
Historically, specifying the +command argument to the edit command required a filename to be
specified as well; for example, :edit +100 would always fail. For consistency and simplicity of specification,
POSIX.1-2024 does not permit this usage to fail for that reason.
Historically, only the cursor position of the last file edited was remembered by the editor. POSIX.1-2024 requires
that this be supported; however, implementations are permitted to remember and restore the cursor position for any file previously
edited.
File
Historical versions of the ex editor file command displayed a current line and number of lines in the
edit buffer of 0 when the file was empty, while the vi -G command
displayed a current line and number of lines in the edit buffer of 1 in the same situation. POSIX.1-2024 does not permit this
discrepancy, instead requiring that a message be displayed indicating that the file is empty.
Global
The two-pass operation of the global and v commands is not intended to imply implementation, only the
required result of the operation.
The current line and column are set as specified for the individual ex commands. This requirement is
cumulative; that is, the current line and column must track across all the commands executed by the global or v
commands.
Insert
See the RATIONALE for the append command.
Historically, insert could not be used with an address of zero; that is, not when the edit buffer was empty.
POSIX.1-2024 requires that this command behave consistently with the append command.
Join
The action of the join command in relation to the special characters is only defined for the POSIX locale
because the correct amount of white space after a period varies; in Japanese none is required, in French only a single space, and
so on.
List
The historical output of the list command was potentially ambiguous. The standard developers believed
correcting this to be more important than adhering to historical practice, and POSIX.1-2024 requires unambiguous output.
Map
Historically, command mode maps only applied to command names; for example, if the character 'x' was
mapped to 'y', the command fx searched for the 'x' character, not the 'y' character. POSIX.1-2024
requires this behavior. Historically, entering -V as the first character of a vi command was an error. Several implementations have extended the semantics of vi such that -V means that the subsequent command character is not mapped. This is
permitted, but not required, by POSIX.1-2024. Regardless, using -V to escape the second or later character in a
sequence of characters that might match a map command, or any character in text input mode, is historical practice, and
stops the entered keys from matching a map. POSIX.1-2024 requires conformance to historical practice.
Historical implementations permitted digits to be used as a map command lhs, but then ignored the
map. POSIX.1-2024 requires that the mapped digits not be ignored.
The historical implementation of the map command did not permit map commands that were more than a
single character in length if the first character was printable. This behavior is permitted, but not required, by POSIX.1-2024.
Historically, mapped characters were remapped unless the remap edit option was not set, or the prefix of the
mapped characters matched the mapping characters; for example, in the map:
:map ab abcd
the characters "ab" were used as is and were not remapped, but the characters "cd" were mapped if
appropriate. This can cause infinite loops in the vi mapping mechanisms. POSIX.1-2024
requires conformance to historical practice, and that such loops be interruptible.
Text input maps had the same problems with expanding the lhs for the ex map! and unmap!
command as did the ex abbreviate and unabbreviate commands. See the RATIONALE for the ex
abbreviate command. POSIX.1-2024 requires similar modification of some historical practice for the map and
unmap commands, as described for the abbreviate and unabbreviate commands.
Historically, maps that were subsets of other maps behaved differently depending on the order in
which they were defined. For example:
:map! ab     short
:map! abc    long
would always translate the characters "ab" to "short", regardless of how fast the characters
"abc" were entered. If the entry order was reversed:
:map! abc    long
:map! ab     short
the characters "ab" would cause the editor to pause, waiting for the completing 'c' character,
and the characters might never be mapped to "short". For consistency and simplicity of specification, POSIX.1-2024
requires that the shortest match be used at all times.
The length of time the editor spends waiting for the characters to complete the lhs is unspecified because
the timing capabilities of systems are often inexact and variable, and it may depend on other factors such as the speed of the
connection. The time should be long enough for the user to be able to complete the sequence, but not long enough for the user to
have to wait. Some implementations of vi have added a keytime option, which
permits users to set the number of 0,1 seconds the editor waits for the completing characters. Because mapped terminal function and
cursor keys tend to start with an  character, and  is the key ending vi text input mode, maps starting with  characters are generally exempted from
this timeout period, or, at least timed out differently.
Mark
Historically, users were able to set the "previous context" marks explicitly. In addition, the ex commands
'' and '` and the vi commands '', ``, `',
and '` all referred to the same mark. In addition, the previous context marks were not set if the command, with which the
address setting the mark was associated, failed. POSIX.1-2024 requires conformance to historical practice. Historically, if marked
lines were deleted, the mark was also deleted, but would reappear if the change was undone. POSIX.1-2024 requires conformance to
historical practice.
The description of the special events that set the ` and ' marks matches historical practice. For
example, historically the command /a/,/b/ did not set the ` and ' marks, but the command /a/,/b/delete
did.
Historically, any ex command could be entered as a +command argument to the next
command, although some (for example, insert and append) were known to confuse historical implementations.
POSIX.1-2024 requires that any command be permitted and that it behave as specified. The next command can accept more than
one file, so usage such as:
next `ls [abc] `
is valid; it need not be valid for the edit or read commands, for example, because they expect only
one filename.
Historically, the next command behaved differently from the :rewind command in that it ignored the
force flag if the autowrite flag was set. For consistency, POSIX.1-2024 does not permit this behavior.
Historically, the next command positioned the cursor as if the file had never been edited before,
regardless. POSIX.1-2024 does not permit this behavior, for consistency with the edit command.
Implementations wanting to provide a counterpart to the next command that edited the previous file have used
the command prev[ious], which takes no file argument. POSIX.1-2024 does not require this command.
Open
Historically, the open command would fail if the open edit option was not set. POSIX.1-2024 does not
mention the open edit option and does not require this behavior. Some historical implementations do not permit entering open
mode from open or visual mode, only from ex mode. For consistency, POSIX.1-2024 does not permit this behavior.
Historically, entering open mode from the command line (that is, vi
+open) resulted in anomalous behaviors; for example, the ex file and set commands, and the vi command
-G did not work. For consistency, POSIX.1-2024 does not permit this behavior.
Historically, the open command only permitted '/' characters to be used as the search pattern
delimiter. For consistency, POSIX.1-2024 requires that the search delimiters used by the s, global, and v
commands be accepted as well.
Preserve
The preserve command does not historically cause the file to be considered unmodified for the purposes of
future commands that may exit the editor. POSIX.1-2024 requires conformance to historical practice.
Historical documentation stated that mail was not sent to the user when preserve was executed; however, historical
implementations did send mail in this case. POSIX.1-2024 requires conformance to the historical implementations.
Print
The writing of NUL by the print command is not specified as a special case because the standard developers
did not want to require ex to support NUL characters. Historically, characters were displayed using the ARPA standard
mappings, which are as follows:
Printable characters are left alone.
Control characters less than \177 are represented as '^' followed by the character offset from the
'@' character in the ASCII map; for example, \007 is represented as '^G'.
\177 is represented as '^' followed by '?'.
The display of characters having their eighth bit set was less standard. Existing implementations use hex (0x00),
octal (\000), and a meta-bit display. (The latter displayed bytes that had their eighth bit set as the two characters "M-"
followed by the seven-bit display as described above.) The latter probably has the best claim to historical practice because it was
used for the -v option of 4 BSD and 4 BSD-derived versions of the cat utility
since 1980.
No specific display format is required by POSIX.1-2024.
Explicit dependence on the ASCII character set has been avoided where possible, hence the use of the phrase an
"implementation-defined multi-character sequence" for the display of non-printable characters in preference to the historical
usage of, for instance, "^I" for the . Implementations are encouraged to conform to historical practice in the
absence of any strong reason to diverge.
Historically, all ex commands beginning with the letter 'p' could be entered using capitalized
versions of the commands; for example, P[rint], Pre[serve], and Pu[t] were all valid command names.
POSIX.1-2024 permits, but does not require, this historical practice because capital forms of the commands are used by some
implementations for other purposes.
Put
Historically, an ex put command, executed from open or visual mode, was the same as the open or
visual mode P command, if the buffer was named and was cut in character mode, and the same as the p command if the
buffer was named and cut in line mode. If the unnamed buffer was the source of the text, the entire line from which the text was
taken was usually put, and the buffer was handled as if in line mode, but it was possible to get extremely anomalous
behavior. In addition, using the Q command to switch into ex mode, and then doing a put often resulted in
errors as well, such as appending text that was unrelated to the (supposed) contents of the buffer. For consistency and simplicity
of specification, POSIX.1-2024 does not permit these behaviors. All ex put commands are required to operate in line
mode, and the contents of the buffers are not altered by changing the mode of the editor.
Read
Historically, an ex read command executed from open or visual mode, executed in an empty file, left
an empty line as the first line of the file. For consistency and simplicity of specification, POSIX.1-2024 does not permit this
behavior. Historically, a read in open or visual mode from a program left the cursor at the last line read in, not the
first. For consistency, POSIX.1-2024 does not permit this behavior.
Historical implementations of ex were unable to undo read commands that read from the output of a
program. For consistency, POSIX.1-2024 does not permit this behavior.
Historically, the ex and vi message after a successful read
or write command specified "characters", not "bytes". POSIX.1-2024 requires that the number of bytes be displayed, not
the number of characters, because it may be difficult in multi-byte implementations to determine the number of characters read.
Implementations are encouraged to clarify the message displayed to the user.
Historically, reads were not permitted on files other than type regular, except that FIFO files could be read
(probably only because they did not exist when ex and vi were originally written).
Because the historical ex evaluated read! and read ! equivalently, there can be no optional way to force
the read. POSIX.1-2024 permits, but does not require, this behavior.
Recover
Some historical implementations of the editor permitted users to recover the edit buffer contents from a previous
edit session, and then exit without saving those contents (or explicitly discarding them). The intent of POSIX.1-2024 in requiring
that the edit buffer be treated as already modified is to prevent this user error.
Rewind
Historical implementations supported the rewind command when the user was editing the first file in the
list; that is, the file that the rewind command would edit. POSIX.1-2024 requires conformance to historical practice.
Substitute
Historically, ex accepted an r option to the s command. The effect of the r option was
to use the last regular expression used in any command as the pattern, the same as the ~ command. The r option is not
required by POSIX.1-2024. Historically, the c and g options were toggled; for example, the command :s/abc/def/
was the same as s/abc/def/ccccgggg. For simplicity of specification, POSIX.1-2024 does not permit this behavior.
The tilde command is often used to replace the last search RE. For example, in the sequence:
s/red/blue/
/green
~
the ~ command is equivalent to:
s/green/blue/
Historically, ex accepted all of the following forms:
s/abc/def/
s/abc/def
s/abc/
s/abc
POSIX.1-2024 requires conformance to this historical practice.
The s command presumes that the '^' character only occupies a single column in the display. Much of
the ex and vi specification presumes that the  only occupies a single
column in the display. There are no known character sets for which this is not true.
Historically, the final column position for the substitute commands was based on previous column movements; a
search for a pattern followed by a substitution would leave the column position unchanged, while a 0 command followed by a
substitution would change the column position to the first non-. For consistency and simplicity of specification,
POSIX.1-2024 requires that the final column position always be set to the first non-.
Set
Historical implementations redisplayed all of the options for each occurrence of the all keyword.
POSIX.1-2024 permits, but does not require, this behavior.
Tag
No requirement is made as to where ex and vi shall look for the
file referenced by the tag entry. Historical practice has been to look for the path found in the tags file, based on the
current directory. A useful extension found in some implementations is to look based on the directory containing the tags file that
held the entry, as well. No requirement is made as to which reference for the tag in the tags file is used. This is deliberate, in
order to permit extensions such as multiple entries in a tags file for a tag.
Because users often specify many different tags files, some of which need not be relevant or exist at any
particular time, POSIX.1-2024 requires that error messages about problem tags files be displayed only if the requested tag is not
found, and then, only once for each time that the tag edit option is changed.
The requirement that the current edit buffer be unmodified is only necessary if the file indicated by the tag entry
is not the same as the current file (as defined by the current pathname). Historically, the file would be reloaded if the filename
had changed, as well as if the filename was different from the current pathname. For consistency and simplicity of specification,
POSIX.1-2024 does not permit this behavior, requiring that the name be the only factor in the decision.
Historically, vi only searched for tags in the current file from the
current cursor to the end of the file, and therefore, if the wrapscan option was not set, tags occurring before the current
cursor were not found. POSIX.1-2024 considers this a bug, and implementations are required to search for the first occurrence in
the file, regardless.
Undo
The undo description deliberately uses the word "modified". The undo command is not intended to
undo commands that replace the contents of the edit buffer, such as edit, next, tag, or recover.
Cursor positioning after the undo command was inconsistent in the historical vi, sometimes attempting to restore the original cursor position (global, undo, and
v commands), and sometimes, in the presence of maps, placing the cursor on the last line added or changed instead of the
first. POSIX.1-2024 requires a simplified behavior for consistency and simplicity of specification.
Version
The version command cannot be exactly specified since there is no widely-accepted definition of what the
version information should contain. Implementations are encouraged to do something reasonably intelligent.
Write
Historically, the ex and vi message after a successful read
or write command specified "characters", not "bytes". POSIX.1-2024 requires that the number of bytes be displayed, not
the number of characters because it may be difficult in multi-byte implementations to determine the number of characters written.
Implementations are encouraged to clarify the message displayed to the user.
Implementation-defined tests are permitted so that implementations can make additional checks; for example, for
locks or file modification times.
Historically, attempting to append to a nonexistent file caused an error. It has been left unspecified in
POSIX.1-2024 to permit implementations to let the write succeed, so that the append semantics are similar to those of the
historical csh.
Historical vi permitted empty edit buffers to be written. However, since
the way vi got around dealing with "empty" files was to always have a line in the edit
buffer, no matter what, it wrote them as files of a single, empty line. POSIX.1-2024 does not permit this behavior.
Historically, ex restored standard output and standard error to their values as of when ex was
invoked, before writes to programs were performed. This could disturb the terminal configuration as well as be a security issue for
some terminals. POSIX.1-2024 does not permit this, requiring that the program output be captured and displayed as if by the
ex print command.
Adjust Window
Historically, the line count was set to the value of the scroll option if the type character was
end-of-file. This feature was broken on most historical implementations long ago, however, and is not documented anywhere. For this
reason, POSIX.1-2024 is resolutely silent.
Historically, the z command was -sensitive and z + and z - did
different things than z+ and z- because the type could not be distinguished from a flag. (The commands
z . and z = were historically invalid.) POSIX.1-2024 requires conformance to this historical practice.
Historically, the z command was further -sensitive in that the count could not be
-delimited; for example, the commands z= 5 and z- 5 were also invalid. Because the
count is not ambiguous with respect to either the type character or the flags, this is not permitted by POSIX.1-2024.
Escape
Historically, ex filter commands only read the standard output of the commands, letting standard error
appear on the terminal as usual. The vi utility, however, read both standard output and
standard error. POSIX.1-2024 requires the latter behavior for both ex and vi, for
consistency.
In Issue 8 the system() function was changed to require that the
POSIX shell be invoked with "sh", "-c", "--", and command arguments to make it easier to execute
programs with  ('-') or  ('+') as the first character of the program's
filename. A similar request to have the ex escape command do the same was not accepted. Unlike system() (which always invokes a POSIX shell), ex invokes the program named by the
shell edit option. For example, the csh and tcsh shells that are frequently used as login shells do not
recognize "--" after "-c" as an end-of-options indicator. The program need not even be one that recognizes any
POSIX shell command line syntax. Some users invoke shell scripts to process lines that are being supplied to the specified utility.
These utilities know that they will be given "-c" as a first argument and just ignore it. Any utilities used in this
manner would have to be modified to skip over another argument (the "--") to find the desired argument.
Shift Left and Shift Right
Historically, it was possible to add shift characters to increase the effect of the command; for example,
>> indented) the lines 3 levels of indentation instead of the default 1.
POSIX.1-2024 requires conformance to historical practice.
-D
Historically, the -D command erased the prompt, providing the user with an unbroken presentation of
lines from the edit buffer. This is not required by POSIX.1-2024; implementations are encouraged to provide it if possible.
Historically, the -D command took, and then ignored, a count. POSIX.1-2024 does not permit this behavior.
Write Line Number
Historically, the ex = command, when executed in ex mode in an empty edit buffer, reported 0,
and from open or visual mode, reported 1. For consistency and simplicity of specification, POSIX.1-2024 does not permit this
behavior.
Execute
Historically, ex did not correctly handle the inclusion of text input commands (that is, append,
insert, and change) in executed buffers. POSIX.1-2024 does not permit this exclusion for consistency.
Historically, the logical contents of the buffer being executed did not change if the buffer itself were modified
by the commands being executed; that is, buffer execution did not support self-modifying code. POSIX.1-2024 requires conformance to
historical practice.
Historically, the @ command took a range of lines, and the @ buffer was executed once per line, with
the current line ('.') set to each specified line. POSIX.1-2024 requires conformance to historical practice.
Some historical implementations did not notice if errors occurred during buffer execution. This, coupled with the
ability to specify a range of lines for the ex @ command, makes it trivial to cause them to drop core.
POSIX.1-2024 requires that implementations stop buffer execution if any error occurs, if the specified line doesn't exist, or if
the contents of the edit buffer itself are replaced (for example, the buffer executes the ex :edit command).
Regular Expressions in ex
Historical practice is that the characters in the replacement part of the last s command—that is, those
matched by entering a '~' in the regular expression—were not further expanded by the regular expression engine. So, if the
characters contained the string "a.," they would match 'a' followed by ".," and not 'a'
followed by any character. POSIX.1-2024 requires conformance to historical practice.
Edit Options in ex
The following paragraphs describe the historical behavior of some edit options that were not, for whatever reason,
included in POSIX.1-2024. Implementations are strongly encouraged to only use these names if the functionality described here is
fully supported.
extended
The extended edit option has been used in some implementations of vi to
provide extended regular expressions instead of basic regular expressions This option was omitted from POSIX.1-2024 because it is
not widespread historical practice.
flash
The flash edit option historically caused the screen to flash instead of beeping on error. This option was omitted from
POSIX.1-2024 because it is not found in some historical implementations.
hardtabs
The hardtabs edit option historically defined the number of columns between hardware tab settings. This option was
omitted from POSIX.1-2024 because it was believed to no longer be generally useful.
modeline
The modeline (sometimes named modelines) edit option historically caused ex or vi to read the five first and last lines of the file for editor commands. This option is a
security problem, and vendors are strongly encouraged to delete it from historical implementations.
open
The open edit option historically disallowed the ex open and visual commands. This edit option was
omitted because these commands are required by POSIX.1-2024.
optimize
The optimize edit option historically expedited text throughput by setting the terminal to not do automatic
characters when printing more than one logical line of output. This option was omitted from POSIX.1-2024
because it was intended for terminals without addressable cursors, which are rarely, if ever, still used.
ruler
The ruler edit option has been used in some implementations of vi to present a
current row/column ruler for the user. This option was omitted from POSIX.1-2024 because it is not widespread historical
practice.
sourceany
The sourceany edit option historically caused ex or vi to source
start-up files that were owned by users other than the user running the editor. This option is a security problem, and vendors are
strongly encouraged to remove it from their implementations.
timeout
The timeout edit option historically enabled the (now standard) feature of only waiting for a short period before
returning keys that could be part of a macro. This feature was omitted from POSIX.1-2024 because its behavior is now standard, it
is not widely useful, and it was rarely documented.
verbose
The verbose edit option has been used in some implementations of vi to cause
vi to output error messages for common errors; for example, attempting to move the cursor
past the beginning or end of the line instead of only alerting the screen. (The historical vi only alerted the terminal and presented no message for such errors. The historical editor
option terse did not select when to present error messages, it only made existing error messages more or less verbose.) This
option was omitted from POSIX.1-2024 because it is not widespread historical practice; however, implementors are encouraged to use
it if they wish to provide error messages for naive users.
wraplen
The wraplen edit option has been used in some implementations of vi to specify
an automatic margin measured from the left margin instead of from the right margin. This is useful when multiple screen sizes are
being used to edit a single file. This option was omitted from POSIX.1-2024 because it is not widespread historical practice;
however, implementors are encouraged to use it if they add this functionality.
autoindent, ai
Historically, the command 0a did not do any autoindentation, regardless of the current indentation of line
1. POSIX.1-2024 requires that any indentation present in line 1 be used.
autoprint, ap
Historically, the autoprint edit option was not completely consistent or based solely on modifications to
the edit buffer. Exceptions were the read command (when reading from a file, but not from a filter), the append,
change, insert, global, and v commands, all of which were not affected by autoprint, and the
tag command, which was affected by autoprint. POSIX.1-2024 requires conformance to historical practice.
Historically, the autoprint option only applied to the last of multiple commands entered using
delimiters; for example, delete  was affected by autoprint, but
delete|version  was not. POSIX.1-2024 requires conformance to historical practice.
autowrite, aw
Appending the '!' character to the ex next command to avoid performing an automatic write
was not supported in historical implementations. POSIX.1-2024 requires that the behavior match the other ex commands for
consistency.
ignorecase, ic
Historical implementations of case-insensitive matching (the ignorecase edit option) lead to
counter-intuitive situations when uppercase characters were used in range expressions. Historically, the process was as
follows:
Take a line of text from the edit buffer.
Convert uppercase to lowercase in text line.
Convert uppercase to lowercase in regular expressions, except in character class specifications.
Match regular expressions against text.
This would mean that, with ignorecase in effect, the text:
The cat sat on the mat
would be matched by
/^the/
but not by:
/^[A-Z]he/
For consistency with other commands implementing regular expressions, POSIX.1-2024 does not permit this
behavior.
paragraphs, para
The ISO POSIX-2:1993 standard made the default paragraphs and sections edit options
implementation-defined, arguing they were historically oriented to the UNIX system troff text formatter, and a "portable
user" could use the {, }, [[, ]], (, and ) commands in open or visual mode and have the
cursor stop in unexpected places. POSIX.1-2024 specifies their values in the POSIX locale because the unusual grouping (they only
work when grouped into two characters at a time) means that they cannot be used for general-purpose movement, regardless.
readonly
Implementations are encouraged to provide the best possible information to the user as to the read-only status of
the file, with the exception that they should not consider the current special privileges of the process. This provides users with
a safety net because they must force the overwrite of read-only files, even when running with additional privileges.
The readonly edit option specification largely conforms to historical practice. The only difference is that
historical implementations did not notice that the user had set the readonly edit option in cases where the file was already
marked read-only for some reason, and would therefore reinitialize the readonly edit option the next time the contents of
the edit buffer were replaced. This behavior is disallowed by POSIX.1-2024.
report
The requirement that lines copied to a buffer interact differently than deleted lines is historical practice. For
example, if the report edit option is set to 3, deleting 3 lines will cause a report to be written, but 4 lines must be
copied before a report is written.
The requirement that the ex global, v, open, undo, and visual commands
present reports based on the total number of lines added or deleted during the command execution, and that commands executed by the
global and v commands not present reports, is historical practice. POSIX.1-2024 extends historical practice by
requiring that buffer execution be treated similarly. The reasons for this are two-fold. Historically, only the report by the last
command executed from the buffer would be seen by the user, as each new report would overwrite the last. In addition, the standard
developers believed that buffer execution had more in common with global and v commands than it did with other
ex commands, and should behave similarly, for consistency and simplicity of specification.
showmatch, sm
The length of time the cursor spends on the matching character is unspecified because the timing capabilities of
systems are often inexact and variable. The time should be long enough for the user to notice, but not long enough for the user to
become annoyed. Some implementations of vi have added a matchtime option that
permits users to set the number of 0,1 second intervals the cursor pauses on the matching character.
showmode
The showmode option has been used in some historical implementations of ex and vi to display the current editing mode when in open or visual mode. The editing modes have
generally included "command" and "input", and sometimes other modes such as "replace" and "change". The string was usually
displayed on the bottom line of the screen at the far right-hand corner. In addition, a preceding '*' character often
denoted whether the contents of the edit buffer had been modified. The latter display has sometimes been part of the
showmode option, and sometimes based on another option. This option was not available in the 4 BSD historical implementation
of vi, but was viewed as generally useful, particularly to novice users, and is required
by POSIX.1-2024.
The smd shorthand for the showmode option was not present in all historical implementations of the
editor. POSIX.1-2024 requires it, for consistency.
Not all historical implementations of the editor displayed a mode string for command mode, differentiating command
mode from text input mode by the absence of a mode string. POSIX.1-2024 permits this behavior for consistency with historical
practice, but implementations are encouraged to provide a display string for both modes.
slowopen
Historically, the slowopen option was automatically set if the terminal baud rate was less than 1200 baud,
or if the baud rate was 1200 baud and the redraw option was not set. The slowopen option had two effects. First, when
inserting characters in the middle of a line, characters after the cursor would not be pushed ahead, but would appear to be
overwritten. Second, when creating a new line of text, lines after the current line would not be scrolled down, but would appear to
be overwritten. In both cases, ending text input mode would cause the screen to be refreshed to match the actual contents of the
edit buffer. Finally, terminals that were sufficiently intelligent caused the editor to ignore the slowopen option.
POSIX.1-2024 permits most historical behavior, extending historical practice to require slowopen behaviors if the edit
option is set by the user.
tags
The default path for tags files is left unspecified as implementations may have their own tags
implementations that do not correspond to the historical ones. The default tags option value should probably at least
include the file ./tags.
term
Historical implementations of ex and vi ignored changes to the
term edit option after the initial terminal information was loaded. This is permitted by POSIX.1-2024; however,
implementations are encouraged to permit the user to modify their terminal type at any time.
terse
Historically, the terse edit option optionally provided a shorter, less descriptive error message, for some
error messages. This is permitted, but not required, by POSIX.1-2024. Historically, most common visual mode errors (for example,
trying to move the cursor past the end of a line) did not result in an error message, but simply alerted the terminal.
Implementations wishing to provide messages for novice users are urged to do so based on the edit option verbose, and
not terse.
window
In historical implementations, the default for the window edit option was based on the baud rate as
follows:
If the baud rate was less than 1200, the edit option w300 set the window value; for example, the
line:
set w300=12
would set the window option to 12 if the baud rate was less than 1200.
If the baud rate was equal to 1200, the edit option w1200 set the window value.
If the baud rate was greater than 1200, the edit option w9600 set the window value.
The w300, w1200, and w9600 options do not appear in POSIX.1-2024 because of their dependence
on specific baud rates.
In historical implementations, the size of the window displayed by various commands was related to, but not
necessarily the same as, the window edit option. For example, the size of the window was set by the ex command
visual 10, but it did not change the value of the window edit option. However, changing the value of the
window edit option did change the number of lines that were displayed when the screen was repainted. POSIX.1-2024 does not
permit this behavior in the interests of consistency and simplicity of specification, and requires that all commands that change
the number of lines that are displayed do it by setting the value of the window edit option.
wrapmargin, wm
Historically, the wrapmargin option did not affect maps inserting characters that also had associated
counts; for example :map K 5aABC DEF. Unfortunately, there are widely used maps that depend on this
behavior. For consistency and simplicity of specification, POSIX.1-2024 does not permit this behavior.
Historically, wrapmargin was calculated using the column display width of all characters on the screen. For
example, an implementation using "^I" to represent  characters when the list edit option was set, where
'^' and 'I' each took up a single column on the screen, would calculate the wrapmargin based on a value of
2 for each . The number edit option similarly changed the effective length of the line as well. POSIX.1-2024
requires conformance to historical practice.
Earlier versions of this standard allowed for implementations with bytes other than eight bits, but this has been
modified in this version.
FUTURE DIRECTIONS
If this utility is directed to create a new directory entry that contains any bytes that have the encoded value of a
character, implementations are encouraged to treat this as an error. A future version of this standard may require
implementations to treat this as an error.
SEE ALSO
2.9.1.4 Command Search and Execution, ctags, ed, sed, sh, stty, vi
XBD Escape Sequences and Associated Actions, 8. Environment Variables, 9.3
Basic Regular Expressions, 12.2 Utility Syntax Guidelines
XSH access()
CHANGE HISTORY
First released in Issue 2.
Issue 5
The FUTURE DIRECTIONS section is added.
Issue 6
This utility is marked as part of the User Portability Utilities option.
The obsolescent SYNOPSIS is removed, removing the +command and - options.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX
Specification:
In the map command description, the sequence #digit is added.
The directory, edcompatible, redraw, and slowopen edit options are added.
The ex utility is extensively changed for alignment with the IEEE P1003.2b draft standard. This
includes changes as a result of the IEEE PASC Interpretations 1003.2 #31, #38, #49, #50, #51, #52, #55, #56, #57, #61, #62, #63,
#64, #65, and #78.
The -l option is removed.
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/23 is applied, correcting a URL.
IEEE Std 1003.1-2001/Cor 2-2004, item XCU/TC2/D6/8 is applied, making an editorial correction in the
EXTENDED DESCRIPTION.
IEEE Std 1003.1-2001/Cor 2-2004, item XCU/TC2/D6/9 is applied, removing text describing behavior on
systems with bytes consisting of more than eight bits.
Issue 7
Austin Group Interpretation 1003.1-2001 #027 is applied, clarifying the behavior if an operand is '-'.
Austin Group Interpretation 1003.1-2001 #036 is applied, clarifying the behavior for BREs.
Austin Group Interpretation 1003.1-2001 #121 is applied, clarifying the ex write command.
Austin Group Interpretation 1003.1-2001 #156 is applied.
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0093 [584] is applied.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to disallow the creation of filenames containing any bytes that
have the encoded value of a  character.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
Austin Group Defect 1185 is applied, changing the SIGCONT entry in ASYNCHRONOUS EVENTS and adding a SIGWINCH
entry.
Austin Group Defect 1251 is applied, clarifying the set command, changing "addr" to "2addr" in the
! command synopsis, and adding spaces in some synopsis lines.
Austin Group Defect 1281 is applied, changing the description of the substitute command to clarify that it
is an error if the substitution fails on every addressed line.
Austin Group Defect 1298 is applied, changing the CONSEQUENCES OF ERRORS section.
Austin Group Defect 1378 is applied, changing the description of the LC_MESSAGES environment variable.
Austin Group Defect 1529 is applied, changing the synopsis of the escape command and adding related
paragraphs to the APPLICATION USAGE and RATIONALE sections.
Austin Group Defect 1642 is applied, changing the description of the redraw edit option.
Austin Group Defect 1662 is applied, clarifying requirements relating to delimiters in addresses and in s
commands.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/awk.html =====
awk
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
awk — pattern scanning and processing language
SYNOPSIS
awk [-F sepstring] [-v assignment]... program
[argument...]
awk [-F sepstring] -f progfile [-f
progfile]... [-v assignment]...
[argument...]
DESCRIPTION
The awk utility shall execute programs written in the awk programming language, which is specialized for textual
data manipulation. An awk program is a sequence of patterns and corresponding actions. When input is read that matches a
pattern, the action associated with that pattern is carried out.
Input shall be interpreted as a sequence of records. By default, a record is a line, less its terminating , but
this can be changed by using the RS built-in variable. Each record of input shall be matched in turn against each pattern in
the program. For each pattern matched, the associated action shall be executed.
The awk utility shall interpret each input record as a sequence of fields where, by default, a field is a string of
non- non- characters. This default  and  field delimiter can be changed by
using the FS built-in variable or the -F sepstring option. The awk utility shall denote the first field
in a record $1, the second $2, and so on. The symbol $0 shall refer to the entire record; setting any other field causes the
re-evaluation of $0. Assigning to $0 shall reset the values of all other fields and the NF built-in variable.
OPTIONS
The awk utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following options shall be supported:
-F sepstring
Define the input field separator. This option shall be equivalent to:
-v FS=sepstring
except that if -F sepstring and -v FS=sepstring are both used, it is unspecified whether
the FS assignment resulting from -F sepstring is processed in command line order or is processed after the
last -v FS=sepstring. See the description of the FS built-in variable, and how it is used, in the
EXTENDED DESCRIPTION section.
-f progfile
Specify the pathname of the file progfile containing an awk program. A pathname of '-' shall denote the
standard input. If multiple instances of this option are specified, the concatenation of the files specified as progfile in
the order specified shall be the awk program. The awk program can alternatively be specified in the command line as a
single argument.
-v assignment
The application shall ensure that the assignment argument is in the same form as an assignment operand. The specified
variable assignment shall occur prior to executing the awk program, including the actions associated with BEGIN
patterns (if any). Multiple occurrences of this option can be specified.
OPERANDS
The following operands shall be supported:
program
If no -f option is specified, the first operand to awk shall be the text of the awk program. The
application shall supply the program operand as a single argument to awk. If the text does not end in a
, awk shall interpret the text as if it did.
argument
Either of the following two types of argument can be intermixed:
file
A pathname of a file that contains the input to be read, which is matched against the set of patterns in the program. If no
file operands or their equivalents, achieved by modifying the awk variables ARGV and ARGC, are
specified, or if a file operand is '-', the standard input shall be used.
assignment
An operand that begins with an  or alphabetic character from the portable character set (see the table in XBD
6.1 Portable Character Set), followed by a sequence of underscores,
digits, and alphabetics from the portable character set, followed by the '=' character, shall specify a variable
assignment rather than a pathname. The characters before the '=' represent the name of an awk variable; if that
name is an awk reserved word (see Grammar) the behavior is undefined. The characters
following the  shall be interpreted as if they appeared in the awk program preceded and followed by a
double-quote ('"' ) character, as a STRING token (see Grammar), except that if the
last character is an unescaped , it shall be interpreted as a literal  rather than as the first
character of the sequence "\"". The variable shall be assigned the value of that STRING token and, if appropriate,
shall be considered a numeric string (see Expressions in awk), the variable shall also be
assigned its numeric value. Each such variable assignment shall occur just prior to the processing of the following file, if
any. Thus, an assignment before the first file argument shall be executed after the BEGIN actions (if any), while an
assignment after the last file argument shall occur before the END actions (if any). If there are no file
arguments or their equivalents, achieved by modifying the awk variables ARGV and ARGC, assignments shall be
executed before processing the standard input.
STDIN
The standard input shall be used only if no file operands or their equivalents, achieved by modifying the awk
variables ARGV and ARGC, are specified; or if a file operand, or its equivalent, is '-'; or if a
progfile option-argument is '-'; see the INPUT FILES section. If the awk program contains no actions and no
patterns, but is otherwise a valid awk program, standard input and any file operands shall not be read and awk
shall exit with a return status of zero.
INPUT FILES
Input files to the awk program from any of the following sources shall be text files:
Any file operands or their equivalents, achieved by modifying the awk variables ARGV and ARGC
Standard input in the absence of any file operands, or their equivalents
Arguments to the getline function
Whether the variable RS is set to a value other than a  or not, for these files, implementations shall
support records terminated with the specified separator up to {LINE_MAX} bytes and may support longer records.
If -f progfile is specified, the application shall ensure that the files named by each of the progfile
option-arguments are text files and their concatenation, in the same order as they appear in the arguments, is an awk
program.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of awk:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_COLLATE
Determine the locale for the behavior of ranges, equivalence classes, and multi-character collating elements within regular
expressions and in comparisons of string values.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files), the behavior of character classes within regular expressions, the
identification of characters as letters, and the mapping of uppercase and lowercase characters for the toupper and
tolower functions.
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
LC_NUMERIC
Determine the radix character used when interpreting numeric input, performing conversions between numeric and string values, and
formatting numeric output. Regardless of locale, the  character (the decimal-point character of the POSIX locale) is
the decimal-point character recognized in processing awk programs (including assignments in command line arguments).
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
PATH
Determine the search path when looking for commands executed by system(expr), or input and output pipes; see XBD
8. Environment Variables.
In addition, all environment variables shall be visible via the awk variable ENVIRON.
ASYNCHRONOUS EVENTS
Default.
STDOUT
The nature of the output files depends on the awk program.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
The nature of the output files depends on the awk program.
EXTENDED DESCRIPTION
Overall Program Structure
An awk program is composed of pairs of the form:
pattern { action }
Either the pattern or the action (including the enclosing brace characters) can be omitted.
A missing pattern shall match any record of input, and a missing action shall be equivalent to:
{ print }
Execution of the awk program shall start by first executing the actions associated with all BEGIN patterns in the
order they occur in the program. Then each file operand (or standard input if no files were specified) shall be processed in
turn by reading data from the file until a record separator is seen ( by default). Before the first reference to a
field in the record is evaluated, the record shall be split into fields, according to the rules in Regular Expressions, using the value of FS that was current at the time the record was read. Each
pattern in the program then shall be evaluated in the order of occurrence, and the action associated with each pattern that matches
the current record executed. The action for a matching pattern shall be executed before evaluating subsequent patterns. Finally,
the actions associated with all END patterns shall be executed in the order they occur in the program.
Expressions in awk
Expressions describe computations used in patterns and actions. In the following table, valid expression
operations are given in groups from highest precedence first to lowest precedence last, with equal-precedence operators grouped
between horizontal lines. In expression evaluation, where the grammar is formally ambiguous, higher precedence operators shall be
evaluated before lower precedence operators. In this table expr, expr1, expr2, and expr3 represent any
expression, while lvalue represents any entity that can be assigned to (that is, on the left side of an assignment operator). The
precise syntax of expressions is given in Grammar.
Table: Expressions in Decreasing Precedence in awk
Syntax
Name
Type of Result
Associativity
(expr)
Grouping
Type of expr
N/A
$expr
Field reference
Uninitialized or String
N/A
lvalue ++
lvalue --
Post-increment
Post-decrement
Numeric
Numeric
N/A
N/A
++ lvalue
-- lvalue
Pre-increment
Pre-decrement
Numeric
Numeric
N/A
N/A
expr ^ expr
Exponentiation
Numeric
Right
! expr
+ expr
- expr
Logical not
Unary plus
Unary minus
Numeric
Numeric
Numeric
N/A
N/A
N/A
expr * expr
expr / expr
expr % expr
Multiplication
Division
Modulus
Numeric
Numeric
Numeric
Left
Left
Left
expr + expr
expr - expr
Addition
Subtraction
Numeric
Numeric
Left
Left
expr expr
String concatenation
String
Left
expr  expr
expr >= expr
Less than
Less than or equal to
Not equal to
Equal to
Greater than
Greater than or equal to
Numeric
Numeric
Numeric
Numeric
Numeric
Numeric
None
None
None
None
None
None
expr ˜ expr
expr !˜ expr
ERE match
ERE non-match
Numeric
Numeric
None
None
expr in array
(index) in array
Array membership
Multi-dimension array membership
Numeric
Numeric
Left
Left
expr && expr
Logical AND
Numeric
Left
expr || expr
Logical OR
Numeric
Left
expr1 ? expr2 : expr3
Conditional expression
Type of selectedexpr2 or expr3
Right
lvalue ^= expr
lvalue %= expr
lvalue *= expr
lvalue /= expr
lvalue += expr
lvalue -= expr
lvalue = expr
Exponentiation assignment
Modulus assignment
Multiplication assignment
Division assignment
Addition assignment
Subtraction assignment
Assignment
Numeric
Numeric
Numeric
Numeric
Numeric
Numeric
Type of expr
Right
Right
Right
Right
Right
Right
Right
Each expression shall have either a string value, a numeric value, or both. Except as stated for specific contexts,
the value of an expression shall be implicitly converted to the type needed for the context in which it is used. A string value
shall be converted to a numeric value either by the equivalent of the following calls to functions defined by the ISO C
standard:
setlocale(LC_NUMERIC, "");
numeric_value = atof(string_value);
or by converting the initial portion of the string to type double representation as follows:
The input string is decomposed into two parts: an initial, possibly empty, sequence of white-space characters (as
specified by isspace()) and a subject sequence interpreted as a floating-point
constant.
The expected form of the subject sequence is an optional '+' or '-' sign, then a non-empty
sequence of digits optionally containing a radix character, then an optional exponent part. An exponent part consists of
'e' or 'E', followed by an optional sign, followed by one or more decimal digits.
The sequence starting with the first digit or the radix character (whichever occurs first) is interpreted as a
floating constant of the C language, except that the radix character shall be used in place of a , and if neither an
exponent part nor a radix character appears, a radix character is assumed to follow the last digit in the string. If the subject
sequence begins with a , the value resulting from the conversion is negated.
A numeric value that is exactly equal to the value of an integer (see 1.1.2 Concepts Derived from the ISO C Standard) shall be converted to a
string by the equivalent of a call to the sprintf function (see String Functions) with the
string "%d" as the fmt argument and the numeric value being converted as the first and only expr argument.
Any other numeric value shall be converted to a string by the equivalent of a call to the sprintf function with the value of
the variable CONVFMT as the fmt argument and the numeric value being converted as the first and only expr
argument. The result of the conversion is unspecified if the value of CONVFMT is not a floating-point format specification.
This volume of POSIX.1-2024 specifies no explicit conversions between numbers and strings. An application can force an expression
to be treated as a number by adding zero to it, or can force it to be treated as a string by concatenating the null string
("") to it.
A string value shall be considered a numeric string if it comes from one of the following:
Field variables
Input from the getline() function
FILENAME
ARGV array elements
ENVIRON array elements
Array elements created by the split() function
A command line variable assignment
Variable assignment from another numeric string variable
and an implementation-dependent condition corresponding to either case (a) or (b) below is met.
After the equivalent of the following calls to functions defined by the ISO C standard,
string_value_end would differ from string_value, and any characters before the terminating null character in
string_value_end would be  characters:
char *string_value_end;
setlocale(LC_NUMERIC, "");
numeric_value = strtod (string_value, &string_value_end);
After all the following conversions have been applied, the resulting string would lexically be recognized as a
NUMBER token as described by the lexical conventions in Grammar:
All leading and trailing  characters are discarded.
If the first non- is '+' or '-', it is discarded.
Each occurrence of the radix character from the current locale is changed to a .
In case (a) the numeric value of the numeric string shall be the value that would be returned by the strtod() call. In case (b) if the first non- is '-', the numeric value
of the numeric string shall be the negation of the numeric value of the recognized NUMBER token; otherwise, the
numeric value of the numeric string shall be the numeric value of the recognized NUMBER token. Whether or not a
string is a numeric string shall be relevant only in contexts where that term is used in this section.
When an expression is used in a Boolean context, if it has a numeric value, a value of zero shall be treated as
false and any other value shall be treated as true. Otherwise, a string value of the null string shall be treated as false and any
other value shall be treated as true. A Boolean context shall be one of the following:
The first subexpression of a conditional expression
An expression operated on by logical NOT, logical AND, or logical OR
The second expression of a for statement
The expression of an if statement
The expression of the while clause in either a while or do...while statement
An expression used as a pattern (as in Overall Program Structure)
All arithmetic shall follow the semantics of floating-point arithmetic as specified by the ISO C standard (see
1.1.2 Concepts Derived from the ISO C Standard).
The value of the expression:
expr1 ^ expr2
shall be equivalent to the value returned by the ISO C standard function call:
pow(expr1, expr2)
The expression:
lvalue ^= expr
shall be equivalent to the ISO C standard expression:
lvalue = pow(lvalue, expr)
except that lvalue shall be evaluated only once. The value of the expression:
expr1 % expr2
shall be equivalent to the value returned by the ISO C standard function call:
fmod(expr1, expr2)
The expression:
lvalue %= expr
shall be equivalent to the ISO C standard expression:
lvalue = fmod(lvalue, expr)
except that lvalue shall be evaluated only once.
Variables and fields shall be set by the assignment statement:
lvalue = expression
and the type of expression shall determine the resulting variable type. The assignment includes the
arithmetic assignments ("+=", "-=", "*=", "/=", "%=", "^=", "++",
"--") all of which shall produce a numeric result. The left-hand side of an assignment and the target of increment and
decrement operators can be one of a variable, an array with index, or a field selector.
The awk language supplies arrays that are used for storing numbers or strings. Arrays need not be declared.
They shall initially be empty, and their sizes shall change dynamically. The subscripts, or element identifiers, are strings,
providing a type of associative array capability. An array name followed by a subscript within square brackets can be used as an
lvalue and thus as an expression, as described in the grammar; see Grammar. Unsubscripted array
names can be used in only the following contexts:
A parameter in a function definition or function call
The NAME token following any use of the keyword in as specified in the grammar (see Grammar); if the name used in this context is not an array name, the behavior is undefined
The NAME token following the keyword Delete without a subscript as specified in the grammar (see
Grammar); if the name used in this context is not an array name, the behavior is undefined.
A valid array index shall consist of one or more -separated expressions, similar to the way in
which multi-dimensional arrays are indexed in some programming languages. Because awk arrays are really one-dimensional,
such a -separated list shall be converted to a single string by concatenating the string values of the separate
expressions, each separated from the other by the value of the SUBSEP variable. Thus, the following two index operations
shall be equivalent:
var[expr1, expr2, ... exprn]
var[expr1 SUBSEP expr2 SUBSEP ... SUBSEP exprn]
The application shall ensure that a multi-dimensioned index used with the in operator is
parenthesized. The in operator, which tests for the existence of a particular array element, shall not cause that element to
exist. Any other reference to a nonexistent array element shall automatically create it.
Comparisons (with the '', and
">=" operators) shall be made numerically:
if both operands are numeric,
if one is numeric and the other has a string value that is a numeric string,
if both have string values that are numeric strings, or
if one is numeric and the other has the uninitialized value.
Otherwise, operands shall be converted to strings as required and a string comparison shall be made as follows:
For the "!=" and "==" operators, the strings shall be compared to check if they are identical
(not to check if they collate equally).
For the other operators, the strings shall be compared using the locale-specific collation sequence.
The value of the comparison expression shall be 1 if the relation is true, or 0 if the relation is false.
Variables and Special Variables
Variables can be used in an awk program by referencing them. With the exception of function parameters (see
User-Defined Functions), they are not explicitly declared. Function parameter names shall be local
to the function; all other variable names shall be global. The same name shall not be used as both a function parameter name and as
the name of a function or a special awk variable. The same name shall not be used both as a variable name with global scope
and as the name of a function. The same name shall not be used within the same scope both as a scalar variable and as an array.
Uninitialized variables, including scalar variables, array elements, and field variables, shall have an uninitialized value. An
uninitialized value shall have both a numeric value of zero and a string value of the empty string. Evaluation of variables with an
uninitialized value, to either string or numeric, shall be determined by the context in which they are used.
Field variables shall be designated by a '$' followed by a number or numerical expression. The effect of
the field number expression evaluating to anything other than a non-negative integer is unspecified; uninitialized variables
or string values need not be converted to numeric values in this context. New field variables can be created by assigning a value
to them. References to nonexistent fields (that is, fields after $NF), shall evaluate to the uninitialized value. Such
references shall not create new fields. However, assigning to a nonexistent field (for example, $(NF+2)=5) shall increase
the value of NF; create any intervening fields with the uninitialized value; and cause the value of $0 to be recomputed,
with the fields being separated by the value of OFS. Each field variable shall have a string value or an uninitialized value
when created. Field variables shall have the uninitialized value when created from $0 using FS and the variable does not
contain any characters. If appropriate, the field variable shall be considered a numeric string (see Expressions in awk).
Implementations shall support the following other special variables that are set by awk:
ARGC
A number determining when the iteration described for ARGV stops. When an awk program starts, ARGC shall
be initialized to the number of elements in the ARGV array. ARGC can be updated by the awk program and by
assignment operands. If ARGC is set to a value less than 1, the behavior is unspecified. It is unspecified whether
alterations to ARGC can be made using the -v option.
ARGV
An array containing, initially, the command name (see 2.9.1 Simple
Commands) used to invoke awk in ARGV[0] and the command line arguments, if any, excluding options and the
program operand, in ARGV[1] through ARGV[ARGC-1]. The elements in ARGV can be assigned new values
or deleted, and new elements can be added. Note that alterations to ARGV cannot be made using either the assignment
operand or the -v option, because an operand with a '[' before '=' is treated as a file operand,
not an assignment operand, and applications are required to ensure that the -v option-argument has the same form as
an assignment operand. (See the OPTIONS and OPERANDS sections.)
After processing the BEGIN actions, if any, awk begins interating over the elements of ARGV,
processing them as if they were argument operands. It shall behave as if the implementation maintains an internal counter
that is initialized to 1 and increments by 1 at the end of each iteration. For each iteration, the following shall occur:
If the internal counter is greater than or equal to the current value of ARGC and no file operands
have been processed, awk shall set FILENAME to '-' and process standard input as if it was given as a file
operand. The internal counter shall not be incremented at the end of this iteration.
Otherwise, if the internal counter is greater than or equal to the current value of ARGC, the iterations
shall stop and processing of the END actions, if any, shall begin. Any ARGV elements with index values greater than
or equal to ARGC shall not be processed as argument operands.
Otherwise, if the element ARGV[ internal counter value] does not exist, it is unspecified
whether that element is created. No other action shall be taken.
Otherwise, if ARGV[ internal counter value] is a null string, no action shall be
taken.
Otherwise, if ARGV[ internal counter value] matches the format of an assignment
operand (see OPERANDS), awk shall process the assignment.
Otherwise, ARGV[ internal counter value] shall be treated as a file operand,
FILENAME shall be set to that value, and the named file, or standard input if the value is '-', shall be processed
as an input file.
Since only non-null elements are processed, setting an element of ARGV to the null string or deleting it
means that it shall not be treated as an argument operand.
CONVFMT
The printf format for converting numbers to strings (except for output statements, where OFMT is used);
"%.6g" by default.
ENVIRON
An array representing the value of the environment, as described in the exec functions defined in the System Interfaces
volume of POSIX.1-2024. The indices of the array shall be strings consisting of the names of the environment variables, and the
value of each array element shall be a string consisting of the value of that variable. If appropriate, the environment variable
shall be considered a numeric string (see Expressions in awk); the array element shall also
have its numeric value.
In all cases where the behavior of awk is affected by environment variables (including the environment of
any commands that awk executes via the system function or via pipeline redirections with the print statement,
the printf statement, or the getline function), the environment used shall be the environment at the time awk
began executing; it is implementation-defined whether any modification of ENVIRON affects this environment.
FILENAME
The pathname used to open the current input file, or '-' if the file is standard input. Inside a BEGIN action
FILENAME shall be unset. Inside an END action the value shall be the name of the last input file processed. If an
application changes the value of FILENAME, the results are unspecified.
FNR
The ordinal number of the current record in the current file. Inside a BEGIN action the value shall be zero. Inside an
END action the value shall be the number of the last record processed in the last file processed.
FS
Input field separator regular expression; a  by default.
NF
The number of fields in the current record. Inside a BEGIN action, the use of NF is undefined unless a
getline function without a var argument is executed previously. Inside an END action, NF shall retain
the value it had for the last record read, unless a subsequent, redirected, getline function without a var argument
is performed prior to entering the END action.
NR
The ordinal number of the current record from the start of input. Inside a BEGIN action the value shall be zero. Inside
an END action the value shall be the number of the last record processed. Records skipped by the nextfile statement
shall not be included.
OFMT
The printf format for converting numbers to strings in output statements (see Output
Statements); "%.6g" by default. The result of the conversion is unspecified if the value of OFMT is not a
floating-point format specification.
OFS
The print statement output field separator;  by default.
ORS
The print statement output record separator; a  by default.
RLENGTH
The length of the string matched by the match function.
RS
The first character of the string value of RS shall be the input record separator; a  by default. If
RS contains more than one character, the results are unspecified. If RS is null, then records are separated by
sequences consisting of a  plus one or more blank lines, leading or trailing blank lines shall not result in empty
records at the beginning or end of the input, and a  shall always be a field separator, no matter what the value of
FS is.
RSTART
The starting position of the string matched by the match function, numbering from 1. This shall always be equivalent to
the return value of the match function.
SUBSEP
The subscript separator string for multi-dimensional arrays; the default value is implementation-defined.
Regular Expressions
The awk utility shall make use of the extended regular expression notation (see XBD 9.4 Extended Regular Expressions) except that it shall allow the use of
C-language conventions for escaping special characters within the EREs, as specified in the table in XBD 5. File Format Notation for '\\', '\a', '\b',
'\f', '\n', '\r', '\t', '\v' and in the following table for other sequences; these
escape sequences shall be recognized both inside and outside bracket expressions. Note that records need not be separated by
characters and string constants can contain  characters, so even the "\n" sequence is valid
in awk EREs. Using a  character within the lexical token ERE (except as one of the two delimiters)
requires the escaping shown in the following table.
Table: Escape Sequences in awk
Escape Sequence
Description
Meaning
\"
In the lexical token STRING,  character. Otherwise undefined.
\/
In the lexical token ERE,  character. Otherwise undefined.
\ddd
A  character followed by the longest sequence of one, two, or three octal-digit characters
(01234567). If all of the digits are 0 (that is, representation of the NUL character), the behavior is undefined. If the digits
produce a value greater than octal 377, the behavior is undefined.
The character whose encoding is represented by the one, two, or three-digit octal integer. Multi-byte characters
require multiple, concatenated escape sequences of this type, including the leading  for each byte.
\., \[, \(,\*, \+, \?, \{, \|, \^, \$
A  character followed by a character that has a special meaning in EREs (see XBD 9.4 Extended Regular Expressions), other than .
In the lexical token ERE when not inside a bracket expression, the sequence shall represent itself.
Otherwise undefined.
\\
Two  characters.
In the lexical token ERE, the sequence shall represent itself. In the lexical token STRING, it shall
represent a single .
\c
A  character followed by any character not described in this table or in the table in XBD 5. File Format Notation ('\\', '\a', '\b', '\f',
'\n', '\r', '\t', '\v').
Undefined
A regular expression can be matched against a specific field or string by using one of the two regular expression
matching operators, '~' and "!~". These operators shall interpret their right-hand operand as a regular
expression and their left-hand operand as a string. If the regular expression matches the string, the '~' expression shall
evaluate to a value of 1, and the "!~" expression shall evaluate to a value of 0. (The regular expression matching
operation is as defined by the term matched in XBD 9.1 Regular Expression
Definitions, where a match occurs on any part of the string unless the regular expression is limited with the
or  special characters.) If the regular expression does not match the string, the
'~' expression shall evaluate to a value of 0, and the "!~" expression shall evaluate to a value of 1. If the
right-hand operand is any expression other than the lexical token ERE, the string value of the expression shall be
interpreted as an extended regular expression, including the escape conventions described above. Note that these escape conventions
shall also be applied in determining the value of a string literal (the lexical token STRING), and thus shall be applied a
second time when a string literal is used in this context.
When an ERE token appears as an expression in any context other than as the right-hand of the '~'
or "!~" operator or as one of the built-in function arguments described below, the value of the resulting expression shall
be the equivalent of:
$0 ~ /ere/
The ere argument to the gsub, match, sub functions, and the fs argument to the
split function (see String Functions) shall be interpreted as extended regular expressions.
These can be either ERE tokens or arbitrary expressions, and shall be interpreted in the same manner as the right-hand side
of the '~' or "!~" operator.
An extended regular expression can be used to separate fields by assigning a string containing the expression to
the built-in variable FS, either directly or as a consequence of using the -F sepstring option. The default
value of the FS variable shall be a single . The following describes FS behavior:
If FS is a null string, the behavior is unspecified.
If FS is a single character:
If FS is , skip leading and trailing  and  characters; fields
shall be delimited by sets of one or more  or  characters.
Otherwise, if FS is any other character c, fields shall be delimited by each single occurrence of
c.
Otherwise, the string value of FS shall be considered to be an extended regular expression. Each occurrence
of a sequence of one or more characters matching the extended regular expression shall delimit fields.
When ERE matching is performed against input records; that is, the match is against $0 and the current value of $0
resulted from processing an input record, record separator characters (the first character of the value of the variable RS,
by default) cannot be embedded in the expression, and no expression shall match the record separator character. If
the record separator is not ,  characters embedded in the expression can be matched. When ERE
matching is not performed against input records, it shall be based on text strings; any character (including  and
the record separator) can be embedded in the pattern, and an appropriate pattern shall match any character. However, in all
awk ERE matching, the use of one or more NUL characters in the pattern, input record, or text string produces undefined
results.
Patterns
A pattern is any valid expression, a range specified by two expressions separated by a comma, or one
of the two special patterns BEGIN or END.
Special Patterns
The awk utility shall recognize two special patterns, BEGIN and END. Each BEGIN pattern
shall be matched once and its associated action executed before the first record of input is read—except possibly by use of the
getline function (see Input/Output and General Functions) in a prior BEGIN action—and
before command line assignment is done. Each END pattern shall be matched once and its associated action executed after the
last record of input has been read, or if there is no further input file to process following a nextfile statement. These
two patterns shall have associated actions.
BEGIN and END shall not combine with other patterns. Multiple BEGIN and END patterns
shall be allowed. The actions associated with the BEGIN patterns shall be executed in the order specified in the program, as
are the END actions. An END pattern can precede a BEGIN pattern in a program.
If an awk program consists of only actions with the pattern BEGIN, and the BEGIN action
contains no getline function, awk shall exit without reading its input when the last statement in the last
BEGIN action is executed. If an awk program consists of only actions with the pattern END or only actions with
the patterns BEGIN and END, the input shall be read before the statements in the END actions are executed.
Expression Patterns
An expression pattern shall be evaluated as if it were an expression in a Boolean context. If the result is true,
the pattern shall be considered to match, and the associated action (if any) shall be executed. If the result is false, the action
shall not be executed.
Pattern Ranges
A pattern range consists of two expressions separated by a comma; in this case, the action shall be performed for
all records between a match of the first expression and the following match of the second expression, inclusive. At this point, the
pattern range can be repeated starting at input records subsequent to the end of the matched range.
Actions
An action is a sequence of statements as shown in the grammar in Grammar. Any
single statement can be replaced by a statement list enclosed in curly braces. The application shall ensure that statements in a
statement list are separated by  or  characters. Statements in a statement list shall be executed
sequentially in the order that they appear.
The expression acting as the conditional in an if statement shall be evaluated and if it is non-zero
or non-null, the following statement shall be executed; otherwise, if else is present, the statement following the
else shall be executed.
The if, while, do...while, for, break, and continue statements are
based on the ISO C standard (see 1.1.2 Concepts Derived from the ISO C
Standard), except that the Boolean expressions shall be treated as described in Expressions in
awk, and except in the case of:
for (variable in array)
which shall iterate, assigning each index of array to variable in an unspecified order. The
results of adding new elements to array within such a for loop are undefined. If a break or continue
statement occurs outside of a loop, the behavior is undefined.
The delete statement shall remove either a specified individual array element or, if no element is
specified, all array elements. Thus, the following code:
for (index in array)
delete array[index]
is equivalent to:
delete array
Both delete all elements of the array.
The next statement shall cause all further processing of the current input record to be abandoned. The
behavior is undefined if a next statement appears or is invoked in a BEGIN or END action.
The nextfile statement shall cause all further processing of the current input file to be abandoned. The
behavior is undefined if a nextfile statement appears or is invoked in a BEGIN or END action, or in a
user-defined function.
The exit statement shall invoke all END actions in the order in which they occur in the program
source and then terminate the program without reading further input. An exit statement inside an END action shall
terminate the program without further execution of END actions. If an expression is specified in an exit statement,
its numeric value shall be the exit status of awk, unless subsequent errors are encountered or a subsequent exit
statement with an expression is executed.
Output Statements
Both print and printf statements shall write to standard output by default. The output shall be
written to the location specified by output_redirection if one is supplied, as follows:
> expression
>> expression
| expression
In all cases, the expression shall be evaluated to produce a string that is used as a pathname into which to
write (for '>' or ">>") or as a command to be executed (for '|'). Using the first two forms, if
the file of that name is not currently open, it shall be opened, creating it if necessary and using the first form, truncating the
file. The output then shall be appended to the file. As long as the file remains open, subsequent calls in which expression
evaluates to the same string value shall simply append output to the file. The file remains open until the close function
(see Input/Output and General Functions) is called with an expression that evaluates to the same
string value.
The third form shall write output onto a stream piped to the input of a command. The stream shall be created if no
stream is currently open with the value of expression as its command name. The stream created shall be equivalent to one
created by a call to the popen() function defined in the System Interfaces volume of
POSIX.1-2024 with the value of expression as the command argument and a value of w as the mode
argument. As long as the stream remains open, subsequent calls in which expression evaluates to the same string value shall
write output to the existing stream. The stream shall remain open until the close function (see Input/Output and General Functions) is called with an expression that evaluates to the same string value.
At that time, the stream shall be closed as if by a call to the pclose() function
defined in the System Interfaces volume of POSIX.1-2024.
As described in detail by the grammar in Grammar, these output statements shall
take a -separated list of expressions referred to in the grammar by the non-terminal symbols expr_list,
print_expr_list, or print_expr_list_opt. This list is referred to here as the expression list, and each member
is referred to as an expression argument.
The print statement shall write the value of each expression argument onto the indicated output stream
separated by the current output field separator (see variable OFS above), and terminated by the output record separator (see
variable ORS above). All expression arguments shall be taken as strings, being converted if necessary; this conversion shall
be as described in Expressions in awk, with the exception that the printf format in
OFMT shall be used instead of the value in CONVFMT. An empty expression list shall stand for the whole input record
($0).
The printf statement shall produce output based on a notation similar to the File Format Notation used to
describe file formats in this volume of POSIX.1-2024 (see XBD 5. File Format
Notation). Output shall be produced as specified with the first expression argument as the string format and
subsequent expression arguments as the strings arg1 to argn, inclusive, with the following exceptions:
The format shall be an actual character string rather than a graphical representation. Therefore, it cannot
contain empty character positions. The  in the format string, in any context other than a flag of a
conversion specification, shall be treated as an ordinary character that is copied to the output.
If the character set contains a 'Δ' character and that character appears in the format string, it
shall be treated as an ordinary character that is copied to the output.
The escape sequences beginning with a  character shall be treated as sequences of ordinary
characters that are copied to the output. Note that these same sequences shall be interpreted lexically by awk when they
appear in literal strings, but they shall not be treated specially by the printf statement.
A field width or precision can be specified as the '*' character instead of a digit string.
In this case the next argument from the expression list shall be fetched and its numeric value taken as the field width or
precision.
The implementation shall not precede or follow output from the d or u conversion specifier
characters with  characters not specified by the format string.
The implementation shall not precede output from the o conversion specifier character with leading zeros
not specified by the format string.
For the c conversion specifier character: if the argument has a numeric value, the character whose
encoding is that value shall be output. If the value is zero or is not the encoding of any character in the character set, the
behavior is undefined. If the argument does not have a numeric value, the first character of the string value shall be output; if
the string does not contain any characters, the behavior is undefined.
For each conversion specification that consumes an argument, the next expression argument shall be evaluated. With
the exception of the c conversion specifier character, the value shall be converted (according to the rules specified in
Expressions in awk) to the appropriate type for the conversion specification.
If there are insufficient expression arguments to satisfy all the conversion specifications in the format
string, the behavior is undefined.
If any character sequence in the format string begins with a '%' character, but does not form a
valid conversion specification, the behavior is unspecified.
Both print and printf can output at least {LINE_MAX} bytes.
Functions
The awk language has a variety of built-in functions: arithmetic, string, input/output, and general.
Function parameters, if present, can be either scalars or arrays; the behavior is undefined if an array name is
passed as a parameter that the function uses as a scalar, or if a scalar expression is passed as a parameter that the function uses
as an array. Function parameters shall be passed by value if scalar and by reference if array name.
Arithmetic Functions
The arithmetic functions, except for int, shall be based on the ISO C standard (see 1.1.2 Concepts Derived from the ISO C Standard). The behavior is undefined
in cases where the ISO C standard specifies that an error be returned or that the behavior is undefined. Although the grammar
(see Grammar) permits built-in functions to appear with no arguments or parentheses, unless the
argument or parentheses are indicated as optional in the following list (by displaying them within the "[]" brackets),
such use is undefined.
atan2(y,x)
Return arctangent of y/x in radians in the range [-ℼ,ℼ].
cos(x)
Return cosine of x, where x is in radians.
sin(x)
Return sine of x, where x is in radians.
exp(x)
Return the exponential function of x.
log(x)
Return the natural logarithm of x.
sqrt(x)
Return the square root of x.
int(x)
Return the argument truncated to an integer. Truncation shall be toward 0 when x>0.
rand()
Return a floating point pseudo-random number n, such that 0 ('&') appearing in the string repl shall be
replaced by the string from in that matches the ERE. An  preceded with a  shall be
interpreted as the literal  character. An occurrence of two consecutive  characters shall be
interpreted as just a single literal  character. Any other occurrence of a  (for example,
preceding any other character) shall be treated as a literal  character. Note that if repl is a string
literal (the lexical token STRING; see Grammar), the handling of the
character occurs after any lexical processing, including any lexical -escape sequence processing. If in is
specified and it is not an lvalue (see Expressions in awk), the behavior is undefined. If in
is omitted, awk shall use the current record ($0) in its place.
substr(s, m[, n ])
Return the at most n-character substring of s that begins at position m, numbering from 1. If n is
omitted, or if n specifies more characters than are left in the string, the length of the substring shall be limited by the
length of the string s.
tolower(s)
Return a string based on the string s. Each character in s that is an uppercase letter specified to have a
tolower mapping by the LC_CTYPE category of the current locale shall be replaced in the returned string by the
lowercase letter specified by the mapping. Other characters in s shall be unchanged in the returned string.
toupper(s)
Return a string based on the string s. Each character in s that is a lowercase letter specified to have a
toupper mapping by the LC_CTYPE category of the current locale is replaced in the returned string by the uppercase
letter specified by the mapping. Other characters in s are unchanged in the returned string.
All of the preceding functions that take ERE as a parameter expect a pattern or a string valued expression
that is a regular expression as defined in Regular Expressions.
Input/Output and General Functions
The input/output and general functions are:
close(expression)
Close the file or pipe opened by a print or printf statement or a call to getline with the same string-valued
expression. The limit on the number of open expression arguments is implementation-defined. If the close was
successful, the function shall return zero; otherwise, it shall return non-zero.
fflush([expression])
Write any unwritten data to the file or piped stream opened by a print or printf statement with the same
string-valued expression. If no argument, or if expression evaluates to the null string, then write all such data for
all such open files and piped streams, and standard output.
If fflush is successful, it shall return 0; otherwise, it shall return non-zero.
expression | getline [var]
Read a record of input from a stream piped from the output of a command. The stream shall be created if no stream is currently open
with the value of expression as its command name. The stream created shall be equivalent to one created by a call to the
popen() function with the value of expression as the command argument
and a value of r as the mode argument. As long as the stream remains open, subsequent calls in which
expression evaluates to the same string value shall read subsequent records from the stream. The stream shall remain open
until the close function is called with an expression that evaluates to the same string value. At that time, the stream
shall be closed as if by a call to the pclose() function. If var is omitted,
$0 and NF shall be set; otherwise, var shall be set and, if appropriate, it shall be considered a numeric string (see
Expressions in awk).
The getline operator can form ambiguous constructs when there are unparenthesized operators (including
concatenate) to the left of the '|' (to the beginning of the expression containing getline). In the context of the
'$' operator, '|' shall behave as if it had a lower precedence than '$'. The result of evaluating other
operators is unspecified, and conforming applications shall parenthesize properly all such usages.
getline
Set $0 to the next input record from the current input file. This form of getline shall set the NF, NR,
and FNR variables.
getline var
Set variable var to the next input record from the current input file and, if appropriate, var shall be
considered a numeric string (see Expressions in awk). This form of getline shall set the
FNR and NR variables.
getline [var]  characters, represent different files.
User-Defined Functions
The awk language also provides user-defined functions. Such functions can be defined as:
function name([parameter, ...]) { statements }
A function can be referred to anywhere in an awk program; in particular, its use can precede its definition.
The scope of a function is global.
The number of parameters in the function definition need not match the number of parameters in the function call.
Excess formal parameters can be used as local variables. If fewer arguments are supplied in a function call than are in the
function definition, the extra parameters that are used in the function body as scalars shall evaluate to the uninitialized value
until they are otherwise initialized, and the extra parameters that are used in the function body as arrays shall be treated as
uninitialized arrays where each element evaluates to the uninitialized value until otherwise initialized.
When invoking a function, no white space can be placed between the function name and the opening parenthesis.
Function calls can be nested and recursive calls can be made upon functions. Upon return from any nested or recursive function
call, the values of all of the calling function's parameters shall be unchanged, except for array parameters passed by reference.
The return statement can be used to return a value. If a return statement appears outside of a function definition,
the behavior is undefined.
In the function definition,  characters shall be optional before the opening brace and after the
closing brace. Function definitions can appear anywhere in the program where a pattern-action pair is allowed.
Grammar
The grammar in this section and the lexical conventions in the following section shall together describe the syntax
for awk programs. The general conventions for this style of grammar are described in 1.3 Grammar Conventions. A valid program can be represented as the non-terminal
symbol program in the grammar. This formal syntax shall take precedence over the preceding text syntax description.
%token NAME NUMBER STRING ERE
%token FUNC_NAME   /* Name followed by '(' without white space. */
/* Keywords */
%token       Begin   End
/*          'BEGIN' 'END'                                */
%token       Break   Continue   Delete   Do   Else
/*          'break' 'continue' 'delete' 'do' 'else'      */
%token       Exit   For   Function   If   In   Next
/*          'exit' 'for' 'function' 'if' 'in' 'next'     */
%token       Nextfile   Print   Printf   Return   While
/*          'nextfile' 'print' 'printf' 'return' 'while' */
/* Reserved function names */
%token BUILTIN_FUNC_NAME
/* One token for the following:
* atan2 cos sin exp log sqrt int rand srand
* gsub index length match split sprintf sub
* substr tolower toupper close fflush system
*/
%token GETLINE
/* Syntactically different from other built-ins. */
/* Two-character tokens. */
%token ADD_ASSIGN SUB_ASSIGN MUL_ASSIGN DIV_ASSIGN MOD_ASSIGN POW_ASSIGN
/*     '+='       '-='       '*='       '/='       '%='       '^=' */
%token OR   AND  NO_MATCH   EQ   LE   GE   NE   INCR  DECR  APPEND
/*     '||' '&&' '!~' '==' '=' '!=' '++'  '--'  '>>'   */
/* One-character tokens. */
%token '{' '}' '(' ')' '[' ']' ',' ';' NEWLINE
%token '+' '-' '*' '%' '^' '!' '>' ''    expr
| APPEND expr
| '|'    expr
;
expr_list_opt    : /* empty */
| expr_list
;
expr_list        : expr
| multiple_expr_list
;
multiple_expr_list : expr ',' newline_opt expr
| multiple_expr_list ',' newline_opt expr
;
expr_opt         : /* empty */
| expr
;
expr             : unary_expr
| non_unary_expr
;
unary_expr       : '+' expr
| '-' expr
| unary_expr '^'      expr
| unary_expr '*'      expr
| unary_expr '/'      expr
| unary_expr '%'      expr
| unary_expr '+'      expr
| unary_expr '-'      expr
| unary_expr          non_unary_expr
| unary_expr ''      expr
| unary_expr GE       expr
| unary_expr '~'      expr
| unary_expr NO_MATCH expr
| unary_expr In NAME
| unary_expr AND newline_opt expr
| unary_expr OR  newline_opt expr
| unary_expr '?' expr ':' expr
| unary_input_function
;
non_unary_expr   : '(' expr ')'
| '!' expr
| non_unary_expr '^'      expr
| non_unary_expr '*'      expr
| non_unary_expr '/'      expr
| non_unary_expr '%'      expr
| non_unary_expr '+'      expr
| non_unary_expr '-'      expr
| non_unary_expr          non_unary_expr
| non_unary_expr ''      expr
| non_unary_expr GE       expr
| non_unary_expr '~'      expr
| non_unary_expr NO_MATCH expr
| non_unary_expr In NAME
| '(' multiple_expr_list ')' In NAME
| non_unary_expr AND newline_opt expr
| non_unary_expr OR  newline_opt expr
| non_unary_expr '?' expr ':' expr
| NUMBER
| STRING
| lvalue
| ERE
| lvalue INCR
| lvalue DECR
| INCR lvalue
| DECR lvalue
| lvalue POW_ASSIGN expr
| lvalue MOD_ASSIGN expr
| lvalue MUL_ASSIGN expr
| lvalue DIV_ASSIGN expr
| lvalue ADD_ASSIGN expr
| lvalue SUB_ASSIGN expr
| lvalue '=' expr
| FUNC_NAME '(' expr_list_opt ')'
/* no white space allowed before '(' */
| BUILTIN_FUNC_NAME '(' expr_list_opt ')'
| BUILTIN_FUNC_NAME
| non_unary_input_function
;
print_expr_list_opt : /* empty */
| print_expr_list
;
print_expr_list  : print_expr
| print_expr_list ',' newline_opt print_expr
;
print_expr       : unary_print_expr
| non_unary_print_expr
;
unary_print_expr : '+' print_expr
| '-' print_expr
| unary_print_expr '^'      print_expr
| unary_print_expr '*'      print_expr
| unary_print_expr '/'      print_expr
| unary_print_expr '%'      print_expr
| unary_print_expr '+'      print_expr
| unary_print_expr '-'      print_expr
| unary_print_expr          non_unary_print_expr
| unary_print_expr '~'      print_expr
| unary_print_expr NO_MATCH print_expr
| unary_print_expr In NAME
| unary_print_expr AND newline_opt print_expr
| unary_print_expr OR  newline_opt print_expr
| unary_print_expr '?' print_expr ':' print_expr
;
non_unary_print_expr : '(' expr ')'
| '!' print_expr
| non_unary_print_expr '^'      print_expr
| non_unary_print_expr '*'      print_expr
| non_unary_print_expr '/'      print_expr
| non_unary_print_expr '%'      print_expr
| non_unary_print_expr '+'      print_expr
| non_unary_print_expr '-'      print_expr
| non_unary_print_expr          non_unary_print_expr
| non_unary_print_expr '~'      print_expr
| non_unary_print_expr NO_MATCH print_expr
| non_unary_print_expr In NAME
| '(' multiple_expr_list ')' In NAME
| non_unary_print_expr AND newline_opt print_expr
| non_unary_print_expr OR  newline_opt print_expr
| non_unary_print_expr '?' print_expr ':' print_expr
| NUMBER
| STRING
| lvalue
| ERE
| lvalue INCR
| lvalue DECR
| INCR lvalue
| DECR lvalue
| lvalue POW_ASSIGN print_expr
| lvalue MOD_ASSIGN print_expr
| lvalue MUL_ASSIGN print_expr
| lvalue DIV_ASSIGN print_expr
| lvalue ADD_ASSIGN print_expr
| lvalue SUB_ASSIGN print_expr
| lvalue '=' print_expr
| FUNC_NAME '(' expr_list_opt ')'
/* no white space allowed before '(' */
| BUILTIN_FUNC_NAME '(' expr_list_opt ')'
| BUILTIN_FUNC_NAME
;
lvalue           : NAME
| NAME '[' expr_list ']'
| '$' expr
;
non_unary_input_function : simple_get
| simple_get ' ('/') that is used to surround an ERE could also be the division
operator. This shall be resolved in such a way that wherever the division operator could appear, a  is assumed to be
the division operator. (There is no unary division operator.)
Each expression in an awk program shall conform to the precedence and associativity rules, even when this is
not needed to resolve an ambiguity. For example, because '$' has higher precedence than '++', the string
"$x++--" is not a valid awk expression, even though it is unambiguously parsed by the grammar as
"$(x++)--".
One convention that might not be obvious from the formal grammar is where  characters are
acceptable. There are several obvious placements such as terminating a statement, and a  can be used to escape
characters between any lexical tokens. In addition,  characters without  characters
can follow a comma, an open brace, logical AND operator ("&&"), logical OR operator ("||"), the do
keyword, the else keyword, and the closing parenthesis of an if, for, or while statement. For
example:
{ print  $1,
$2 }
Lexical Conventions
The lexical conventions for awk programs, with respect to the preceding grammar, shall be as follows:
Except as noted, awk shall recognize the longest possible token or delimiter beginning at a given
point.
A comment shall consist of any characters beginning with the  character and terminated by, but
excluding the next occurrence of, a . Comments shall have no effect, except to delimit lexical tokens.
The  shall be recognized as the token NEWLINE.
A  character immediately followed by a  shall have no effect.
The token STRING shall represent a string constant. A string constant shall begin with the character
'"'. Within a string constant, a  character shall be considered to begin an escape sequence as specified
in the table in XBD 5. File Format Notation ('\\', '\a',
'\b', '\f', '\n', '\r', '\t', '\v'). In addition, the escape sequences in
Escape Sequences in awk shall be recognized. A  shall not occur within a string constant.
A string constant shall be terminated by the first unescaped occurrence of the character '"' after the one that begins the
string constant. The value of the string shall be the sequence of all unescaped characters and values of escape sequences between,
but not including, the two delimiting '"' characters.
The token ERE represents an extended regular expression constant. An ERE constant shall begin with the
character. Within an ERE constant, a  character shall be considered to begin an escape sequence as
specified in the table in XBD 5. File Format Notation. In addition, the
escape sequences in Escape Sequences in awk shall be recognized. The application shall ensure that a
does not occur within an ERE constant. An ERE constant shall be terminated by the first unescaped occurrence of the
character after the one that begins the ERE constant. The extended regular expression represented by the ERE constant
shall be the sequence of all unescaped characters and values of escape sequences between, but not including, the two delimiting
characters.
A  shall have no effect, except to delimit lexical tokens or within STRING or ERE
tokens.
The token NUMBER shall represent a numeric constant. Its form and numeric value shall either be equivalent
to the decimal-floating-constant token as specified by the ISO C standard, or it shall be a sequence of decimal digits
and shall be evaluated as an integer constant in decimal. In addition, implementations may accept numeric constants with the form
and numeric value equivalent to the hexadecimal-constant and hexadecimal-floating-constant tokens as specified by the
ISO C standard. Note that these forms do not use the radix character from the current locale; they always use a
.
If the value is too large or too small to be representable (see 1.1.2 Concepts Derived from the ISO C Standard), the behavior is
undefined.
A sequence of underscores, digits, and alphabetics from the portable character set (see XBD 6.1 Portable Character Set), beginning with an  or alphabetic
character, shall be considered a word.
The following words are keywords that shall be recognized as individual tokens; the name of the token is the same
as the keyword:
BEGIN
break
continue
delete
do
else
END
exit
for
function
getline
if
in
next
nextfile
print
printf
return
while
The following words are names of built-in functions and shall be recognized as the token BUILTIN_FUNC_NAME:
atan2
close
cos
exp
fflush
gsub
index
int
length
log
match
rand
sin
split
sprintf
sqrt
srand
sub
substr
system
tolower
toupper
The above-listed keywords and names of built-in functions are considered reserved words.
The token NAME shall consist of a word that is not a keyword or a name of a built-in function and is not
followed immediately (without any delimiters) by the '(' character.
The token FUNC_NAME shall consist of a word that is not a keyword or a name of a built-in function,
followed immediately (without any delimiters) by the '(' character. The '(' character shall not be included as
part of the token.
The following two-character sequences shall be recognized as the named tokens:
Token Name
Sequence
Token Name
Sequence
ADD_ASSIGN
+=
NO_MATCH
!~
SUB_ASSIGN
-=
EQ
==
MUL_ASSIGN
*=
LE
=
MOD_ASSIGN
%=
NE
!=
POW_ASSIGN
^=
INCR
++
OR
||
DECR
--
AND
&&
APPEND
>>
The following single characters shall be recognized as tokens whose names are the character:
{ } ( ) [ ] , ; + - * % ^ ! >  character in any syntactic context where the token '/' or DIV_ASSIGN
could appear as the next token in a valid program, the longer of those two tokens that can be recognized shall be recognized. In
any other syntactic context where the token ERE could appear as the next token in a valid program, the token ERE
shall be recognized.
EXIT STATUS
The following exit values shall be returned:
0
All input files were processed successfully.
>0
An error occurred.
The exit status can be altered within the program by using an exit expression.
CONSEQUENCES OF ERRORS
If any file operand is specified and the named file cannot be accessed, awk shall write a diagnostic message to
standard error and terminate without any further action.
If the program specified by either the program operand or a progfile operand is not a valid
awk program (as specified in the EXTENDED DESCRIPTION section), the behavior is undefined.
The following sections are informative.
APPLICATION USAGE
Since  has a special meaning both in the assignment option-argument to the -v option and in the
assignment operand, applications that need to pass strings to awk without special interpretation of
should not use these methods but should instead make use of the ARGV or ENVIRON array.
The index, length, match, and substr functions should not be confused with similar
functions in the ISO C standard; the awk versions deal with characters, while the ISO C standard deals with
bytes.
Because the concatenation operation is represented by adjacent expressions rather than an explicit operator, it is
often necessary to use parentheses to enforce the proper evaluation precedence.
When using awk to process pathnames, it is recommended that LC_ALL, or at least LC_CTYPE and LC_COLLATE, are
set to POSIX or C in the environment, since pathnames can contain byte sequences that do not form valid characters in some locales,
in which case the utility's behavior would be undefined. In the POSIX locale each byte is a valid single-byte character, and
therefore this problem is avoided.
Since the "==" operator checks if strings are identical, not whether they collate equally, applications
needing to check whether strings collate equally can use:
a = b
To specify a file operand naming a file with a name containing an , users can use
"./" as the first two characters of a relative file pathname that starts with an  or an alphabetic
character to keep the file operand from being interpreted as an assignment operand. Similarly, "./-" can be
used to access a file named '-' in the current directory rather than use standard input.
EXAMPLES
The awk program specified in the command line is most easily specified within single-quotes (for example,
'program') for applications using sh, because awk programs commonly contain
characters that are special to the shell, including double-quotes. In the cases where an awk program contains single-quote
characters, it is usually easiest to specify most of the program as strings within single-quotes concatenated by the shell with
quoted single-quote characters. For example:
awk '/'\''/ { print "quote:", $0 }'
prints all lines from the standard input containing a single-quote character, prefixed with quote:.
The following are examples of simple awk programs:
Write to the standard output all input lines for which field 3 is greater than 5:
$3 > 5
Write every tenth line:
(NR % 10) == 0
Write any line with a substring matching the regular expression:
/(G|D)(2[0-9][[:alpha:]]*)/
Print any line with a substring containing a 'G' or 'D', followed by a sequence of digits and
characters. This example uses character classes digit and alpha to match language-independent digit and alphabetic
characters respectively:
/(G|D)([[:digit:][:alpha:]]*)/
Write any line in which the second field matches the regular expression and the fourth field does not:
$2 ~ /xyz/ && $4 !~ /xyz/
Write any line in which the second field contains a :
$2 ~ /\\/
Write any line in which the second field contains a . Note that -escapes are
interpreted twice; once in lexical processing of the string and once in processing the regular expression:
$2 ~ "\\\\"
Write the second to the last and the last field in each line. Separate the fields by a :
{OFS=":";print $(NF-1), $NF}
Write the line number and number of fields in each line. The three strings representing the line number, the
, and the number of fields are concatenated and that string is written to standard output:
{print NR ":" NF}
Write lines longer than 72 characters:
length($0) > 72
Write the first two fields in opposite order separated by OFS:
{ print $2, $1 }
Same, with input fields separated by a  or  and  characters, or both:
BEGIN { FS = ",[ \t]*|[ \t]+" }
{ print $2, $1 }
Add up the first column, print sum, and average:
{s += $1 }
END   {print "sum is ", s, " average is", s/NR}
Write fields in reverse order, one per line (many lines out for each line in):
{ for (i = NF; i > 0; --i) print $i }
Write all lines between occurrences of the strings start and stop:
/start/, /stop/
Write all lines whose first field is different from the previous one:
$1 != prev { print; prev = $1 }
Simulate echo:
BEGIN  {
for (i = 1; i  1) ...
if (!"wk" ~ /bwk/) ...
Several features have been added based on newer implementations of awk:
Multiple instances of -f progfile are permitted.
The new option -v assignment.
The new predefined variable ENVIRON.
New built-in functions toupper and tolower.
More formatting capabilities are added to printf to match the ISO C standard.
Earlier versions of this standard required implementations to support multiple adjacent s, lines
with one or more  before a rule (pattern-action pairs), and lines with only (s). These are
not required by this standard and are considered poor programming practice, but can be accepted by an implementation of awk
as an extension.
The overall awk syntax has always been based on the C language, with a few features from the shell command
language and other sources. Because of this, it is not completely compatible with any other language, which has caused confusion
for some users. It is not the intent of the standard developers to address such issues. A few relatively minor changes toward
making the language more compatible with the ISO C standard were made; most of these changes are based on similar changes in
recent implementations, as described above. There remain several C-language conventions that are not in awk. One of the
notable ones is the  operator, which is commonly used to specify multiple expressions in the C language for
statement. Also, there are various places where awk is more restrictive than the C language regarding the type of expression
that can be used in a given context. These limitations are due to the different features that the awk language does
provide.
Regular expressions in awk have been extended somewhat from historical implementations to make them a pure
superset of extended regular expressions, as defined by POSIX.1-2024 (see XBD 9.4
Extended Regular Expressions). The main extensions are internationalization features and interval expressions. Historical
implementations of awk have long supported -escape sequences as an extension to extended regular
expressions, and this extension has been retained despite inconsistency with other utilities. The number of escape sequences
recognized in both extended regular expressions and strings has varied (generally increasing with time) among implementations. The
set specified by POSIX.1-2024 includes most sequences known to be supported by popular implementations and by the ISO C
standard. One sequence that is not supported is hexadecimal value escapes beginning with '\x'. This would allow values
expressed in more than 9 bits to be used within awk as in the ISO C standard. However, because this syntax has a
non-deterministic length, it does not permit the subsequent character to be a hexadecimal digit. This limitation can be dealt with
in the C language by the use of lexical string concatenation. In the awk language, concatenation could also be a solution
for strings, but not for extended regular expressions (either lexical ERE tokens or strings used dynamically as regular
expressions). Because of this limitation, the feature has not been added to POSIX.1-2024.
When a string variable is used in a context where an extended regular expression normally appears (where the
lexical token ERE is used in the grammar) the string does not contain the literal  characters.
Some versions of awk allow the form:
func name(args, ... ) { statements }
This has been deprecated by the authors of the language, who asked that it not be specified.
Historical implementations of awk produce an error if a next statement is executed in a BEGIN
action, and cause awk to terminate if a next statement is executed in an END action. This behavior has not
been documented, and it was not believed that it was necessary to standardize it.
The specification of conversions between string and numeric values is much more detailed than in the documentation
of historical implementations or in the referenced The AWK Programming Language. Although most of the behavior is designed
to be intuitive, the details are necessary to ensure compatible behavior from different implementations. This is especially
important in relational expressions since the types of the operands determine whether a string or numeric comparison is performed.
From the perspective of an application developer, it is usually sufficient to expect intuitive behavior and to force conversions
(by adding zero or concatenating a null string) when the type of an expression does not obviously match what is needed. The intent
has been to specify historical practice in almost all cases. The one exception is that, in historical implementations, variables
and constants maintain both string and numeric values after their original value is converted by any use. This means that
referencing a variable or constant can have unexpected side-effects. For example, with historical implementations the following
program:
{
a = "+2"
b = 2
if (NR % 2)
c = a + b
if (a == b)
print "numeric comparison"
else
print "string comparison"
}
would perform a numeric comparison (and output numeric comparison) for each odd-numbered line, but perform a string
comparison (and output string comparison) for each even-numbered line. POSIX.1-2024 ensures that comparisons will be numeric if
necessary. With historical implementations, the following program:
BEGIN {
OFMT = "%e"
print 3.14
OFMT = "%f"
print 3.14
}
would output "3.140000e+00" twice, because in the second print statement the constant
"3.14" would have a string value from the previous conversion. POSIX.1-2024 requires that the output of the second
print statement be "3.140000". The behavior of historical implementations was seen as too unintuitive and
unpredictable.
It was pointed out that with the rules contained in early drafts, the following script would print nothing:
BEGIN {
y[1.5] = 1
OFMT = "%e"
print y[1.5]
}
Therefore, a new variable, CONVFMT, was introduced. The OFMT variable is now restricted to affecting
output conversions of numbers to strings and CONVFMT is used for internal conversions, such as comparisons or array
indexing. The default value is the same as that for OFMT, so unless a program changes CONVFMT (which no historical
program would do), it will receive the historical behavior associated with internal string conversions.
The POSIX awk lexical and syntactic conventions are specified more formally than in other sources. Again the
intent has been to specify historical practice. One convention that may not be obvious from the formal grammar as in other verbal
descriptions is where  characters are acceptable. There are several obvious placements such as terminating a
statement, and a  can be used to escape  characters between any lexical tokens. In addition,
characters without  characters can follow a comma, an open brace, a logical AND operator
("&&"), a logical OR operator ("||"), the do keyword, the else keyword, and the closing
parenthesis of an if, for, or while statement. For example:
{ print $1,
$2 }
The requirement that awk add a trailing  to the program argument text is to simplify the
grammar, making it match a text file in form. There is no way for an application or test suite to determine whether a literal
is added or whether awk simply acts as if it did.
POSIX.1-2024 requires several changes from historical implementations in order to support internationalization.
Probably the most subtle of these is the use of the decimal-point character, defined by the LC_NUMERIC category of the
locale, in representations of floating-point numbers. This locale-specific character is used in recognizing numeric input, in
converting between strings and numeric values, and in formatting output. However, regardless of locale, the
character (the decimal-point character of the POSIX locale) is the decimal-point character recognized in processing awk
programs (including assignments in command line arguments). This is essentially the same convention as the one used in the
ISO C standard. The difference is that the C language includes the setlocale() function, which permits an application to modify its locale. Because of this
capability, a C application begins executing with its locale set to the C locale, and only executes in the environment-specified
locale after an explicit call to setlocale(). However, adding such an elaborate
new feature to the awk language was seen as inappropriate for POSIX.1-2024. It is possible to execute an awk program
explicitly in any desired locale by setting the environment in the shell.
The undefined behavior resulting from NULs in extended regular expressions allows future extensions for the GNU
gawk program to process binary data.
The behavior in the case of invalid awk programs (including lexical, syntactic, and semantic errors) is
undefined because it was considered overly limiting on implementations to specify. In most cases such errors can be expected to
produce a diagnostic and a non-zero exit status. However, some implementations may choose to extend the language in ways that make
use of certain invalid constructs. Other invalid constructs might be deemed worthy of a warning, but otherwise cause some
reasonable behavior. Still other constructs may be very difficult to detect in some implementations. Also, different
implementations might detect a given error during an initial parsing of the program (before reading any input files) while others
might detect it when executing the program after reading some input. Implementors should be aware that diagnosing errors as early
as possible and producing useful diagnostics can ease debugging of applications, and thus make an implementation more usable.
The unspecified behavior from using multi-character RS values is to allow possible future extensions based
on extended regular expressions used for record separators. Historical implementations take the first character of the string and
ignore the others.
Unspecified behavior when split(string,array,) is used is to allow a proposed future extension
that would split up a string into an array of individual characters.
In the context of the getline function, equally good arguments for different precedences of the | and
characters should be used in the string to ensure a single  will precede the
when the resultant string is passed to the function. (For example, to specify one literal  in
the replacement string, use gsub(ERE, "\\&").)
Historically, the only special character in the repl argument of sub and gsub string functions
was the  ('&') character and preceding it with the  character was used to turn off
its special meaning.
The description in the ISO POSIX-2:1993 standard introduced behavior such that the  character
was another special character and it was unspecified whether there were any other special characters. This description introduced
several portability problems, some of which are described below, and so it has been replaced with the more historical description.
Some of the problems include:
Historically, to create the replacement string, a script could use gsub(ERE, "\\&"),
but with the ISO POSIX-2:1993 standard wording, it was necessary to use gsub(ERE, "\\\\&"). The
characters are doubled here because all string literals are subject to lexical analysis, which would reduce each
pair of  characters to a single  before being passed to gsub.
Since it was unspecified what the special characters were, for portable scripts to guarantee that characters are
printed literally, each character had to be preceded with a . (For example, a portable script had to use
gsub(ERE, "\\h\\i") to produce a replacement string of "hi".)
The description for comparisons in the ISO POSIX-2:1993 standard did not properly describe historical practice
because of the way numeric strings are compared as numbers. The current rules cause the following code:
if (0 == "000")
print "strange, but true"
else
print "not true"
to do a numeric comparison, causing the if to succeed. It should be intuitively obvious that this is
incorrect behavior, and indeed, no historical implementation of awk actually behaves this way.
To fix this problem, the definition of numeric string was enhanced to include only those values obtained
from specific circumstances (mostly external sources) where it is not possible to determine unambiguously whether the value is
intended to be a string or a numeric.
Variables that are assigned to a numeric string shall also be treated as a numeric string. (For example, the notion
of a numeric string can be propagated across assignments.) In comparisons, all variables having the uninitialized value are to be
treated as a numeric operand evaluating to the numeric value zero.
Uninitialized variables include all types of variables including scalars, array elements, and fields. The
definition of an uninitialized value in Variables and Special Variables is necessary to describe the
value placed on uninitialized variables and on fields that are valid (for example,  character, implementations are encouraged to treat this as an error. A future version of this standard may require
implementations to treat this as an error.
A future version of this standard may require srand to accept any numeric value and calculate the seed by
taking the provided value, converting it to an integer, and calculating the integer value modulo
2n where n is an implementation-defined value greater than or equal to 32.
A future version of this standard may require the initial seed for the rand function (the seed value used if
srand is not called) to be an integer between 0 and 2n-1 inclusive where n is an
implementation-defined value greater than or equal to 32. Additionally, the initial seed value may be required to be a
(pseudo-)random value such that two invocations of awk are unlikely to emit the same sequence of random values (unless the
seed is explicitly set to the same value via srand).
A future version of this standard may define a new posix_srand function that enables application authors to
set the seed to a (pseudo-)random value generated by the system. Alternatively, the specification of the srand function may
be altered to provide some means to set the default seed value to a (pseudo-)random value.
SEE ALSO
1.3 Grammar Conventions, grep, lex, sed
XBD 5. File Format Notation, 6.1 Portable Character Set, 8.
Environment Variables, 9. Regular Expressions, 12.2 Utility Syntax Guidelines
XSH atof(), exec, isspace(), popen(), setlocale(), strtod()
CHANGE HISTORY
First released in Issue 2.
Issue 5
The FUTURE DIRECTIONS section is added.
Issue 6
The awk utility is aligned with the IEEE P1003.2b draft standard.
The normative text is reworded to avoid use of the term "must" for application requirements.
IEEE PASC Interpretation 1003.2 #211 is applied, adding the sentence "An occurrence of two consecutive
characters shall be interpreted as just a single literal  character." into the description of
the sub string function.
Issue 7
PASC Interpretation 1003.2-1992 #107 (SD5-XCU-ERN-73) is applied, updating the description of the OFS variable.
Austin Group Interpretation 1003.1-2001 #189 is applied.
Austin Group Interpretation 1003.1-2001 #201 is applied, permitting implementations to support infinities and
NaNs.
SD5-XCU-ERN-79 is applied, restoring the horizontal lines to Expressions in Decreasing
Precedence in awk, and SD5-XCU-ERN-80 is applied, changing the order of some table entries.
SD5-XCU-ERN-87 is applied, updating the descriptive text of the Grammar.
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
The EXTENDED DESCRIPTION is changed to make the support of hexadecimal integer and floating constants optional.
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0057 [224], XCU/TC1-2008/0058 [454], XCU/TC1-2008/0059 [224],
XCU/TC1-2008/0060 [224], XCU/TC1-2008/0061 [254], XCU/TC1-2008/0062 [254], XCU/TC1-2008/0063 [224], and XCU/TC1-2008/0064 [454] are
applied.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0058 [584], XCU/TC2-2008/0059 [963], XCU/TC2-2008/0060 [226],
XCU/TC2-2008/0061 [663], XCU/TC2-2008/0062 [963], XCU/TC2-2008/0063 [226], and XCU/TC2-2008/0064 [963] are applied.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to disallow the creation of filenames containing any bytes that
have the encoded value of a  character.
Austin Group Defects 544 and 1136 are applied, requiring implementations to accept the delete statement with
an unsubscripted array name.
Austin Group Defect 607 is applied, adding the nextfile statement.
Austin Group Defect 634 is applied, adding the fflush function.
Austin Group Defects 974 and 1451 are applied, clarifying the ARGC, ARGV and FILENAME
variables, and adding to APPLICATION USAGE.
Austin Group Defect 983 is applied, changing the descriptions of the rand and srand functions and the
FUTURE DIRECTIONS section.
Austin Group Defect 1070 is applied, requiring the "!=" and "==" operators to perform string
comparisons by checking if the strings are identical (and not by checking if they collate equally).
Austin Group Defect 1105 is applied, clarifying the requirements for  escaping.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
Austin Group Defect 1198 is applied, requiring comparisons to be performed numerically when both operands have
string values that are numeric strings.
Austin Group Defect 1277 is applied, clarifying that using a  character within an ERE requires
escaping only if it is within the lexical token ERE.
Austin Group Defect 1320 is applied, clarifying the condition under which ERE matching is against input
records.
Austin Group Defect 1395 is applied, changing the requirements for string to number conversion.
Austin Group Defect 1468 is applied, clarifying the behavior when FS is an ERE that can match the null
string.
Austin Group Defect 1566 is applied, specifying the behavior of the length function when passed an array
argument.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/time.html =====
time
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
time — time a simple command
SYNOPSIS
time [-p] utility [argument...]
DESCRIPTION
The time utility shall invoke the utility named by the utility operand with arguments supplied as the
argument operands and write a message to standard error that lists timing statistics for the utility. The message shall
include the following information:
The elapsed (real) time between invocation of utility and its termination.
The User CPU time, equivalent to the sum of the tms_utime and tms_cutime fields returned by the times() function defined in the System Interfaces volume of POSIX.1-2024 for the process in
which utility is executed.
The System CPU time, equivalent to the sum of the tms_stime and tms_cstime fields returned by the times() function for the process in which utility is executed.
The precision of the timing shall be no less than the granularity defined for the size of the clock tick unit on the system, but
the results shall be reported in terms of standard time units (for example, 0.02 seconds, 00:00:00.02, 1m33.75s, 365.21 seconds),
not numbers of clock ticks.
When time is used in any of the following circumstances, via a simple command for which the word time is the
command name (see 2.9.1.1 Order of Processing), and none of the
characters in the word time is quoted, the results (including parsing of later words) are unspecified:
The simple command for which the word time is the command name includes one or more redirections (see 2.7 Redirection) or is (directly) part of a pipeline (see 2.9.2 Pipelines).
The next word that follows time would, if the word time were not present, be recognized as a reserved word (see
2.4 Reserved Words) or a control operator (see XBD 3.85 Control Operator).
Since these limitations only apply when time is executed via a simple command for which the word time is the
command name and none of the characters in the word time is quoted, they can be avoided by quoting all or part of the word
time, by arranging for the command name not to be time (for example, by having the command name be a word expansion),
or by executing time via another utility such as command or env.
The limitations on redirections and pipelines can also be overcome by embedding the simple command within a compound
command—most commonly a grouping command (see 2.9.4.1 Grouping
Commands)—and applying the redirections or piping to the compound command instead.
Note that in no circumstances where the results are specified is it possible to apply different redirections to the time
utility than are applied to the utility it invokes.
The following examples (where a and b are assumed to be the names of utilities found by searching PATH )
show unspecified usages:
time a arg1 arg2 | b    # part of a pipeline
a | time -p b           # part of a pipeline
time a >/dev/null       # output redirection
/dev/null
, ,
where each floating-point number shall be expressed in seconds. The precision used may be less than the default six digits of
%f, but shall be sufficiently precise to accommodate the size of the clock tick on the system (for example, if there were
60 clock ticks per second, at least two digits shall follow the radix character). The number of digits following the radix
character shall be no less than one, even if this always results in a trailing zero. The implementation may append white space and
additional information following the format shown here. The implementation may also prepend a single empty line before the format
shown here.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
If the utility utility is invoked, the exit status of time shall be the exit status of utility; otherwise,
the time utility shall exit with one of the following values:
1-125
An error occurred in the time utility.
126
The utility specified by utility was found but could not be invoked.
127
The utility specified by utility could not be found.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
The command, env, nice, nohup, time, timeout, and xargs utilities have been
specified to use exit code 127 if a utility to be invoked cannot be found, so that applications can distinguish "failure to find a
utility" from "invoked utility exited with an error indication". The value 127 was chosen because it is not commonly used for
other meanings; most utilities use small values for "normal error conditions" and the values above 128 can be confused with
termination due to receipt of a signal. The value 126 was chosen in a similar manner to indicate that the utility could be found,
but not invoked. Some scripts produce meaningful error messages differentiating the 126 and 127 cases. The distinction between exit
codes 126 and 127 is based on KornShell practice that uses 127 when all attempts to exec the utility fail with [ENOENT], and
uses 126 when any attempt to exec the utility fails for any other reason.
EXAMPLES
It is frequently desirable to apply time to pipelines or lists of commands. This can be done by placing pipelines and
command lists in a single file; this file can then be invoked as a utility, and the time applies to everything in the
file.
Alternatively, the following command can be used to apply time to a complex command:
time sh -c -- 'complex-command-line'
RATIONALE
When the time utility was originally proposed to be included in the ISO POSIX-2:1993 standard, questions were raised
about its suitability for inclusion on the grounds that it was not useful for conforming applications, specifically:
The underlying CPU definitions from the System Interfaces volume of POSIX.1-2024 are vague, so the numeric output could not be
compared accurately between systems or even between invocations.
The creation of portable benchmark programs was outside the scope this volume of POSIX.1-2024.
However, time does fit in the scope of user portability. Human judgement can be applied to the analysis of the output,
and it could be very useful in hands-on debugging of applications or in providing subjective measures of system performance. Hence
it has been included in this volume of POSIX.1-2024.
The default output format has been left unspecified because historical implementations differ greatly in their style of
depicting this numeric output. The -p option was invented to provide scripts with a common means of obtaining this
information.
In the KornShell, time is a shell reserved word that can be used to time an entire pipeline, rather than just a simple
command. The POSIX definition has been worded to allow this implementation. Consideration was given to invalidating this approach
because of the historical model from the C shell and System V shell. However, since the System V time utility historically
has not produced accurate results in pipeline timing (because the constituent processes are not all owned by the same parent
process, as allowed by POSIX), it did not seem worthwhile to break historical KornShell usage.
The term utility is used, rather than command, to highlight the fact that shell compound commands, pipelines,
special built-ins, and so on, cannot be used directly. However, utility includes user application programs and shell
scripts, not just the standard utilities.
FUTURE DIRECTIONS
None.
SEE ALSO
2. Shell Command Language, sh
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
XSH times()
CHANGE HISTORY
First released in Issue 2.
Issue 6
This utility is marked as part of the User Portability Utilities option.
Issue 7
The time utility is moved from the User Portability Utilities option to the Base. User Portability Utilities is now an
option for interactive utilities.
SD5-XCU-ERN-115 is applied, updating the example in the DESCRIPTION.
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0144 [266] is applied.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0194 [723] is applied.
Issue 8
Austin Group Defect 267 is applied, allowing time to be a reserved word.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
Austin Group Defect 1530 is applied, changing "sh -c" to "sh -c --".
Austin Group Defect 1586 is applied, adding the timeout utility.
Austin Group Defect 1594 is applied, changing the APPLICATION USAGE section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/lp.html =====
lp
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
lp — send files to a printer
SYNOPSIS
lp [-c] [-d dest] [-n copies] [-msw]
[-o option]... [-t title] [file...]
DESCRIPTION
The lp utility shall copy the input files to an output destination in an unspecified manner. The default output
destination should be to a hardcopy device, such as a printer or microfilm recorder, that produces non-volatile, human-readable
documents. If such a device is not available to the application, or if the system provides no such device, the lp utility
shall exit with a non-zero exit status.
The actual writing to the output device may occur some time after the lp utility successfully exits. During the portion
of the writing that corresponds to each input file, the implementation shall guarantee exclusive access to the device.
The lp utility shall associate a unique request ID with each request.
Normally, a banner page is produced to separate and identify each print job. This page may be suppressed by
implementation-defined conditions, such as an operator command or one of the -o option values.
OPTIONS
The lp utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following options shall be supported:
-c
Exit only after further access to any of the input files is no longer required. The application can then safely delete or
modify the files without affecting the output operation. Normally, files are not copied, but are linked whenever possible. If the
-c option is not given, then the user should be careful not to remove any of the files before the request has been printed
in its entirety. It should also be noted that in the absence of the -c option, any changes made to the named files after the
request is made but before it is printed may be reflected in the printed output. On some implementations, -c may be on by
default.
-d dest
Specify a string that names the destination (dest). If dest is a printer, the request shall be printed only on
that specific printer. If dest is a class of printers, the request shall be printed on the first available printer that is a
member of the class. Under certain conditions (printer unavailability, file space limitation, and so on), requests for specific
destinations need not be accepted. Destination names vary between systems.
If -d is not specified, and neither the LPDEST nor PRINTER environment variable is set, an unspecified
destination is used. The -d dest option shall take precedence over LPDEST , which in turn shall take
precedence over PRINTER . Results are undefined when dest contains a value that is not a valid destination name.
-m
Send mail (see mailx) after the files have been printed. By default, no mail is
sent upon normal completion of the print request.
-n copies
Write copies number of copies of the files, where copies is a positive decimal integer. The methods for producing
multiple copies and for arranging the multiple copies when multiple file operands are used are unspecified, except that each
file shall be output as an integral whole, not interleaved with portions of other files.
-o option
Specify printer-dependent or class-dependent options. Several such options may be collected by specifying the
-o option more than once.
-s
Suppress messages from lp.
-t title
Write title on the banner page of the output.
-w
Write a message on the user's terminal after the files have been printed. If the user is not logged in, then mail shall be sent
instead.
OPERANDS
The following operand shall be supported:
file
A pathname of a file to be output. If no file operands are specified, or if a file operand is '-', the
standard input shall be used. If a file operand is used, but the -c option is not specified, the process performing
the writing to the output device may have user and group permissions that differ from that of the process invoking lp.
STDIN
The standard input shall be used only if no file operands are specified, or if a file operand is '-'. See
the INPUT FILES section.
INPUT FILES
The input files shall be text files.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of lp:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error and
informative messages written to standard output.
LC_TIME
Determine the format and contents of date and time strings displayed in the lp banner page, if any.
LPDEST
Determine the destination. If the LPDEST environment variable is not set, the PRINTER environment variable shall
be used. The -d dest option takes precedence over LPDEST . Results are undefined when -d is not
specified and LPDEST contains a value that is not a valid destination name.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
PRINTER
Determine the output device or destination. If the LPDEST and PRINTER environment variables are not set, an
unspecified output device is used. The -d dest option and the LPDEST environment variable shall take
precedence over PRINTER . Results are undefined when -d is not specified, LPDEST is unset, and PRINTER
contains a value that is not a valid device or destination name.
TZ
Determine the timezone used to calculate date and time strings displayed in the lp banner page, if any. If TZ is
unset or null, an unspecified default timezone shall be used.
ASYNCHRONOUS EVENTS
Default.
STDOUT
The lp utility shall write a request ID to the standard output, unless -s is specified. The format of the
message is unspecified. The request ID can be used on systems supporting the historical cancel and lpstat
utilities.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
All input files were processed successfully.
>0
No output device was available, or an error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
The pr and fold utilities can be used to
achieve reasonable formatting for the implementation's default page size.
A conforming application can use one of the file operands only with the -c option or if the file is publicly
readable and guaranteed to be available at the time of printing. This is because POSIX.1-2024 gives the implementation the freedom
to queue up the request for printing at some later time by a different process that might not be able to access the file.
EXAMPLES
To print file file:
lp -c file
To print multiple files with headers:
pr file1 file2 | lp
RATIONALE
The lp utility was designed to be a basic version of a utility that is already available in many historical
implementations. The standard developers considered that it should be implementable simply as:
cat "$@" > /dev/lp
after appropriate processing of options, if that is how the implementation chose to do it and if exclusive access could be
granted (so that two users did not write to the device simultaneously). Although in the future the standard developers may add
other options to this utility, it should always be able to execute with no options or operands and send the standard input to an
unspecified output device.
This volume of POSIX.1-2024 makes no representations concerning the format of the printed output, except that it must be
"human-readable" and "non-volatile". Thus, writing by default to a disk or tape drive or a display terminal would not qualify.
(Such destinations are not prohibited when -d dest, LPDEST , or PRINTER are used, however.)
This volume of POSIX.1-2024 is worded such that a "print job" consisting of multiple input files, possibly in multiple copies,
is guaranteed to print so that any one file is not intermixed with another, but there is no statement that all the files or copies
have to print out together.
The -c option may imply a spooling operation, but this is not required. The utility can be implemented to wait until the
printer is ready and then wait until it is finished. Because of that, there is no attempt to define a queuing mechanism
(priorities, classes of output, and so on).
On some historical systems, the request ID reported on the STDOUT can be used to later cancel or find the status of a request
using utilities not defined in this volume of POSIX.1-2024.
Although the historical System V lp and BSD lpr utilities have provided similar functionality, they used different
names for the environment variable specifying the destination printer. Since the name of the utility here is lp,
LPDEST (used by the System V lp utility) was given precedence over PRINTER (used by the BSD lpr
utility). Since environments of users frequently contain one or the other environment variable, the lp utility is required
to recognize both. If this was not done, many applications would send output to unexpected output devices when users moved from
system to system.
Some have commented that lp has far too little functionality to make it worthwhile. Requests have proposed additional
options or operands or both that added functionality. The requests included:
Wording requiring the output to be "hardcopy"
A requirement for multiple printers
Options for supporting various page-description languages
Given that a compliant system is not required to even have a printer, placing further restrictions upon the behavior of the
printer is not useful. Since hardcopy format is so application-dependent, it is difficult, if not impossible, to select a
reasonable subset of functionality that should be required on all compliant systems.
The term unspecified is used in this section in lieu of implementation-defined as most known implementations would
not be able to make definitive statements in their conformance documents; the existence and usage of printers is very dependent on
how the system administrator configures each individual system.
Since the default destination, device type, queuing mechanisms, and acceptable forms of input are all unspecified, usage
guidelines for what a conforming application can do are as follows:
Use the command in a pipeline, or with -c, so that there are no permission problems and the files can be safely deleted
or modified.
Limit output to text files of reasonable line lengths and printable characters and include no device-specific formatting
information, such as a page description language. The meaning of "reasonable" in this context can only be answered as a
quality-of-implementation issue, but it should be apparent from historical usage patterns in the industry and the locale. The
pr and fold utilities can be used to achieve
reasonable formatting for the default page size of the implementation.
Alternatively, the application can arrange its installation in such a way that it requires the system administrator or operator
to provide the appropriate information on lp options and environment variable values.
At a minimum, having this utility in this volume of POSIX.1-2024 tells the industry that conforming applications require a means
to print output and provides at least a command name and LPDEST routing mechanism that can be used for discussions between
vendors, application developers, and users. The use of "should" in the DESCRIPTION of lp clearly shows the intent of the
standard developers, even if they cannot mandate that all systems (such as laptops) have printers.
This volume of POSIX.1-2024 does not specify what the ownership of the process performing the writing to the output device may
be. If -c is not used, it is unspecified whether the process performing the writing to the output device has permission to
read file if there are any restrictions in place on who may read file until after it is printed. Also, if -c
is not used, the results of deleting file before it is printed are unspecified.
FUTURE DIRECTIONS
None.
SEE ALSO
mailx
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 2.
Issue 6
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
In the DESCRIPTION, the requirement to associate a unique request ID, and the normal generation of a banner page is added.
In the OPTIONS section:
The -d dest description is expanded, but references to lpstat are removed.
The -m, -o, -s, -t, and -w options are added.
In the ENVIRONMENT VARIABLES section, LC_TIME may now affect the execution.
The STDOUT section is added.
The normative text is reworded to avoid use of the term "must" for application requirements.
The TZ entry is added to the ENVIRONMENT VARIABLES section.
Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
Issue 8
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/nohup.html =====
nohup
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
nohup — invoke a utility immune to hangups
SYNOPSIS
nohup utility [argument...]
DESCRIPTION
The nohup utility shall invoke the utility named by the utility operand with arguments supplied as the
argument operands. At the time the named utility is invoked, the SIGHUP signal shall be set to be ignored.
If standard input is associated with a terminal, the nohup utility may redirect standard input from an unspecified
file.
If the standard output is a terminal, all output written by the named utility to its standard output shall be appended to
the end of the file nohup.out in the current directory. If nohup.out cannot be created or opened for appending, the
output shall be appended to the end of the file nohup.out in the directory specified by the HOME environment
variable. If neither file can be created or opened for appending, utility shall not be invoked. If a file is created, the
file's permission bits shall be set to S_IRUSR | S_IWUSR.
If standard error is a terminal and standard output is open but is not a terminal, all output written by the named utility to
its standard error shall be redirected to the same open file description as the standard output. If standard error is a terminal
and standard output either is a terminal or is closed, the same output shall instead be appended to the end of the nohup.out
file as described above.
OPTIONS
None.
OPERANDS
The following operands shall be supported:
utility
The name of a utility that is to be invoked. If the utility operand names any of the special built-in utilities in
2.15 Special Built-In Utilities, the results are undefined.
argument
Any string to be supplied as an argument when invoking the utility named by the utility operand.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of nohup:
HOME
Determine the pathname of the user's home directory: if the output file nohup.out cannot be created in the current
directory, the nohup utility shall use the directory named by HOME to create the file.
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
PATH
Determine the search path that is used to locate the utility to be invoked. See XBD 8. Environment Variables.
ASYNCHRONOUS EVENTS
The nohup utility shall take the standard action for all signals except that SIGHUP shall be ignored.
STDOUT
If the standard output is not a terminal, the standard output of nohup shall be the standard output generated by the
execution of the utility specified by the operands. Otherwise, nothing shall be written to the standard output.
STDERR
If the standard output is a terminal, a message shall be written to the standard error, indicating the name of the file to which
the output is being appended. The name of the file shall be either nohup.out or $HOME/nohup.out.
OUTPUT FILES
Output written by the named utility is appended to the file nohup.out (or $HOME/nohup.out), if the conditions hold
as described in the DESCRIPTION.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
126
The utility specified by utility was found but could not be invoked.
127
An error occurred in the nohup utility or the utility specified by utility could not be found.
Otherwise, the exit status of nohup shall be that of the utility specified by the utility operand.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
The command, env, nice, nohup, time, timeout, and xargs utilities have been
specified to use exit code 127 if a utility to be invoked cannot be found, so that applications can distinguish "failure to find a
utility" from "invoked utility exited with an error indication". However, the command and nohup utilities also use exit code 127 when an error occurs in those
utilities, which means exit code 127 is not universally a "not found" indicator. The value 127 was chosen because it is not
commonly used for other meanings; most utilities use small values for "normal error conditions" and the values above 128 can be
confused with termination due to receipt of a signal. The value 126 was chosen in a similar manner to indicate that the utility
could be found, but not invoked. Some scripts produce meaningful error messages differentiating the 126 and 127 cases. The
distinction between exit codes 126 and 127 is based on KornShell practice that uses 127 when all attempts to exec the
utility fail with [ENOENT], and uses 126 when any attempt to exec the utility fails for any other reason.
EXAMPLES
It is frequently desirable to apply nohup to pipelines or lists of commands. This can be done by placing pipelines and
command lists in a single file; this file can then be invoked as a utility, and the nohup applies to everything in the
file.
Alternatively, the following command can be used to apply nohup to a complex command:
nohup sh -c -- 'complex-command-line' >>
===== susv5-html/utilities/pwd.html =====
pwd
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pwd — return working directory name
SYNOPSIS
pwd [-L|-P]
DESCRIPTION
The pwd utility shall write to standard output an absolute pathname of the current working directory, which does not
contain the filenames dot or dot-dot.
OPTIONS
The pwd utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following options shall be supported by the implementation:
-L
If the PWD environment variable contains an absolute pathname of the current directory and the pathname does not contain
any components that are dot or dot-dot, pwd shall write this pathname to standard output, except that if the PWD
environment variable is longer than {PATH_MAX} bytes including the terminating null, it is unspecified whether pwd writes
this pathname to standard output or behaves as if the -P option had been specified. Otherwise, the -L option shall
behave as the -P option.
-P
The pathname written to standard output shall not contain any components that refer to files of type symbolic link. If there
are multiple pathnames that the pwd utility could write to standard output, one beginning with a single
character and one or more beginning with two  characters, then it shall write the pathname beginning with a single
character. The pathname shall not contain any unnecessary  characters after the leading one or two
characters.
If both -L and -P are specified, the last one shall apply. If neither -L nor -P is specified, the
pwd utility shall behave as if -L had been specified.
OPERANDS
None.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of pwd:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
PWD
An absolute pathname of the current working directory. If an application sets or unsets the value of PWD , the behavior
of pwd is unspecified.
ASYNCHRONOUS EVENTS
Default.
STDOUT
The pwd utility output is an absolute pathname of the current working directory:
"%s\n",
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
If an error is detected other than a write error when writing to standard output, no output shall be written to standard output,
a diagnostic message shall be written to standard error, and the exit status shall be non-zero.
The following sections are informative.
APPLICATION USAGE
If the pathname obtained from pwd is longer than {PATH_MAX} bytes, it could produce an error if passed to cd. Therefore, in order to return to that directory it may be necessary to break the pathname
into sections shorter than {PATH_MAX} and call cd on each section in turn (the first
section being an absolute pathname and subsequent sections being relative pathnames).
EXAMPLES
None.
RATIONALE
Some implementations have historically provided pwd as a shell special built-in command.
In most utilities, if an error occurs, partial output may be written to standard output. This does not happen in historical
implementations of pwd (unless an error condition causes a partial write). Because pwd is frequently used in
historical shell scripts without checking the exit status, it is important that the historical behavior is required here;
therefore, the CONSEQUENCES OF ERRORS section specifically disallows any partial output being written to standard output, except
when a write error occurs when writing to standard output.
An earlier version of this standard stated that the PWD environment variable was affected when the -P option was
in effect. This was incorrect; conforming implementations do not do this.
FUTURE DIRECTIONS
If this utility is directed to display a pathname that contains any bytes that have the encoded value of a
character when  is a terminator or separator in the output format being used, implementations are encouraged to
treat this as an error. A future version of this standard may require implementations to treat this as an error.
SEE ALSO
cd
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
XSH getcwd()
CHANGE HISTORY
First released in Issue 2.
Issue 6
The -P and -L options are added to describe actions relating to symbolic links as specified in the
IEEE P1003.2b draft standard.
Issue 7
Austin Group Interpretation 1003.1-2001 #097 is applied.
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
Changes to the pwd utility and PWD environment variable have been made to match the changes to the getcwd() function made for Austin Group Interpretation 1003.1-2001 #140.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0161 [471] is applied.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to report an error if a utility is directed to display a
pathname that contains any bytes that have the encoded value of a  character when  is a terminator or
separator in the output format being used.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
Austin Group Defect 1488 is applied, clarifying the behavior when a write error occurs when writing to standard output.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/uustat.html =====
uustat
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
uustat — uucp status enquiry and job control
SYNOPSIS
[UU]  uustat [-q|-k jobid|-r jobid]
uustat [-s system] [-u user]
DESCRIPTION
The uustat utility shall display the status of, or cancel, previously specified uucp requests, or provide general status on uucp
connections to other systems.
When no options are given, uustat shall write to standard output the status of all uucp requests issued by the current user.
Typical implementations of this utility require a communications line configured to use XBD 11. General Terminal Interface, but other communications means may be used. On
systems where there are no available communications means (either temporarily or permanently), this utility shall write an error
message describing the problem and exit with a non-zero exit status.
OPTIONS
The uustat utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following options shall be supported:
-q
Write the jobs queued for each machine.
-k jobid
Kill the uucp request whose job identification is jobid. The application
shall ensure that the killed uucp request belongs to the person invoking uustat
unless that user has appropriate privileges.
-r jobid
Rejuvenate jobid. The files associated with jobid are touched so that their modification time is set to the
current time. This prevents the cleanup program from deleting the job until the jobs modification time reaches the limit imposed by
the program.
-s system
Write the status of all uucp requests for remote system system.
-u user
Write the status of all uucp requests issued by user.
OPERANDS
None.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of uustat:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error, and
informative messages written to standard output.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
The standard output shall consist of information about each job selected, in an unspecified format. The information shall
include at least the job ID, the user ID or name, and the remote system name.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
This utility is part of the UUCP Utilities option and need not be supported by all implementations.
EXAMPLES
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
uucp
XBD 8. Environment Variables, 11. General Terminal Interface, 12.2 Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 2.
Issue 6
The normative text is reworded to avoid use of the term "must" for application requirements.
The LC_TIME and TZ entries are removed from the ENVIRONMENT VARIABLES section.
The UN margin code and associated shading are removed from the -q option in response to The Open Group Base Resolution
bwg2001-003.
Issue 7
SD5-XCU-ERN-46 is applied, moving this utility to the UUCP Utilities Option Group.
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
Issue 8
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
Austin Group Defect 1516 is applied, adding XSI shading to text relating to NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/mv.html =====
mv
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
mv — move files
SYNOPSIS
mv [-if] source_file target_file
mv [-if] source_file... target_dir
DESCRIPTION
In the first synopsis form, the mv utility shall move the file named by the source_file operand to the destination
specified by the target_file. This first synopsis form is assumed when the final operand does not name an existing directory
and is not a symbolic link referring to an existing directory. In this case, if source_file names a non-directory file and
target_file ends with a trailing  character, mv shall treat this as an error and no source_file
operands shall be processed.
In the second synopsis form, mv shall move each file named by a source_file operand to a destination file in the
existing directory named by the target_dir operand, or referenced if target_dir is a symbolic link referring to an
existing directory. The destination path for each source_file shall be the concatenation of the target directory, a single
character if the target did not end in a , and the last pathname component of the source_file.
This second form is assumed when the final operand names an existing directory.
If any operand specifies an existing file of a type not specified by the System Interfaces volume of POSIX.1-2024, the behavior
is implementation-defined.
For each source_file the following steps shall be taken:
If the destination path exists, the -f option is not specified, and either of the following conditions is true:
The permissions of the destination path do not permit writing and the standard input is a terminal.
The -i option is specified.
the mv utility shall write a prompt to standard error and read a line from standard input. If the response is not
affirmative, mv shall do nothing more with the current source_file and go on to any remaining
source_files.
If the source_file operand and destination path resolve to either the same existing directory entry or different
directory entries for the same existing file, then the destination path shall not be removed, and one of the following shall
occur:
No change is made to source_file, no error occurs, and no diagnostic is issued.
No change is made to source_file, a diagnostic is issued to standard error identifying the two names, and the exit status
is affected.
If the source_file operand and destination path name distinct directory entries, then the source_file operand is
removed, no error occurs, and no diagnostic is issued.
The mv utility shall do nothing more with the current source_file, and go on to any remaining
source_files.
The mv utility shall perform actions equivalent to the rename() function
defined in the System Interfaces volume of POSIX.1-2024, called with the following arguments:
The source_file operand is used as the old argument.
The destination path is used as the new argument.
If this succeeds, mv shall do nothing more with the current source_file and go on to any remaining
source_files. If this fails for any reasons other than those described for the errno [EXDEV] in the System Interfaces
volume of POSIX.1-2024, mv shall write a diagnostic message to standard error, do nothing more with the current
source_file, and go on to any remaining source_files.
If the destination path exists, and it is a file of type directory and source_file is not a file of type directory, or it
is a file not of type directory and source_file is a file of type directory, mv shall write a diagnostic message to
standard error, do nothing more with the current source_file, and go on to any remaining source_files. If the
destination path exists and was created by a previous step, it is unspecified whether this will treated as an error or the
destination path will be overwritten.
If the destination path exists, mv shall attempt to remove it. If this fails for any reason, mv shall write a
diagnostic message to standard error, do nothing more with the current source_file, and go on to any remaining
source_files.
The file hierarchy rooted in source_file shall be duplicated as a file hierarchy rooted in the destination path. If
source_file or any of the files below it in the hierarchy are symbolic links, the links themselves shall be duplicated,
including their contents, rather than any files to which they refer. The following characteristics of each file in the file
hierarchy shall be duplicated:
The time of last data modification and time of last access
The user ID and group ID
The file mode
If the user ID, group ID, or file mode of a regular file cannot be duplicated, the file mode bits S_ISUID and S_ISGID shall not
be duplicated.
When files are duplicated to another file system, the implementation may require that the process invoking mv has read
access to each file being duplicated.
If files being duplicated to another file system have hard links to other files, it is unspecified whether the files copied to
the new file system have the hard links preserved or separate copies are created for the linked files.
If the duplication of the file hierarchy fails for any reason, mv shall write a diagnostic message to standard error, do
nothing more with the current source_file, and go on to any remaining source_files.
If the duplication of the file characteristics fails for any reason, mv shall write a diagnostic message to standard
error, but this failure shall not cause mv to modify its exit status.
The file hierarchy rooted in source_file shall be removed. If this fails for any reason, mv shall write a
diagnostic message to the standard error, do nothing more with the current source_file, and go on to any remaining
source_files.
OPTIONS
The mv utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following options shall be supported:
-f
Do not prompt for confirmation if the destination path exists. Any previous occurrence of the -i option is ignored.
-i
Prompt for confirmation if the destination path exists. Any previous occurrence of the -f option is ignored.
Specifying more than one of the -f or -i options shall not be considered an error. The last option specified shall
determine the behavior of mv.
OPERANDS
The following operands shall be supported:
source_file
A pathname of a file or directory to be moved.
target_file
A new pathname for the file or directory being moved.
target_dir
A pathname of an existing directory into which to move the input files.
STDIN
The standard input shall be used to read an input line in response to each prompt specified in the STDERR section. Otherwise,
the standard input shall not be used.
INPUT FILES
The input files specified by each source_file operand can be of any file type.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of mv:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_COLLATE
Determine the locale for the behavior of ranges, equivalence classes, and multi-character collating elements used in the extended
regular expression defined for the yesexpr locale keyword in the LC_MESSAGES category.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files), the behavior of character classes used in the extended regular
expression defined for the yesexpr locale keyword in the LC_MESSAGES category.
LC_MESSAGES
Determine the locale used to process affirmative responses, and the locale used to affect the format and contents of diagnostic
messages and prompts written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
Not used.
STDERR
Prompts shall be written to the standard error under the conditions specified in the DESCRIPTION section. The prompts shall
contain the destination pathname, but their format is otherwise unspecified. Otherwise, the standard error shall be used only for
diagnostic messages.
OUTPUT FILES
The output files may be of any file type.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
All requested files (excluding files where a non-affirmative response was given to a request for confirmation) were
successfully moved.
>0
An error occurred.
CONSEQUENCES OF ERRORS
If the copying or removal of source_file is prematurely terminated by a signal or error, mv may leave a partial
copy of source_file at the source or destination. The mv utility shall not modify both source_file and the
destination path simultaneously; termination at any point shall leave either source_file or the destination path
complete.
The following sections are informative.
APPLICATION USAGE
Some implementations mark for update the last file status change timestamp of renamed files and some do not. Applications which
make use of the last file status change timestamp may behave differently with respect to renamed files unless they are designed to
allow for either behavior.
The specification ensures that mv a a will not alter the contents of file a, and allows the
implementation to issue an error that a file cannot be moved onto itself. Likewise, when a and b are hard links to
the same file, mv a b will not alter b, but if a diagnostic is not issued, then it is unspecified
whether a is left untouched (as it would be by the rename() function) or
unlinked (reducing the link count of b).
EXAMPLES
If the current directory contains only files a (of any type defined by the System Interfaces volume of POSIX.1-2024),
b (also of any type), and a directory c:
mv a b c
mv c d
results with the original files a and b residing in the directory d in the current directory.
RATIONALE
Early proposals diverged from the SVID and BSD historical practice in that they required that when the destination path exists,
the -f option is not specified, and input is not a terminal, mv fails. This was done for compatibility with cp. The current text returns to historical practice. It should be noted that this is consistent
with the rename() function defined in the System Interfaces volume of POSIX.1-2024,
which does not require write permission on the target.
For absolute clarity, paragraph (1), describing the behavior of mv when prompting for confirmation, should be interpreted
in the following manner:
if (exists AND (NOT f_option) AND
((not_writable AND input_is_terminal) OR i_option))
The -i option exists on BSD systems, giving applications and users a way to avoid accidentally unlinking files when
moving others. When the standard input is not a terminal, the 4.3 BSD mv deletes all existing destination paths without
prompting, even when -i is specified; this is inconsistent with the behavior of the 4.3 BSD cp utility, which always generates an error when the file is unwritable and the standard input is
not a terminal. The standard developers decided that use of -i is a request for interaction, so when the destination path
exists, the utility takes instructions from whatever responds to standard input.
The rename() function is able to move directories within the same file system.
Some historical versions of mv have been able to move directories, but not to a different file system. The standard
developers considered that this was an annoying inconsistency, so this volume of POSIX.1-2024 requires directories to be able to be
moved even across file systems. There is no -R option to confirm that moving a directory is actually intended, since such an
option was not required for moving directories in historical practice. Requiring the application to specify it sometimes, depending
on the destination, seemed just as inconsistent. The semantics of the rename()
function were preserved as much as possible. For example, mv is not permitted to "rename" files to or from directories,
even though they might be empty and removable.
Historic implementations of mv did not exit with a non-zero exit status if they were unable to duplicate any file
characteristics when moving a file across file systems, nor did they write a diagnostic message for the user. The former behavior
has been preserved to prevent scripts from breaking; a diagnostic message is now required, however, so that users are alerted that
the file characteristics have changed.
The exact format of the interactive prompts is unspecified. Only the general nature of the contents of prompts are specified
because implementations may desire more descriptive prompts than those used on historical implementations. Therefore, an
application not using the -f option or using the -i option relies on the system to provide the most suitable dialog
directly with the user, based on the behavior specified.
When mv is dealing with a single file system and source_file is a symbolic link, the link itself is moved as a
consequence of the dependence on the rename() functionality, per the DESCRIPTION.
Across file systems, this has to be made explicit.
FUTURE DIRECTIONS
If this utility is directed to create a new directory entry that contains any bytes that have the encoded value of a
character, implementations are encouraged to treat this as an error. A future version of this standard may require
implementations to treat this as an error.
SEE ALSO
cp, ln
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
XSH rename()
CHANGE HISTORY
First released in Issue 2.
Issue 6
The mv utility is changed to describe processing of symbolic links as specified in the IEEE P1003.2b draft
standard.
The APPLICATION USAGE section is added.
Issue 7
Austin Group Interpretation 1003.1-2001 #016 is applied.
Austin Group Interpretation 1003.1-2001 #126 is applied, changing the description of the LC_MESSAGES environment
variable.
Austin Group Interpretations 1003.1-2001 #164, #168, and #169 are applied.
SD5-XCU-ERN-13 is applied, making an editorial correction to the SYNOPSIS.
SD5-XCU-ERN-51 is applied to the DESCRIPTION, defining the behavior for when files are being duplicated to another file system
while having hard links.
Changes are made related to support for finegrained timestamps.
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0124 [48] is applied.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0147 [534] is applied.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to disallow the creation of filenames containing any bytes that
have the encoded value of a  character.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
Austin Group Defect 1732 is applied, changing the EXIT STATUS section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/timeout.html =====
timeout
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
timeout — execute a utility with a time limit
SYNOPSIS
timeout [-fp] [-k time] [-s signal_name]
duration utility [argument...]
DESCRIPTION
The timeout utility shall execute the utility named by the utility operand, with arguments supplied as the
argument operands (if any), in a child process. If the value of the duration operand is non-zero and the child
process has not terminated after the specified time period, timeout shall send the signal specified by the -s option,
or the SIGTERM signal if -s is not given.
If the -f option is specified, the signal shall be sent only to the child process. Otherwise, it is implementation
defined which one of the following methods is used to signal additional processes:
The timeout utility ensures it is a process group leader before creating the child process which executes the utility, in
which case it shall send the signal to its process group.
The timeout utility arranges for any descendants of the child process that are orphaned to have their parent process
changed to the timeout utility, in which case the signal shall be sent to the child process and all of its descendants.
If the subsequent wait status of the child process shows that it was stopped by a signal, a SIGCONT signal shall also be sent in
the same manner as the first signal; otherwise, a SIGCONT signal may be sent in the same manner.
If the -k option is specified, and the child process created to execute the utility still has not terminated after the
time period specified by the time option-argument has elapsed since the first signal was sent, timeout shall send a
SIGKILL signal in the same manner as the first signal. If timeout receives a signal and propagates it to the child process
(see ASYNCHRONOUS EVENTS below), this shall be treated as the first signal.
OPTIONS
The timeout utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following options shall be supported:
-f
Only time out the utility itself, not its descendants.
-k time
Send a SIGKILL signal if the child process created to execute the utility has not terminated after the time period specified by
time has elapsed since the first signal was sent. The value of time shall be interpreted as specified for the
duration operand (see OPERANDS below).
-p
Always preserve (mimic) the wait status of the executed utility, even if the time limit was reached.
-s signal_name
Specify the signal to send when the time limit is reached, using one of the symbolic names defined in the  header. Values of signal_name shall be recognized in a
case-independent fashion, without the SIG prefix. By default, SIGTERM shall be sent.
OPERANDS
The following operands shall be supported:
duration
The maximum amount of time to allow the utility to run, specified as a decimal number with an optional decimal fraction and an
optional suffix, which can be:
s
seconds
m
minutes
h
hours
d
days
If a decimal fraction is present, the application shall ensure that it is separated from the units by a . If no
suffix is present, the value shall specify seconds.
If the value is zero, timeout shall not enforce a time limit.
utility
The name of a utility that is to be executed. If the utility operand names any of the special built-in utilities in
2.15 Special Built-In Utilities, the results are undefined.
argument
Any string to be supplied as an argument when executing the utility named by the utility operand.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of timeout:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
PATH
Determine the search path that is used to locate the utility to be executed. See XBD 8.3 Other Environment Variables.
ASYNCHRONOUS EVENTS
The default behavior specified in 1.4 Utility Description Defaults
shall apply, except that:
The timeout utility shall ignore SIGTTIN and SIGTTOU signals.
The timeout utility may alter the disposition of SIGALRM if the inherited disposition was for it to be ignored.
If the signal specified with the -s option, or any signal whose default action is to terminate the process, is delivered
to the timeout utility, then unless the signal is SIGKILL or SIGSTOP, the timeout utility shall immediately send the
same signal to the process or processes to which it would send a signal when the time limit is reached. If the delivered signal is
SIGALRM, timeout may behave as if the time limit had been reached instead of sending SIGALRM.
If the -f option is not specified, then if timeout sends a signal to its process group, it shall briefly change
the disposition of that signal to ignored while it sends the signal, so that it does not receive the signal itself.
With the single exception of the signal specified with the -s option, or SIGTERM if -s is not used, all signal
dispositions inherited by the utility specified by the utility operand shall be the same as the disposition that
timeout inherited.
STDOUT
Not used.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
If the -p option is not specified and the time limit was reached:
If the -k option was not specified or the utility terminated before the time period specified by the time
option-argument elapsed since the first signal was sent, the exit status shall be 124.
If the -k option was specified and the SIGKILL signal was sent, it is unspecified whether the exit status is 124 or the
behavior is as if the -p option was specified.
Otherwise, if the executed utility terminated by exiting, the exit status of timeout shall be that of the utility; if the
utility was terminated by a signal, timeout shall terminate itself with the same signal while ensuring that a core image is
not created.
If an error occurs, the following exit values shall be returned:
125
An error other than the two described below occurred.
126
The utility specified by utility was found but could not be executed.
127
The utility specified by utility could not be found.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
Unlike the kill utility, the -s option of timeout is not required to
accept the symbolic name 0 to represent signal value zero.
When the value of duration is zero, timeout does not time out the utility, but it does still perform signal
propagation (including to descendants of the utility if -f is not specified).
Regardless of locale, the  character (the decimal-point character of the POSIX locale) is the decimal-point
character recognized in the duration operand and the time option-argument.
The command, env, nice, nohup, time, timeout, and xargs utilities have
been specified to use exit code 127 if a utility to be invoked cannot be found, so that applications can distinguish "failure to
find a utility" from "invoked utility exited with an error indication". The value 127 was chosen because it is not commonly used
for other meanings; most utilities use small values for "normal error conditions" and the values above 128 can be confused with
termination due to receipt of a signal. The value 126 was chosen in a similar manner to indicate that the utility could be found,
but not invoked. Some scripts produce meaningful error messages differentiating the 126 and 127 cases. The distinction between exit
codes 126 and 127 is based on KornShell practice that uses 127 when all attempts to exec the utility fail with [ENOENT], and
uses 126 when any attempt to exec the utility fails for any other reason. The timeout utility extends these special
exit codes to 125 and 124, with the meanings described in EXIT STATUS. A timeout exit status below 124 can only result from
passing through the exit status of the executed utility.
EXAMPLES
None.
RATIONALE
Some timeout implementations make themselves a process group leader (when -f is not used) in order to be able to
send signals to descendants of the child process. However, using this method means that any descendants which change their process
group do not receive the signal. To ensure all descendants receive the signal, some implementations instead make use of a feature
whereby descendants that are orphaned have their parent process changed to the timeout utility—that is, timeout
becomes their "reaper"—together with the ability of a reaper to send a signal to all of its descendants.
Some historical timeout implementations exited with status 128+signal_number when the child process was terminated
by a signal before the time limit was reached (or when -p was used). This is reasonable when timeout is invoked from
a shell which sets $? to 128+signal_number, but not all shells do that. In particular, the KornShell sets $? to
256+signal_number and so an exit status of 128+signal_number from timeout would be misleading. In order to
avoid any possible ambiguity, this standard requires that timeout mimics the wait status of the child process by terminating
itself with the same signal. When it does this it needs to ensure that it does not create a core image, otherwise it could
overwrite one created by the invoked utility.
The timeout utility ignores SIGTTIN and SIGTTOU so that if the utility it executes reads from or writes to the
controlling terminal and this generates a SIGTTIN or SIGTTOU for the process group, timeout will not be stopped by the
signal and can still time out the utility.
Some historical timeout implementations always set the disposition for SIGTTIN and SIGTTOU in the child process to
default, even if these signals were inherited as ignored. This could result in processes being stopped unexpectedly. Likewise, they
did not ensure that for signals they caught, the disposition inherited by the executed utility was the same as the disposition that
was inherited by timeout. This meant that, for example, if timeout was used in a script that was run with nohup, the utility executed by timeout would unexpectedly not be protected from SIGHUP.
This standard requires that all signal dispositions inherited by the utility specified by the utility operand are the same
as the disposition that timeout inherited, with the single exception of the signal that timeout sends when the time
limit is reached, which needs to be inherited as default in order for the timeout to take effect (without resorting to SIGKILL if
-k is specified).
Some historical timeout implementations only propagated a subset of the signals whose default action is to terminate the
process to the child process if one was delivered to the timeout utility. Propagating these signals is beneficial, as
otherwise termination of the timeout utility by a signal results in the utility it executed being left running indefinitely
(unless it also received the signal, for example a terminal-generated SIGINT). There is no reason to select a subset of these
signals to be propagated, therefore this standard requires them all to be propagated (except SIGKILL, which cannot). In the event
that a user wants to prevent the utility being timed out, sending timeout a SIGKILL can be used for this purpose.
FUTURE DIRECTIONS
None.
SEE ALSO
kill
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines,
CHANGE HISTORY
First released in Issue 8.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/ls.html =====
ls
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ls — list directory contents
SYNOPSIS
[XSI] ls [-ikqrs] [-glno] [-A|-a] [-C|-m|-x|-1] \
[-F|-p] [-H|-L] [-R|-d]
[-S|-f|-t] [-c|-u] [file...]
DESCRIPTION
For each operand that names a file of a type other than directory or symbolic link to a directory, ls shall write the
name of the file as well as any requested, associated information. For each operand that names a file of type directory, ls
shall write the names of files contained within the directory as well as any requested, associated information. Filenames beginning
with a  ('.') and any associated information shall not be written out unless explicitly referenced, the
-A or -a option is supplied, or an implementation-defined condition causes them to be written. If one or more of the
-d, -F, or -l options are specified, and neither the -H nor the -L option is specified, for each
operand that names a file of type symbolic link to a directory, ls shall write the name of the file as well as any
requested, associated information. If none of the -d, -F, or -l options are specified, or the -H or
-L options are specified, for each operand that names a file of type symbolic link to a directory, ls shall write the
names of files contained within the directory as well as any requested, associated information. In each case where the names of
files contained within a directory are written, if the directory contains any symbolic links then ls shall evaluate the file
information and file type to be those of the symbolic link itself, unless the -L option is specified.
If no operands are specified, ls shall behave as if a single operand of dot ('.') had been specified. If more
than one operand is specified, ls shall write non-directory operands first; it shall sort directory and non-directory
operands separately according to the collating sequence in the current locale.
Whenever ls sorts filenames or pathnames according to the collating sequence in the current locale, if this collating
sequence does not have a total ordering of all characters (see XBD 7.3.2
LC_COLLATE), then any filenames or pathnames that collate equally shall be further compared byte-by-byte using the
collating sequence for the POSIX locale.
The ls utility shall detect infinite loops; that is, entering a previously visited directory that is an ancestor of the
last file encountered. When it detects an infinite loop, ls shall write a diagnostic message to standard error and shall
either recover its position in the hierarchy or terminate.
OPTIONS
The ls utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following options shall be supported:
-A
Write out all directory entries, including those whose names begin with a  ('.') but excluding the
entries dot and dot-dot (if they exist).
-C
Write multi-text-column output with entries sorted down the columns, according to the collating sequence. The number of text
columns and the column separator characters are unspecified, but should be adapted to the nature of the output device. This option
disables long format output.
Note:
Since the output from this option may use separator characters that include characters that might appear in filenames (in
addition to the problems related to s in filenames), -C should not be used when filenames might be extracted
from the output by a script.
-F
Do not follow symbolic links named as operands unless the -H or -L options are specified. Write a
('/') immediately after each pathname that is a directory, an  ('*') after each that is
executable, a  ('|') after each that is a FIFO, an  ('=') after each that
is a socket, and a  ('@') after each that is a symbolic link. For other file types, other symbols may
be written.
-H
Evaluate the file information and file type for symbolic links specified on the command line to be those of the file referenced
by the link, and not the link itself; however, ls shall write the name of the link itself and not the file referenced by the
link.
-L
Evaluate the file information and file type for all symbolic links (whether named on the command line or encountered in a file
hierarchy) to be those of the file referenced by the link, and not the link itself; however, ls shall write the name of the
link itself and not the file referenced by the link. When -L is used with -l, write the contents of symbolic links in
the long format (see the STDOUT section).
-R
Recursively list subdirectories encountered. Subdirectories with filenames beginning with a  ('.') shall
be recursively listed if and only if the subdirectory name was included in the filenames listed for the containing directory. When
a symbolic link to a directory is encountered, the directory shall not be recursively listed unless the -L option is
specified. The use of -R with -d or -f produces unspecified results.
-S
Sort with the primary key being file size (in decreasing order) and the secondary key being filename in the collating sequence
(in increasing order). For a symbolic link, the size used as the sort key is that of the symbolic link itself, unless ls is
evaluating its file information to be that of the file referenced by the link (see the -H and -L options).
-a
Write out all directory entries, including those whose names begin with a  ('.').
-c
Use time of last modification of the file status information (see XBD ) instead of last modification of the file itself for sorting
(-t) or writing (-l).
-d
Do not follow symbolic links named as operands unless the -H or -L options are specified. Do not treat
directories differently than other types of files. The use of -d with -R or -f produces unspecified
results.
-f
List the entries in directory operands in the order they appear in the directory. The behavior for non-directory operands is
unspecified. This option shall turn on -a. When -f is specified, any occurrences of the -r, -S, and
-t options shall be ignored and any occurrences of the -A, [XSI]
-g,  -l, -n, [XSI]  -o,  and -s options
may be ignored. The use of -f with -R or -d produces unspecified results.
-g
[XSI]
Turn on the -l (ell) option, but disable writing the file's owner name or number. Disable the -C, -m, and
-x options.
-i
For each file, write the file's file serial number (see stat() in the System
Interfaces volume of POSIX.1-2024).
-k
Set the block size for the -s option and the per-directory block count written for the -l, -n, -s,
[XSI]
-g, and -o  options (see the STDOUT section) to 1024
bytes.
-l
(The letter ell.) Do not follow symbolic links named as operands unless the -H or -L options are specified. Write
out in long format (see the STDOUT section). Disable the -C, -m, and -x options.
-m
Stream output format; list pathnames across the page, separated by a  character followed by a
character. Use a  character as the list terminator and after the separator sequence when there is not room on a line
for the next list entry. This option disables long format output.
-n
Turn on the -l (ell) option, but when writing the file's owner or group, write the file's numeric UID or GID rather than
the user or group name, respectively. Disable the -C, -m, and -x options.
-o
[XSI]
Turn on the -l (ell) option, but disable writing the file's group name or number. Disable the -C, -m, and
-x options.
-p
Write a  ('/') after each pathname if that file is a directory.
-q
Force each instance of non-printable filename characters (including , , and other control characters)
to be written as the  ('?') character. Implementations may provide this option by default if the
output is to a terminal device.
-r
Reverse the order of the sort to get reverse collating sequence, oldest first, or smallest file size first depending on the
other options given.
-s
Indicate the total number of file system blocks consumed by each file displayed. If the -k option is also specified, the
block size shall be 1024 bytes; otherwise, the block size is implementation-defined.
-t
Sort with the primary key being time modified (most recently modified first) and the secondary key being filename in the
collating sequence. For a symbolic link, the time used as the sort key is that of the symbolic link itself, unless ls is
evaluating its file information to be that of the file referenced by the link (see the -H and -L options).
-u
Use time of last access (see XBD ) instead of last
modification of the file for sorting (-t) or writing (-l).
-x
The same as -C, except that the multi-text-column output is produced with entries sorted across, rather than down, the
columns. This option disables long format output.
-1
(The numeric digit one.) Force output to be one entry per line. This option does not disable long format output. (Long format
output is enabled by [XSI]  -g,  -l (ell), -n,
and [XSI]
-o;  and disabled by -C, -m, and
-x.)
If an option that enables long format output ([XSI]  -g,  -l (ell), -n, and [XSI]  -o ) is given with an option
that disables long format output (-C, -m, and -x), this shall not be considered an error. The last of these
options specified shall determine whether long format output is written.
If -R, -d, or -f are specified, the results of specifying these mutually-exclusive options are specified by
the descriptions of these options above. If more than one of any of the other options shown in the SYNOPSIS section in
mutually-exclusive sets are given, this shall not be considered an error; the last option specified in each set shall determine the
output.
Note that if -t is specified, -c and -u are not only mutually-exclusive with each other, they are also
mutually-exclusive with -S when determining sort order. But even if -S is specified after all occurrences of
-c, -t, and -u, the last use of -c or -u determines the timestamp printed when producing long
format output.
OPERANDS
The following operand shall be supported:
file
A pathname of a file to be written. If the file specified is not found, a diagnostic message shall be output on standard
error.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of ls:
COLUMNS
Override the system-selected horizontal display line size, used to determine the column position width for writing multiple
text-column output. See XBD 8. Environment Variables for valid values and
results when it is unset or null. The ls utility shall use this value to calculate how many pathname text columns to write
(see -C). The column width chosen to write the names of files in any given directory shall be constant. Filenames shall not
be truncated to fit into the multiple text-column output.
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_COLLATE
Determine the locale for character collation information in determining the pathname collation sequence.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments) and which characters are defined as printable (character class print).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
LC_TIME
Determine the format and contents for date and time strings written by ls.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
TZ
Determine the timezone for date and time strings written by ls. If TZ is unset or null, an unspecified default
timezone shall be used.
ASYNCHRONOUS EVENTS
Default.
STDOUT
The default format shall be to list one entry per line to standard output; the exceptions are to terminals or when one of the
-C, -m, or -x options is specified. If the output is to a terminal, the format is implementation-defined.
In the formats specified below, except where specified otherwise the  field shall consist of the file's
pathname and, if the -F or -p option is specified, any indicator character written after the pathname as described
for those options.
When -m is specified, the format used for the last element of the list shall be:
"%s\n",
The format used for each other element of the list shall be:
"%s,%s", ,
where, if there is not room for the next element of the list to fit within the current line length,  is
a string containing an optional  character and a mandatory  character; otherwise it is a single
character.
If the -i option is specified, the file's file serial number (see XBD ) shall be written in the following format before any other output for
the corresponding entry:
%u ",
If the -l option is specified, the following information shall be written for files other than character special and
block special files:
"%s %u %s %s %u %s %s\n", , ,
, , , ,
If the -l option is specified, the following information shall be written for character special and block special
files:
"%s %u %s %s %s %s %s\n", , ,
, , , ,
In both cases if the file is a symbolic link and the -L option is also specified, this information shall be for the file
resolved from the symbolic link, except that the  field shall contain the pathname of the symbolic link
itself. If the file is a symbolic link and the -L option is not specified, this information shall be about the link itself
and the  field shall be one of the following forms:
"%s%sΔ->Δ%s", , ,
"%sΔ->Δ%s%s", , ,
"%s%sΔ->Δ%s%s", , ,
,
where  is a  ('@') if the -F option is specified, or an
empty string otherwise and  is the required indicator character, if any, for the file resolved
from the symbolic link if the -F or -p option is specified, or an empty string otherwise. If pathname resolution
fails when following the symbolic link, this shall not be treated as an error and the  field
shall be an empty string.
The -n, [XSI]  -g, and -o  options use
the same format as -l, but with omitted items and their associated  characters. See the OPTIONS section.
In both the preceding -l forms, if  or  cannot be determined, or if
-n is given, they shall be replaced with their associated numeric values using the format %u.
The  field shall contain the value that would be returned for the file in the st_size field of
struct stat (see XBD ). Note that for some file types
this value is unspecified.
The  field shall contain implementation-defined information associated with the device in
question.
The  field shall contain the appropriate date and timestamp of when the file was last
modified. In the POSIX locale, the field shall be the equivalent of the output of the following date command:
date "+%b %e %H:%M"
if the file has been modified in the last six months, or:
date "+%b %e %Y"
(where two  characters are used between %e and %Y) if the file has not been modified in the last
six months or if the modification date is in the future, except that, in both cases, the final  produced by date shall not be included and the output shall be as if the date command were executed at the time of the last modification date of the file rather than
the current time. When the LC_TIME locale category is not set to the POSIX locale, a different format and order of
presentation of this field may be used.
If the pathname was specified as a file operand, it shall be written as specified.
The file mode written under the -l, -n, [XSI]  -g, and -o  options shall consist of the following format:
"%c%s%s%s%s", , ,
, ,
The  shall be the empty string if there is no alternate
or additional access control method associated with the file; otherwise, it shall be a string containing a single printable
character that is not a .
The  character shall describe the type of file, as follows:
d
Directory.
b
Block special file.
c
Character special file.
l (ell)
Symbolic link.
p
FIFO.
s
Socket.
-
Regular file.
Implementations may add other characters to this list to represent other implementation-defined file types.
The next three fields shall be three characters each:
Permissions for the file owner class (see XBD 4.7 File Access Permissions
).
Permissions for the file group class.
Permissions for the file other class.
Each field shall have three character positions:
If 'r', the file is readable; if '-', the file is not readable.
If 'w', the file is writable; if '-', the file is not writable.
The first of the following that applies:
S
If in , the file is not executable and set-user-ID mode is set. If in
, the file is not executable and set-group-ID mode is set.
s
If in , the file is executable and set-user-ID mode is set. If in
, the file is executable and set-group-ID mode is set.
T
[XSI]
If in  and the file is a directory, search permission is not granted to others, and the
restricted deletion flag is set.
t
[XSI]
If in  and the file is a directory, search permission is granted to others, and the restricted
deletion flag is set.
x
The file is executable or the directory is searchable.
-
None of the attributes of 'S', 's', 'T', 't', or 'x' applies.
Implementations may add other characters to this list for the third character position. Such additions shall, however, be
written in lowercase if the file is executable or searchable, and in uppercase if it is not.
If any of the -l, -n, -s, [XSI]  -g, or -o  options is specified, each list of files within a directory shall be preceded by a status line
indicating the number of file system blocks occupied by the listed files for that directory in 512-byte units if the -k
option is not specified, or 1024-byte units if the -k option is specified, rounded up to the next integral number of units,
if necessary. In the POSIX locale, the format shall be:
"total %u\n",
If more than one directory, or a combination of non-directory files and directories are written, either as a result of
specifying multiple operands, or the -R option, each list of files within a directory shall be preceded by:
"\n%s:\n",
The above string may be omitted for the directory named by the operand if only one operand is present. It may also be omitted
for dot ('.') if no operands are present. If this string is the first thing to be written, the first  shall
not be written. This output shall precede the number of units in the directory.
If the -s option is given, each file shall be written with the number of blocks used by the file. Along with -C,
-1, -m, or -x, the number and a  shall precede the filename; with -l, -n,
[XSI]
-g, or -o,  they shall precede each line describing a
file.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
It is difficult for an application to use every part of the file modes field of ls -l in a portable manner.
Certain file types and executable bits are not guaranteed to be exactly as shown, as implementations may have extensions.
Applications can use this field to pass directly to a user printout or prompt, but actions based on its contents should generally
be deferred, instead, to the test utility.
The output of ls (with the -l and related options) contains information that logically could be used by utilities
such as chmod and touch to restore files
to a known state. However, this information is presented in a format that cannot be used directly by those utilities or be easily
translated into a format that can be used. A character has been added to the end of the permissions string so that applications at
least have an indication that they may be working in an area they do not understand instead of assuming that they can translate the
permissions string into something that can be used. Future versions or related documents may define one or more specific characters
to be used based on different standard additional or alternative access control mechanisms.
As with many of the utilities that deal with filenames, the output of ls for multiple files or in one of the long listing
formats must be used carefully on systems where filenames can contain embedded white space. Systems and system administrators
should institute policies and user training to limit the use of such filenames.
The number of disk blocks occupied by the file that it reports varies depending on underlying file system type, block size units
reported, and the method of calculating the number of blocks. On some file system types, the number is the actual number of blocks
occupied by the file (counting indirect blocks and ignoring holes in the file); on others it is calculated based on the file size
(usually making an allowance for indirect blocks, but ignoring holes).
The total number provided when using ls -l does not necessarily correspond to the space that would be
reclaimed if all the listed files were removed, because of hard links (and symbolic links if -L is present). The space for
each listed file is counted in the total regardless of any relationship between the files.
EXAMPLES
An example of a small directory tree being fully listed with ls -laRF a in the POSIX locale:
a:
total 11
drwxr-xr-x   3 fox      prog          64 Jul  4 12:07 ./
drwxrwxrwx   4 fox      prog        3264 Jul  4 12:09 ../
drwxr-xr-x   2 fox      prog          48 Jul  4 12:07 b/
-rwxr--r--   1 fox      prog         572 Jul  4 12:07 foo*
a/b:
total 4
drwxr-xr-x   2 fox      prog          48 Jul  4 12:07 ./
drwxr-xr-x   3 fox      prog          64 Jul  4 12:07 ../
-rw-r--r--   1 fox      prog         700 Jul  4 12:07 bar
where the "a:" line may be omitted by some implementations.
RATIONALE
Some historical implementations of the ls utility show all entries in a directory except dot and dot-dot when a superuser
invokes ls without specifying the -a option. When "normal" users invoke ls without specifying -a,
they should not see information about any files with names beginning with a  unless they were named as file
operands.
Implementations are expected to traverse arbitrary depths when processing the -R option. The only limitation on depth
should be based on running out of physical storage for keeping track of untraversed directories.
The -1 (one) option was historically found in BSD and BSD-derived implementations only. It is required in this volume of
POSIX.1-2024 so that conforming applications might ensure that output is one entry per line, even if the output is to a
terminal.
The -S option was added in Issue 7, but had been provided by several implementations for many years. The description
given in the standard documents historic practice, but does not match much of the documentation that described its behavior.
Historical documentation typically described it as something like:
-S
Sort by size (largest size first) instead of by name. Special character devices (listed last) are sorted by name.
even though the file type was never considered when sorting the output. Character special files do typically sort close to the
end of the list because their file size on most implementations is zero. But they are sorted alphabetically with any other files
that happen to have the same file size (zero), not sorted separately and added to the end.
This volume of POSIX.1-2024 is frequently silent about what happens when mutually-exclusive options are specified. Except for
-R, -d, and -f, the ls utility is required to accept multiple options from each mutually-exclusive
option set without treating them as errors and to use the behavior specified by the last option given in each mutually-exclusive
set. Since ls is one of the most aliased commands, it is important that the implementation perform intuitively. For example,
if the alias were:
alias ls="ls -C"
and the user typed ls -1 (one), single-text-column output should result, not an error.
The -g, -l (ell), -n, and -o options are not mutually-exclusive options. They all enable long format
output. They work together to determine whether the file's owner is written (no if -g is present), file's group is written
(no if -o is present), and if the file's group or owner is written whether it is written as the name (default) or a string
representation of the UID or GID number (if -n is present). The -C, -m, -x, and -1 (one) are
mutually-exclusive options and the first three of these disable long format output. The -1 (one) option does not directly
change whether or not long format output is enabled, but by overriding -C, -m, and -x, it can re-enable long
format output that had been disabled by one of these options.
Earlier versions of this standard did not describe the BSD -A option (like -a, but dot and dot-dot are not written
out). It has been added due to widespread implementation.
Implementations may make -q the default for terminals to prevent trojan horse attacks on terminals with special escape
sequences. This is not required because:
Some control characters may be useful on some terminals; for example, a system might write them as "\001" or
"^A".
Special behavior for terminals is not relevant to applications portability.
An early proposal specified that the  had to be
'+' if there was an alternate access method used on the file or  if there was not. This was changed to be
if there is not and a single printable character if there is. This was done for three reasons:
There are historical implementations using characters other than '+'.
There are implementations that vary this character used in that position to distinguish between various alternate access methods
in use.
The standard developers did not want to preclude future specifications that might need a way to specify more than one alternate
access method.
Nonetheless, implementations providing a single alternate access method are encouraged to use '+'.
Earlier versions of this standard did not have the -k option, which meant that the -s option could not be used
portably as its block size was implementation-defined, and the units used to specify the number of blocks occupied by files in a
directory in an ls -l listing were fixed as 512-byte units. The -k option has been added to provide a way for
the -s option to be used portably, and for consistency it also changes the aforementioned units from 512-byte to
1024-byte.
The  field in the -l format is specified only for the POSIX locale. As noted, the
format can be different in other locales. No mechanism for defining this is present in this volume of POSIX.1-2024, as the
appropriate vehicle is a messaging system; that is, the format should be specified as a "message".
FUTURE DIRECTIONS
If this utility is directed to display a pathname that contains any bytes that have the encoded value of a
character when  is a terminator or separator in the output format being used, implementations are encouraged to
treat this as an error. A future version of this standard may require implementations to treat this as an error.
Allowing -f to ignore the -A, -g, -l, -n, -o, and -s options may be removed in
a future version.
SEE ALSO
chmod, find, readlink
XBD 7.3.2 LC_COLLATE, 4.7 File Access Permissions, 8.
Environment Variables, 12.2 Utility Syntax Guidelines,
XSH fstatat()
CHANGE HISTORY
First released in Issue 2.
Issue 5
A second FUTURE DIRECTION is added.
Issue 6
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
In the -F option, other symbols are allowed for other file types.
Treatment of symbolic links is added, as defined in the IEEE P1003.2b draft standard.
The Open Group Base Resolution bwg2001-010 is applied, adding the T and t fields as part of the XSI
option.
Issue 7
Austin Group Interpretation 1003.1-2001 #101 is applied, clarifying the optional alternate access method flag in the STDOUT
section.
Austin Group Interpretation 1003.1-2001 #128 is applied, clarifying the DESCRIPTION and the definition of the -R
option.
Austin Group Interpretation 1003.1-2001 #129 is applied, clarifying the behavior of ls when no operands are
specified.
Austin Group Interpretation 1003.1-2001 #198 is applied, clarifying the requirements for the -H option.
SD5-XCU-ERN-50 is applied, adding the -A option.
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
The -S option is added from The Open Group Technical Standard, 2006, Extended API Set Part 1.
The -f, -m, -n, -p, -s, and -x options are moved from the XSI option to the Base.
The description of the -f, -s, and -t options are revised and the -k option is added.
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0098 [424], XCU/TC1-2008/0099 [424], XCU/TC1-2008/0100 [424],
XCU/TC1-2008/0101 [424], XCU/TC1-2008/0102 [424], XCU/TC1-2008/0103 [424], XCU/TC1-2008/0104 [424], XCU/TC1-2008/0105 [423,424],
XCU/TC1-2008/0106 [424], XCU/TC1-2008/0107 [424], XCU/TC1-2008/0108 [424], XCU/TC1-2008/0109 [424], XCU/TC1-2008/0110 [424],
XCU/TC1-2008/0111 [423], XCU/TC1-2008/0112 [117], XCU/TC1-2008/0113 [117], XCU/TC1-2008/0114 [117], XCU/TC1-2008/0115 [424], and
XCU/TC1-2008/0116 [424] are applied.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0115 [963] and XCU/TC2-2008/0116 [963] are applied.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to report an error if a utility is directed to display a
pathname that contains any bytes that have the encoded value of a  character when  is a terminator or
separator in the output format being used.
Austin Group Defect 1023 is applied, clarifying the -R option with respect to subdirectory filenames beginning with a
.
Austin Group Defect 1070 is applied, requiring that any filenames or pathnames that collate equally are further compared
byte-by-byte using the collating sequence for the POSIX locale.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
Austin Group Defect 1146 is applied, clarifying the requirements for the status line written by ls -l.
Austin Group Defect 1147 is applied, clarifying the requirements for trailing file type indicators (such as '/' for a
directory).
Austin Group Defect 1148 is applied, clarifying the behavior of the -S option for symbolic links.
Austin Group Defect 1149 is applied, inserting a comma in the description of the -r option.
Austin Group Defect 1185 is applied, changing the COLUMNS entry in ENVIRONMENT VARIABLES.
Austin Group Defect 1217 is applied, adding file type indicators for sockets.
Austin Group Defect 1261 is applied, changing the STDOUT and EXAMPLES sections in relation to the  output.
Austin Group Defect 1457 is applied, adding readlink to the SEE ALSO
section.
Austin Group Defect 1703 is applied, changing "at-sign" to "".
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/find.html =====
find
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
find — find files
SYNOPSIS
find [-H|-L] path... [operand_expression...]
DESCRIPTION
The find utility shall recursively descend the directory hierarchy from each file specified by path, evaluating a
Boolean expression composed of the primaries described in the OPERANDS section for each file encountered. Each path operand
shall be evaluated unaltered as it was provided, including all trailing  characters; all pathnames for other files
encountered in the hierarchy shall consist of the concatenation of the current path operand, a  if the current
path operand did not end in one, and the filename relative to the path operand. The relative portion shall contain no
dot or dot-dot components, no trailing  characters, and only single  characters between pathname
components.
The find utility shall be able to descend to arbitrary depths in a file hierarchy and shall not fail due to path length
limitations (unless a path operand specified by the application exceeds {PATH_MAX} requirements).
The find utility shall detect infinite loops; that is, entering a previously visited directory that is an ancestor of the
last file encountered. When it detects an infinite loop, find shall write a diagnostic message to standard error and shall
either recover its position in the hierarchy or terminate. In either case, the final exit status shall be non-zero.
If a file is removed from or added to the directory hierarchy being searched it is unspecified whether or not find
includes that file in its search.
OPTIONS
The find utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following options shall be supported by the implementation:
-H
Cause the file information and file type evaluated for each symbolic link encountered as a path operand on the command
line to be those of the file referenced by the link, and not the link itself. If the referenced file does not exist, the file
information and type shall be for the link itself. File information and type for symbolic links encountered during the traversal of
a file hierarchy shall be that of the link itself.
-L
Cause the file information and file type evaluated for each symbolic link encountered as a path operand on the command
line or encountered during the traversal of a file hierarchy to be those of the file referenced by the link, and not the link
itself. If the referenced file does not exist, the file information and type shall be for the link itself.
Specifying more than one of the mutually-exclusive options -H and -L shall not be considered an error. The last
option specified shall determine the behavior of the utility. If neither the -H nor the -L option is specified, then
the file information and type for symbolic links encountered as a path operand on the command line or encountered during the
traversal of a file hierarchy shall be that of the link itself.
OPERANDS
The following operands shall be supported:
The first operand and subsequent operands up to but not including the first operand that starts with a '-', or is a
'!' or a '(', shall be interpreted as path operands. If the first operand starts with a '-', or
is a '!' or a '(', the behavior is unspecified. Each path operand is a pathname of a starting point in the
file hierarchy.
The first operand that starts with a '-', or is a '!' or a '(', and all subsequent arguments shall be
interpreted as an expression made up of the following primaries and operators. In the descriptions, wherever n is
used as a primary argument, it shall be interpreted as a decimal integer optionally preceded by a  ('+')
or  ('-'), as follows:
+n
More than n.
n
Exactly n.
-n
Less than n.
The following primaries shall be supported:
-name pattern
The primary shall evaluate as true if the basename of the current pathname matches pattern using the pattern matching
notation described in 2.14 Pattern Matching Notation. The additional
rules in 2.14.3 Patterns Used for Filename Expansion do not apply as
this is a matching operation, not an expansion.
-iname pattern
The -iname primary shall be equivalent to -name, except that the match shall be case insensitive. See XBD 4.1 Case Insensitive Comparisons.
-path pattern
The primary shall evaluate as true if the current pathname matches pattern using the pattern matching notation described in
2.14 Pattern Matching Notation. The additional rules in 2.14.3 Patterns Used for Filename Expansion do not apply as this is a
matching operation, not an expansion.
-nouser
The primary shall evaluate as true if the file belongs to a user ID for which the getpwuid() function defined in the System Interfaces volume of POSIX.1-2024 (or equivalent)
returns NULL.
-nogroup
The primary shall evaluate as true if the file belongs to a group ID for which the getgrgid() function defined in the System Interfaces volume of POSIX.1-2024 (or equivalent)
returns NULL.
-mount
The primary shall always evaluate as true; it shall cause find to act only on files that have the same device ID
(st_dev, see XSH fstatat()) as the path operand below which they are
encountered and cause find not to descend below directories that have a different device ID than that path operand.
If any -mount primary is specified, it shall apply to the entire expression even if the -mount primary would not
normally be evaluated.
-xdev
The primary shall always evaluate as true; it shall cause find not to descend below directories that have a different
device ID (st_dev, see XSH fstatat()) than the path operand below
which they are encountered; that is, when a directory with a different device ID is encountered, find shall act on the
directory itself (unless -mount is specified) but shall not act on any files below the directory. If any -xdev
primary is specified, it shall apply to the entire expression even if the -xdev primary would not normally be
evaluated.
-prune
The primary shall always evaluate as true; it shall cause find not to descend the current pathname if it is a directory.
If the -depth primary is specified, the -prune primary shall have no effect.
-perm [-]mode
The mode argument is used to represent file mode bits. It shall be processed in an identical manner to the
symbolic_mode operand described in chmod, except that:
The changes to file mode bits shall be applied to a template instead of to any files. The template shall initially have all file
mode bits cleared.
The op symbol '-' cannot be the first character of mode; this avoids ambiguity with the optional leading
. Since the initial mode is all bits off, there are not any symbolic modes that need to use '-' as the
first character.
If the  is omitted, the primary shall evaluate as true when the file permission bits exactly match the value
of the resulting template.
Otherwise, if mode is prefixed by a , the primary shall evaluate as true if at least all the bits in
the resulting template are set in the file permission bits.
-perm [-]onum
If the  is omitted, the primary shall evaluate as true when the file mode bits exactly match the value of the
octal number onum (see the description of the octal mode in chmod).
Otherwise, if onum is prefixed by a , the primary shall evaluate as true if at least all of the bits
specified in onum are set. In both cases, the behavior is unspecified when onum exceeds 07777.
-type c
The primary shall evaluate as true if the type of the file is c, where c is 'b', 'c',
'd', 'l', 'p', 'f', or 's' for block special file, character special file, directory,
symbolic link, FIFO, regular file, or socket, respectively.
-links n
The primary shall evaluate as true if the file has n links.
-user uname
The primary shall evaluate as true if the file belongs to the user uname. If uname is a decimal integer and the
getpwnam() (or equivalent) function does not return a valid user name, uname
shall be interpreted as a user ID.
-group gname
The primary shall evaluate as true if the file belongs to the group gname. If gname is a decimal integer and the
getgrnam() (or equivalent) function does not return a valid group name,
gname shall be interpreted as a group ID.
-size n[c]
The primary shall evaluate as true if the file size in bytes, divided by 512 and rounded up to the next integer, is n.
If n is followed by the character 'c', the size shall be in bytes.
-atime n
The primary shall evaluate as true if the file access time subtracted from the initialization time, divided by 86400 (with any
remainder discarded), is n.
-ctime n
The primary shall evaluate as true if the time of last change of file status information subtracted from the initialization
time, divided by 86400 (with any remainder discarded), is n.
-mtime n
The primary shall evaluate as true if the file modification time subtracted from the initialization time, divided by 86400
(with any remainder discarded), is n.
-exec utility_name [argument ...] ;
-exec utility_name [argument ...]  {} +
The end of the primary expression shall be punctuated by a  or by a . Only a
that immediately follows an argument containing only the two characters "{}" shall punctuate the end of the primary
expression. Other uses of the  shall not be treated as special.
If the primary expression is punctuated by a , the utility utility_name shall be invoked once for each
pathname and the primary shall evaluate as true if the utility returns a zero value as exit status. A utility_name or
argument containing only the two characters "{}" shall be replaced by the current pathname. If a
utility_name or argument string contains the two characters "{}", but not just the two characters
"{}", it is implementation-defined whether find replaces those two characters or uses the string without
change.
If the primary expression is punctuated by a , the primary shall always evaluate as true, and the pathnames for
which the primary is evaluated shall be aggregated into sets. The utility utility_name shall be invoked once for each set of
aggregated pathnames. Each invocation shall begin after the last pathname in the set is aggregated, and shall be completed before
the find utility exits and before the first pathname in the next set (if any) is aggregated for this primary, but it is
otherwise unspecified whether the invocation occurs before, during, or after the evaluations of other primaries. If any invocation
returns a non-zero value as exit status, the find utility shall return a non-zero exit status. An argument containing only
the two characters "{}" shall be replaced by the set of aggregated pathnames, with each pathname passed as a separate
argument to the invoked utility in the same order that it was aggregated. The size of any set of two or more pathnames shall be
limited such that execution of the utility does not cause the system's {ARG_MAX} limit to be exceeded. If more than one argument
containing the two characters "{}" is present, the behavior is unspecified.
The current directory for the invocation of utility_name shall be the same as the current directory when the find
utility was started. If the utility_name names any of the special built-in utilities (see 2.15 Special Built-In Utilities), the results are undefined.
-ok utility_name [argument ...] ;
The -ok primary shall be equivalent to -exec, except that the use of a  to punctuate the end of the
primary expression need not be supported, and find shall request affirmation of the invocation of utility_name using
the current file as an argument by writing to standard error as described in the STDERR section. If the response on standard input
is affirmative, the utility shall be invoked. Otherwise, the command shall not be invoked and the value of the -ok operand
shall be false.
-print
The primary shall always evaluate as true; it shall cause the current pathname to be written to standard output, followed by a
.
-print0
The primary shall always evaluate as true; it shall cause the current pathname to be written to standard output, followed by a
null byte.
-newer file
The primary shall evaluate as true if the modification time of the current file is more recent than the modification time of
the file named by the pathname file. If file names a symbolic link, the modification time used shall be that of the
file referenced by the symbolic link if either the -H or -L option is specified; if neither -H nor -L
is specified, it is unspecified whether the modification time is that of the symbolic link itself or of the file referenced by the
symbolic link. In either case, if the referenced file does not exist, the modification time used shall be that of the link itself.
If file is a relative pathname, it shall be resolved relative to the current working directory that was inherited by
find when it was invoked.
-depth
The primary shall always evaluate as true; it shall cause descent of the directory hierarchy to be done so that all entries in
a directory are acted on before the directory itself. If a -depth primary is not specified, all entries in a directory shall
be acted on after the directory itself. If any -depth primary is specified, it shall apply to the entire expression even if
the -depth primary would not normally be evaluated.
The primaries can be combined using the following operators (in order of decreasing precedence):
( expression )
True if expression is true.
! expression
Negation of a primary; the unary NOT operator.
expression [-a] expression
Conjunction of primaries; the AND operator is implied by the juxtaposition of two primaries or made explicit by the optional
-a operator. The second expression shall not be evaluated if the first expression is false.
expression -o expression
Alternation of primaries; the OR operator. The second expression shall not be evaluated if the first expression is true.
If no expression is present, -print shall be used as the expression. Otherwise, if the given expression does not
contain any of the primaries -exec, -ok, or -print, the given expression shall be effectively replaced by:
( given_expression ) -print
The -user, -group, and -newer primaries each shall evaluate their respective arguments only once.
When the file type evaluated for the current file is a symbolic link, the results of evaluating the -perm primary are
implementation-defined.
STDIN
If the -ok primary is used, the response shall be read from the standard input. An entire line shall be read as the
response. Otherwise, the standard input shall not be used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of find:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_COLLATE
Determine the locale for the behavior of ranges, equivalence classes, and multi-character collating elements used in the pattern
matching notation for the -name, -iname, and -path primaries and in the extended regular expression defined
for the yesexpr locale keyword in the LC_MESSAGES category.
LC_CTYPE
This variable determines the locale for the interpretation of sequences of bytes of text data as characters (for example,
single-byte as opposed to multi-byte characters in arguments), the behavior of character classes within the pattern matching
notation used for the -name, -iname, and -path primaries, and the behavior of character classes within regular
expressions used in the extended regular expression defined for the yesexpr locale keyword in the LC_MESSAGES
category.
LC_MESSAGES
Determine the locale used to process affirmative responses, and the locale used to affect the format and contents of diagnostic
messages and prompts written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
PATH
Determine the location of the utility_name for the -exec and -ok primaries, as described in XBD 8. Environment Variables.
ASYNCHRONOUS EVENTS
Default.
STDOUT
The -print primary shall cause the current pathname to be written to standard output. The format shall be:
"%s\n",
The -print0 primary shall cause the current pathname to be written to standard output, followed by a null byte.
STDERR
The -ok primary shall write a prompt to standard error containing at least the utility_name to be invoked and the
current pathname. In the POSIX locale, the last non- in the prompt shall be '?'. The exact format used is
unspecified.
Otherwise, the standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
All path operands were traversed successfully, the output (if any) specified in STDOUT was successfully written to
standard output, and all commands (if any) executed using the -exec primary punctuated by a  exited with
exit status 0.
>0
A command executed using the -exec primary punctuated by a  exited with non-zero status, or an error
occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
When used in operands, pattern matching notation, , , and
characters are special to the shell and must be quoted (see 2.2 Quoting
).
When restricting the search to files on one file system, it can sometimes be desirable for the crossing points themselves to be
acted on and sometimes for them not to be acted on. (Crossing points are mount points and, if the -L option is specified,
symbolic links to directories on other file systems.) The -xdev primary acts on them and the -mount primary does not.
However, -mount also does not act on symbolic links to non-directory files on other file systems (if -L is
specified). If there is a need for an application to exclude crossing points but include symbolic links to non-directory files on
other file systems, this can be achieved by using two find commands as follows:
find -L dir -mount -type d -print
find -L dir -xdev ! -type d -print
(in a subshell whose output is piped to sort, if the order matters).
If both -mount and -xdev are specified, find obeys both primaries but the end result is the same as if
-xdev were not specified.
The bit that is traditionally used for sticky (historically 01000) is specified in the -perm primary using the octal
number argument form. Since this bit is not defined by this volume of POSIX.1-2024, applications must not assume that it actually
refers to the traditional sticky bit.
EXAMPLES
The following commands are equivalent:
find .
find . -print
They both write out the entire directory hierarchy from the current directory.
With this output format, if any pathnames include  characters, it is not possible to tell where each pathname
begins and ends. This problem can be avoided by omitting such pathnames:
LC_ALL=POSIX find . -name $'*\n*' -prune -o -print
or by using a sentinel in the pathname that find would never otherwise produce, such as:
find .//. -print
or by using -print0 instead of -print and processing the output with a utility that can accept null-terminated
pathnames as input, such as xargs with the -0 option or read with -d "", for example:
find . -print0 | while IFS= read -rd "" file
do
# process "$file"
done
It should be noted that using find with -print0 to pipe input to xargs -r0 is less safe than using find with -exec because if find
-print0 is terminated after it has written a partial pathname, the partial pathname may be processed as if it was a complete
pathname.
The following command:
find / \( -name tmp -o -name '*.xx' \) ! -type d -mtime +7 \
-exec rm {} +
removes all files named tmp or ending in .xx that have not been modified for more than seven (that is, eight or
more) 24-hour periods.
The following command:
find . -perm -o+w,+s
prints (-print is assumed) the names of all files in or below the current directory, with all of the file permission bits
S_ISUID, S_ISGID, and S_IWOTH set, regardless of the value of the file creation mask. (Note that the file creation mask is only
specified for the file permission bits, and not S_ISUID, S_ISGID or S_ISVTX.)
The following command:
find . -perm -+w
prints (-print is assumed) the names of all files in or below the current directory, with S_IWUSR set if the file
creation mask does not have S_IWUSR set (otherwise the S_IWUSR bit is ignored), S_IWGRP set if the file creation mask does not have
S_IWGRP set (otherwise S_IWGRP is ignored), and S_IWOTH set if the file creation mask does not have S_IWOTH set (otherwise S_IWOTH
is ignored).
The following command:
find . -name SCCS -prune -o -print
recursively prints pathnames of all files in the current directory and below, but skips directories named SCCS and files in
them.
The following command:
find . -print -name SCCS -prune
behaves as in the previous example, but prints the names of the SCCS directories.
The following command is roughly equivalent to the -nt extension to test:
if [ -n "$(find file1 -prune -newer file2)" ]; then
printf %s\\n "file1 is newer than file2"
fi
The descriptions of -atime, -ctime, and -mtime use the terminology n "86400 second periods
(days)". For example, a file accessed at 23:59 is selected by:
find . -atime -1 -print
at 00:01 the next day (less than 24 hours later, not more than one day ago); the midnight boundary between days has no effect on
the 24-hour calculation.
The following command:
find . ! -name . -prune -name '*.old' -exec \
sh -c 'mv "$@" ../old/' sh {} +
performs the same task as:
mv ./*.old ./.old ./.*.old ../old/
while avoiding an "Argument list too long" error if there are a large number of files ending with .old and without
running mv if there are no such files (and avoiding "No such file or directory" errors
if ./.old does not exist or no files match ./*.old or ./.*.old).
The alternative:
find . ! -name . -prune -name '*.old' -exec mv {} ../old/ \;
is less efficient if there are many files to move because it executes one mv command
per file.
On systems configured to mount removable media on directories under /media, the following command searches the file
hierarchy for files of size larger than 100000 KiB without searching any mounted removable media:
find / -path /media -prune -o -size +200000 -print
Except for the root directory, and "//" on implementations where "//" does not refer to the root directory, no
pattern given to -name will match a , because trailing  characters are ignored when computing the
basename of the file under evaluation. Given two empty directories named foo and bar, the following command:
find foo/// bar/// -name foo -o -name 'bar?*'
prints only the line "foo///".
RATIONALE
The -a operator was retained as an optional operator for compatibility with historical shell scripts, even though it is
redundant with expression concatenation.
The descriptions of the '-' modifier on the mode and onum arguments to the -perm primary agree
with historical practice on BSD and System V implementations. System V and BSD documentation both describe it in terms of checking
additional bits; in fact, it uses the same bits, but checks for having at least all of the matching bits set instead of having
exactly the matching bits set.
The exact format of the interactive prompts is unspecified. Only the general nature of the contents of prompts are specified
because:
Implementations may desire more descriptive prompts than those used on historical implementations.
Since the historical prompt strings do not terminate with  characters, there is no portable way for another
program to interact with the prompts of this utility via pipes.
Therefore, an application using this prompting option relies on the system to provide the most suitable dialog directly with the
user, based on the general guidelines specified.
The -size operand refers to the size of a file, rather than the number of blocks it may occupy in the file system. The
intent is that the st_size field defined in the System Interfaces volume of POSIX.1-2024 should be used, not the
st_blocks found in historical implementations. There are at least two reasons for this:
In both System V and BSD, find only uses st_size in size calculations for the operands specified by this volume of
POSIX.1-2024. (BSD uses st_blocks only when processing the -ls primary.)
Users usually think of file size in terms of bytes, which is also the unit used by the ls utility for the output from the -l option. (In both System V and BSD, ls uses st_size for the -l option size field and uses st_blocks for the
ls -s calculations. This volume of POSIX.1-2024 does not specify ls -s.)
The descriptions of -atime, -ctime, and -mtime were changed from the SVID description of n "days"
to n being the result of the integer division of the time difference in seconds by 86400. The description is also different
in terms of the exact timeframe for the n case (versus the +n or -n), but it matches all known
historical implementations. It refers to one 86400 second period in the past, not any time from the beginning of that period to the
current time. For example, -atime 2 is true if the file was accessed any time in the period from 72 hours to 48 hours
ago.
Historical implementations do not modify "{}" when it appears as a substring of an -exec or -ok
utility_name or argument string. There have been numerous user requests for this extension, so this volume of POSIX.1-2024
allows the desired behavior. At least one recent implementation does support this feature, but encountered several problems in
managing memory allocation and dealing with multiple occurrences of "{}" in a string while it was being developed, so it
is not yet required behavior.
Assuming the presence of -print was added to correct a historical pitfall that plagues novice users, it is entirely
upwards-compatible from the historical System V find utility. In its simplest form (find directory), it could be confused with the historical BSD fast find. The BSD
developers agreed that adding -print as a default expression was the correct decision and have added the fast find
functionality within a new utility called locate.
Historically, the -L option was implemented using the primary -follow. The -H and -L options were
added for two reasons. First, they offer a finer granularity of control and consistency with other programs that walk file
hierarchies. Second, the -follow primary always evaluated to true. As they were historically really global variables that
took effect before the traversal began, some valid expressions had unexpected results. An example is the expression -print
-o -follow. Because -print always evaluates to true, the standard order of evaluation implies that
-follow would never be evaluated. This was never the case. Historical practice for the -follow primary, however, is
not consistent. Some implementations always follow symbolic links on the command line whether -follow is specified or not.
Others follow symbolic links on the command line only if -follow is specified. Both behaviors are provided by the -H
and -L options, but scripts using the current -follow primary would be broken if the -follow option is
specified to work either way.
Since the -L option resolves all symbolic links and the -type l primary is true for symbolic links that
still exist after symbolic links have been resolved, the command:
find -L . -type l
prints a list of symbolic links reachable from the current directory that do not resolve to accessible files.
A feature of SVR4's find utility was the -exec primary's + terminator. This allowed filenames containing
special characters (especially  characters) to be grouped together without the problems that occur if such filenames
are piped to xargs.
The "-exec ... {} +" syntax adopted was a result of IEEE PASC Interpretation 1003.2 #210. It should be noted that this
is an incompatible change to IEEE Std 1003.2-1992. For example, the following command printed all files with a
'-' after their name if they are regular files, and a '+' otherwise:
find / -type f -exec echo {} - ';' -o -exec echo {} + ';'
The change invalidates usage like this. Even though the previous standard stated that this usage would work, in practice many
did not support it and the standard developers felt it better to now state that this was not allowable.
Historically, many find implementations supported -mount and -xdev as synonymous primaries and earlier
versions of this standard only required support for -xdev. However, the behavior of find with -xdev differed
from that of the nftw() function with FTW_MOUNT as regards whether the mount point
itself was included or excluded. Therefore the standard now requires support for both primaries with slightly differing behaviors:
-mount behaves in the manner of nftw() with the traditional FTW_MOUNT flag, and
-xdev in the manner of nftw() with a new FTW_XDEV flag.
FUTURE DIRECTIONS
If this utility is directed to display a pathname that contains any bytes that have the encoded value of a
character when  is a terminator or separator in the output format being used, implementations are encouraged to
treat this as an error. A future version of this standard may require implementations to treat this as an error.
SEE ALSO
2.2 Quoting, 2.14
Pattern Matching Notation, 2.15 Special Built-In Utilities,
chmod, mv, pax, sh, test
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
XSH fstatat(), getgrgid(),
getpwuid()
CHANGE HISTORY
First released in Issue 2.
Issue 5
The FUTURE DIRECTIONS section is added.
Issue 6
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The -perm [-]onum primary is supported.
The find utility is aligned with the IEEE P1003.2b draft standard, to include processing of symbolic links and
changes to the description of the atime, ctime, and mtime operands.
IEEE PASC Interpretation 1003.2 #210 is applied, extending the -exec operand.
IEEE Std 1003.1-2001/Cor 2-2004, item XCU/TC2/D6/13 is applied, updating the RATIONALE section to be consistent
with the normative text.
Issue 7
Austin Group Interpretation 1003.1-2001 #126 is applied, changing the description of the LC_MESSAGES environment
variable.
Austin Group Interpretation 1003.1-2001 #127 is applied, rephrasing the description of the -exec primary to be
"immediately follows".
Austin Group Interpretation 1003.1-2001 #185 is applied, clarifying the requirements for the -H and -L
options.
Austin Group Interpretation 1003.1-2001 #186 is applied, clarifying the requirements for the evaluation of path
operands.
Austin Group Interpretation 1003.1-2001 #195 is applied, clarifying the interpretation of the first operand.
SD5-XCU-ERN-48 is applied, clarifying the -L option in the case that the referenced file does not exist.
SD5-XCU-ERN-89 is applied, updating the OPERANDS section.
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
SD5-XCU-ERN-117 is applied, clarifying the -perm operand.
SD5-XCU-ERN-122 is applied, adding a new EXAMPLE.
The description of the -name primary is revised and the -path primary is added (with a new example).
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0086 [365], XCU/TC1-2008/0087 [310], XCU/TC1-2008/0088 [309,310,430],
XCU/TC1-2008/0089 [235], and XCU/TC1-2008/0090 [445] are applied.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0099 [584], XCU/TC2-2008/0100 [584], and XCU/TC2-2008/0101 [584] are
applied.
Issue 8
Austin Group Defect 243 is applied, adding the -print0 primary.
Austin Group Defect 251 is applied, encouraging implementations to report an error if a utility is directed to display a
pathname that contains any bytes that have the encoded value of a  character when  is a terminator or
separator in the output format being used.
Austin Group Defect 1031 is applied, adding the -iname primary.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
Austin Group Defect 1133 is applied, adding the -mount primary.
Austin Group Defects 1259 and 1777 are applied, changing the EXAMPLES section.
Austin Group Defect 1392 is applied, changing the effect of the file creation mask on the mode argument for the
-perm primary to be consistent with chmod.
Austin Group Defect 1501 is applied, changing the EXIT STATUS section.
Austin Group Defect 1553 is applied, changing the ENVIRONMENT VARIABLES section.
Austin Group Defect 1554 is applied, changing the RATIONALE section.
Austin Group Defect 1606 is applied, clarifying that if find detects an infinite loop and recovers its position, the
final exit status is non-zero.
Austin Group Defect 1776 is applied, clarifying how symbolic links are handled by the -newer file primary.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/dd.html =====
dd
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
dd — convert and copy a file
SYNOPSIS
dd [operand...]
DESCRIPTION
The dd utility shall copy the specified input file to the specified output file with possible conversions using specific
input and output block sizes. It shall read the input one block at a time, using the specified input block size; it shall then
process the block of data actually returned, which could be smaller than the requested block size. It shall apply any conversions
that have been specified and write the resulting data to the output in blocks of the specified output block size. If the
bs=expr operand is specified and no conversions other than sync, noerror, or notrunc are
requested, the data returned from each input block shall be written as a separate output block; if the read returns less than a
full block and the sync conversion is not specified, the resulting output block shall be the same size as the input block.
If the bs=expr operand is not specified, or a conversion other than sync, noerror, or notrunc is
requested, the input shall be processed and collected into full-sized output blocks until the end of the input is reached.
The processing order shall be as follows:
An input block is read. If the iflags=fullblock operand is specified, this might entail multiple reads; otherwise, the
input block shall be used even if the read was shorter than the specified block size.
If the input block is shorter than the specified input block size and the sync conversion is specified, null bytes shall
be appended to the input data up to the specified size. (If either block or unblock is also specified,
characters shall be appended instead of null bytes.) The remaining conversions and output shall include the pad characters as if
they had been read from the input.
If the bs=expr operand is specified and no conversion other than sync or noerror is requested, the
resulting data shall be written to the output as a single block, and the remaining steps are omitted.
If the swab conversion is specified, each pair of input data bytes shall be swapped. If there is an odd number of bytes
in the input block, the last byte in the input record shall not be swapped.
Any remaining conversions (block, unblock, lcase, and ucase) shall be performed. These conversions
shall operate on the input data independently of the input blocking; an input or output fixed-length record may span block
boundaries.
The data resulting from input or conversion or both shall be aggregated into output blocks of the specified size. After the end
of input is reached, any remaining output shall be written as a block without padding if conv=sync is not specified;
thus, the final output block may be shorter than the output block size.
OPTIONS
None.
OPERANDS
All of the operands shall be processed before any input is read. The following operands shall be supported:
if=file
Specify the input pathname; the default is standard input.
of=file
Specify the output pathname; the default is standard output. If the seek=expr conversion is not also specified,
the output file shall be truncated before the copy begins if an explicit of=file operand is specified, unless
conv=notrunc is specified. If seek=expr is specified, but conv=notrunc is not, the effect
of the copy shall be to preserve the blocks in the output file over which dd seeks, but no other portion of the output file
shall be preserved. (If the size of the seek plus the size of the input file is less than the previous size of the output file, the
output file shall be shortened by the copy. If the input file is empty and either the size of the seek is greater than the previous
size of the output file or the output file did not previously exist, the size of the output file shall be set to the file offset
after the seek.)
ibs=expr
Specify the input block size, in bytes, by expr (default is 512).
obs=expr
Specify the output block size, in bytes, by expr (default is 512).
bs=expr
Set both input and output block sizes to expr bytes, superseding ibs= and obs=. If no conversion other
than sync, noerror, and notrunc is specified, each input block shall be copied to the output as a single block
without aggregating short blocks.
cbs=expr
Specify the conversion block size for block and unblock in bytes by expr (default is zero). If cbs=
is omitted or given a value of zero, using block or unblock produces unspecified results.
[XSI]
The application shall ensure that this operand is also specified if the conv= operand is specified with a value of
ascii, ebcdic, or ibm. For a conv= operand with an ascii value, the input is handled as
described for the unblock value, except that characters are converted to ASCII before any trailing  characters
are deleted. For conv= operands with ebcdic or ibm values, the input is handled as described for the
block value except that the characters are converted to EBCDIC or IBM EBCDIC, respectively, after any trailing
characters are added.
skip=n
Skip n input blocks (using the specified input block size) before starting to copy. On seekable files, the
implementation shall read the blocks or seek past them; on non-seekable files, the blocks shall be read and the data shall be
discarded.
seek=n
Skip n blocks (using the specified output block size) from the beginning of the output file before copying. On
non-seekable files, existing blocks shall be read and space from the current end-of-file to the specified offset, if any, filled
with null bytes; on seekable files, the implementation shall seek to the specified offset or read the blocks as described for
non-seekable files.
count=n
Copy only n input blocks. If n is zero, it is unspecified whether no blocks or all blocks are copied.
conv=value[,value ...]
Where values are -separated symbols from the following list:
ascii
[XSI]
Convert EBCDIC to ASCII; see ASCII to EBCDIC Conversion.
ebcdic
[XSI]
Convert ASCII to EBCDIC; see ASCII to EBCDIC Conversion.
ibm
[XSI]
Convert ASCII to a different EBCDIC set; see ASCII to IBM EBCDIC Conversion.
[XSI]
The ascii, ebcdic, and ibm values are mutually-exclusive.
block
Treat the input as a sequence of -terminated or end-of-file-terminated variable-length records independent of
the input block boundaries. Each record shall be converted to a record with a fixed length specified by the conversion block size.
Any  shall be removed from the input line;  characters shall be appended to lines that are shorter than
their conversion block size to fill the block. Lines that are longer than the conversion block size shall be truncated to the
largest number of characters that fit into that size; the number of truncated lines shall be reported (see the STDERR section).
The block and unblock values are mutually-exclusive.
unblock
Convert fixed-length records to variable length. Read a number of bytes equal to the conversion block size (or the number of
bytes remaining in the input, if less than the conversion block size), delete all trailing  characters, and append a
.
lcase
Map uppercase characters specified by the LC_CTYPE keyword tolower to the corresponding lowercase character.
Characters for which no mapping is specified shall not be modified by this conversion.
The lcase and ucase symbols are mutually-exclusive.
ucase
Map lowercase characters specified by the LC_CTYPE keyword toupper to the corresponding uppercase character.
Characters for which no mapping is specified shall not be modified by this conversion.
swab
Swap every pair of input bytes.
noerror
Do not stop processing on an input error. When an input error occurs, a diagnostic message shall be written on standard error,
followed by the current input and output block counts in the same format as used at completion (see the STDERR section). If the
sync conversion is specified, the missing input shall be replaced with null bytes and processed normally; otherwise, the
input block shall be omitted from the output.
notrunc
Do not truncate the output file. Preserve blocks in the output file not explicitly written by this invocation of the dd
utility. (See also the preceding of=file operand.)
sync
Pad every input block to the size of the ibs= buffer, appending null bytes. (If either block or unblock is
also specified, append  characters, rather than null bytes.)
iflags=fullblock
Perform as many reads as required to reach the full input block size or end of file, rather than acting on partial reads. If this
operand is in effect, then the count= operand refers to the number of full input blocks rather than reads. The behavior is
unspecified if iflags=fullblock is requested alongside the sync, block, or unblock conversions.
The behavior is unspecified if operands other than conv= are specified more than once.
For the bs=, cbs=, ibs=, and obs= operands, the application shall supply an expression specifying a
size in bytes. The expression, expr, can be:
A positive decimal number
A positive decimal number followed by k, specifying multiplication by 1024
A positive decimal number followed by b, specifying multiplication by 512
Two or more positive decimal numbers (with or without k or b) separated by x, specifying the product of the
indicated values
All of the operands are processed before any input is read.
[XSI]
The following two tables display the octal number character values used for the ascii and ebcdic conversions (first
table) and for the ibm conversion (second table). In both tables, the ASCII values are the row and column headers and the
EBCDIC values are found at their intersections. For example, ASCII 0012 (LF) is the second row, third column, yielding 0045 in
EBCDIC. The inverted tables (for EBCDIC to ASCII conversion) are not shown, but are in one-to-one correspondence with these tables.
The differences between the two tables are highlighted by small boxes drawn around five entries.
Table: ASCII to EBCDIC Conversion
Table: ASCII to IBM EBCDIC Conversion
STDIN
If no if= operand is specified, the standard input shall be used. See the INPUT FILES section.
INPUT FILES
The input file can be any file type.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of dd:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files), the classification of characters as uppercase or lowercase, and the
mapping of characters from one case to the other.
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error and
informative messages written to standard output.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
For SIGINT, the dd utility shall interrupt its current processing, write status information to standard error, and
terminate abnormally as if by the default action for SIGINT. One or more implementation defined non-job-control signals other than
SIGABRT, SIGHUP, and SIGTERM may write status information to standard error and continue processing. All other signals (including
job control signals, SIGABRT, SIGHUP, and SIGTERM) shall take their default action; see the ASYNCHRONOUS EVENTS section in 1.4 Utility Description Defaults.
STDOUT
If no of= operand is specified, the standard output shall be used. The nature of the output depends on the operands
selected.
STDERR
On completion, dd shall write the number of input and output blocks to standard error. In the POSIX locale the following
formats shall be used:
"%u+%u records in\n", ,
"%u+%u records out\n", ,
A partial input block is one for which read() returned less than the input block
size. A partial output block is one that was written with fewer bytes than specified by the output block size.
In addition, when there is at least one truncated block, the number of truncated blocks shall be written to standard error. In
the POSIX locale, the format shall be:
"%u truncated %s\n", , "record" (if
is one) "records" (otherwise)
Diagnostic messages may also be written to standard error.
OUTPUT FILES
If the of= operand is used, the output shall be the same as described in the STDOUT section.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
If an input error is detected and the noerror conversion has not been specified, any partial output block shall be
written to the output file, a diagnostic message shall be written, and the copy operation shall be discontinued. If some other
error is detected, a diagnostic message shall be written and the copy operation shall be discontinued.
The following sections are informative.
APPLICATION USAGE
The input and output block size can be specified to take advantage of raw physical I/O.
There are many different versions of the EBCDIC codesets. The ASCII and EBCDIC conversions specified for the dd utility
perform conversions for the version specified by the tables.
Using the count= operand of dd with a pipe or FIFO as the input can lead to surprising results, since these file
types are prone to encountering short reads for any input block size other than 1. Unless the iflags=fullblock operand is in
effect, dd will stop after the specified number of reads, rather than full input blocks, and therefore can often result in
fewer bytes being output than the product of the count and input block size.
EXAMPLES
The following command:
dd if=/dev/rmt0h  of=/dev/rmt1h
copies from tape drive 0 to tape drive 1, using a common historical device naming convention.
The following command:
dd ibs=10  skip=1
strips the first 10 bytes from standard input.
This example reads an EBCDIC tape blocked ten 80-byte EBCDIC card images per block into the ASCII file x:
dd if=/dev/tape of=x ibs=800 cbs=80 conv=ascii,lcase
RATIONALE
The OPTIONS section is listed as "None" because there are no options recognized by historical dd utilities. Certainly,
many of the operands could have been designed to use the Utility Syntax Guidelines, which would have resulted in the classic
hyphenated option letters. In this version of this volume of POSIX.1-2024, dd retains its curious JCL-like syntax due to the
large number of applications that depend on the historical implementation.
A suggested implementation technique for conv=noerror,sync is to zero (or -fill, if
blocking or unblocking) the input buffer before each read and to write the contents of the input buffer to the output
even after an error. In this manner, any data transferred to the input buffer before the error was detected is preserved. Another
point is that a failed read on a regular file or a disk generally does not increment the file offset, and dd must then seek
past the block on which the error occurred; otherwise, the input error occurs repetitively. When the input is a magnetic tape,
however, the tape normally has passed the block containing the error when the error is reported, and thus no seek is necessary.
The default ibs= and obs= sizes are specified as 512 bytes because there are historical (largely portable) scripts
that assume these values. If they were left unspecified, unusual results could occur if an implementation chose an odd block
size.
Historical implementations of dd used creat() when processing
of=file. This makes the seek= operand unusable except on special files. The conv=notrunc feature
was added because more recent BSD-based implementations use open() (without O_TRUNC)
instead of creat(), but they fail to delete output file contents after the data
copied.
The w multiplier (historically meaning word), is used in System V to mean 2 and in 4.2 BSD to mean 4. Since
word is inherently non-portable, its use is not supported by this volume of POSIX.1-2024.
Standard EBCDIC does not have the characters '[' and ']'. The values used in the table are taken from a common
print train that does contain them. Other than those characters, the print train values are not filled in, but appear to provide
some of the motivation for the historical choice of translations reflected here.
The Standard EBCDIC table provides a 1:1 translation for all 256 bytes.
The IBM EBCDIC table does not provide such a translation. The marked cells in the tables differ in such a way that:
EBCDIC 0112 ('¢') and 0152 (broken pipe) do not appear in the table.
EBCDIC 0137 ('¬') translates to/from ASCII 0236 ('^'). In the standard table, EBCDIC 0232 (no graphic) is
used.
EBCDIC 0241 ('~') translates to/from ASCII 0176 ('~'). In the standard table, EBCDIC 0137 ('¬') is
used.
0255 ('[') and 0275 (']') appear twice, once in the same place as for the standard table and once in place of
0112 ('¢') and 0241 ('~').
In net result:
EBCDIC 0275 (']') displaced EBCDIC 0241 ('~') in cell 0345.
That displaced EBCDIC 0137 ('¬') in cell 0176.
That displaced EBCDIC 0232 (no graphic) in cell 0136.
That replaced EBCDIC 0152 (broken pipe) in cell 0313.
EBCDIC 0255 ('[') replaced EBCDIC 0112 ('¢').
This translation, however, reflects historical practice that (ASCII) '~' and '¬' were often mapped to each
other, as were '[' and '¢'; and ']' and (EBCDIC) '~'.
The cbs operand is required if any of the ascii, ebcdic, or ibm operands are specified. For the
ascii operand, the input is handled as described for the unblock operand except that characters are converted to
ASCII before the trailing  characters are deleted. For the ebcdic and ibm operands, the input is handled
as described for the block operand except that the characters are converted to EBCDIC or IBM EBCDIC after the trailing
characters are added.
The block and unblock keywords are from historical BSD practice.
The consistent use of the word record in standard error messages matches most historical practice. An earlier version of
System V used block, but this has been updated in more recent releases.
Early proposals only allowed two numbers separated by x to be used in a product when specifying bs=, cbs=,
ibs=, and obs= sizes. This was changed to reflect the historical practice of allowing multiple numbers in the product
as provided by Version 7 and all releases of System V and BSD.
A change to the swab conversion is required to match historical practice and is the result of IEEE PASC Interpretations
1003.2 #03 and #04, submitted for the ISO POSIX-2:1993 standard.
A change to the handling of SIGINT is required to match historical practice and is the result of IEEE PASC Interpretation 1003.2
#06 submitted for the ISO POSIX-2:1993 standard.
FUTURE DIRECTIONS
If this utility is directed to create a new directory entry that contains any bytes that have the encoded value of a
character, implementations are encouraged to treat this as an error. A future version of this standard may require
implementations to treat this as an error.
A future version of this standard may introduce the SIGINFO signal; on platforms where such a signal is available, it is
recommended that this signal be used for reporting status without terminating the process.
SEE ALSO
1.4 Utility Description Defaults, sed, tr
XBD 8. Environment Variables
CHANGE HISTORY
First released in Issue 2.
Issue 5
The second paragraph of the cbs= description is reworded and marked EX.
The FUTURE DIRECTIONS section is added.
Issue 6
Changes are made to swab conversion and SIGINT handling to align with the IEEE P1003.2b draft standard.
The normative text is reworded to avoid use of the term "must" for application requirements.
IEEE PASC Interpretation 1003.2 #209 is applied, clarifying the interaction between dd of=file and
conv=notrunc.
Issue 7
Austin Group Interpretation 1003.1-2001 #102 is applied.
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0081 [907] is applied.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to disallow the creation of filenames containing any bytes that
have the encoded value of a  character.
Austin Group Defect 406 is applied, adding the iflags=fullblock operand.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
Austin Group Defect 1159 is applied, changing the ASYNCHRONOUS EVENTS and FUTURE DIRECTIONS sections.
Austin Group Defect 1497 is applied, changing the EXIT STATUS section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/true.html =====
true
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
true — return true value
SYNOPSIS
true
DESCRIPTION
The true utility shall return with exit code zero.
OPTIONS
None.
OPERANDS
None.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
None.
ASYNCHRONOUS EVENTS
Default.
STDOUT
Not used.
STDERR
Not used.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
Zero.
CONSEQUENCES OF ERRORS
None.
The following sections are informative.
APPLICATION USAGE
This utility is typically used in shell scripts, as shown in the EXAMPLES section.
Although the special built-in utility : (colon) is similar to true,
there are some notable differences, including:
Whereas colon is required to accept, and do nothing with, any number of arguments,
true is only required to accept, and discard, a first argument of "--". Passing any other argument(s) to
true may cause its behavior to differ from that described in this standard.
A non-interactive shell exits when a redirection error occurs with colon (unless
executed via command), whereas with true it does not.
Variable assignments preceding the command name persist after executing colon
(unless executed via command), but not after executing true.
In shell implementations where true is not provided as a built-in, using colon avoids the overheads associated with executing an external utility.
EXAMPLES
This command is executed forever:
while true
do
command
done
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.9 Shell Commands, colon, command, false
CHANGE HISTORY
First released in Issue 2.
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/39 is applied, replacing the terms "None" and "Default" from
the STDERR and EXIT STATUS sections, respectively, with terms as defined in 1.4
Utility Description Defaults.
Issue 8
Austin Group Defect 1640 is applied, clarifying the differences between true and : (colon).
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/fuser.html =====
fuser
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fuser — list process IDs of all processes that are using one or more named files
SYNOPSIS
[XSI]  fuser [-cfu] file...
DESCRIPTION
For each file operand, in order, fuser shall write one line of output, some of it to standard output, and the rest
to standard error, giving information about processes running on the local system that are using the file. A process shall be
considered to be using a file if it has at least one open file descriptor associated with the file or if the file is a directory
that is the current working directory or the root directory for the process, and may be considered to be using a file for other
implementation-dependent reasons. If file names a block special device that contains a mounted file system, and the
-f option is not specified, any processes using any file on that mounted file system and any processes that are using the
device file itself shall be listed.
Any output for processes running on remote systems that are using a named file is unspecified.
A user may need appropriate privileges to invoke the fuser utility.
When standard output and standard error are directed to the same file, the output for each file operand shall be
interleaved so that it is written to the file in the following order:
On standard error, a pathname for the file, immediately followed by a  and zero or more  characters.
The pathname shall be either the file operand (unaltered) or the pathname that would result from a successful call to the realpath() function, defined in the System Interfaces volume of POSIX.1-2024, with the
file operand as its file_name argument.
For each process using the file:
On standard output, the process ID in the format:
" %1d",
On standard error, information about the file's use by the process, in the following format:
"%s",
if the -u option is not specified, or in the following format:
"%s(%s)", ,
if the -u option is specified, where  is a string of zero or more characters indicating the use
of the file and  is the user name corresponding to the real user ID of the process or, if the user name
cannot be resolved from the real user ID of the process, the real user ID of the process in decimal. The value of  shall include the character 'c' if the process is using the file as its current directory and the character
'r' if the process is using the file as its root directory; implementations may include other alphabetic characters to
indicate other uses of the file.
On standard error, a  character.
When standard output and standard error are not directed to the same file, the data written to each shall be as described above
but the ordering of writes to standard output relative to writes to standard error is unspecified. For example, fuser might
first write the information for all file operands to standard error and then write all of the process IDs to standard output.
OPTIONS
The fuser utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following options shall be supported:
-c
If a file operand names a directory that is the mount point of a mounted file system, all processes using any file on
that file system shall be listed as if they were using the named directory. The behavior for any file operand that names an
existing file that is not the mount point of a mounted file system is unspecified.
-f
The report shall be only for the named files.
-u
The user name, in parentheses, associated with each process ID written to standard output shall be written to standard
error.
OPERANDS
The following operand shall be supported:
file
A pathname of a file for which the processes using the file are to be reported.
STDIN
Not used.
INPUT FILES
The user database.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of fuser:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
See DESCRIPTION.
STDERR
The fuser utility shall write diagnostic messages to standard error.
The fuser utility also shall write information to standard error as specified in the DESCRIPTION section.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
Things can change while fuser is running; the snapshot it gives is only true for an instant, and might not be accurate by
the time it is displayed.
EXAMPLES
The command:
fuser -fu .
writes to standard output the process IDs of processes that are using the current directory and writes to standard error an
indication of how those processes are using the directory and the user names associated with the processes that are using the
current directory.
fuser -c
writes to standard output the process IDs of processes that are using any file in the file system which is mounted on
and writes to standard error an indication of how those processes are using the files.
fuser
writes to standard output the process IDs of processes that are using the file which is named by  and
writes to standard error an indication of how those processes are using the file.
fuser
writes to standard output the process IDs of processes that are using any file on the mounted file system contained by
and of processes that are using the device file  itself, and
writes to standard error an indication of how those processes are using the files.
fuser -f
writes to standard output the process IDs of processes that are using the file  itself and
writes to standard error an indication of how those processes are using the file.
RATIONALE
The definition of the fuser utility follows existing practice.
FUTURE DIRECTIONS
If this utility is directed to display a pathname that contains any bytes that have the encoded value of a
character when  is a terminator or separator in the output format being used, implementations are encouraged to
treat this as an error. A future version of this standard may require implementations to treat this as an error.
SEE ALSO
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 5.
Issue 7
SD5-XCU-ERN-90 is applied, updating the EXAMPLES section.
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to report an error if a utility is directed to display a
pathname that contains any bytes that have the encoded value of a  character when  is a terminator or
separator in the output format being used.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
Austin Group Defect 1746 is applied, clarifying the output written to standard output and standard error.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/talk.html =====
talk
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
talk — talk to another user
SYNOPSIS
[UP]  talk address [terminal]
DESCRIPTION
The talk utility is a two-way, screen-oriented communication program.
When first invoked, talk shall send a message similar to:
Message from
talk: connection requested by your_address
talk: respond with: talk your_address
to the specified address. At this point, the recipient of the message can reply by typing:
talk your_address
Once communication is established, the two parties can type simultaneously, with their output displayed in separate regions of
the screen. Characters shall be processed as follows:
Typing the  character shall alert the recipient's terminal.
Typing -L shall cause the sender's screen regions to be refreshed.
Typing the erase and kill characters shall affect the sender's terminal in the manner described by the termios interface
in XBD 11. General Terminal Interface.
Typing the interrupt or end-of-file characters shall terminate the local talk utility. Once the talk session has
been terminated on one side, the other side of the talk session shall be notified that the talk session has been
terminated and shall be able to do nothing except exit.
Typing characters from LC_CTYPE classifications print or space shall cause those characters to be sent to
the recipient's terminal.
When and only when the stty iexten local mode is enabled, the existence and
processing of additional special control characters and multi-byte or single-byte functions shall be implementation-defined.
Typing other non-printable characters shall cause implementation-defined sequences of printable characters to be sent to the
recipient's terminal.
Permission to be a recipient of a talk message can be denied or granted by use of the mesg utility. However, a user's privilege may further constrain the domain of accessibility of
other users' terminals. The talk utility shall fail when the user lacks appropriate privileges to perform the requested
action.
Certain block-mode terminals do not have all the capabilities necessary to support the simultaneous exchange of messages
required for talk. When this type of exchange cannot be supported on such terminals, the implementation may support an
exchange with reduced levels of simultaneous interaction or it may report an error describing the terminal-related deficiency.
OPTIONS
None.
OPERANDS
The following operands shall be supported:
address
The recipient of the talk session. One form of address is the , as returned by the
who utility. Other address formats and how they are handled are unspecified.
terminal
If the recipient is logged in more than once, the terminal argument can be used to indicate the appropriate terminal
name. If terminal is not specified, the talk message shall be displayed on one or more accessible terminals in use by
the recipient. The format of terminal shall be the same as that returned by the who utility.
STDIN
Characters read from standard input shall be copied to the recipient's terminal in an unspecified manner. If standard input is
not a terminal, talk shall write a diagnostic message and exit with a non-zero status.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of talk:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files). If the recipient's locale does not use an LC_CTYPE
equivalent to the sender's, the results are undefined.
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error and
informative messages written to standard output.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
TERM
Determine the name of the invoker's terminal type. If this variable is unset or null, an unspecified default terminal type
shall be used.
ASYNCHRONOUS EVENTS
When the talk utility receives a SIGINT signal, the utility shall terminate and exit with a zero status. It shall take
the standard action for all other signals.
STDOUT
If standard output is a terminal, characters copied from the recipient's standard input may be written to standard output.
Standard output also may be used for diagnostic messages. If standard output is not a terminal, talk shall exit with a
non-zero status.
STDERR
None.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred or talk was invoked on a terminal incapable of supporting it.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
Because the handling of non-printable, non- characters is tied to the stty description of iexten, implementation extensions within the terminal driver can be
accessed. For example, some implementations provide line editing functions with certain control character sequences.
EXAMPLES
None.
RATIONALE
The write utility was included in this volume of POSIX.1-2024 since it can be
implemented on all terminal types. The talk utility, which cannot be implemented on certain terminals, was considered to be
a "better" communications interface. Both of these programs are in widespread use on historical implementations. Therefore, both
utilities have been specified.
All references to networking abilities (talking to a user on another system) were removed as being outside the scope of
this volume of POSIX.1-2024.
Historical BSD and System V versions of talk terminate both of the conversations when either user breaks out of the
session. This can lead to adverse consequences if a user unwittingly continues to enter text that is interpreted by the shell when
the other terminates the session. Therefore, the version of talk specified by this volume of POSIX.1-2024 requires both
users to terminate their end of the session explicitly.
Only messages sent to the terminal of the invoking user can be internationalized in any way:
The original "Message from  ..." message sent to the terminal of the recipient cannot be
internationalized because the environment of the recipient is as yet inaccessible to the talk utility. The environment of
the invoking party is irrelevant.
Subsequent communication between the two parties cannot be internationalized because the two parties may specify different
languages in their environment (and non-portable characters cannot be mapped from one language to another).
Neither party can be required to communicate in a language other than C and/or the one specified by their environment because
unavailable terminal hardware support (for example, fonts) may be required.
The text in the STDOUT section reflects the usage of the verb "display" in this section; some talk implementations
actually use standard output to write to the terminal, but this volume of POSIX.1-2024 does not require that to be the case.
The format of the terminal name is unspecified, but the descriptions of ps,
talk, who, and write require that
they all use or accept the same format.
The handling of non-printable characters is partially implementation-defined because the details of mapping them to printable
sequences is not needed by the user. Historical implementations, for security reasons, disallow the transmission of non-printable
characters that may send commands to the other terminal.
FUTURE DIRECTIONS
None.
SEE ALSO
mesg, stty, who, write
XBD 8. Environment Variables, 11. General Terminal Interface
CHANGE HISTORY
First released in Issue 4.
Issue 6
This utility is marked as part of the User Portability Utilities option.
Issue 8
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/delta.html =====
delta
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
delta — make a delta (change) to an SCCS file (DEVELOPMENT)
SYNOPSIS
[XSI]  delta [-nps] [-g list] [-m
mrlist] [-r SID] [-y[comment]] file...
DESCRIPTION
The delta utility shall be used to permanently introduce into the named SCCS files changes that were made to the files
retrieved by get (called the g-files, or generated files).
OPTIONS
The delta utility shall conform to XBD 12.2 Utility Syntax
Guidelines, except that the -y option has an optional option-argument. This optional option-argument shall not be
presented as a separate argument.
The following options shall be supported:
-r SID
Uniquely identify which delta is to be made to the SCCS file. The use of this option shall be necessary only if two or more
outstanding get commands for editing (get
-e) on the same SCCS file were done by the same person (login name). The SID value specified with the -r option can
be either the SID specified on the get command line or the SID to be made as reported by
the get utility; see get.
-s
Suppress the report to standard output of the activity associated with each file. See the STDOUT section.
-n
Specify retention of the edited g-file (normally removed at completion of delta processing).
-g list
Specify a list (see get for the definition of list) of deltas that
shall be ignored when the file is accessed at the change level (SID) created by this delta.
-m mrlist
Specify a modification request (MR) number that the application shall supply as the reason for creating the new delta. This
shall be used if the SCCS file has the v flag set; see admin.
If -m is not used and '-' is not specified as a file argument, and the standard input is a terminal, the prompt
described in the STDOUT section shall be written to standard output before the standard input is read; if the standard input is not
a terminal, no prompt shall be issued.
MRs in a list shall be separated by  characters or escaped  characters. An unescaped
shall terminate the MR list. The escape character is .
If the v flag has a value, it shall be taken to be the name of a program which validates the correctness of the MR
numbers. If a non-zero exit status is returned from the MR number validation program, the delta utility shall terminate. (It
is assumed that the MR numbers were not all valid.)
-y[comment]
Describe the reason for making the delta. The comment shall be an arbitrary group of lines that would meet the
definition of a text file. Implementations shall support comments from zero to 512 bytes and may support longer values. A
null string (specified as either -y, -y"", or in response to a prompt for a comment) shall be considered a
valid comment.
If -y is not specified and '-' is not specified as a file argument, and the standard input is a terminal, the
prompt described in the STDOUT section shall be written to standard output before the standard input is read; if the standard input
is not a terminal, no prompt shall be issued. An unescaped  shall terminate the comment text. The escape character
is .
The -y option shall be required if the file operand is specified as '-'.
-p
Write (to standard output) the SCCS file differences before and after the delta is applied in diff format; see diff.
OPERANDS
The following operand shall be supported:
file
A pathname of an existing SCCS file or a directory. If file is a directory, the delta utility shall behave as
though each file in the directory were specified as a named file, except that non-SCCS files (last component of the pathname does
not begin with s.) and unreadable files shall be silently ignored.
If exactly one file operand appears, and it is '-', the standard input shall be read; each line of the standard
input shall be taken to be the name of an SCCS file to be processed. Non-SCCS files and unreadable files shall be silently
ignored.
STDIN
The standard input shall be a text file used only in the following cases:
To read an mrlist or a comment (see the -m and -y options).
A file operand shall be specified as '-'. In this case, the -y option needs to be used to specify the
comment, and if the SCCS file has the v flag set, the -m option also needs to be used to specify the MR list.
INPUT FILES
Input files shall be text files whose data is to be included in the SCCS files. If the first character of any line of an input
file is  in the POSIX locale, the results are unspecified. If this file contains more than 99999 lines, the number of
lines recorded in the header for this file shall be 99999 for this delta.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of delta:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error, and
informative messages written to standard output.
NLSPATH
Determine the location of messages objects and message catalogs.
TZ
Determine the timezone in which the time and date are written in the SCCS file. If the TZ variable is unset or NULL, an
unspecified system default timezone is used.
ASYNCHRONOUS EVENTS
If SIGINT is caught, temporary files shall be cleaned up and delta shall exit with a non-zero exit code. The standard
action shall be taken for all other signals; see 1.4 Utility Description
Defaults.
STDOUT
The standard output shall be used only for the following messages in the POSIX locale:
Prompts (see the -m and -y options) in the following formats:
"MRs? "
"comments? "
The MR prompt, if written, shall always precede the comments prompt.
A report of each file's activities (unless the -s option is specified) in the following format:
"%s\n%d inserted\n%d deleted\n%d unchanged\n", ,
, ,
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
Any SCCS files updated shall be files of an unspecified format.
EXTENDED DESCRIPTION
System Date and Time
When a delta is added to an SCCS file, the system date and time shall be recorded for the new delta. If a get is performed using an SCCS file with a date recorded apparently in the future, the behavior
is unspecified.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
Problems can arise if the system date and time have been modified (for example, put forward and then back again, or
unsynchronized clocks across a network) and can also arise when different values of the TZ environment variable are
used.
Problems of a similar nature can also arise for the operation of the get utility,
which records the date and time in the file body.
EXAMPLES
None.
RATIONALE
None.
FUTURE DIRECTIONS
If this utility is directed to display a pathname that contains any bytes that have the encoded value of a
character when  is a terminator or separator in the output format being used, implementations are encouraged to
treat this as an error. A future version of this standard may require implementations to treat this as an error.
If this utility is directed to create a new directory entry that contains any bytes that have the encoded value of a
character, implementations are encouraged to treat this as an error. A future version of this standard may require
implementations to treat this as an error.
SEE ALSO
1.4 Utility Description Defaults, admin, diff, get, prs, rmdel
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 2.
Issue 5
The output format description in the STDOUT section is corrected.
Issue 6
The APPLICATION USAGE section is added.
The normative text is reworded to avoid use of the term "must" for application requirements.
The Open Group Base Resolution bwg2001-007 is applied as follows:
The use of '-' as a file argument is clarified.
The use of STDIN is added.
The ASYNCHRONOUS EVENTS section is updated to remove the implicit requirement that implementations re-signal themselves when
catching a normally fatal signal.
New text is added to the INPUT FILES section warning that the maximum lines recorded in the file is 99999.
New text is added to the EXTENDED DESCRIPTION and APPLICATION USAGE sections regarding how the system date and time may be taken
into account, and the TZ environment variable is added to the ENVIRONMENT VARIABLES section as per The Open Group Base
Resolution bwg2001-007.
Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to behave as follows:
Report an error if a utility is directed to display a pathname that contains any bytes that have the encoded value of a
character when  is a terminator or separator in the output format being used.
Disallow the creation of filenames containing any bytes that have the encoded value of a  character.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/tail.html =====
tail
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
tail — copy the last part of a file
SYNOPSIS
tail [-f] [-c number|-n number] [file]
tail -r [-n number] [file]
DESCRIPTION
The tail utility shall copy its input file to the standard output beginning at a designated place.
Copying shall begin at the point in the file indicated by the -c number or -n number options. The
option-argument number shall be counted in units of lines or bytes, according to the options -n and -c. Both
line and byte counts start from 1.
Tails relative to the end of the file may be saved in an internal buffer, and thus may be limited in length. Such a buffer, if
any, shall be no smaller than {LINE_MAX}*10 bytes.
OPTIONS
The tail utility shall conform to XBD 12.2 Utility Syntax
Guidelines, except that '+' may be recognized as an option delimiter as well as '-'.
The following options shall be supported:
-c number
The application shall ensure that the number option-argument is a decimal integer, optionally including a sign. The sign
shall affect the location in the file, measured in bytes, to begin the copying:
Sign
Copying Starts
+
Relative to the beginning of the file.
-
Relative to the end of the file.
none
Relative to the end of the file.
The application shall ensure that if the sign of the number option-argument is '+', the
number option-argument is a non-zero decimal integer.
The origin for counting shall be 1; that is, -c +1 represents the first byte of the file, -c -1 the
last.
-f
If the input file is a regular file or if the file operand specifies a FIFO, do not terminate after the last line of the
input file has been copied, but read and copy further bytes from the input file when they become available. If no file
operand is specified and standard input is a pipe or FIFO, the -f option shall be ignored. If the input file is not a FIFO,
pipe, or regular file, it is unspecified whether or not the -f option shall be ignored.
-n number
If -r is not specified, this option shall be equivalent to -c number, except the starting location in the
file shall be measured in lines instead of bytes. The origin for counting shall be 1; that is, -n +1 represents the first
line of the file, -n -1 the last.
If -r is specified, number shall specify the number of lines to read (in reverse) from the end of the
input file. The application shall ensure that number does not have a sign.
-r
Copy the lines in reverse order (last line first). If -n is specified, that many lines of the file, starting with the
last line, shall be copied. If -n is not specified, every line of the input file shall be copied.
If none of the -c, -n or -r options is specified, -n 10 shall be assumed.
OPERANDS
The following operand shall be supported:
file
A pathname of an input file. If no file operand is specified, the standard input shall be used.
STDIN
The standard input shall be used if no file operand is specified, and shall be used if the file operand is
'-' and the implementation treats the '-' as meaning standard input. Otherwise, the standard input shall not be
used. See the INPUT FILES section.
INPUT FILES
If the -c option is specified, the input file can contain arbitrary data; otherwise, the input file shall be a text
file.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of tail:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
The designated portion of the input file shall be written to standard output.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
The -c option should be used with caution when the input is a text file containing multi-byte characters; it may produce
output that does not start on a character boundary.
Although the input file to tail can be any type, the results might not be what would be expected on some
character special device files or on file types not described by the System Interfaces volume of POSIX.1-2024. Since this volume of
POSIX.1-2024 does not specify the block size used when doing input, tail need not read all of the data from devices that
only perform block transfers.
When using tail to process pathnames, and the -c option is not specified, it is recommended that
LC_ALL, or at least LC_CTYPE and LC_COLLATE, are set to POSIX or C in the environment, since pathnames can contain byte sequences
that do not form valid characters in some locales, in which case the utility's behavior would be undefined. In the POSIX locale
each byte is a valid single-byte character, and therefore this problem is avoided.
EXAMPLES
The -f option can be used to monitor the growth of a file that is being written by some other process. For example, the
command:
tail -f fred
prints the last ten lines of the file fred, followed by any lines that are appended to fred between
the time tail is initiated and killed. As another example, the command:
tail -f -c 15 fred
prints the last 15 bytes of the file fred, followed by any bytes that are appended to fred between
the time tail is initiated and killed.
RATIONALE
This version of tail was created to allow conformance to the Utility Syntax Guidelines. The historical -b option
was omitted because of the general non-portability of block-sized units of text. The -c option historically meant
"characters", but this volume of POSIX.1-2024 indicates that it means "bytes". This was selected to allow reasonable
implementations when multi-byte characters are possible; it was not named -b to avoid confusion with the historical
-b.
The origin of counting both lines and bytes is 1, matching all widespread historical implementations. Hence
tail -n +0 is not conforming usage because it attempts to output line zero; but note that tail -n 0
does conform, and outputs nothing.
Earlier versions of this standard allowed the following forms in the SYNOPSIS:
tail -[number][b|c|l][f] [file]
tail +[number][b|c|l][f] [file]
These forms are no longer specified by POSIX.1-2024, but may be present in some implementations.
The restriction on the internal buffer is a compromise between the historical System V implementation of 4096 bytes
and the BSD 32768 bytes.
The -f option has been implemented as a loop that sleeps for 1 second and copies any bytes that are
available. This is sufficient, but if more efficient methods of determining when new data are available are developed,
implementations are encouraged to use them.
Historical documentation indicates that tail ignores the -f option if the input file is a pipe (pipe
and FIFO on systems that support FIFOs). On BSD-based systems, this has been true; on System V-based systems, this was true when
input was taken from standard input, but it did not ignore the -f flag if a FIFO was named as the file operand. Since
the -f option is not useful on pipes and all historical implementations ignore -f if no file operand is
specified and standard input is a pipe, this volume of POSIX.1-2024 requires this behavior. However, since the -f option is
useful on a FIFO, this volume of POSIX.1-2024 also requires that if a FIFO is named, the -f option shall not be ignored.
Earlier versions of this standard did not state any requirement for the case where no file operand is specified and standard
input is a FIFO. The standard has been updated to reflect current practice which is to treat this case the same as a pipe on
standard input. Although historical behavior does not ignore the -f option for other file types, this is unspecified so that
implementations are allowed to ignore the -f option if it is known that the file cannot be extended.
The functionality made available by tail -r has been historically provided on some systems by a
separate utility (tac), although tac traditionally lacked support for -n to limit the output. While both
tail -n$n | tac and tac | head -n$n can be used to output a fixed length of reversed line output, the standard
developers decided that it was preferable to have a single utility tail -r -n$n for the same purpose. Furthermore, in
deciding whether to standardize tac rather than tail -r, it was determined that more implementations that have
achieved POSIX certification had already implemented tail -r as an extension.
FUTURE DIRECTIONS
None.
SEE ALSO
head
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 2.
Issue 6
The obsolescent SYNOPSIS lines and associated text are removed.
The normative text is reworded to avoid use of the term "must" for application requirements.
Issue 7
Austin Group Interpretation 1003.1-2001 #027 is applied, clarifying that '+' may be recognized as an option delimiter
in the OPTIONS section.
Austin Group Interpretation 1003.1-2001 #092 is applied.
Austin Group Interpretation 1003.1-2001 #100 is applied, adding the requirement on applications that if the sign of
the option-argument number is '+', the number option-argument is a non-zero decimal integer.
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
SD5-XCU-ERN-114 is applied, updating the OPTIONS section (the -f option).
SD5-XCU-ERN-149 is applied.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0190 [663] is applied.
Issue 8
Austin Group Defect 877 is applied, adding the -r option.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/msgfmt.html =====
msgfmt
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
msgfmt — create messages objects from portable messages object source files
SYNOPSIS
msgfmt [-cfSv] [-D dir] [-o outputfile]
pathname...
DESCRIPTION
The msgfmt utility shall create messages object files from portable messages object source files (dot-po files).
A dot-po file contains messages to be output by system commands or by applications. The messages in these files should be able
to be translated to any language supported by the system.
The msgfmt utility shall interpret message strings for output as characters according to the codeset specified in the
dot-po file or, if not present, the current setting of the LC_CTYPE locale category.
OPTIONS
The msgfmt utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following options shall be supported:
-c
If this option and -v are both specified, msgfmt shall detect and diagnose input file abnormalities which might
represent translation errors. The msgid and msgstr strings shall be compared. It shall be considered abnormal if one
string starts or ends with a  while the other does not. Also, if the flag c-format appears in a "#,"
comment for a msgid directive (see EXTENDED DESCRIPTION), it shall be considered abnormal if the strings do not have the
same number of '%' conversion specifiers, or if corresponding conversion specifiers take different argument types (see XSH
fprintf()). If an abnormality is detected, the exit status shall be non-zero and a
diagnostic message shall be output. Additional checks beyond those described here may also be performed. These checks may produce
diagnostics or informational messages and need not affect the exit status. If -c is specified without -v or -v
is specified without -c, the behavior is unspecified.
-D dir
Add dir to the list of directories to search for input files.
-f
Use fuzzy entries in output. If this option is not specified, fuzzy entries shall not be included in the output.
-o outputfile
Specify the name of an output file to be used instead of the default filename(s) specified in EXTENDED DESCRIPTION. All
domain domainname directives in the dot-po file(s) shall be ignored.
-S
Append the suffix .mo to each generated messages object filename if it does not have this suffix.
-v
See -c.
OPERANDS
The following operand shall be supported:
pathname
A pathname of a dot-po file.
STDIN
Not used.
INPUT FILES
The input files shall be text files in the format described in EXTENDED DESCRIPTION.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of msgfmt:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LANGUAGE
Determine the location of messages objects [XSI]   if NLSPATH is not set or the evaluation of NLSPATH
did not lead to a suitable messages object being found.
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files).
LC_MESSAGES
Determine the locale name used to locate messages objects, and the locale that should be used to affect the format and contents of
diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
Not Used.
STDERR
The standard error shall be used for diagnostic messages and may also be used for warning messages. If the -c and
-v options are specified, additional unspecified informational messages may be written to standard error.
OUTPUT FILES
The format of the created messages object files is unspecified.
EXTENDED DESCRIPTION
The msgfmt utility shall accept portable messages object source files (dot-po files) in the following format.
A dot-po file contains zero or more lines, with each non-blank line containing a comment, a statement, or a statement
continuation. A comment has an unquoted  ('#') as the first non- character and ends with
the next  character. A statement continuation is a double-quoted string on a line by itself, optionally preceded
and/or followed by  characters, and the string shall be concatenated with the string on the previous statement line.
If a comment occurs between a statement and a statement continuation, the behavior is unspecified. All other comments, except for
comments beginning with  ("#,"), and blank lines shall be ignored.
The format of a statement is:
directive value
The directive starts at the first non- character of the line and is separated from the value by one
or more  characters. The value consists of a double-quoted string optionally followed by
characters. Zero or more statement continuation lines (see above) can follow the statement. The following directives shall be
supported:
domain domainname
msgid message_identifier
msgid_plural untranslated_string_plural
msgstr message_string
msgstr[index] message_string
A dot-po file consists of zero or more sections. Each section specifies the messages to be processed in a domain. The first
directive in each section shall be a domain directive (except for the first section which shall behave as if
domain "messages"
had been specified if the first directive is not a domain directive).
The behavior of the domain directive is affected by the options used. See OPTIONS for the behavior when the -o
option is specified. If the -o option is not specified, all data obtained from the non-domain directives in a dot-po
section shall be output to the messages object file named domainname.mo when the -S option is specified. When
the -S option is not specified, it is implementation-defined whether domainname or domainname.mo is
used.
If multiple domain directives specify the same domainname, the sections shall be processed as if there was only
one section that starts with a domain domainname statement which contained the statements of the sections, in the
same order, excluding all but the first domain domainname statement.
Within each section, there can be a header. A header is identified by having a msgid directive with the empty string
("") as the message_identifier immediately followed by a statement containing a msgstr directive. The
message_string in this msgstr statement in a header shall be treated specially. If message_string contains a
specification of the form:
"nplurals=count; plural=expression"
then count indicates the number of plural forms for messages in that domain, and expression is a C-language
expression that evaluates to an unsigned integer value which determines the msgstr[index] directive to be
used. The value of expression is used as the index value. The variable n in expression is assigned the value
of the n argument to the ngettext(), ngettext_l(), dngettext(), dngettext_l(), dcngettext(), and
dcngettext_l() functions or of the n operand of the ngettext utility before expression is evaluated. The application shall ensure that
expression evaluates to a non-negative value less than count for all n that can be supplied by the
aforementioned functions and utility.
If message_string in the header contains a specification of the form:
"charset=codeset"
then codeset indicates the codeset to be used to encode the message strings in this section's domain (overriding
LC_CTYPE ). If the output string's codeset is different from the message string's codeset, codeset conversion from the
message string's codeset to the output string's codeset shall be performed by the gettext family of functions and by the
gettext and ngettext utilities. See
XSH gettext() and gettext. The output string's codeset shall be determined by the current or
specified locale's codeset.
Note:
It is the responsibility of translators to ensure that the characters they enter into message strings in a dot-po file are
encoded in the codeset specified in the header.
If a header is present in a section, the application shall ensure that the header is provided by the first msgid
directive in that section.
After the header, if present, zero or more messages are identified by a msgid directive with a message_identifier
that is not an empty string. Each of these directives start a subsection that is used to get a translated message from the
gettext family of functions and from the gettext and ngettext utilities. If the message_identifier string is the string identified by the
gettext family of functions msgid argument or by the gettext and
ngettext utility msgid operand, this subsection specifies how that
translation is to be processed.
If there is only a singular form for the given message_identifier, the application shall ensure that the statement
containing the msgid directive is immediately followed by a msgstr directive.
If there are plural forms for the given message_identifier and the header for this section exists and contains an
"nplurals=count; plural=expression"
specification, the application shall ensure that the statement containing the msgid directive is immediately followed by
a msgid_plural directive and that each statement containing a msgid_plural directive is followed by count
statements containing msgstr[index] directives, starting with msgstr[0] and ending with
msgstr[count-1] in increasing order, with no duplicate index values. If a header for this section does not
exist or does not contain an
"nplurals=count; plural=expression"
specification, the application shall ensure that no msgid_plural or msgstr[index] directives are
used in this section.
For example, if the header's message_string contains the specification:
"nplurals=2; plural= n == 1 ? 0 : 1"
there are two forms in the domain; msgstr[0] is used if n is equal to 1, otherwise msgstr[1] is used. For
another example, if the header's message_string contains:
"nplurals=3; plural= n == 1 ? 0 : n == 2 ? 1 : 2"
there are three forms in the domain; msgstr[0] is used if n is equal to 1, msgstr[1] is used if n is
equal to 2, otherwise msgstr[2] is used.
C-language escape sequences in strings shall be processed as specified for character string literals in the ISO C standard,
except that universal-character-name escape sequences need not be supported.
Comments in a dot-po file can be in one of the following formats:
#: reference
#. utility-added-comments
#, flag
#translator-comments (where translator-comments does not begin with '.', ':' or ',')
A #: reference comment indicates the location(s) of the msgid string in the source files, in
pathname1:linenumber1 [pathname2:linenumber2 ... ]
format. They can be added, as might "#." prefixed additional comments of unspecified format, by the xgettext utility. All comments that do not begin with "#," are informative only
and shall be silently ignored by the msgfmt utility. In "#," comments the following values for flag can be
specified:
fuzzy
This flag indicates that the msgstr string might not be a correct translation at this point in time. Only the translator
can judge if the translation requires further modification or is acceptable as is. Once satisfied with the translation, the
translator should remove this fuzzy flag. If this flag is specified, the msgfmt utility shall not generate the entry
for the next following msgid in the output message catalog, unless the -f option is specified. If other flag comments
are specified between fuzzy and the msgid, the behavior is unspecified.
c-format
no-c-format
The c-format flag indicates that the next following msgid string contains a printf() format string. When the c-format flag is given and the -c and
-v options are specified, the msgfmt utility shall perform additional tests to check the validity of the translation
(see OPTIONS); these additional tests may also be performed if neither c-format nor no-c-format is given. When the
no-c-format flag is given for a string, no additional checks shall be performed for the string. When both the
c-format and the no-c-format flags are given, the last flag specified takes precedence.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
The msgfmt utility need not continue processing later pathname operands when an error condition that affects the
exit status is detected. It is unspecified whether a messages object file is written when checks performed for the -c and
-v options fail.
The following sections are informative.
APPLICATION USAGE
The xgettext utility can be used to create template dot-po files from C-language
source files.
Installing messages object files for the POSIX or C locale is not recommended, since they may be ignored for the sake of
efficiency.
The first section for each domain in a dot-po file should include a header containing a
"charset=codeset"
specification. If this specification is omitted, message conversions in the gettext family of functions and in the
gettext and ngettext utilities may
fail.
The msgid_plural directive's untranslated_string_plural string comes from the msgid_plural arguments in
calls to the ngettext(), ngettext_l(), dngettext(), dngettext_l(), dcngettext(), and
dcngettext_l() functions when a prototype dot-po file is created by the
xgettext utility. These strings (and the msgid_plural operands in calls to
the ngettext utility) can provide context when a translator is modifying a template
dot-po file into a dot-po file for a specific language. These functions and the ngettext utility do not try to match the msgid_plural arguments or operands with
anything in a messages object file; they only match the msgid arguments and operands.
Unlike shell command language strings, double-quoted strings in dot-po files cannot contain a literal
character.
EXAMPLES
In this example, module1.po and module2.po are portable messages object source files.
$ cat module1.po
# default domain "messages"
msgid ""
msgstr "charset=utf-8"
msgid "msg 1"
msgstr "msg 1 translation"
#
domain "help_domain"
msgid ""
msgstr "charset=utf-8"
msgid "help 2"
msgstr "help 2 translation"
#
domain "error_domain"
msgid ""
msgstr "charset=utf-8"
msgid "error 3"
msgstr "error 3 translation"
$ cat module2.po
# default domain "messages"
msgid ""
msgstr "charset=utf-8"
msgid "mesg 4"
msgstr "mesg 4 translation"
#
domain "error_domain"
msgid ""
msgstr "charset=utf-8"
#, c-format
msgid "error 5 %s"
msgstr "error 5 translation %s"
#
domain "window_domain"
msgid ""
msgstr "charset=utf-8"
msgid "window 6"
msgstr "window 6 translation"
$ cat module3.po
# default domain "messages"
# header will be used for the whole output file in the third example
msgid ""
msgstr "charset=utf-8"
msgid "info 0"
msgstr "info 0 translation"
$ cat opt_debug.po
#
domain "debug_domain"
msgid "debug 8"
msgstr "debug 8 translation"
The following command will produce the output files messages.mo, help_domain.mo, and error_domain.mo:
$ msgfmt -S module1.po
The following command will produce the output files messages.mo, help_domain.mo, error_domain.mo, and
window_domain.mo:
$ msgfmt -S module1.po module2.po
The following command will produce the output file hello.mo:
$ msgfmt -o hello.mo module3.po opt_debug.po
RATIONALE
Some implementations are less strict about the format of dot-po files and simply treat all occurrences of one or more white
space characters as a separator. The format described in this standard is accepted by all known implementations.
In some implementations, duplicate msgid directives within a domain are ignored, and only an entry for the first
msgid directive and the following msgid, msgid_plural, msgstr, or msgstr[index]
directives is created. However, some implementations consider duplicate msgid directives within a domain to be an error and
do not produce output at all. Consequently this standard does not specify the behavior of msgfmt if duplicate msgid
directives are encountered within one domain.
FUTURE DIRECTIONS
If this utility is directed to create a new directory entry that contains any bytes that have the encoded value of a
character, implementations are encouraged to treat this as an error. A future version of this standard may require
implementations to treat this as an error.
SEE ALSO
gettext, xgettext
XSH fprintf(), gettext()
CHANGE HISTORY
First released in Issue 8.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/test.html =====
test
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
test — evaluate expression
SYNOPSIS
test [expression]
[ [expression] ]
DESCRIPTION
The test utility shall evaluate the expression and indicate the result of the evaluation by its exit status. An
exit status of zero indicates that the expression evaluated as true and an exit status of 1 indicates that the expression evaluated
as false.
In the second form of the utility, where the utility name used is [ rather than test, the application shall ensure
that the closing square bracket is a separate argument. The test and [ utilities may be implemented as a single
linked utility which examines the basename of the zeroth command line argument to determine whether to behave as the test or
[ variant. Applications using the exec family of functions to execute these utilities shall ensure that the argument
passed in arg0 or argv[0] is '[' when executing the [ utility and has a basename of "test"
when executing the test utility.
OPTIONS
The test utility shall not recognize the "--" argument in the manner specified by Guideline 10 in XBD 12.2 Utility Syntax Guidelines. In addition, when the utility name used is
[ the utility does not conform to Guidelines 1 and 2.
No options shall be supported.
OPERANDS
The application shall ensure that all operators and elements of primaries are presented as separate arguments to the test
utility.
The following primaries can be used to construct expression:
-b pathname
True if pathname resolves to an existing directory entry for a block special file. False if pathname cannot be
resolved, or if pathname resolves to an existing directory entry for a file that is not a block special file.
-c pathname
True if pathname resolves to an existing directory entry for a character special file. False if pathname cannot
be resolved, or if pathname resolves to an existing directory entry for a file that is not a character special file.
-d pathname
True if pathname resolves to an existing directory entry for a directory. False if pathname cannot be resolved,
or if pathname resolves to an existing directory entry for a file that is not a directory.
-e pathname
True if pathname resolves to an existing directory entry. False if pathname cannot be resolved.
pathname1 -ef pathname2
True if pathname1 and pathname2 resolve to existing directory entries for the same file; otherwise, false.
-f pathname
True if pathname resolves to an existing directory entry for a regular file. False if pathname cannot be
resolved, or if pathname resolves to an existing directory entry for a file that is not a regular file.
-g pathname
True if pathname resolves to an existing directory entry for a file that has its set-group-ID flag set. False if
pathname cannot be resolved, or if pathname resolves to an existing directory entry for a file that does not have its
set-group-ID flag set.
-h pathname
True if pathname resolves to an existing directory entry for a symbolic link. False if pathname cannot be
resolved, or if pathname resolves to an existing directory entry for a file that is not a symbolic link. If the final
component of pathname is a symbolic link, that symbolic link is not followed.
-L pathname
True if pathname resolves to an existing directory entry for a symbolic link. False if pathname cannot be
resolved, or if pathname resolves to an existing directory entry for a file that is not a symbolic link. If the final
component of pathname is a symbolic link, that symbolic link is not followed.
-n string
True if the length of string is non-zero; otherwise, false.
pathname1 -nt pathname2
True if pathname1 resolves to an existing file and pathname2 cannot be resolved, or if both resolve to existing files
and pathname1 is newer than pathname2 according to their last data modification timestamps; otherwise, false.
pathname1 -ot pathname2
True if pathname2 resolves to an existing file and pathname1 cannot be resolved, or if both resolve to existing files
and pathname1 is older than pathname2 according to their last data modification timestamps; otherwise, false.
-p pathname
True if pathname resolves to an existing directory entry for a FIFO. False if pathname cannot be resolved, or if
pathname resolves to an existing directory entry for a file that is not a FIFO.
-r pathname
True if pathname resolves to an existing directory entry for a file for which permission to read from the file is
granted, as defined in 1.1.1.4 File Read, Write, and Creation.
False if pathname cannot be resolved, or if pathname resolves to an existing directory entry for a file for which
permission to read from the file is not granted.
-S pathname
True if pathname resolves to an existing directory entry for a socket. False if pathname cannot be resolved, or
if pathname resolves to an existing directory entry for a file that is not a socket.
-s pathname
True if pathname resolves to an existing directory entry for a file that has a size greater than zero. False if
pathname cannot be resolved, or if pathname resolves to an existing directory entry for a file that does not have a
size greater than zero.
-t file_descriptor
True if file descriptor number file_descriptor is open and is associated with a terminal. False if file_descriptor is
not a valid file descriptor number, or if file descriptor number file_descriptor is not open, or if it is open but is not
associated with a terminal.
-u pathname
True if pathname resolves to an existing directory entry for a file that has its set-user-ID flag set. False if
pathname cannot be resolved, or if pathname resolves to an existing directory entry for a file that does not have its
set-user-ID flag set.
-w pathname
True if pathname resolves to an existing directory entry for a file for which permission to write to the file is
granted, as defined in 1.1.1.4 File Read, Write, and Creation.
False if pathname cannot be resolved, or if pathname resolves to an existing directory entry for a file for which
permission to write to the file is not granted.
-x pathname
True if pathname resolves to an existing directory entry for a file for which permission to execute the file (or search
it, if it is a directory) is granted, as defined in 1.1.1.4 File Read,
Write, and Creation. False if pathname cannot be resolved, or if pathname resolves to an existing directory
entry for a file for which permission to execute (or search) the file is not granted.
-z string
True if the length of string string is zero; otherwise, false.
string
True if the string string is not the null string; otherwise, false.
s1 = s2
True if the strings s1 and s2 are identical; otherwise, false.
s1 != s2
True if the strings s1 and s2 are not identical; otherwise, false.
s1 > s2
True if s1 collates after s2 in the current locale; otherwise, false.
s1
final argument shall not be counted in this algorithm.)
In the following list, $1, $2, $3, and $4 represent the arguments presented to test:
0 arguments:
Exit false (1).
1 argument:
Exit true (0) if $1 is not null; otherwise, exit false.
2 arguments:
If $1 is '!', exit true if $2 is null, false if $2 is not null.
If $1 is a unary primary, exit true if the unary test is true, false if the unary test is false.
Otherwise, produce unspecified results.
3 arguments:
If $2 is a binary primary, perform the binary test of $1 and $3.
If $1 is '!', negate the two-argument test of $2 and $3.
Otherwise, produce unspecified results.
4 arguments:
If $1 is '!', negate the three-argument test of $2, $3, and $4.
Otherwise, the results are unspecified.
>4 arguments:
The results are unspecified.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of test:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_COLLATE
Determine the locale for the behavior of the > and 1
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
Since '>' and ' s2, s1  s2, and s1 >>
===== susv5-html/utilities/uniq.html =====
uniq
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
uniq — report or filter out repeated lines in a file
SYNOPSIS
uniq [-c|-d|-u] [-f fields] [-s char]
[input_file [output_file]]
DESCRIPTION
The uniq utility shall read an input file comparing adjacent lines, and write one copy of each input line on the output.
The second and succeeding copies of repeated adjacent input lines shall not be written. The trailing  of each line
in the input shall be ignored when doing comparisons.
Repeated lines in the input shall not be detected if they are not adjacent.
OPTIONS
The uniq utility shall conform to XBD 12.2 Utility Syntax
Guidelines, except that '+' may be recognized as an option delimiter as well as '-'.
The following options shall be supported:
-c
Precede each output line with a count of the number of times the line occurred in the input.
-d
Suppress the writing of lines that are not repeated in the input.
-f fields
Ignore the first fields fields on each input line when doing comparisons, where fields is a positive decimal
integer. A field is the maximal string matched by the basic regular expression:
[[:blank:]]*[^[:blank:]]*
If the fields option-argument specifies more fields than appear on an input line, a null string shall be used for
comparison.
-s chars
Ignore the first chars characters when doing comparisons, where chars shall be a positive decimal integer. If
specified in conjunction with the -f option, the first chars characters after the first fields fields shall be
ignored. If the chars option-argument specifies more characters than remain on an input line, a null string shall be used
for comparison.
-u
Suppress the writing of lines that are repeated in the input.
OPERANDS
The following operands shall be supported:
input_file
A pathname of the input file. If the input_file operand is not specified, or if the input_file is '-',
the standard input shall be used.
output_file
A pathname of the output file. If the output_file operand is not specified, the standard output shall be used. The
results are unspecified if the file named by output_file is the file named by input_file.
STDIN
The standard input shall be used only if no input_file operand is specified or if input_file is '-'. See
the INPUT FILES section.
INPUT FILES
The input file shall be a text file.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of uniq:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files) and which characters constitute a  in the current
locale.
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
The standard output shall be used if no output_file operand is specified, and shall be used if the output_file
operand is '-' and the implementation treats the '-' as meaning standard output. Otherwise, the standard output
shall not be used. See the OUTPUT FILES section.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
If the -c option is specified, the output file shall be empty or each line shall be of the form:
"%d %s", ,
otherwise, the output file shall be empty or each line shall be of the form:
"%s",
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
The sort utility can be used to cause repeated lines to be adjacent in the input
file.
If the collating sequence of the current locale does not have a total ordering of all characters, the behavior of sort |
uniq differs from sort -u, as uniq treats lines as duplicates only if they are identical, whereas sort
-u treats lines as duplicates if they collate equally.
When using uniq to process pathnames, it is recommended that LC_ALL, or at least LC_CTYPE and LC_COLLATE, are set to
POSIX or C in the environment, since pathnames can contain byte sequences that do not form valid characters in some locales, in
which case the utility's behavior would be undefined. In the POSIX locale each byte is a valid single-byte character, and therefore
this problem is avoided.
EXAMPLES
The following input file data (but flushed left) was used for a test series on uniq:
#01 foo0 bar0 foo1 bar1
#02 bar0 foo1 bar1 foo1
#03 foo0 bar0 foo1 bar1
#04
#05 foo0 bar0 foo1 bar1
#06 foo0 bar0 foo1 bar1
#07 bar0 foo1 bar1 foo0
What follows is a series of test invocations of the uniq utility that use a mixture of uniq options against the
input file data. These tests verify the meaning of adjacent. The uniq utility views the input data as a sequence of
strings delimited by '\n'. Accordingly, for the fieldsth member of the sequence, uniq interprets unique or
repeated adjacent lines strictly relative to the fields+1th member.
This first example tests the line counting option, comparing each line of the input file data starting from the second
field:
uniq -c -f 1 uniq_0I.t
1 #01 foo0 bar0 foo1 bar1
1 #02 bar0 foo1 bar1 foo1
1 #03 foo0 bar0 foo1 bar1
1 #04
2 #05 foo0 bar0 foo1 bar1
1 #07 bar0 foo1 bar1 foo0
The number '2', prefixing the fifth line of output, signifies that the uniq utility detected a pair of repeated
lines. Given the input data, this can only be true when uniq is run using the -f 1 option (which shall cause
uniq to ignore the first field on each input line).
The second example tests the option to suppress unique lines, comparing each line of the input file data starting from the
second field:
uniq -d -f 1 uniq_0I.t
#05 foo0 bar0 foo1 bar1
This test suppresses repeated lines, comparing each line of the input file data starting from the second field:
uniq -u -f 1 uniq_0I.t
#01 foo0 bar0 foo1 bar1
#02 bar0 foo1 bar1 foo1
#03 foo0 bar0 foo1 bar1
#04
#07 bar0 foo1 bar1 foo0
This suppresses unique lines, comparing each line of the input file data starting from the third character:
uniq -d -s 2 uniq_0I.t
In the last example, the uniq utility found no input matching the above criteria.
RATIONALE
Some historical implementations have limited lines to be 1080 bytes in length, which does not meet the implied {LINE_MAX}
limit.
Earlier versions of this standard allowed the -number and +number options. These options are no
longer specified by POSIX.1-2024 but may be present in some implementations.
FUTURE DIRECTIONS
If this utility is directed to create a new directory entry that contains any bytes that have the encoded value of a
character, implementations are encouraged to treat this as an error. A future version of this standard may require
implementations to treat this as an error.
SEE ALSO
comm, sort
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 2.
Issue 6
The obsolescent SYNOPSIS and associated text are removed.
The normative text is reworded to avoid use of the term "must" for application requirements.
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/40 is applied, adding LC_COLLATE to the ENVIRONMENT
VARIABLES section, and changing "the application shall ensure that" in the OUTPUT FILES section.
Issue 7
Austin Group Interpretation 1003.1-2001 #027 is applied, clarifying that '+' may be recognized as an option delimiter
in the OPTIONS section.
Austin Group Interpretation 1003.1-2001 #092 is applied.
Austin Group Interpretation 1003.1-2001 #133 is applied, clarifying the behavior of the trailing .
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
SD5-XCU-ERN-141 is applied, updating the EXAMPLES section.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0199 [963] and XCU/TC2-2008/0200 [663] are applied.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to disallow the creation of filenames containing any bytes that
have the encoded value of a  character.
Austin Group Defect 1070 is applied, changing the APPLICATION USAGE section.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
Austin Group Defect 1492 is applied, changing the EXIT STATUS section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/locale.html =====
locale
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
locale — get locale-specific information
SYNOPSIS
locale [-a|-m]
locale [-ck] name...
DESCRIPTION
The locale utility shall write information about the current locale environment, or all public locales, to the standard
output. For the purposes of this section, a public locale is one provided by the implementation that is accessible to the
application.
When locale is invoked without any arguments, it shall summarize the current locale environment for each locale category
as determined by the settings of the environment variables defined in XBD 7.
Locale.
When invoked with operands, it shall write values that have been assigned to the keywords in the locale categories, as
follows:
Specifying a keyword name shall select the named keyword and the category containing that keyword.
Specifying a category name shall select the named category and all keywords in that category.
OPTIONS
The locale utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following options shall be supported:
-a
Write information about all available public locales. The available locales shall include POSIX, representing the POSIX
locale. The manner in which the implementation determines what other locales are available is implementation-defined.
-c
Write the names of selected locale categories; see the STDOUT section. The -c option increases readability when more
than one category is selected (for example, via more than one keyword name or via a category name). It is valid both with and
without the -k option.
-k
Write the names and values of selected keywords. The implementation may omit values for some keywords; see the OPERANDS
section.
-m
Write names of available charmaps; see XBD 6.1 Portable Character Set
.
OPERANDS
The following operand shall be supported:
name
The name of a locale category as defined in XBD 7. Locale, the name of
a keyword in a locale category, or the reserved name charmap. The named category or keyword shall be selected for output. If
a single name represents both a locale category name and a keyword name in the current locale, the results are unspecified.
Otherwise, both category and keyword names can be specified as name operands, in any sequence. It is implementation-defined
whether any keyword values are written for the categories LC_CTYPE and LC_COLLATE .
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of locale:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
The application shall ensure that the LANG , LC_* , and [XSI]
NLSPATH   environment variables specify the current locale environment to be written out; they shall be used
if the -a option is not specified.
ASYNCHRONOUS EVENTS
Default.
STDOUT
The LANG variable shall be written first using the format:
"LANG=%s\n",
If LANG is not set or is an empty string, the value is the empty string.
If locale is invoked without any options or operands, the names and values of the LC_* environment variables
described in this volume of POSIX.1-2024 shall be written to the standard output, one variable per line, and each line using the
following format. Only those variables set in the environment and not overridden by LC_ALL shall be written using this
format:
"%s=%s\n", ,
The names of those LC_* variables associated with locale categories defined in this volume of POSIX.1-2024 that are not
set in the environment or are overridden by LC_ALL shall be written in the following format:
"%s=\"%s\"\n", ,
The  shall be the name of the locale that has been selected for that category by the
implementation, based on the values in LANG and LC_ALL , as described in XBD 8. Environment Variables.
The  and  shown above shall be properly quoted for possible later reentry
to the shell. The  shall not be quoted using double-quotes (so that it can be distinguished by the user from
the  case, which always requires double-quotes).
The LC_ALL variable shall be written last, using the first format shown above. If it is not set, it shall be written
as:
"LC_ALL=\n"
If any arguments are specified:
If the -a option is specified, the names of all the public locales shall be written, each in the following format:
"%s\n",
If the -c option is specified, the names of all selected categories shall be written, each in the following format:
"%s\n",
If keywords are also selected for writing (see following items), the category name output shall precede the keyword output for
that category.
If the -c option is not specified, the names of the categories shall not be written; only the keywords, as selected by
the  operand, shall be written.
If the -k option is specified, the names and values of selected keywords shall be written. If a value is non-numeric and
is not a compound keyword value, it shall be written in the following format:
"%s=\"%s\"\n", ,
If a value is a non-numeric compound keyword value, it shall either be written in the format:
"%s=\"%s\"\n", ,
where the  is a single string of values separated by  characters, or it shall be
written in the format:
"%s=%s\n", ,
where the  is encoded as a set of strings, each enclosed in double-quotation-marks, separated by
characters.
If the keyword was charmap, the name of the charmap (if any) that was specified via the localedef -f option when the locale was created shall be written, with the word
charmap as .
If a value is numeric, it shall be written in one of the following formats:
"%s=%d\n", ,
"%s=%c%o\n", , ,
"%s=%cx%x\n", , ,
where the  is that identified by the escape_char keyword in the current locale; see
XBD 7.3 Locale Definition.
Compound keyword values (list entries) shall be separated in the output by  characters. When included in
keyword values, the , , double-quote, and any control character shall be preceded (escaped) with
the escape character.
If the -k option is not specified, selected keyword values shall be written, each in the following format:
"%s\n",
If the keyword was charmap, the name of the charmap (if any) that was specified via the localedef -f option when the locale was created shall be written.
If the -m option is specified, then a list of all available charmaps shall be written, each in the format:
"%s\n",
where  is in a format suitable for use as the option-argument to the localedef -f option.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
All the requested information was found and output successfully.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
If the LANG environment variable is not set or set to an empty value, or one of the LC_* environment variables is
set to an unrecognized value, the actual locales assumed (if any) are implementation-defined as described in XBD 8. Environment Variables.
Implementations are not required to write out the actual values for keywords in the categories LC_CTYPE and LC_COLLATE
; however, they must write out the categories (allowing an application to determine, for example, which character classes are
available).
EXAMPLES
In the following examples, the assumption is that locale environment variables are set as follows:
LANG=locale_x
LC_COLLATE=locale_y
The command locale would result in the following output:
LANG=locale_x
LC_CTYPE="locale_x"
LC_COLLATE=locale_y
LC_TIME="locale_x"
LC_NUMERIC="locale_x"
LC_MONETARY="locale_x"
LC_MESSAGES="locale_x"
LC_ALL=
The order of presentation of the categories is not specified by this volume of POSIX.1-2024.
The command:
LC_ALL=POSIX locale -ck decimal_point
would produce:
LC_NUMERIC
decimal_point="."
The following command shows an application of locale to determine whether a user-supplied response is affirmative:
printf 'Prompt for response: '
read response
if printf "%s\n" "$response" | grep -Eq -- "$(locale yesexpr)"
then
affirmative processing goes here
else
non-affirmative processing goes here
fi
RATIONALE
The output for categories LC_CTYPE and LC_COLLATE has been made implementation-defined because there is a
questionable value in having a shell script receive an entire array of characters. It is also difficult to return a logical
collation description, short of returning a complete localedef source.
The -m option was included to allow applications to query for the existence of charmaps. The output is a list of the
charmaps (implementation-supplied and user-supplied, if any) on the system.
The -c option was included for readability when more than one category is selected (for example, via more than one
keyword name or via a category name). It is valid both with and without the -k option.
The charmap keyword, which returns the name of the charmap (if any) that was used when the current locale was created,
was included to allow applications needing the information to retrieve it.
According to XBD 6.1 Portable Character Set, the standard requires
that all supported locales must have the same encoding for  and , because these two characters are used
within the locale-independent pathname resolution sequence. Therefore, it would be an error if locale -a listed both
ASCII and EBCDIC-based locales, since those two encodings do not share the same representation for either  or
. Any system that supports both environments would be expected to provide two POSIX locales, one in either codeset,
where only the locales appropriate to the current environment can be visible at a time. In an XSI-compliant implementation, the
dd utility is the only portable means for performing conversions between the two
character sets.
FUTURE DIRECTIONS
None.
SEE ALSO
localedef
XBD 6.1 Portable Character Set, 7. Locale, 8. Environment
Variables, 12.2 Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 4.
Issue 5
The FUTURE DIRECTIONS section is added.
Issue 6
The normative text is reworded to avoid use of the term "must" for application requirements.
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/30 is applied, correcting an editorial error in the STDOUT
section.
Issue 7
Austin Group Interpretations 1003.1-2001 #017, #021, and #088 are applied, clarifying the standard output for the -k
option when LANG is not set or is an empty string.
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0097 [291] is applied.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0114 [941] is applied.
Issue 8
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
Austin Group Defect 1262 is applied, changing the EXAMPLES section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/rm.html =====
rm
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
rm — remove directory entries
SYNOPSIS
rm [-diRrv] file...
rm -f [-diRrv] [file...]
DESCRIPTION
The rm utility shall remove the directory entry specified by each file argument.
If either of the files dot or dot-dot are specified as the basename portion of an operand (that is, the final pathname
component) or if an operand resolves to the root directory, rm shall write a diagnostic message to standard error and do
nothing more with such operands.
For each file the following steps shall be taken:
If the file does not exist:
If the -f option is not specified, rm shall write a diagnostic message to standard error.
Go on to any remaining files.
If file is of type directory, the following steps shall be taken:
If neither the -R option nor the -r option is specified, but -d is specified, rm shall proceed with
step 3 for the current file. If none of -r, -R, or -d is specified, rm shall write a diagnostic message
to standard error, do nothing more with file, and go on to any remaining files.
If file is an empty directory, rm may skip to step 2d. If the -f option is not specified, and either the
permissions of file do not permit writing and the standard input is a terminal or the -i option is specified,
rm shall write a prompt to standard error and read a line from the standard input. If the response is not affirmative,
rm shall do nothing more with the current file and go on to any remaining files.
For each entry contained in file, other than dot or dot-dot, the four steps listed here (1 to 4) shall be taken with the
entry as if it were a file operand. The rm utility shall not traverse directories by following symbolic links into
other parts of the hierarchy, but shall remove the links themselves.
If the -i option is specified, rm shall write a prompt to standard error and read a line from the standard input.
If the response is not affirmative, rm shall do nothing more with the current file, and go on to any remaining files.
rm shall proceed with step 4 for the current file.
If the -f option is not specified, and either the permissions of file do not permit writing and the standard input
is a terminal or the -i option is specified, rm shall write a prompt to the standard error and read a line from the
standard input. If the response is not affirmative, rm shall do nothing more with the current file and go on to any
remaining files.
rm shall perform actions equivalent to the remove() function defined in the
System Interfaces volume of POSIX.1-2024 called with a pathname of the current file used as the path argument.
If rm successfully performed the above actions on the current file, and the -v option is specified, rm
shall write a message containing the pathname of the current file to the standard output. If the actions fail for any reason,
rm shall write a diagnostic message to standard error, do nothing more with the current file, and go on to any remaining
files.
The rm utility shall be able to descend to arbitrary depths in a file hierarchy, and shall not fail due to path length
limitations (unless an operand specified by the user exceeds system limitations).
OPTIONS
The rm utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following options shall be supported:
-d
Remove empty directories. See the DESCRIPTION.
-f
Do not prompt for confirmation. Do not write diagnostic messages or modify the exit status in the case of no file operands, or
in the case of operands that do not exist. Any previous occurrences of the -i option shall be ignored.
-i
Prompt for confirmation as described previously. Any previous occurrences of the -f option shall be ignored.
-R
Remove file hierarchies. See the DESCRIPTION.
-r
Equivalent to -R.
-v
After each file has been removed, write a message to standard output indicating that it has been removed.
OPERANDS
The following operand shall be supported:
file
A pathname of a directory entry to be removed.
STDIN
The standard input shall be used to read an input line in response to each prompt specified in the STDOUT section. Otherwise,
the standard input shall not be used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of rm:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_COLLATE
Determine the locale for the behavior of ranges, equivalence classes, and multi-character collating elements used in the extended
regular expression defined for the yesexpr locale keyword in the LC_MESSAGES category.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments) and the behavior of character classes within regular expressions used in the
extended regular expression defined for the yesexpr locale keyword in the LC_MESSAGES category.
LC_MESSAGES
Determine the locale used to process affirmative responses, and the locale used to affect the format and contents of diagnostic
messages and prompts written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
If the -v option is specified, information about each removed file shall be written to standard output in an unspecified
format.
STDERR
Prompts shall be written to standard error under the conditions specified in the DESCRIPTION and OPTIONS sections. The prompts
shall contain the file pathname, but their format is otherwise unspecified. The standard error also shall be used for
diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
All requested directory entries (excluding directory entries where a non-affirmative response was given to a request for
confirmation) were successfully deleted. In addition, if the -v option is specified, information about each removed
directory entry was successfully written to standard output.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
The rm utility is forbidden to remove the names dot and dot-dot in order to avoid the consequences of inadvertently doing
something like:
rm -r .*
Some implementations do not permit the removal of the last hard link to an executable binary file that is being executed; see
the [EBUSY] error in the unlink() function defined in the System Interfaces volume of
POSIX.1-2024. Thus, the rm utility can fail to remove such files.
The -i option causes rm to prompt and read the standard input even if the standard input is not a terminal, but in
the absence of -i the mode prompting is not done when the standard input is not a terminal.
EXAMPLES
The following command:
rm a.out core
removes the directory entries: a.out and core, or issues an error if either directory entry is itself a directory
or does not exist.
The following command:
rm -Rf junk
removes the directory junk and all its contents, without prompting.
The following command:
rm -d name
behaves like
rmdir name
if name is a directory (including failing if name is not empty), as if by the rmdir() function; and behaves like
rm name
if name is not a directory, as if by the unlink() function.
RATIONALE
For absolute clarity, paragraphs (2b) and (3) in the DESCRIPTION of rm describing the behavior when prompting for
confirmation, should be interpreted in the following manner:
if ((NOT f_option) AND
((not_writable AND input_is_terminal) OR i_option))
The exact format of the interactive prompts is unspecified. Only the general nature of the contents of prompts are specified
because implementations may desire more descriptive prompts than those used on historical implementations. Therefore, an
application not using the -f option, or using the -i option, relies on the system to provide the most suitable dialog
directly with the user, based on the behavior specified.
The -r option is historical practice on all known systems. The synonym -R option is provided for consistency with
the other utilities in this volume of POSIX.1-2024 that provide options requesting recursive descent through the file
hierarchy.
The behavior of the -f option in historical versions of rm is inconsistent. In general, along with "forcing" the
unlink without prompting for permission, it always causes diagnostic messages to be suppressed and the exit status to be unmodified
for nonexistent operands and files that cannot be unlinked. In some versions, however, the -f option suppresses usage
messages and system errors as well. Suppressing such messages is not a service to either shell scripts or users.
It is less clear that error messages regarding files that cannot be unlinked (removed) should be suppressed. Although this is
historical practice, this volume of POSIX.1-2024 does not permit the -f option to suppress such messages.
When given the -r and -i options, historical versions of rm prompt the user twice for each directory, once
before removing its contents and once before actually attempting to delete the directory entry that names it. This allows the user
to "prune" the file hierarchy walk. Historical versions of rm were inconsistent in that some did not do the former prompt
for directories named on the command line and others had obscure prompting behavior when the -i option was specified and the
permissions of the file did not permit writing. The POSIX Shell and Utilities rm differs little from historic practice, but
does require that prompts be consistent. Historical versions of rm were also inconsistent in that prompts were done to both
standard output and standard error. This volume of POSIX.1-2024 requires that prompts be done to standard error, for consistency
with cp and mv, and to allow historical
extensions to rm that provide an option to list deleted files on standard output.
The rm utility is required to descend to arbitrary depths so that any file hierarchy may be deleted. This means, for
example, that the rm utility cannot run out of file descriptors during its descent (that is, if the number of file
descriptors is limited, rm cannot be implemented in the historical fashion where one file descriptor is used per directory
level). Also, rm is not permitted to fail because of path length restrictions, unless an operand specified by the user is
longer than {PATH_MAX}.
The rm utility removes symbolic links themselves, not the files they refer to, as a consequence of the dependence on the
unlink() functionality, per the DESCRIPTION. When removing hierarchies with -r
or -R, the prohibition on following symbolic links has to be made explicit.
The addition of the -d option allows the use of rm to delete either a file or an empty directory without the risk
of recursion into a non-empty directory, and without the inherent race between determining a file's type and deciding what action
to attempt on that file. If either the -r or -R option is specified, the use of recursion takes precedence.
The addition of the -v option allows a user of rm to see which files have been deleted.
FUTURE DIRECTIONS
If this utility is directed to display a pathname that contains any bytes that have the encoded value of a
character when  is a terminator or separator in the output format being used, implementations are encouraged to
treat this as an error. A future version of this standard may require implementations to treat this as an error.
SEE ALSO
rmdir
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
XSH remove(), rmdir(),
unlink()
CHANGE HISTORY
First released in Issue 2.
Issue 5
The FUTURE DIRECTIONS section is added.
Issue 6
Text is added to clarify actions relating to symbolic links as specified in the IEEE P1003.2b draft standard.
Issue 7
Austin Group Interpretations 1003.1-2001 #019 and #091 are applied.
Austin Group Interpretation 1003.1-2001 #126 is applied, changing the description of the LC_MESSAGES environment
variable.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0163 [542], XCU/TC2-2008/0164 [819], and XCU/TC2-2008/0165 [542] are
applied.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to report an error if a utility is directed to display a
pathname that contains any bytes that have the encoded value of a  character when  is a terminator or
separator in the output format being used.
Austin Group Defect 802 is applied, adding the -d option.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
Austin Group Defects 1154, 1365, and 1487 are applied, adding the -v option.
Austin Group Defect 1380 is applied, changing "last link" to "last hard link".
Austin Group Defect 1732 is applied, changing the EXIT STATUS section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/dot.html =====
Shell Command Language
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
Please enable javascript in your browser to automatically redirect to the target page, otherwise select the link below.
2.15 Special Built-In Utilities
break
colon
continue
dot
eval
exec
exit
export
readonly
return
set
shift
times
trap
unset
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
===== susv5-html/utilities/unexpand.html =====
unexpand
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
unexpand — convert spaces to tabs
SYNOPSIS
unexpand [-a|-t tablist] [file...]
DESCRIPTION
The unexpand utility shall copy files or standard input to standard output, converting  characters at the
beginning of each line into the maximum number of  characters followed by the minimum number of  characters
needed to fill the same column positions originally filled by the translated  characters. By default, tabstops shall
be set at every eighth column position. Each  shall be copied to the output, and shall cause the column position
count for tab calculations to be decremented; the count shall never be decremented to a value less than one.
OPTIONS
The unexpand utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following options shall be supported:
-a
In addition to translating  characters at the beginning of each line, translate all sequences of two or more
characters immediately preceding a tab stop to the maximum number of  characters followed by the minimum
number of  characters needed to fill the same column positions originally filled by the translated
characters.
-t tablist
Specify the tab stops. The application shall ensure that the tablist option-argument is a single argument consisting of
a single positive decimal integer or multiple positive decimal integers, separated by  or  characters, in
ascending order. If a single number is given, tabs shall be set tablist column positions apart instead of the default 8. If
multiple numbers are given, the tabs shall be set at those specific column positions.
The application shall ensure that each tab-stop position N is an integer value greater than zero, and the list shall be
in strictly ascending order. This is taken to mean that, from the start of a line of output, tabbing to position N shall
cause the next character output to be in the (N+1)th column position on that line. When the -t option is not
specified, the default shall be the equivalent of specifying -t 8 (except for the interaction with -a, described
below).
No -to- conversions shall occur for characters at positions beyond the last of those specified in a
multiple tab-stop list.
When -t is specified, the presence or absence of the -a option shall be ignored; conversion shall not be limited
to the processing of leading  characters.
OPERANDS
The following operand shall be supported:
file
A pathname of a text file to be used as input.
STDIN
See the INPUT FILES section.
INPUT FILES
The input files shall be text files.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of unexpand:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files), the processing of  and  characters, and for
the determination of the width in column positions each character would occupy on an output device.
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
The standard output shall be equivalent to the input files with the specified -to- conversions.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
One non-intuitive aspect of unexpand is its restriction to leading  characters when neither -a nor
-t is specified. Users who always want to convert all  characters in a file can easily alias unexpand to
use the -a or -t 8 option.
EXAMPLES
None.
RATIONALE
On several occasions, consideration was given to adding a -t option to the unexpand utility to complement the
-t in expand (see expand). The
historical intent of unexpand was to translate multiple  characters into tab stops, where tab stops were a
multiple of eight column positions on most UNIX systems. An early proposal omitted -t because it seemed outside the scope of
the User Portability Utilities option; it was not described in any of the base documents for IEEE Std 1003.2-1992.
However, hard-coding tab stops every eight columns was not suitable for the international community and broke historical precedents
for some vendors in the FORTRAN community, so -t was restored in conjunction with the list of valid extension categories
considered by the standard developers. Thus, unexpand is now the logical converse of expand.
FUTURE DIRECTIONS
None.
SEE ALSO
expand, tabs
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 4.
Issue 6
This utility is marked as part of the User Portability Utilities option.
The definition of the LC_CTYPE environment variable is changed to align with the IEEE P1003.2b draft standard.
The normative text is reworded to avoid use of the term "must" for application requirements.
Issue 7
The unexpand utility is moved from the User Portability Utilities option to the Base. User Portability Utilities is now
an option for interactive utilities.
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0198 [885] is applied.
Issue 8
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/compress.html =====
compress
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
compress, uncompress, zcat — compress and decompress data
SYNOPSIS
[XSI]
compress [-fv] [-b value] [-g | -m algo] [file...]
compress -c [-fv] [-b value] [-g | -m algo] [file]
compress -d [-cfv] [file...]
uncompress [-cfv] [file...]
zcat [file...]
DESCRIPTION
The
compress
utility, when the
-d
option is not specified, shall apply the compression algorithm identified
by the
-g
option or the
-m
algo
option to the named files to attempt to reduce their size without loss
of information. The compress utility with the
-d
option shall apply the appropriate decompression algorithm to the
named files to restore the data to their original state.
The
uncompress
utility shall be equivalent to
compress
-d.
The
zcat
utility shall be equivalent to
compress
-c -d.
If multiple
file
operands are specified, the decompressed data from each input file
shall be concatenated to standard output.
When compressing data, unless the
-c
option is specified, after an input file other than standard input has
been compressed, the compressed data from the input file shall be
stored in a file with the same pathname as the input file but with an
added suffix. The added suffix shall be the suffix associated with the
algorithm (see the algorithms in
Compression algorithms, algo option-argument values, and suffixes
).
If appending the suffix would make the size of the last component of
the output file's pathname exceed
{NAME_MAX}
bytes, the command shall fail. If appending the suffix would make the
size of the pathname exceed
{PATH_MAX}
bytes, the command may fail.
When decompressing data, unless the
-c
option is specified, after an input file other than standard input has
been decompressed, the decompressed data from the input file shall be
stored in a file with the same pathname as the input file but with the
suffix associated with the algorithm removed.
[OB]
If
file
has no suffix associated with a known compression algorithm or
file
does not exist and does not have a
.Z
suffix,
file
shall be used as the name of the output file, and the default suffix
.Z
shall be appended to
file
to form the input pathname.
The behavior is unspecified if the input pathname ends with a suffix
other than the suffix associated with the algorithm used to compress
the data. When the
-c
option is specified,
file
can have any suffix, or no suffix, and the utility shall use
file
as the input file and examine the file's contents to determine which
algorithm to use to decompress the data (it is not an error if
file
does not have a suffix that matches the suffix associated with the
compression algorithm).
When compressing or decompressing a file other than standard input and the
-c
option is not specified, if the invoking process has sufficient privilege,
the ownership, modes, access time, and modification time of the output
file shall match the ownership, modes, access time, and modification
time of the input file. After the output file has been successfully
created, the input file shall be removed if the invoking process has
sufficient privileges. If the invoking process does not have sufficient
privileges to remove the input file (for example, if the directory has
the S_ISVTX bit set) the behavior depends on whether the
-f
option is specified: if
-f
is not specified, the output file shall be removed, a diagnostic
message shall be written and the utility shall continue processing
other files but the final exit status shall be non-zero; if
-f
is specified, the output file shall not be removed and it is
unspecified whether the inability to remove the input file is treated
as an error. If it is not treated as an error, a warning message may
be written to standard error
If no
file
operands are specified, standard input shall be compressed or
decompressed to standard output.
[OB]
If an input file that is to be removed after processing has multiple
hard links, the
compress
and
uncompress
utilities may write a diagnostic message to standard error and do
nothing with the file; this behavior may depend on whether the
-f
option is specified. If a diagnostic message is written, the final
exit status shall be non-zero.
OPTIONS
The
compress,
uncompress,
and
zcat
utilities shall conform to XBD
12.2 Utility Syntax Guidelines
,
except that Guideline 1 does not apply to
uncompress
since the utility name has ten letters.
The following options shall be supported:
-b valueIf the compression algorithm is LZW,
value
specifies the maximum number of bits to use in a code. For a
conforming application, the
value
argument shall be:
9 2An error occurred.
The following exit values shall be returned for
uncompress
and
zcat:
0Successful completion.
>0An error occurred.
CONSEQUENCES OF ERRORS
If an error occurs while compressing or decompressing an input file
other than standard input, the input file shall remain unmodified.
The following sections are informative.
APPLICATION USAGE
The amount of compression obtained depends on the size of the input,
the number of bits
per code, and the distribution of common substrings. Typically, text
such as source code or English is reduced by 50-60%. Compression is
generally much better than that achieved by Huffman coding
or adaptive Huffman coding (compact),
and takes less time to compute.
Although
compress
strictly follows the default actions upon receipt of a signal or when
an error occurs, some unexpected results may occur. In some
implementations it is likely that a partially compressed file is left
in place, alongside its uncompressed input file. Since the general
operation of
compress
is to delete the uncompressed file only after the
.Z
file has been successfully filled, an application should always
carefully check the exit status of
compress
before arbitrarily deleting files that have like-named neighbors with
.Z
suffixes.
In addition to trying
file
and
file.Z
when looking for a file to decompress, some implementations of
uncompress
and
zcat
also try suffixes for other known compression algorithms if neither
file
nor
file.Z
is found. This version of the standard allows, but does not require
this behavior. Portable applications should always specify the full
pathname (including the suffix) of files to be decompressed.
EXAMPLES
None.
RATIONALE
Earlier versions of this standard limited the number of bits used by
conforming applications for the
lzw
algorithm to 14 due to address space limitations on 16-bit
architectures. Using 15 or 16 is a much more common default when using
current hardware.
Earlier versions of this standard only supported LZW compression. The
standard developers noted that existing implementations added other
compression utilities, such as
gzip,
and found it desirable to support this widespread usage. Some
implementations had extended the
compress
utility to support such other schemes. The standard developers
generalized this practice by the addition of the
-m
option, even though this was not previous practice.
The
uncompress
-d
option is added to match undocumented existing practice of tested
implementations.
FUTURE DIRECTIONS
If this utility is directed to create a new directory entry that
contains any bytes that have the encoded value of a
character, implementations are encouraged to treat this as an error.
A future version of this standard may require implementations to treat
this as an error.
When decompressing a file, the requirement to add
.Z
to a
file
operand if the given pathname does not include a suffix associated
with a known compression algorithm or if
file
does not exist and does not already have a
.Z
extension is an obsolescent feature and may be removed in a future version.
SEE ALSO
XBD
8. Environment Variables
,
12.2 Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 4.
Issue 6
The normative text is reworded to avoid use of the term "must"
for application requirements.
An error case is added for systems not supporting adaptive Lempel-Ziv
coding.
Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
Austin Group Interpretation 1003.1-2001 #125 is applied, revising
the ENVIRONMENT VARIABLES section.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to
disallow the creation of filenames containing any bytes that have the
encoded value of a
character.
Austin Group Defect 1041 is applied, combining the
compress,
uncompress
and
zcat
pages into one and extensively modifying most sections.
Austin Group Defect 1122 is applied, changing the description of
NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index |
XBD |
XSH |
XCU |
XRAT ]
>>
===== susv5-html/utilities/env.html =====
env
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
env — set the environment for command invocation
SYNOPSIS
env [-i] [name=value]... [utility
[argument...]]
DESCRIPTION
The env utility shall obtain the current environment, modify it according to its arguments, then invoke the utility named
by the utility operand with the modified environment.
Optional arguments shall be passed to utility.
If no utility operand is specified, the resulting environment shall be written to the standard output, with one
name=value pair per line.
If the first argument is '-', the results are unspecified.
OPTIONS
The env utility shall conform to XBD 12.2 Utility Syntax
Guidelines, except for the unspecified usage of '-'.
The following options shall be supported:
-i
Invoke utility with exactly the environment specified by the arguments; the inherited environment shall be ignored
completely.
OPERANDS
The following operands shall be supported:
name=value
Arguments of the form name=value shall modify the execution environment, and shall be placed into the inherited
environment before the utility is invoked.
utility
The name of the utility to be invoked. If the utility operand names any of the special built-in utilities in 2.15 Special Built-In Utilities, the results are undefined.
argument
A string to pass as an argument for the invoked utility.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of env:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
PATH
Determine the location of the utility, as described in XBD 8. Environment
Variables. If PATH is specified as a name=value operand to env, the value given shall
be used in the search for utility.
ASYNCHRONOUS EVENTS
Default.
STDOUT
If no utility operand is specified, each name=value pair in the resulting environment shall be written in
the form:
"%s=%s\n", ,
If the utility operand is specified, the env utility shall not write to standard output.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
If utility is invoked, the exit status of env shall be the exit status of utility; otherwise, the
env utility shall exit with one of the following values:
0
The env utility completed successfully.
1-125
An error occurred in the env utility.
126
The utility specified by utility was found but could not be invoked.
127
The utility specified by utility could not be found.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
The command, env, nice,
nohup, time, timeout, and xargs utilities have been
specified to use exit code 127 if a utility to be invoked cannot be found, so that applications can distinguish "failure to find a
utility" from "invoked utility exited with an error indication". The value 127 was chosen because it is not commonly used for
other meanings; most utilities use small values for "normal error conditions" and the values above 128 can be confused with
termination due to receipt of a signal. The value 126 was chosen in a similar manner to indicate that the utility could be found,
but not invoked. Some scripts produce meaningful error messages differentiating the 126 and 127 cases. The distinction between exit
codes 126 and 127 is based on KornShell practice that uses 127 when all attempts to exec the utility fail with [ENOENT], and
uses 126 when any attempt to exec the utility fails for any other reason.
Historical implementations of the env utility use the execvp() or execlp() functions defined in the System Interfaces volume of POSIX.1-2024 to invoke the
specified utility; this provides better performance and keeps users from having to escape characters with special meaning to the
shell. Therefore, shell functions, special built-ins, and built-ins that are only provided by the shell are not found by this type
of env implementation. However, env can be implemented as a shell built-in, in which case it may be able to execute
shell functions and built-ins. An application wishing to ensure execution of a non-built-in utility can use exec in a subshell for this purpose.
EXAMPLES
The following command:
env -i PATH=/mybin:"$PATH" $(getconf V7_ENV) mygrep xyz myfile
invokes the command mygrep with a new PATH value as the only entry in its environment other than any variables
required by the implementation for conformance. In this case, PATH is used to locate mygrep, which is expected to
reside in /mybin.
RATIONALE
As with all other utilities that invoke other utilities, this volume of POSIX.1-2024 only specifies what env does with
standard input, standard output, standard error, input files, and output files. If a utility is executed, it is not constrained by
the specification of input and output by env.
The -i option was added to allow the functionality of the removed - option in a manner compatible with the Utility
Syntax Guidelines. It is possible to create a non-conforming environment using the -i option, as it may remove environment
variables required by the implementation for conformance. The following will preserve these environment variables as well as
preserve the PATH for conforming utilities:
IFS='
'
# The preceding value should be .
# Set IFS to its default value.
set -f
# disable pathname expansion
\unalias -a
# Unset all possible aliases.
# Note that unalias is escaped to prevent an alias
# being used for unalias.
# This step is not strictly necessary, since aliases are not inherited,
# and the ENV environment variable is only used by interactive shells,
# the only way any aliases can exist in a script is if it defines them
# itself.
unset -f env getconf
# Ensure env and getconf are not user functions.
env -i $(getconf V7_ENV) PATH="$(getconf PATH)" command
Some have suggested that env is redundant since the same effect is achieved by:
name=value ... utility [ argument ... ]
The example is equivalent to env when an environment variable is being added to the environment of the command, but not
when the environment is being set to the given value. The env utility also writes out the current environment if invoked
without arguments. There is sufficient functionality beyond what the example provides to justify inclusion of env.
FUTURE DIRECTIONS
None.
SEE ALSO
2.15 Special Built-In Utilities, 2.5 Parameters and Variables
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 2.
Issue 7
Austin Group Interpretation 1003.1-2001 #027 is applied, clarifying the behavior if the first argument is '-'.
Austin Group Interpretation 1003.1-2001 #047 is applied, providing RATIONALE on how to use the env utility to preserve a
conforming environment.
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
The EXAMPLES section is revised to change the use of env -i.
Issue 8
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
Austin Group Defect 1157 is applied, adding a note about shell built-in implementations of env to the APPLICATION USAGE
section.
Austin Group Defect 1586 is applied, adding the timeout utility.
Austin Group Defect 1594 is applied, changing the APPLICATION USAGE section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/cal.html =====
cal
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
cal — print a calendar
SYNOPSIS
[XSI]  cal [[month] year]
DESCRIPTION
The cal utility shall write a calendar to standard output using the Julian calendar for dates from January 1, 1 through
September 2, 1752 and the Gregorian calendar for dates from September 14, 1752 through December 31, 9999 as though the Gregorian
calendar had been adopted on September 14, 1752.
If no operands are given, cal shall produce a one-month calendar for the current month in the current year. If only the
year operand is given, cal shall produce a calendar for all twelve months in the given calendar year. If both
month and year operands are given, cal shall produce a one-month calendar for the given month in the given
year.
OPTIONS
None.
OPERANDS
The following operands shall be supported:
month
Specify the month to be displayed, represented as a decimal integer from 1 (January) to 12 (December).
year
Specify the year for which the calendar is displayed, represented as a decimal integer from 1 to 9999.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of cal:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error, and
informative messages written to standard output.
LC_TIME
Determine the format and contents of the calendar.
NLSPATH
Determine the location of messages objects and message catalogs.
TZ
Determine the timezone used to calculate the value of the current month.
ASYNCHRONOUS EVENTS
Default.
STDOUT
The standard output shall be used to display the calendar, in an unspecified format.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
Note that:
cal 83
refers to A.D. 83, not 1983.
EXAMPLES
None.
RATIONALE
Earlier versions of this standard incorrectly required that the command:
cal 2000
write a one-month calendar for the current calendar month (no matter what the current year is) in the year 2000 to standard
output. This did not match historic practice in any known version of the cal utility. The description has been updated to
match historic practice. When only the year operand is given, cal writes a twelve-month calendar for the specified
year.
FUTURE DIRECTIONS
A future version of this standard may support locale-specific recognition of the date of adoption of the Gregorian calendar.
SEE ALSO
XBD 8. Environment Variables
CHANGE HISTORY
First released in Issue 2.
Issue 6
The DESCRIPTION is updated to allow for traditional behavior for years before the adoption of the Gregorian calendar.
Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0074 [56] and XCU/TC1-2008/0075 [56] are applied.
Issue 8
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/file.html =====
file
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
file — determine file type
SYNOPSIS
file [-dh] [-M file] [-m file]
file...
file -i [-h] file...
DESCRIPTION
The file utility shall perform a series of tests in sequence on each specified file in an attempt to classify
it:
If file does not exist, cannot be read, or its file status could not be determined, the output shall indicate that the
file was processed, but that its type could not be determined.
If the file is not a regular file, its file type shall be identified. The file types directory, FIFO, socket, block special, and
character special shall be identified as such. Other implementation-defined file types may also be identified. If file is a
symbolic link, by default the link shall be resolved and file shall test the type of file referenced by the symbolic link.
(See the -h and -i options below.)
If the length of file is zero, it shall be identified as an empty file.
The file utility shall examine an initial segment of file and shall make a guess at identifying its contents based
on position-sensitive tests. (The answer is not guaranteed to be correct; see the -d, -M, and -m options
below.)
The file utility shall examine file and make a guess at identifying its contents based on context-sensitive
default system tests. (The answer is not guaranteed to be correct.)
The file shall be identified as a data file.
If file does not exist, cannot be read, or its file status could not be determined, the output shall indicate that the
file was processed, but that its type could not be determined.
If file is a symbolic link, by default the link shall be resolved and file shall test the type of file referenced
by the symbolic link.
OPTIONS
The file utility shall conform to XBD 12.2 Utility Syntax
Guidelines, except that the order of the -m, -d, and -M options shall be significant.
The following options shall be supported by the implementation:
-d
Apply any position-sensitive default system tests and context-sensitive default system tests to the file. This is the default
if no -M or -m option is specified.
-h
When a symbolic link is encountered, identify the file as a symbolic link. If -h is not specified and file is a
symbolic link that refers to a nonexistent file, file shall identify the file as a symbolic link, as if -h had been
specified.
-i
If a file is a regular file, do not attempt to classify the type of the file further, but identify the file as specified in the
STDOUT section.
-M file
Specify the name of a file containing position-sensitive tests that shall be applied to a file in order to classify it (see the
EXTENDED DESCRIPTION). No position-sensitive default system tests nor context-sensitive default system tests shall be applied
unless the -d option is also specified.
-m file
Specify the name of a file containing position-sensitive tests that shall be applied to a file in order to classify it (see the
EXTENDED DESCRIPTION).
If the -m option is specified without specifying the -d option or the -M option, position-sensitive default
system tests shall be applied after the position-sensitive tests specified by the -m option. If the -M option is
specified with the -d option, the -m option, or both, or the -m option is specified with the -d option,
the concatenation of the position-sensitive tests specified by these options shall be applied in the order specified by the
appearance of these options. If a -M or -m file option-argument is -, the results are unspecified.
OPERANDS
The following operand shall be supported:
file
A pathname of a file to be tested.
STDIN
The standard input shall be used if a file operand is '-' and the implementation treats the '-' as
meaning standard input. Otherwise, the standard input shall not be used.
INPUT FILES
The file can be any file type.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of file:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error and
informative messages written to standard output.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
In the POSIX locale, the following format shall be used to identify each operand, file specified:
"%s: %s\n", ,
The values for  are unspecified, except that in the POSIX locale, if file is identified as one of the
types listed in the following table,  shall contain (but is not limited to) the corresponding string, unless the
file is identified by a position-sensitive test specified by a -M or -m option. Each  shown in the
strings shall be exactly one .
Table: File Utility Output Strings
If file is:
shall contain the string:
Notes
Nonexistent
cannot open
Block special
block special
1
Character special
character special
1
Directory
directory
1
FIFO
fifo
1
Socket
socket
1
Symbolic link
symbolic link to
1
Regular file
regular file
1,2
Empty regular file
empty
3
Regular file that cannot be read
cannot open
3
Executable binary
executable
3,4,6
ar archive library (see ar)
archive
3,4,6
Extended cpio format (see pax)
cpio archive
3,4,6
Extended tar format (see ustar in pax)
tar archive
3,4,6
Shell script
commands text
3,5,6
C-language source
c program text
3,5,6
FORTRAN source
fortran program text
3,5,6
Regular file whose type cannot be determined
data
3
Notes:
This is a file type test.
This test is applied only if the -i option is specified.
This test is applied only if the -i option is not specified.
This is a position-sensitive default system test.
This is a context-sensitive default system test.
Position-sensitive default system tests and context-sensitive default system tests are not applied if the
-M option is specified unless the -d option is also specified.
In the POSIX locale, if file is identified as a symbolic link (see the -h option), the following
alternative output format shall be used:
"%s: %s %s\n", , , "
If the file named by the file operand does not exist, cannot be read, or the type of the file named by the
file operand cannot be determined, this shall not be considered an error that affects the exit status.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
A file specified as an option-argument to the -m or -M options shall contain one position-sensitive test per line,
which shall be applied to the file. If the test succeeds, the message field of the line shall be printed and no further tests shall
be applied, with the exception that tests on immediately following lines beginning with a single '>' character shall be
applied.
Each line shall be composed of the following four -separated fields. (Implementations may allow any
combination of one or more white-space characters other than  to act as field separators.)
offset
An unsigned number (optionally preceded by a single '>' character) specifying the offset, in bytes, of the
value in the file that is to be compared against the value field of the line. If the file is shorter than the specified
offset, the test shall fail.
If the offset begins with the character '>', the test contained in the line shall not be applied
to the file unless the test on the last line for which the offset did not begin with a '>' was successful. By
default, the offset shall be interpreted as an unsigned decimal number. With a leading 0x or 0X, the offset shall be
interpreted as a hexadecimal number; otherwise, with a leading 0, the offset shall be interpreted as an octal number.
type
The type of the value in the file to be tested. The type shall consist of the type specification characters d,
s, and u, specifying signed decimal, string, and unsigned decimal, respectively.
The type string shall be interpreted as the bytes from the file starting at the specified offset and
including the same number of bytes specified by the value field. If insufficient bytes remain in the file past the
offset to match the value field, the test shall fail.
The type specification characters d and u can be followed by an optional unsigned decimal integer
that specifies the number of bytes represented by the type. The type specification characters d and u can be
followed by an optional C, S, I, or L, indicating that the value is of type char,
short, int, or long, respectively.
The default number of bytes represented by the type specifiers d, f, and u shall
correspond to their respective C-language types as follows. If the system claims conformance to the C-Language Development
Utilities option, those specifiers shall correspond to the default sizes used in the c17
utility. Otherwise, the default sizes shall be implementation-defined.
For the type specifier characters d and u, the default number of bytes shall correspond to the
size of a basic integer type of the implementation. For these specifier characters, the implementation shall support values of the
optional number of bytes to be converted corresponding to the number of bytes in the C-language types char, short,
int, or long. These numbers can also be specified by an application as the characters C, S,
I, and L, respectively. The byte order used when interpreting numeric values is implementation-defined, but shall
correspond to the order in which a constant of the corresponding type is stored in memory on the system.
All type specifiers, except for s, can be followed by a mask specifier of the form &number. The
mask value shall be AND'ed with the value of the input file before the comparison with the value field of the line is made.
By default, the mask shall be interpreted as an unsigned decimal number. With a leading 0x or 0X, the mask shall be interpreted as
an unsigned hexadecimal number; otherwise, with a leading 0, the mask shall be interpreted as an unsigned octal number.
The strings byte, short, long, and string shall also be supported as type fields, being
interpreted as dC, dS, dL, and s, respectively.
value
The value to be compared with the value from the file.
If the specifier from the type field is s or string, then interpret the value as a string.
Otherwise, interpret it as a number. If the value is a string, then the test shall succeed only when a string value exactly matches
the bytes from the file.
If the value is a string, it can contain the following sequences:
\character
The -escape sequences as specified in XBD Escape Sequences
and Associated Actions ('\\', '\a', '\b', '\f', '\n', '\r',
'\t', '\v'). In addition, the escape sequence '\ ' (the  character followed by a
character) shall be recognized to represent a  character. The results of using any other character,
other than an octal digit, following the  are unspecified.
\octal
Octal sequences that can be used to represent characters with specific coded values. An octal sequence shall consist of a
followed by the longest sequence of one, two, or three octal-digit characters (01234567).
By default, any value that is not a string shall be interpreted as a signed decimal number. Any such value, with a
leading 0x or 0X, shall be interpreted as an unsigned hexadecimal number; otherwise, with a leading zero, the value shall be
interpreted as an unsigned octal number.
If the value is not a string, it can be preceded by a character indicating the comparison to be performed.
Permissible characters and the comparisons they specify are as follows:
=
The test shall succeed if the value from the file equals the value field.
The test shall succeed if the value from the file is greater than the value field.
&
The test shall succeed if all of the set bits in the value field are set in the value from the file.
^
The test shall succeed if at least one of the set bits in the value field is not set in the value from the file.
x
The test shall succeed if the file is large enough to contain a value of the type specified starting at the offset
specified.
message
The message to be printed if the test succeeds. The message shall be interpreted using the notation for the
printf formatting specification; see printf. If the value field was a string, then the value from the file shall be the
argument for the printf formatting specification; otherwise, the value from the file
shall be the argument.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
The file utility can only be required to guess at many of the file types because only exhaustive testing can determine
some types with certainty. For example, binary data on some implementations might match the initial segment of an executable or a
tar archive.
Note that the table indicates that the output contains the stated string. Systems may add text before or after the
string. For executables, as an example, the machine architecture and various facts about how the file was link-edited may be
included. Note also that on systems that recognize shell script files starting with "#!" as executable files, these may be
identified as executable binary files rather than as shell scripts.
EXAMPLES
Determine whether an argument is a binary executable file:
file -- "$1" | grep -q ':.*executable' &&
printf "%s is executable.\n" "$1"
RATIONALE
The -f option was omitted because the same effect can (and should) be obtained using the xargs utility.
Historical versions of the file utility attempt to identify the following types of files: symbolic link,
directory, character special, block special, socket, tar archive, cpio archive, SCCS archive, archive library, empty,
compress output, pack output, binary data, C source, FORTRAN source,
assembler source, nroff/troff/eqn/tbl source troff output, shell script, C shell script, English
text, ASCII text, various executables, APL workspace, compiled terminfo entries, and CURSES screen images. Only those types that
are reasonably well specified in POSIX or are directly related to POSIX utilities are listed in the table.
Historical systems have used a "magic file" named /etc/magic to help identify file types. Because it is
generally useful for users and scripts to be able to identify special file types, the -m flag and a portable format for
user-created magic files has been specified. No requirement is made that an implementation of file use this method of
identifying files, only that users be permitted to add their own classifying tests.
In addition, three options have been added to historical practice. The -d flag has been added to permit
users to cause their tests to follow any default system tests. The -i flag has been added to permit users to test portably
for regular files in shell scripts. The -M flag has been added to permit users to ignore any default system tests.
The POSIX.1-2024 description of default system tests and the interaction between the -d, -M, and
-m options did not clearly indicate that there were two types of "default system tests". The "position-sensitive tests"
determine file types by looking for certain string or binary values at specific offsets in the file being examined. These
position-sensitive tests were implemented in historical systems using the magic file described above. Some of these tests are now
built into the file utility itself on some implementations so the output can provide more detail than can be provided by
magic files. For example, a magic file can easily identify a file containing a core image on most implementations, but cannot name
the program file that dropped the core. A magic file could produce output such as:
/home/dwc/core: ELF 32-bit MSB core file SPARC Version 1
but by building the test into the file utility, you could get output such as:
/home/dwc/core: ELF 32-bit MSB core file SPARC Version 1, from 'testprog'
These extended built-in tests are still to be treated as position-sensitive default system tests even if they are
not listed in /etc/magic or any other magic file.
The context-sensitive default system tests were always built into the file utility. These tests looked for
language constructs in text files trying to identify shell scripts, C, FORTRAN, and other computer language source files, and even
plain text files. With the addition of the -m and -M options the distinction between position-sensitive and
context-sensitive default system tests became important because the order of testing is important. The context-sensitive system
default tests should never be applied before any position-sensitive tests even if the -d option is specified before a
-m option or -M option due to the high probability that the context-sensitive system default tests will incorrectly
identify arbitrary text files as text files before position-sensitive tests specified by the -m or -M option would be
applied to give a more accurate identification.
Leaving the meaning of -M - and -m - unspecified allows an existing prototype of these options to
continue to work in a backwards-compatible manner. (In that implementation, -M - was roughly equivalent to -d in
POSIX.1-2024.)
The historical -c option was omitted as not particularly useful to users or portable shell scripts. In
addition, a reasonable implementation of the file utility would report any errors found each time the magic file is
read.
The historical format of the magic file was the same as that specified by the Rationale in the
ISO POSIX-2:1993 standard for the offset, value, and message fields; however, it used less precise type
fields than the format specified by the current normative text. The new type field values are a superset of the historical
ones.
The following is an example magic file:
0  short     070707              cpio archive
0  short     0143561             Byte-swapped cpio archive
0  string    070707              ASCII cpio archive
0  long      0177555             Very old archive
0  short     0177545             Old archive
0  short     017437              Old packed data
0  string    \037\036            Packed data
0  string    \377\037            Compacted data
0  string    \037\235            Compressed data
>2 byte&0x80 >0                  Block compressed
>2 byte&0x1f x                   %d bits
0  string    \032\001            Compiled Terminfo Entry
0  short     0433                Curses screen image
0  short     0434                Curses screen image
0  string                    System V Release 1 archive
0  string    !\n__.SYMDEF  Archive random library
0  string    !             Archive
0  string    ARF_BEGARF          PHIGS clear text archive
0  long      0x137A2950          Scalable OpenFont binary
0  long      0x137A2951          Encrypted scalable OpenFont binary
The use of a basic integer data type is intended to allow the implementation to choose a word size commonly used by
applications on that architecture.
Earlier versions of this standard allowed for implementations with bytes other than eight bits, but this has been
modified in this version.
FUTURE DIRECTIONS
If this utility is directed to display a pathname that contains any bytes that have the encoded value of a
character when  is a terminator or separator in the output format being used, implementations are encouraged to
treat this as an error. A future version of this standard may require implementations to treat this as an error.
SEE ALSO
ar, ls, pax, printf
XBD Escape Sequences and Associated Actions, 8. Environment Variables, 12.2
Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 4.
Issue 6
This utility is marked as part of the User Portability Utilities option.
Options and an EXTENDED DESCRIPTION are added as specified in the IEEE P1003.2b draft standard.
IEEE PASC Interpretations 1003.2 #192 and #178 are applied.
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/25 is applied, making major changes to address
ambiguities raised in defect reports.
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/26 is applied, making it clear in the OPTIONS
section that the -m, -d, and -M options do not comply with Guideline 11 of the Utility Syntax Guidelines.
IEEE Std 1003.1-2001/Cor 2-2004, item XCU/TC2/D6/10 is applied, clarifying the specification
characters.
IEEE Std 1003.1-2001/Cor 2-2004, item XCU/TC2/D6/11 is applied, allowing application developers to
create portable magic files that can match characters in strings, and allowing common extensions found in existing
implementations.
IEEE Std 1003.1-2001/Cor 2-2004, item XCU/TC2/D6/12 is applied, removing text describing behavior on
systems with bytes consisting of more than eight bits.
Issue 7
Austin Group Interpretation 1003.1-2001 #092 is applied.
SD5-XCU-ERN-4 is applied, adding further entries in the Notes column in File Utility Output
Strings.
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
The file utility is moved from the User Portability Utilities option to the Base. User Portability Utilities
is now an option for interactive utilities.
The EXAMPLES section is revised to correct an error with the pathname "$1".
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to report an error if a utility is directed to display a
pathname that contains any bytes that have the encoded value of a  character when  is a terminator or
separator in the output format being used.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
Austin Group Defect 1141 is applied, changing "core file" to "file containing a core image".
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/shift.html =====
Shell Command Language
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
Please enable javascript in your browser to automatically redirect to the target page, otherwise select the link below.
2.15 Special Built-In Utilities
break
colon
continue
dot
eval
exec
exit
export
readonly
return
set
shift
times
trap
unset
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
===== susv5-html/utilities/tsort.html =====
tsort
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
tsort — topological sort
SYNOPSIS
tsort [-w] [file]
DESCRIPTION
The tsort utility shall write to standard output a totally ordered list of items consistent with a partial ordering of
items contained in the input.
The application shall ensure that the input consists of pairs of items (non-empty strings) separated by one or more
or  characters. It is unspecified whether other white-space characters can also be used as separators.
Pairs of different items shall indicate ordering. Pairs of identical items shall indicate presence, but not ordering.
If a cycle is found in the input, diagnostic or warning messages shall be written to standard error reporting that there is a
cycle and indicating which nodes are in the cycle(s). If the -w option is specified, these messages shall be diagnostic
messages. If a diagnostic message is written, the final exit status shall be non-zero.
OPTIONS
The tsort utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following option shall be supported:
-w
Set the exit status to the number of cycles found in the input, or to an implementation-defined maximum if there are more
cycles than that maximum. If no cycles are found, the exit status shall be zero unless another error occurs.
OPERANDS
The following operand shall be supported:
file
A pathname of a text file to order. If no file operand is given, the standard input shall be used.
STDIN
The standard input shall be used if no file operand is specified, and shall be used if the file operand is
'-' and the implementation treats the '-' as meaning standard input. Otherwise, the standard input shall not be
used. See the INPUT FILES section.
INPUT FILES
The input file shall be a text file.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of tsort:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
The standard output shall be a text file consisting of the ordered list of items, with one item per line, produced from the
partially ordered input.
STDERR
The standard error shall be used only for diagnostic and warning messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred. If the -w option is specified and one or more cycles were found in the input, the exit status shall
be the number of cycles found, or an implementation-defined maximum if more cycles than that maximum were found.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
The LC_COLLATE variable need not affect the actions of tsort. The output ordering is not lexicographic, but
depends on the pairs of items given as input.
EXAMPLES
The command:
tsort >>
===== susv5-html/utilities/getconf.html =====
getconf
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
getconf — get configuration values
SYNOPSIS
getconf [-v specification] system_var
getconf [-v specification] path_var pathname
DESCRIPTION
In the first synopsis form, the getconf utility shall write to the standard output the value of the variable specified by
the system_var operand.
In the second synopsis form, the getconf utility shall write to the standard output the value of the variable specified
by the path_var operand for the path specified by the pathname operand.
The value of each configuration variable shall be determined as if it were obtained by calling the function from which it is
defined to be available by this volume of POSIX.1-2024 or by the System Interfaces volume of POSIX.1-2024 (see the OPERANDS
section). The value shall reflect conditions in the current operating environment.
OPTIONS
The getconf utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following option shall be supported:
-v specification
Indicate a specific specification and version for which configuration variables shall be determined. If this option is not
specified, the values returned correspond to an implementation default conforming compilation environment.
If the command:
getconf _POSIX_V8_ILP32_OFF32
does not write "-1\n" or "undefined\n" to standard output, then commands of the form:
getconf -v POSIX_V8_ILP32_OFF32 ...
determine values for configuration variables corresponding to the POSIX_V8_ILP32_OFF32 compilation environment specified in
c17, the EXTENDED DESCRIPTION.
If the command:
getconf _POSIX_V8_ILP32_OFFBIG
does not write "-1\n" or "undefined\n" to standard output, then commands of the form:
getconf -v POSIX_V8_ILP32_OFFBIG ...
determine values for configuration variables corresponding to the POSIX_V8_ILP32_OFFBIG compilation environment specified in
c17, the EXTENDED DESCRIPTION.
If the command:
getconf _POSIX_V8_LP64_OFF64
does not write "-1\n" or "undefined\n" to standard output, then commands of the form:
getconf -v POSIX_V8_LP64_OFF64 ...
determine values for configuration variables corresponding to the POSIX_V8_LP64_OFF64 compilation environment specified in
c17, the EXTENDED DESCRIPTION.
If the command:
getconf _POSIX_V8_LPBIG_OFFBIG
does not write "-1\n" or "undefined\n" to standard output, then commands of the form:
getconf -v POSIX_V8_LPBIG_OFFBIG ...
determine values for configuration variables corresponding to the POSIX_V8_LPBIG_OFFBIG compilation environment specified in
c17, the EXTENDED DESCRIPTION.
OPERANDS
The following operands shall be supported:
path_var
A name of a configuration variable. All of the variables in the Variable column of the table in the DESCRIPTION of the fpathconf() function defined in the System Interfaces volume of POSIX.1-2024, without the
enclosing braces, shall be supported. The implementation may add other local variables.
pathname
A pathname for which the variable specified by path_var is to be determined.
system_var
A name of a configuration variable. All of the following variables shall be supported:
The names, without the enclosing braces, in the Variable column of the table in the DESCRIPTION of the sysconf() function in the System Interfaces volume of POSIX.1-2024, except for the entries
corresponding to _SC_CLK_TCK, _SC_GETGR_R_SIZE_MAX, _SC_GETPW_R_SIZE_MAX, _SC_NPROCESSORS_CONF, _SC_NPROCESSORS_ONLN, and
_SC_NSIG.
For compatibility with earlier versions, the following variable names shall also be supported: POSIX2_C_BIND POSIX2_C_DEV
POSIX2_CHAR_TERM POSIX2_FORT_RUN POSIX2_LOCALEDEF POSIX2_SW_DEV POSIX2_UPE POSIX2_VERSION
and shall be equivalent to the same name prefixed with an . This requirement may be removed in a future
version.
The names NPROCESSORS_CONF and NPROCESSORS_ONLN. The values of these configuration variables shall be determined as if they were
obtained by calling the function sysconf() with the argument _SC_NPROCESSORS_CONF or
_SC_NPROCESSORS_ONLN, respectively.
The names of the symbolic constants used as the name argument of the confstr() function in the System Interfaces volume of POSIX.1-2024, without the _CS_
prefix.
The names of the symbolic constants listed under the headings "Maximum Values" and "Minimum Values" in the description of
the  header in the Base Definitions volume of POSIX.1-2024, without
the enclosing braces.
For compatibility with earlier versions, the following variable names shall also be supported: POSIX2_BC_BASE_MAX
POSIX2_BC_DIM_MAX POSIX2_BC_SCALE_MAX POSIX2_BC_STRING_MAX POSIX2_COLL_WEIGHTS_MAX POSIX2_EXPR_NEST_MAX POSIX2_LINE_MAX
POSIX2_RE_DUP_MAX
and shall be equivalent to the same name prefixed with an . This requirement may be removed in a future
version.
The implementation may add other local values.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of getconf:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
If the specified variable is defined on the system and its value is described to be available from the confstr() function defined in the System Interfaces volume of POSIX.1-2024, its value shall
be written in the following format:
"%s\n",
Otherwise, if the specified variable is defined on the system, its value shall be written in the following format:
"%d\n",
If the specified variable is valid, but is undefined on the system, getconf shall write using the following format:
"undefined\n"
If the variable name is invalid or an error occurs, nothing shall be written to standard output.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
The specified variable is valid and information about its current state was written successfully.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
None.
EXAMPLES
The following example illustrates the value of {NGROUPS_MAX}:
getconf NGROUPS_MAX
The following example illustrates the value of {NAME_MAX} for a specific directory:
getconf NAME_MAX /usr
The following example shows how to deal more carefully with results that might be unspecified:
if value=$(getconf PATH_MAX /usr); then
if [ "$value" = "undefined" ]; then
echo PATH_MAX in /usr is indeterminate.
else
echo PATH_MAX in /usr is $value.
fi
else
echo Error in getconf.
fi
RATIONALE
The original need for this utility, and for the confstr() function, was to
provide a way of finding the configuration-defined default value for the PATH environment variable. Since PATH can be
modified by the user to include directories that could contain utilities replacing the standard utilities, shell scripts need a way
to determine the system-supplied PATH environment variable value that contains the correct search path for the standard
utilities. It was later suggested that access to the other variables described in this volume of POSIX.1-2024 could also be useful
to applications.
This functionality of getconf would not be adequately subsumed by another command such as:
grep var /etc/conf
because such a strategy would provide correct values for neither those variables that can vary at runtime, nor those that can
vary depending on the path.
Early proposal versions of getconf specified exit status 1 when the specified variable was valid, but not defined on the
system. The output string "undefined" is now used to specify this case with exit code 0 because so many things depend on
an exit code of zero when an invoked utility is successful.
FUTURE DIRECTIONS
None.
SEE ALSO
c17
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines,
XSH confstr(), fpathconf(),
sysconf(), system()
CHANGE HISTORY
First released in Issue 4.
Issue 5
In the OPERANDS section:
{NL_MAX} is changed to {NL_NMAX}.
Entries beginning NL_ are deleted from the list of standard configuration variables.
The list of variables previously marked UX is merged with the list marked EX.
Operands are added to support new Option Groups.
Operands are added so that getconf can determine supported programming environments.
Issue 6
The Open Group Corrigendum U029/4 is applied, correcting the example command in the last paragraph of the OPTIONS section.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
Operands are added to determine supported programming environments.
This reference page is updated for alignment with the ISO/IEC 9899:1999 standard. Specifically, new macros for c99
programming environments are introduced.
XSI marked system_var (XBS5_*) values are marked LEGACY.
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/27 is applied, correcting the descriptions of path_var
and system_var in the OPERANDS section.
Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
The EXAMPLES section is corrected.
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0091 [125] is applied.
Issue 8
Austin Group Defect 339 is applied, adding the system_var names NPROCESSORS_CONF and NPROCESSORS_ONLN.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
Austin Group Defect 1330 is applied, removing obsolescent interfaces and changing "_V7_" to "_V8_".
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/stty.html =====
stty
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
stty — set the options for a terminal
SYNOPSIS
stty [-a|-g]
stty operand...
DESCRIPTION
The stty utility shall set or report on terminal I/O characteristics for the device that is its standard input. Without
options or operands specified, it shall report the settings of certain characteristics, usually those that differ from
implementation-defined defaults. Otherwise, it shall modify the terminal state according to the specified operands. Detailed
information about the modes listed in the first five groups below are described in XBD 11. General Terminal Interface. Operands in the Combination Modes group (see
Combination Modes) are implemented using operands in the previous groups. Some combinations of
operands are mutually-exclusive on some terminal types; the results of using such combinations are unspecified.
Typical implementations of this utility require a communications line configured to use the termios interface defined in
the System Interfaces volume of POSIX.1-2024. On systems where none of these lines are available, and on lines not currently
configured to support the termios interface, some of the operands need not affect terminal characteristics.
OPTIONS
The stty utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following options shall be supported:
-a
Write to standard output all the current settings for the terminal.
-g
Write to standard output all the current settings, optionally excluding the terminal window size, in an unspecified form that,
when stripped of trailing  characters, and used as the one and only argument to another invocation of the
stty utility on the same system, attempts to apply those settings to the terminal. The form used shall not contain any
sequence that would form an Informational Query, and shall consist of one line of text consisting of only printable characters from
the portable character set, excluding white-space characters (other than the terminating ) and these characters that
could be altered by pathname expansion performed by the shell: '*', '?', and '['.
OPERANDS
The following operands shall be supported.
Control Modes
parenb (-parenb)
Enable (disable) parity generation and detection. This shall have the effect of setting (not setting) PARENB in the
termios c_cflag field, as defined in XBD 11. General Terminal
Interface.
parodd (-parodd)
Select odd (even) parity. This shall have the effect of setting (not setting) PARODD in the termios c_cflag field, as
defined in XBD 11. General Terminal Interface.
cs5 cs6 cs7 cs8
Select character size, if possible. This shall have the effect of setting CS5, CS6, CS7, and CS8, respectively, in the
termios c_cflag field, as defined in XBD 11. General Terminal
Interface.
number
Set terminal baud rate to the number given, if possible. If the baud rate is set to zero, the modem control lines shall no
longer be asserted. This shall have the effect of setting the input and output termios baud rate values as defined in XBD
11. General Terminal Interface.
ispeed number
Set terminal input baud rate to the number given, if possible. If the input baud rate is set to zero, the input baud rate shall
be specified by the value of the output baud rate. This shall have the effect of setting the input termios baud rate value
as defined in XBD 11. General Terminal Interface.
ospeed number
Set terminal output baud rate to the number given, if possible. If the output baud rate is set to zero, the modem control lines
shall no longer be asserted. This shall have the effect of setting the output termios baud rate value as defined in XBD
11. General Terminal Interface.
hupcl (-hupcl)
Stop asserting modem control lines (do not stop asserting modem control lines) on last close. This shall have the effect of
setting (not setting) HUPCL in the termios c_cflag field, as defined in XBD 11. General Terminal Interface.
hup (-hup)
Equivalent to hupcl(-hupcl).
cstopb (-cstopb)
Use two (one) stop bits per character. This shall have the effect of setting (not setting) CSTOPB in the termios
c_cflag field, as defined in XBD 11. General Terminal Interface
.
cread (-cread)
Enable (disable) the receiver. This shall have the effect of setting (not setting) CREAD in the termios c_cflag
field, as defined in XBD 11. General Terminal Interface.
clocal (-clocal)
Assume a line without (with) modem control. This shall have the effect of setting (not setting) CLOCAL in the termios
c_cflag field, as defined in XBD 11. General Terminal Interface
.
It is unspecified whether stty shall report an error if an attempt to set a Control Mode fails.
Input Modes
ignbrk (-ignbrk)
Ignore (do not ignore) break on input. This shall have the effect of setting (not setting) IGNBRK in the termios
c_iflag field, as defined in XBD 11. General Terminal Interface
.
brkint (-brkint)
Signal (do not signal) INTR on break. This shall have the effect of setting (not setting) BRKINT in the termios
c_iflag field, as defined in XBD 11. General Terminal Interface
.
ignpar (-ignpar)
Ignore (do not ignore) bytes with parity errors. This shall have the effect of setting (not setting) IGNPAR in the
termios c_iflag field, as defined in XBD 11. General Terminal
Interface.
parmrk (-parmrk)
Mark (do not mark) parity errors. This shall have the effect of setting (not setting) PARMRK in the termios c_iflag
field, as defined in XBD 11. General Terminal Interface.
inpck (-inpck)
Enable (disable) input parity checking. This shall have the effect of setting (not setting) INPCK in the termios
c_iflag field, as defined in XBD 11. General Terminal Interface
.
istrip (-istrip)
Strip (do not strip) input characters to seven bits. This shall have the effect of setting (not setting) ISTRIP in the
termios c_iflag field, as defined in XBD 11. General Terminal
Interface.
inlcr (-inlcr)
Map (do not map) NL to CR on input. This shall have the effect of setting (not setting) INLCR in the termios
c_iflag field, as defined in XBD 11. General Terminal Interface
.
igncr (-igncr)
Ignore (do not ignore) CR on input. This shall have the effect of setting (not setting) IGNCR in the termios
c_iflag field, as defined in XBD 11. General Terminal Interface
.
icrnl (-icrnl)
Map (do not map) CR to NL on input. This shall have the effect of setting (not setting) ICRNL in the termios
c_iflag field, as defined in XBD 11. General Terminal Interface
.
ixon (-ixon)
Enable (disable) START/STOP output control. Output from the system is stopped when the system receives STOP and started when
the system receives START. This shall have the effect of setting (not setting) IXON in the termios c_iflag field, as
defined in XBD 11. General Terminal Interface.
ixany (-ixany)
Allow any character to restart output. This shall have the effect of setting (not setting) IXANY in the termios
c_iflag field, as defined in XBD 11. General Terminal Interface
.
ixoff (-ixoff)
Request that the system send (not send) STOP characters when the input queue is nearly full and START characters to resume data
transmission. This shall have the effect of setting (not setting) IXOFF in the termios c_iflag field, as defined in
XBD 11. General Terminal Interface.
Output Modes
opost (-opost)
Post-process output (do not post-process output; ignore all other output modes). This shall have the effect of setting (not
setting) OPOST in the termios c_oflag field, as defined in XBD 11.
General Terminal Interface.
onlcr (-onlcr)
[XSI]
Map (do not map) NL to CR-NL on output. This shall have the effect of setting (not setting) ONLCR in the termios
c_oflag field, as defined in XBD 11. General Terminal Interface.
ocrnl (-ocrnl)
[XSI]
Map (do not map) CR to NL on output. This shall have the effect of setting (not setting) OCRNL in the termios c_oflag
field, as defined in XBD 11. General Terminal Interface.
onocr (-onocr)
[XSI]
Do not (do) output CR at column zero. This shall have the effect of setting (not setting) ONOCR in the termios
c_oflag field, as defined in XBD 11. General Terminal Interface.
onlret (-onlret)
[XSI]
The terminal newline key performs (does not perform) the CR function. This shall have the effect of setting (not setting) ONLRET in
the termios c_oflag field, as defined in XBD 11. General Terminal
Interface.
ofill (-ofill)
[XSI]
Use fill characters (use timing) for delays. This shall have the effect of setting (not setting) OFILL in the termios
c_oflag field, as defined in XBD 11. General Terminal Interface.
ofdel (-ofdel)
[XSI]
Fill characters are DELs (NULs). This shall have the effect of setting (not setting) OFDEL in the termios c_oflag
field, as defined in XBD 11. General Terminal Interface.
cr0 cr1 cr2 cr3
[XSI]
Select the style of delay for CRs. This shall have the effect of setting CRDLY to CR0, CR1, CR2, or CR3, respectively, in the
termios c_oflag field, as defined in XBD 11. General Terminal
Interface.
nl0 nl1
[XSI]
Select the style of delay for NL. This shall have the effect of setting NLDLY to NL0 or NL1, respectively, in the termios
c_oflag field, as defined in XBD 11. General Terminal Interface.
tab0 tab1 tab2 tab3
[XSI]
Select the style of delay for horizontal tabs. This shall have the effect of setting TABDLY to TAB0, TAB1, TAB2, or TAB3,
respectively, in the termios c_oflag field, as defined in XBD 11.
General Terminal Interface. Note that TAB3 has the effect of expanding  characters to  characters.
tabs (-tabs)
[XSI]
Synonym for tab0 (tab3).
bs0 bs1
[XSI]
Select the style of delay for  characters. This shall have the effect of setting BSDLY to BS0 or BS1,
respectively, in the termios c_oflag field, as defined in XBD 11.
General Terminal Interface.
ff0 ff1
[XSI]
Select the style of delay for  characters. This shall have the effect of setting FFDLY to FF0 or FF1,
respectively, in the termios c_oflag field, as defined in XBD 11.
General Terminal Interface.
vt0 vt1
[XSI]
Select the style of delay for  characters. This shall have the effect of setting VTDLY to VT0 or VT1,
respectively, in the termios c_oflag field, as defined in XBD 11.
General Terminal Interface.
Local Modes
isig (-isig)
Enable (disable) the checking of characters against the special control characters INTR, QUIT, and SUSP. This shall have the
effect of setting (not setting) ISIG in the termios c_lflag field, as defined in XBD 11. General Terminal Interface.
icanon (-icanon)
Enable (disable) canonical input (ERASE and KILL processing). This shall have the effect of setting (not setting) ICANON in the
termios c_lflag field, as defined in XBD 11. General Terminal
Interface.
iexten (-iexten)
Enable (disable) any implementation-defined special control characters not currently controlled by icanon, isig,
ixon, or ixoff. This shall have the effect of setting (not setting) IEXTEN in the termios c_lflag
field, as defined in XBD 11. General Terminal Interface.
echo (-echo)
Echo back (do not echo back) every character typed. This shall have the effect of setting (not setting) ECHO in the
termios c_lflag field, as defined in XBD 11. General Terminal
Interface.
echoe (-echoe)
The ERASE character visually erases (does not erase) the last character in the current line from the display, if possible. This
shall have the effect of setting (not setting) ECHOE in the termios c_lflag field, as defined in XBD 11. General Terminal Interface.
echok (-echok)
Echo (do not echo) NL after KILL character. This shall have the effect of setting (not setting) ECHOK in the termios
c_lflag field, as defined in XBD 11. General Terminal Interface
.
echonl (-echonl)
Echo (do not echo) NL, even if echo is disabled. This shall have the effect of setting (not setting) ECHONL in the
termios c_lflag field, as defined in XBD 11. General Terminal
Interface.
noflsh (-noflsh)
Disable (enable) flush after INTR, QUIT, SUSP. This shall have the effect of setting (not setting) NOFLSH in the termios
c_lflag field, as defined in XBD 11. General Terminal Interface
.
tostop (-tostop)
Send SIGTTOU for background output. This shall have the effect of setting (not setting) TOSTOP in the termios
c_lflag field, as defined in XBD 11. General Terminal Interface
.
Special Control Character Assignments
-character string
Set -character to string. If -character is one of the character
sequences in the first column of the following table, the corresponding XBD 11.
General Terminal Interface control character from the second column shall be recognized. This has the effect of setting the
corresponding element of the termios c_cc array (see XBD 14.
Headers, ).
Table: Control Character Names in stty
Control Character
c_cc Subscript
Description
eof
VEOF
EOF character
eol
VEOL
EOL character
erase
VERASE
ERASE character
intr
VINTR
INTR character
kill
VKILL
KILL character
quit
VQUIT
QUIT character
susp
VSUSP
SUSP character
start
VSTART
START character
stop
VSTOP
STOP character
If string is a single character, the control character shall be set to that character. If string is
the two-character sequence "^-" or the string undef, the control character shall be set to _POSIX_VDISABLE , if it
is in effect for the device; if _POSIX_VDISABLE is not in effect for the device, it shall be treated as an error. In the POSIX
locale, if string is a two-character sequence beginning with  ('^'), and the second character is
one of those listed in the "^c" column of the following table, the control character shall be set to the corresponding
character value in the Value column of the table.
Table: Circumflex Control Characters in stty
^c
Value
^c
Value
^c
Value
a, A
l, L
w, W
b, B
m, M
x, X
c, C
n, N
y, Y
d, D
o, O
z, Z
e, E
p, P
[
f, F
q, Q
\
g, G
r, R
]
h, H
s, S
^
i, I
t, T
_
j, J
u, U
?
k, K
v, V
min number
Set the value of MIN to number. MIN is used in non-canonical mode input processing (-icanon).
time number
Set the value of TIME to number. TIME is used in non-canonical mode input processing (-icanon).
Combination Modes
saved settings
Set the current terminal characteristics to the saved settings produced by the -g option.
evenp or parity
Enable parenb and cs7; disable parodd.
oddp
Enable parenb, cs7, and parodd.
-parity, -evenp, or -oddp
Disable parenb, and set cs8.
raw (-raw or cooked)
[XSI]
Enable (disable) raw input and output. Raw mode shall be equivalent to setting:
stty cs8 erase ^- kill ^- intr ^- \
quit ^- eof ^- eol ^- -post -inpck
nl (-nl)
Disable (enable) icrnl. In addition, -nl unsets inlcr and igncr.
ek
Reset ERASE and KILL characters back to system defaults.
sane
Reset all modes to some reasonable, unspecified, values.
Terminal Window Size
rows number
Set the number of rows in the terminal window size to the number given.
cols number
Set the number of columns in the terminal window size to the number given.
The terminal window size shall be updated as if the stty utility calls tcgetwinsize() to populate a winsize structure, updates one or both of the
ws_row and ws_col members according to the rows and cols numbers specified, and then calls tcsetwinsize() with the updated structure (see XSH tcgetwinsize() and tcsetwinsize()
).
Informational Queries
size
Write the current terminal window size to standard output.
STDIN
Although no input is read from standard input, standard input shall be used to get the current terminal I/O characteristics and
to set new terminal I/O characteristics.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of stty:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
This variable determines the locale for the interpretation of sequences of bytes of text data as characters (for example,
single-byte as opposed to multi-byte characters in arguments) and which characters are in the class print.
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
If operands are specified and they do not include any Informational Queries, no output shall be produced.
If the size operand is specified, stty shall write to standard output the terminal window size as
follows:
"%1dΔ%1d\n", ,
where  and  are the number of rows and columns in the terminal window size, respectively.
If the -g option is specified, stty shall write to standard output the current settings in a form
that can be used as arguments to another instance of stty on the same system.
If the -a option is specified, all of the information as described in the OPERANDS section shall be written
to standard output. Unless otherwise specified, this information shall be written as -separated tokens in an
unspecified format, on one or more lines, with an unspecified number of tokens per line. Additional information may be written.
If no options or operands are specified, an unspecified subset of the information written for the -a option
shall be written.
If speed information is written as part of the default output, or if the -a option is specified and if the
terminal input speed and output speed are the same, the speed information shall be written as follows:
"speed %d baud;",
Otherwise, speeds shall be written as:
"ispeed %d baud; ospeed %d baud;", ,
In locales other than the POSIX locale, the word baud may be changed to something more appropriate in those
locales.
If control characters are written as part of the default output, or if the -a option is specified, control
characters shall be written as:
"%s = %s;", ,
where  is either the character, or some visual representation of the character if it is
non-printable, or the string "" if the character is disabled.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
The -g flag is designed to facilitate the saving and restoring of terminal state from the shell level. For example, a
program may:
saveterm=$(stty -g)                      # save terminal state
restoresize=$(
printf "stty rows %d cols %d" $(stty size)
)                                        # save terminal size
stty new settings                        # set new state
...
[ -n "$saveterm" ] && stty "$saveterm"   # restore terminal state
eval "$restoresize"                      # restore terminal size
Since the format is unspecified, the saved value is not portable across systems.
Since the -a format is so loosely specified, scripts that save and restore terminal settings should use the
-g option.
EXAMPLES
None.
RATIONALE
The original stty description was taken directly from System V and reflected the System V terminal driver termio.
It has been modified to correspond to the terminal driver termios.
Output modes are specified only for XSI-conformant systems. All implementations are expected to provide stty
operands corresponding to all of the output modes they support.
The stty utility is primarily used to tailor the user interface of the terminal, such as selecting the
preferred ERASE and KILL characters. As an application programming utility, stty can be used within shell scripts to alter
the terminal settings for the duration of the script.
The termios section states that individual disabling of control characters is possible through the option
_POSIX_VDISABLE. If enabled, two conventions currently exist for specifying this: System V uses "^-", and BSD uses
undef. Both are accepted by stty in this volume of POSIX.1-2024. The other BSD convention of using the letter
'u' was rejected because it conflicts with the actual letter 'u', which is an acceptable value for a control
character.
Early proposals did not specify the mapping of "^c" to control characters because the control characters
were not specified in the POSIX locale character set description file requirements. The control character set is now specified in
XBD 3. Definitions, so the historical mapping is specified. Note that
although the mapping corresponds to control-character key assignments on many terminals that use the ISO/IEC 646:1991 standard
(or ASCII) character encodings, the mapping specified here is to the control characters, not their keyboard encodings.
Since termios supports separate speeds for input and output, two new options were added to specify each
distinctly.
Some historical implementations use standard input to get and set terminal characteristics; others use standard
output. Since input from a login TTY is usually restricted to the owner while output to a TTY is frequently open to anyone, using
standard input provides fewer chances of accidentally (or maliciously) altering the terminal settings of other users. Using
standard input also allows stty -a and stty -g output to be redirected for later use. Therefore, usage
of standard input is required by this volume of POSIX.1-2024.
FUTURE DIRECTIONS
None.
SEE ALSO
2. Shell Command Language
XBD 8. Environment Variables, 11. General Terminal Interface, 12.2 Utility Syntax Guidelines,
CHANGE HISTORY
First released in Issue 2.
Issue 5
The description of tabs is clarified.
The FUTURE DIRECTIONS section is added.
Issue 6
The LEGACY items iuclc (-iuclc), xcase (-xcase), olcuc (-olcuc), lcase
(-lcase), and LCASE (-LCASE) are removed.
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/37 is applied, applying IEEE PASC Interpretation
1003.2 #133, fixing an error in the OPERANDS section for the Combination Modes nl (-nl).
Issue 7
Austin Group Interpretation 1003.1-2001 #144 is applied, moving functionality relating to the IXANY symbol from the XSI option
to the Base.
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0189 [908] is applied.
Issue 8
Austin Group Defects 1053, 1532, and 1687 are applied, changing the -g option and adding the rows number,
cols number, and size operands.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
Austin Group Defect 1508 is applied, changing the EXIT STATUS section.
Austin Group Defect 1604 is applied, changing undef to "" in the STDOUT section, and
changing icanon to -icanon in the descriptions of min and time.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/rmdel.html =====
rmdel
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
rmdel — remove a delta from an SCCS file (DEVELOPMENT)
SYNOPSIS
[XSI]  rmdel -r SID file...
DESCRIPTION
The rmdel utility shall remove the delta specified by the SID from each named SCCS file. The delta to be removed shall be
the most recent delta in its branch in the delta chain of each named SCCS file. In addition, the application shall ensure that the
SID specified is not that of a version being edited for the purpose of making a delta; that is, if a p-file (see get) exists for the named SCCS file, the SID specified shall not appear in any entry of the
p-file.
Removal of a delta shall be restricted to:
The user who made the delta
The owner of the SCCS file
The owner of the directory containing the SCCS file
OPTIONS
The rmdel utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following option shall be supported:
-r SID
Specify the SCCS identification string (SID) of the delta to be deleted.
OPERANDS
The following operand shall be supported:
file
A pathname of an existing SCCS file or a directory. If file is a directory, the rmdel utility shall behave as
though each file in the directory were specified as a named file, except that non-SCCS files (last component of the pathname does
not begin with s.) and unreadable files shall be silently ignored.
If exactly one file operand appears, and it is '-', the standard input shall be read; each line of the standard
input is taken to be the name of an SCCS file to be processed. Non-SCCS files and unreadable files shall be silently ignored.
STDIN
The standard input shall be a text file used only when the file operand is specified as '-'. Each line of the
text file shall be interpreted as an SCCS pathname.
INPUT FILES
The SCCS files shall be files of unspecified format.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of rmdel:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
Not used.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
The SCCS files shall be files of unspecified format. During processing of a file, a temporary x-file, as described
in admin, may be created and deleted; a locking z-file, as described in
get, may be created and deleted.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
None.
EXAMPLES
None.
RATIONALE
None.
FUTURE DIRECTIONS
If this utility is directed to create a new directory entry that contains any bytes that have the encoded value of a
character, implementations are encouraged to treat this as an error. A future version of this standard may require
implementations to treat this as an error.
SEE ALSO
admin, delta, get, prs
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 2.
Issue 6
The normative text is reworded to avoid use of the term "must" for application requirements.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to disallow the creation of filenames containing any bytes that
have the encoded value of a  character.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/grep.html =====
grep
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
grep — search a file for a pattern
SYNOPSIS
grep [-E|-F] [-c|-l|-q] [-insvx] -e
pattern_list        [-e pattern_list]...
[-f pattern_file]... [file...]
grep [-E|-F] [-c|-l|-q] [-insvx] [-e
pattern_list]...        -f pattern_file
[-f pattern_file]... [file...]
grep [-E|-F] [-c|-l|-q] [-insvx] pattern_list
[file...]
DESCRIPTION
The grep utility shall search the input files, selecting lines matching one or more patterns; the types of patterns are
controlled by the options specified. The patterns are specified by the -e option, -f option, or the
pattern_list operand. The pattern_list's value shall consist of one or more patterns separated by
characters; the pattern_file's contents shall consist of one or more patterns terminated by a  character. By
default, an input line shall be selected if any pattern, treated as an entire basic regular expression (BRE) as described in XBD
9.3 Basic Regular Expressions, matches any part of the line excluding
the terminating ; a null BRE shall match every line. By default, each selected input line shall be written to the
standard output.
Regular expression matching shall be based on text lines. Since a  separates or terminates patterns (see the
-e and -f options below), regular expressions cannot contain a . Similarly, since patterns are matched
against individual lines (excluding the terminating  characters) of the input, there is no way for a pattern to
match a  found in the input.
OPTIONS
The grep utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following options shall be supported:
-E
Match using extended regular expressions. Treat each pattern specified as an ERE, as described in XBD 9.4 Extended Regular Expressions. If any entire ERE pattern matches some part of
an input line excluding the terminating , the line shall be matched. A null ERE shall match every line.
-F
Match using fixed strings. Treat each pattern specified as a string instead of a regular expression. If an input line contains
any of the patterns as a contiguous sequence of bytes, the line shall be matched. A null string shall match every line.
-c
Write only a count of selected lines to standard output.
-e pattern_list
Specify one or more patterns to be used during the search for input. The application shall ensure that patterns in
pattern_list are separated by a . A null pattern can be specified by two adjacent  characters
in pattern_list. Unless the -E or -F option is also specified, each pattern shall be treated as a BRE, as
described in XBD 9.3 Basic Regular Expressions. Multiple -e and
-f options shall be accepted by the grep utility. All of the specified patterns shall be used when matching lines,
but the order of evaluation is unspecified.
-f pattern_file
Read one or more patterns from the file named by the pathname pattern_file. Patterns in pattern_file shall be
terminated by a . A null pattern can be specified by an empty line in pattern_file. Unless the -E or
-F option is also specified, each pattern shall be treated as a BRE, as described in XBD 9.3 Basic Regular Expressions.
-i
Perform pattern matching in a case-insensitive manner; see XBD 9.2 Regular
Expression General Requirements.
-l
(The letter ell.) Write only the names of files containing selected lines to standard output. Pathnames shall be written once
per file searched. If the standard input is searched, a pathname of "(standard input)" shall be written, in the POSIX
locale. In other locales, "standard input" may be replaced by something more appropriate in those locales.
-n
Precede each output line by its relative line number in the file, each file starting at line 1. The line number counter shall
be reset for each file processed.
-q
Quiet. Nothing shall be written to the standard output, regardless of matching lines. Exit with zero status if an input line is
selected.
-s
Suppress the error messages ordinarily written for nonexistent or unreadable files. Other error messages shall not be
suppressed.
-v
Select lines not matching any of the specified patterns. If the -v option is not specified, selected lines shall be
those that match any of the specified patterns.
-x
Consider only input lines that use all characters in the line excluding the terminating  to match an entire
fixed string or regular expression to be matching lines.
OPERANDS
The following operands shall be supported:
pattern_list
Specify one or more patterns to be used during the search for input. This operand shall be treated as if it were specified as
-e pattern_list.
file
A pathname of a file to be searched for the patterns. If no file operands are specified, the standard input shall be
used.
STDIN
The standard input shall be used if no file operands are specified, and shall be used if a file operand is
'-' and the implementation treats the '-' as meaning standard input. Otherwise, the standard input shall not be
used. See the INPUT FILES section.
INPUT FILES
The input files shall be text files.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of grep:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_COLLATE
Determine the locale for the behavior of ranges, equivalence classes, and multi-character collating elements within regular
expressions.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files) and the behavior of character classes within regular
expressions.
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
If the -l option is in effect, the following shall be written for each file containing at least one selected input
line:
"%s\n",
Otherwise, if more than one file argument appears, and -q is not specified, the grep utility shall prefix
each output line by:
"%s:",
The remainder of each output line shall depend on the other options specified:
If the -c option is in effect, the remainder of each output line shall contain:
"%d\n",
Otherwise, if -c is not in effect and the -n option is in effect, the following shall be written to standard
output:
"%d:",
Finally, the following shall be written to standard output:
"%s",
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
One or more lines were selected and the output specified in STDOUT was successfully written to standard output.
1
No lines were selected.
>1
An error occurred.
CONSEQUENCES OF ERRORS
If the -q option is specified, the exit status shall be zero if an input line is selected, even if an error was detected.
Otherwise, default actions shall be performed.
The following sections are informative.
APPLICATION USAGE
Care should be taken when using characters in pattern_list that may also be meaningful to the command interpreter. It is
safest to enclose the entire pattern_list argument in single-quotes:
'...'
The -e pattern_list option has the same effect as the pattern_list operand, but is useful when
pattern_list begins with the  delimiter. It is also useful when it is more convenient to provide
multiple patterns as separate arguments.
Multiple -e and -f options are accepted and grep uses all of the patterns it is given while matching input
text lines. (Note that the order of evaluation is not specified. If an implementation finds a null string as a pattern, it is
allowed to use that pattern first, matching every line, and effectively ignore any other patterns.)
The -q option provides a means of easily determining whether or not a pattern (or string) exists in a group of files.
When searching several files, it provides a performance improvement (because it can quit as soon as it finds the first match) and
requires less care by the user in choosing the set of files to supply as arguments (because it exits zero if it finds a match even
if grep detected an access or read error on earlier file operands).
When using grep to process pathnames, it is recommended that LC_ALL, or at least LC_CTYPE and LC_COLLATE, are set to
POSIX or C in the environment, since pathnames can contain byte sequences that do not form valid characters in some locales, in
which case the utility's behavior would be undefined. In the POSIX locale each byte is a valid single-byte character, and therefore
this problem is avoided.
EXAMPLES
To find all uses of the word "Posix" (in any case) in file text.mm and write with line numbers:
grep -i -n posix text.mm
To find all empty lines in the standard input:
grep ^$
or:
grep -v .
Both of the following commands print all lines containing strings "abc" or "def" or both:
grep -E 'abc|def'
grep -F 'abc
def'
Both of the following commands print all lines matching exactly "abc" or "def":
grep -E '^abc$|^def$'
grep -F -x 'abc
def'
RATIONALE
This grep has been enhanced in an upwards-compatible way to provide the exact functionality of the historical
egrep and fgrep commands as well. It was the clear intention of the standard developers to consolidate the three
greps into a single command.
The old egrep and fgrep commands are likely to be supported for many years to come as implementation extensions,
allowing historical applications to operate unmodified.
Historical implementations usually silently ignored all but one of multiply-specified -e and -f options, but were
not consistent as to which specification was actually used.
The -b option was omitted from the OPTIONS section because block numbers are implementation-defined.
The System V restriction on using - to mean standard input was omitted.
A definition of action taken when given a null BRE or ERE is specified. This is an error condition in some historical
implementations.
The -l option previously indicated that its use was undefined when no files were explicitly named. This behavior was
historical and placed an unnecessary restriction on future implementations. It has been removed.
The historical BSD grep -s option practice is easily duplicated by redirecting standard output to
/dev/null. The -s option required here is from System V.
The -x option, historically available only with fgrep, is available here for all of the non-obsolescent
versions.
FUTURE DIRECTIONS
If this utility is directed to display a pathname that contains any bytes that have the encoded value of a
character when  is a terminator or separator in the output format being used, implementations are encouraged to
treat this as an error. A future version of this standard may require implementations to treat this as an error.
SEE ALSO
sed
XBD 8. Environment Variables, 9. Regular Expressions, 12.2
Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 2.
Issue 6
The Open Group Corrigendum U029/5 is applied, correcting the SYNOPSIS.
The normative text is reworded to avoid use of the term "must" for application requirements.
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/28 is applied, correcting the examples using the grep
-F option which did not match the normative description of the -F option.
Issue 7
Austin Group Interpretation 1003.1-2001 #092 is applied.
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
SD5-XCU-ERN-98 is applied, updating the STDOUT section.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0105 [584] and XCU/TC2-2008/0106 [663] are applied.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to report an error if a utility is directed to display a
pathname that contains any bytes that have the encoded value of a  character when  is a terminator or
separator in the output format being used.
Austin Group Defect 1031 is applied, changing the description of the -i option.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
Austin Group Defect 1502 is applied, changing the EXIT STATUS section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/mkdir.html =====
mkdir
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
mkdir — make directories
SYNOPSIS
mkdir [-p] [-m mode] dir...
DESCRIPTION
The mkdir utility shall create the directories specified by the operands, in the order specified.
For each dir operand, the mkdir utility shall perform actions equivalent to the mkdir() function defined in the System Interfaces volume of POSIX.1-2024, called with the
following arguments:
The dir operand is used as the path argument.
The value of the bitwise-inclusive OR of S_IRWXU, S_IRWXG, and S_IRWXO is used as the mode argument. (If the -m
option is specified, the value of the mkdir() mode argument is unspecified, but
the directory shall at no time have permissions less restrictive than the -m mode option-argument.)
OPTIONS
The mkdir utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following options shall be supported:
-m mode
Set the file permission bits of the newly-created directory to the specified mode value. The mode option-argument
shall be the same as the mode operand defined for the chmod utility. In the
symbolic_mode strings, the op characters '+' and '-' shall be interpreted relative to an assumed
initial mode of a=rwx; '+' shall add permissions to the default mode, '-' shall delete permissions
from the default mode.
-p
Create any missing intermediate pathname components.
For each dir operand that does not name an existing directory, before performing the actions described in the DESCRIPTION
above, the mkdir utility shall create any pathname components of the path prefix of dir that do not name an existing
directory by performing actions equivalent to first calling the mkdir() function with
the following arguments:
A pathname naming the missing pathname component, ending with a trailing  character, as the path
argument
The value zero as the mode argument
and then calling the chmod() function with the following arguments:
The same path argument as in the mkdir() call
The value (S_IWUSR|S_IXUSR|~filemask)&0777 as the mode argument, where filemask is the file
mode creation mask of the process (see XSH umask())
Each dir operand that names an existing directory shall be ignored without error.
OPERANDS
The following operand shall be supported:
dir
A pathname of a directory to be created.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of mkdir:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
Not used.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
All the specified directories were created successfully, or the -p option was specified and all the specified
directories either already existed or were created successfully.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
The default file mode for directories is a=rwx (777 on most systems) with selected permissions removed in
accordance with the file mode creation mask. For intermediate pathname components created by mkdir, the mode is the default
modified by u+wx so that the subdirectories can always be created regardless of the file mode creation mask; if
different ultimate permissions are desired for the intermediate directories, they can be changed afterwards with chmod.
Note that some of the requested directories may have been created even if an error occurs.
EXAMPLES
None.
RATIONALE
The System V -m option was included to control the file mode.
The System V -p option was included to create any needed intermediate directories and to complement the functionality
provided by rmdir for removing directories in the path prefix as they become empty.
Because no error is produced if any path component already exists, the -p option is also useful to ensure that a particular
directory exists.
The functionality of mkdir is described substantially through a reference to the mkdir() function in the System Interfaces volume of POSIX.1-2024. For example, by default, the
mode of the directory is affected by the file mode creation mask in accordance with the specified behavior of the mkdir() function. In this way, there is less duplication of effort required for describing
details of the directory creation.
FUTURE DIRECTIONS
If this utility is directed to create a new directory entry that contains any bytes that have the encoded value of a
character, implementations are encouraged to treat this as an error. A future version of this standard may require
implementations to treat this as an error.
SEE ALSO
chmod, rm, rmdir, umask
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
XSH mkdir(), umask()
CHANGE HISTORY
First released in Issue 2.
Issue 5
The FUTURE DIRECTIONS section is added.
Issue 7
SD5-XCU-ERN-56 is applied, aligning the -m option with the IEEE P1003.2b draft standard to clarify an ambiguity.
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0122 [161] is applied.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0145 [843] is applied.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to disallow the creation of filenames containing any bytes that
have the encoded value of a  character.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/renice.html =====
renice
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
renice — set nice values of running processes
SYNOPSIS
renice [-g|-p|-u] -n increment ID...
DESCRIPTION
The renice utility shall request that the nice values (see XBD 3.225
Nice Value) of one or more running processes be changed. By default, the applicable processes are specified by their
process IDs. When a process group is specified (see -g), the request shall apply to all processes in the process group.
The nice value shall be bounded in an implementation-defined manner. If the requested increment would raise or lower the
nice value of the executed utility beyond implementation-defined limits, then the limit whose value was exceeded shall be used.
When a user is reniced, the request applies to all processes whose saved set-user-ID matches the user ID corresponding to
the user.
Regardless of which options are supplied or any other factor, renice shall not alter the nice values of any process
unless the user requesting such a change has appropriate privileges to do so for the specified process. If the user lacks
appropriate privileges to perform the requested action, the utility shall return an error status.
The saved set-user-ID of the user's process shall be checked instead of its effective user ID when renice attempts to
determine the user ID of the process in order to determine whether the user has appropriate privileges.
OPTIONS
The renice utility shall conform to XBD 12.2 Utility Syntax
Guidelines, except for Guideline 9.
The following options shall be supported:
-g
Interpret the following operands as unsigned decimal integer process group IDs.
-n increment
Specify how the nice value of the specified process or processes is to be adjusted. The increment option-argument is a
positive or negative decimal integer that shall be used to modify the nice value of the specified process or processes. Negative
increment values may require appropriate privileges.
-p
Interpret the following operands as unsigned decimal integer process IDs. The -p option is the default if no options are
specified.
-u
Interpret the following operands as users. If a user exists with a user name equal to the operand, then the user ID of that
user is used in further processing. Otherwise, if the operand represents an unsigned decimal integer, it shall be used as the
numeric user ID of the user.
OPERANDS
The following operands shall be supported:
ID
A process ID, process group ID, or user name/user ID, depending on the option selected.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of renice:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
Not used.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
None.
EXAMPLES
Adjust the nice value so that process IDs 987 and 32 would have a lower nice value:
renice -n 5 -p 987 32
Adjust the nice value so that group IDs 324 and 76 would have a higher nice value, if the user has appropriate privileges to do
so:
renice -n -4 -g 324 76
Adjust the nice value so that numeric user ID 8 and user sas would have a lower nice value:
renice -n 4 -u 8 sas
Useful nice value increments on historical systems include 19 or 20 (the affected processes run only when nothing else in the
system attempts to run) and any negative number (to make processes run faster).
RATIONALE
The gid, pid, and user specifications do not fit either the definition of operand or option-argument.
However, for clarity, they have been included in the OPTIONS section, rather than the OPERANDS section.
The definition of nice value is not intended to suggest that all processes in a system have priorities that are comparable.
Scheduling policy extensions such as the realtime priorities in the System Interfaces volume of POSIX.1-2024 make the notion of a
single underlying priority for all scheduling policies problematic. Some implementations may implement the nice-related features to affect all processes on the system, others to affect just the general
time-sharing activities implied by this volume of POSIX.1-2024, and others may have no effect at all. Because of the use of
"implementation-defined" in nice and renice, a wide range of implementation
strategies are possible.
Originally, this utility was written in the historical manner, using the term "nice value". This was always a point of concern
with users because it was never intuitively obvious what this meant. With a newer version of renice, which used the term
"system scheduling priority", it was hoped that novice users could better understand what this utility was meant to do. Also, it
would be easier to document what the utility was meant to do. Unfortunately, the addition of the POSIX realtime scheduling
capabilities introduced the concepts of process and thread scheduling priorities that were totally unaffected by the nice/renice utilities or the nice()/setpriority() functions. Continuing
to use the term "system scheduling priority" would have incorrectly suggested that these utilities and functions were indeed
affecting these realtime priorities. It was decided to revert to the historical term "nice value" to reference this unrelated
process attribute.
Although this utility has use by system administrators (and in fact appears in the system administration portion of the BSD
documentation), the standard developers considered that it was very useful for individual end users to control their own
processes.
Earlier versions of this standard allowed the following forms in the SYNOPSIS:
renice nice_value[-p] pid...[-g gid...][-p pid...][-u user...]
renice nice_value -g gid...[-g gid...]-p pid...][-u user...]
renice nice_value -u user...[-g gid...]-p pid...][-u user...]
These forms are no longer specified by POSIX.1-2024 but may be present in some implementations.
FUTURE DIRECTIONS
None.
SEE ALSO
nice
XBD 3.225 Nice Value, 8. Environment Variables, 12.2
Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 4.
Issue 5
In the SYNOPSIS, an ellipsis is added to the -u option in all three obsolescent forms.
Issue 6
This utility is marked as part of the User Portability Utilities option.
The APPLICATION USAGE section is added.
The obsolescent forms of the SYNOPSIS are removed.
Text previously conditional on POSIX_SAVED_IDS is mandatory in this version. This is a FIPS requirement.
Issue 7
Austin Group Interpretation 1003.1-2001 #027 is applied, clarifying that Guideline 9 of the Utility Syntax Guidelines does not
apply.
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
The renice utility is moved from the User Portability Utilities option to the Base. User Portability Utilities is now an
option for interactive utilities.
Issue 8
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
Austin Group Defect 1286 is applied, changing the description of the -n option.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/sccs.html =====
sccs
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sccs — front end for the SCCS subsystem (DEVELOPMENT)
SYNOPSIS
[XSI]  sccs [-r] [-d path] [-p
path] command [options...] [operands...]
DESCRIPTION
The sccs utility is a front end to the SCCS programs. It also includes the capability to run set-user-id to another user
to provide additional protection.
The sccs utility shall invoke the specified command with the specified options and operands. By
default, each of the operands shall be modified by prefixing it with the string "SCCS/s.".
The command can be the name of one of the SCCS utilities in this volume of POSIX.1-2024 (admin, delta, get, prs, rmdel, sact, unget, val, or what) or one of the pseudo-utilities listed in the EXTENDED DESCRIPTION section.
OPTIONS
The sccs utility shall conform to XBD 12.2 Utility Syntax
Guidelines, except that options operands are actually options to be passed to the utility named by command.
When the portion of the command:
command [options ... ] [operands ... ]
is considered, all of the pseudo-utilities used as command shall support the Utility Syntax Guidelines. Any of the other
SCCS utilities that can be invoked in this manner support the Guidelines to the extent indicated by their individual OPTIONS
sections.
The following options shall be supported preceding the command operand:
-d path
A pathname of a directory to be used as a root directory for the SCCS files. The default shall be the current directory. The
-d option shall take precedence over the PROJECTDIR variable. See -p.
-p path
A pathname of a directory in which the SCCS files are located. The default shall be the SCCS directory.
The -p option differs from the -d option in that the -d option-argument shall be prefixed to the entire
pathname and the -p option-argument shall be inserted before the final component of the pathname. For example:
sccs -d /x -p y get a/b
converts to:
get /x/a/y/s.b
This allows the creation of aliases such as:
alias syssccs="sccs -d /usr/src"
which is used as:
syssccs get cmd/who.c
-r
Invoke command with the real user ID of the process, not any effective user ID that the sccs utility is set to.
Certain commands (admin, check, clean, diffs, info,
rmdel, and tell) cannot be run set-user-ID by all users, since this would allow
anyone to change the authorizations. These commands are always run as the real user.
OPERANDS
The following operands shall be supported:
command
An SCCS utility name or the name of one of the pseudo-utilities listed in the EXTENDED DESCRIPTION section.
options
An option or option-argument to be passed to command.
operands
An operand to be passed to command.
STDIN
See the utility description for the specified command.
INPUT FILES
See the utility description for the specified command.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of sccs:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
Determine the location of messages objects and message catalogs.
PROJECTDIR
Provide a default value for the -d path option. If the value of PROJECTDIR begins with a , it
shall be considered an absolute pathname; otherwise, the value of PROJECTDIR is treated as a user name and that user's
initial working directory shall be examined for a subdirectory src or source. If such a directory is found, it shall
be used. Otherwise, the value shall be used as a relative pathname.
Additional environment variable effects may be found in the utility description for the specified command.
ASYNCHRONOUS EVENTS
Default.
STDOUT
See the utility description for the specified command.
STDERR
See the utility description for the specified command.
OUTPUT FILES
See the utility description for the specified command.
EXTENDED DESCRIPTION
The following pseudo-utilities shall be supported as command operands. All options referred to in the following list are
values given in the options operands following command.
check
Equivalent to info, except that nothing shall be printed if nothing is being edited, and a non-zero exit status shall be
returned if anything is being edited. The intent is to have this included in an "install" entry in a makefile to ensure that
everything is included into the SCCS file before a version is installed.
clean
Remove everything from the current directory that can be recreated from SCCS files, but do not remove any files being edited.
If the -b option is given, branches shall be ignored in the determination of whether they are being edited; this is
dangerous if branches are kept in the same directory.
create
Create an SCCS file, taking the initial contents from the file of the same name. Any options to admin are accepted. If the creation is successful, the original files shall be renamed by
prefixing the basenames with a comma. These renamed files should be removed after it has been verified that the SCCS files have
been created successfully.
delget
Perform a delta on the named files and then get new versions. The new versions shall have ID keywords expanded and shall not be editable.
Any -m, -p, -r, -s, and -y options shall be passed to delta, and any -b, -c, -e, -i, -k, -l, -s,
and -x options shall be passed to get.
deledit
Equivalent to delget, except that the get phase shall include the -e
option. This option is useful for making a checkpoint of the current editing phase. The same options shall be passed to delta as described above, and all the options listed for get above except -e shall be passed to edit.
diffs
Write a difference listing between the current version of the files checked out for editing and the versions in SCCS format.
Any -r, -c, -i, -x, and -t options shall be passed to get; any -l, -s, -e, -f, -h, and -b options shall be
passed to diff. A -C option shall be passed to diff as -c.
edit
Equivalent to get -e.
fix
Remove the named delta, but leave a copy of the delta with the changes that were in it. It is useful for fixing small compiler
bugs, and so on. The application shall ensure that it is followed by a -r SID option. Since fix does not leave
audit trails, it should be used carefully.
info
Write a listing of all files being edited. If the -b option is given, branches (that is, SIDs with two or fewer
components) shall be ignored. If a -u user option is given, then only files being edited by the named user shall be
listed. A -U option shall be equivalent to -u.
print
Write out verbose information about the named files, equivalent to sccs prs.
tell
Write a -separated list of the files being edited to standard output. Takes the -b, -u, and
-U options like info and check.
unedit
This is the opposite of an edit or a get -e. It should be used with
caution, since any changes made since the get are lost.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
Many of the SCCS utilities take directory names as operands as well as specific filenames. The pseudo-utilities supported by
sccs are not described as having this capability, but are not prohibited from doing so.
EXAMPLES
To get a file for editing, edit it and produce a new delta:
sccs get -e file.c
ex file.c
sccs delta file.c
To get a file from another directory:
sccs -p /usr/src/sccs/s. get cc.c
or:
sccs get /usr/src/sccs/s.cc.c
To make a delta of a large number of files in the current directory:
sccs delta *.c
To get a list of files being edited that are not on branches:
sccs info -b
To delta everything being edited by the current user:
sccs delta $(sccs tell -U)
In a makefile, to get source files from an SCCS file if it does not already exist:
SRCS =
$(SRCS):
sccs get $(REL) $@
RATIONALE
sccs and its associated utilities are part of the XSI Development Utilities option within the XSI option.
SCCS is an abbreviation for Source Code Control System. It is a maintenance and enhancement tracking tool. When a file is put
under SCCS, the source code control system maintains the file and, when changes are made, identifies and stores them in the file
with the original source code and/or documentation. As other changes are made, they too are identified and retained in the
file.
Retrieval of the original and any set of changes is possible. Any version of the file as it develops can be reconstructed for
inspection or additional modification. History data can be stored with each version, documenting why the changes were made, who
made them, and when they were made.
FUTURE DIRECTIONS
None.
SEE ALSO
admin, delta, get, make, prs, rmdel, sact, unget, val, what
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 4.
Issue 6
In the ENVIRONMENT VARIABLES section, the PROJECTDIR description is updated from "otherwise, the home directory of a
user of that name is examined" to "otherwise, the value of PROJECTDIR is treated as a user name and that user's initial
working directory is examined".
The normative text is reworded to avoid use of the term "must" for application requirements.
Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
Issue 8
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/tee.html =====
tee
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
tee — duplicate standard input
SYNOPSIS
tee [-ai] [file...]
DESCRIPTION
The tee utility shall copy standard input to standard output, making a copy in zero or more files. The tee utility
shall not buffer output.
If the -a option is not specified, output files shall be written (see 1.1.1.4 File Read, Write, and Creation).
OPTIONS
The tee utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following options shall be supported:
-a
Append the output to the files.
-i
Ignore the SIGINT signal.
OPERANDS
The following operands shall be supported:
file
A pathname of an output file. If a file operand is '-', it shall refer to a file named -;
implementations shall not treat it as meaning standard output. Processing of at least 13 file operands shall be
supported.
STDIN
The standard input can be of any type.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of tee:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default, except that if the -i option was specified, SIGINT shall be ignored.
STDOUT
The standard output shall be a copy of the standard input.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
If any file operands are specified, the standard input shall be copied to each named file.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
The standard input was successfully copied to all output files.
>0
An error occurred.
CONSEQUENCES OF ERRORS
If a write to any successfully opened file operand fails, writes to other successfully opened file operands and
standard output shall continue, but the exit status shall be non-zero. Otherwise, the default actions specified in 1.4 Utility Description Defaults apply.
The following sections are informative.
APPLICATION USAGE
The tee utility is usually used in a pipeline, to make a copy of the output of some utility.
The file operand is technically optional, but tee is no more useful than cat when none is specified.
EXAMPLES
Save an unsorted intermediate form of the data in a pipeline:
... | tee unsorted | sort > sorted
RATIONALE
The buffering requirement means that tee is not allowed to use ISO C standard fully buffered or line-buffered
writes. It does not mean that tee has to do 1-byte reads followed by 1-byte writes.
It should be noted that early versions of BSD ignore any invalid options and accept a single '-' as an alternative to
-i. They also print a message if unable to open a file:
"tee: cannot access %s\n",
Historical implementations ignore write errors. This is explicitly not permitted by this volume of POSIX.1-2024.
Some historical implementations use O_APPEND when providing append mode; others use the lseek() function to seek to the end-of-file after opening the file without O_APPEND. This
volume of POSIX.1-2024 requires functionality equivalent to using O_APPEND; see 1.1.1.4 File Read, Write, and Creation.
FUTURE DIRECTIONS
If this utility is directed to create a new directory entry that contains any bytes that have the encoded value of a
character, implementations are encouraged to treat this as an error. A future version of this standard may require
implementations to treat this as an error.
SEE ALSO
1. Introduction, cat
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
XSH lseek()
CHANGE HISTORY
First released in Issue 2.
Issue 6
IEEE PASC Interpretation 1003.2 #168 is applied.
Issue 7
Austin Group Interpretation 1003.1-2001 #092 is applied.
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to disallow the creation of filenames containing any bytes that
have the encoded value of a  character.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
Austin Group Defect 1494 is applied, inserting a missing closing parenthesis.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/expr.html =====
expr
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
expr — evaluate arguments as an expression
SYNOPSIS
expr operand...
DESCRIPTION
The expr utility shall evaluate an expression and write the result to standard output.
OPTIONS
None.
OPERANDS
The single expression evaluated by expr shall be formed from the operand operands, as described in the EXTENDED
DESCRIPTION section. The application shall ensure that each of the expression operator symbols:
(  )  |  &  =  >  >=  , to standard
output.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
The formation of the expression to be evaluated is shown in the following table. The symbols expr, expr1, and
expr2 represent expressions formed from integer and string symbols and the expression operator symbols (all
separate arguments) by recursive application of the constructs described in the table. The expressions are listed in order of
decreasing precedence, with equal-precedence operators grouped between horizontal lines. All of the operators shall be
left-associative.
Expression
Description
integer
An argument consisting only of an (optional) unary minus followed by digits.
string
A string argument; see below.
( expr )
Grouping symbols. Any expression can be placed within parentheses. Parentheses can be nested to a depth of
{EXPR_NEST_MAX}.
expr1 : expr2
Matching expression; see below.
expr1 * expr2
expr1 / expr2
expr1 % expr2
Multiplication of decimal integer-valued arguments.
Integer division of decimal integer-valued arguments, producing an integer result.
Remainder of integer division of decimal integer-valued arguments.
expr1 + expr2
expr1 - expr2
Addition of decimal integer-valued arguments.
Subtraction of decimal integer-valued arguments.
expr1 = expr2
expr1 > expr2
expr1 >= expr2
expr1  >= 2
Another error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
The expr utility has a rather difficult syntax:
Many of the operators are also shell control operators or reserved words, so they have to be escaped on the
command line.
Each part of the expression is composed of separate arguments, so liberal usage of  characters is
required. For example:
Invalid
Valid
expr 1+2
expr 1 + 2
expr "1 + 2"
expr 1 + 2
expr 1 + (2 * 3)
expr 1 + \( 2 \* 3 \)
In many cases, the arithmetic and string features provided as part of the shell command language are easier to use
than their equivalents in expr. Newly written scripts should avoid expr in favor of the new features within the
shell; see 2.5 Parameters and Variables and 2.6.4 Arithmetic Expansion.
After argument processing by the shell, expr is not required to be able to tell the difference between an
operator and an operand except by the value. If "$a" is '=', the command:
expr "$a" = '='
looks like:
expr = = =
as the arguments are passed to expr (and they all may be taken as the '=' operator). The following
works reliably:
expr "X$a" = X=
Also note that this volume of POSIX.1-2024 permits implementations to extend utilities. The expr utility
permits the integer arguments to be preceded with a unary minus. This means that an integer argument could look like an option.
Therefore, the conforming application must employ the "--" construct of Guideline 10 of XBD 12.2 Utility Syntax Guidelines to protect its operands if there is any chance the
first operand might be a negative integer (or any string with a leading minus).
For testing string equality the test utility is preferred over
expr, as it is usually implemented as a shell built-in. However, the functionality is not quite the same because the
expr = and != operators check whether strings collate equally, whereas test checks whether they are identical. Therefore, they can produce different results in
locales where the collation sequence does not have a total ordering of all characters (see XBD 7.3.2 LC_COLLATE).
EXAMPLES
The following command:
a=$(expr "$a" + 1)
adds 1 to the variable a.
The following command, for "$a" equal to either /usr/abc/file or just file:
expr $a : '.*/\(.*\)' \| $a
returns the last segment of a pathname (that is, file). Applications should avoid the character '/'
used alone as an argument; expr may interpret it as the division operator.
The following command:
expr "//$a" : '.*/\(.*\)'
is a better representation of the previous example. The addition of the "//" characters eliminates any
ambiguity about the division operator and simplifies the whole expression. Also note that pathnames may contain characters
contained in the IFS variable and should be quoted to avoid having "$a" expand into multiple arguments.
The following command:
expr "X$VAR" : '.*' - 1
returns the number of characters in VAR.
RATIONALE
In an early proposal, EREs were used in the matching expression syntax. This was changed to BREs to avoid breaking historical
applications.
The use of a leading  in the BRE is unspecified because many historical implementations have
treated it as a special character, despite their system documentation. For example:
expr foo : ^foo     expr ^foo : ^foo
return 3 and 0, respectively, on those systems; their documentation would imply the reverse. Thus, the anchoring
condition is left unspecified to avoid breaking historical scripts relying on this undocumented feature.
FUTURE DIRECTIONS
None.
SEE ALSO
2.5 Parameters and Variables, 2.6.4 Arithmetic Expansion
XBD 7.3.2 LC_COLLATE, 8. Environment Variables, 9.3
Basic Regular Expressions, 12.2 Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 2.
Issue 5
The FUTURE DIRECTIONS section is added.
Issue 6
The expr utility is aligned with the IEEE P1003.2b draft standard, to include resolution of IEEE PASC Interpretation
1003.2 #104.
The normative text is reworded to avoid use of the term "must" for application requirements.
Issue 7
Austin Group Interpretation 1003.1-2001 #036 is applied, clarifying the behavior for BREs.
The SYNOPSIS and OPERANDS sections are revised to explicitly state that the name of each of the operands is
operand.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0094 [942], XCU/TC2-2008/0095 [709], XCU/TC2-2008/0096 [942],
XCU/TC2-2008/0097 [963], and XCU/TC2-2008/0098 [942] are applied.
Issue 8
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
Austin Group Defect 1500 is applied, changing the EXIT STATUS section.
Austin Group Defect 1757 is applied, changing "[\(...\)]" to "\(...\)".
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/head.html =====
head
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
head — copy the first part of files
SYNOPSIS
head [-c number|-n number] [file...]
DESCRIPTION
The head utility shall copy its input files to the standard output, ending the output for each file at a designated
point.
Copying shall end at the point in the file indicated by the -c number or -n number options. The
option-argument number shall be counted in units of lines or bytes, according to the options -n and -c. Both
line and byte counts start from 1.
OPTIONS
The head utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following options shall be supported:
-c number
The first number bytes of each input file shall be copied to standard output. The application shall ensure that the
number option-argument is a positive decimal integer.
-n number
This option shall be equivalent to -c number, except that the ending location in the file shall be measured in
lines instead of bytes.
When a file contains less than number bytes or lines, it shall be copied to standard output in its entirety. This shall
not be an error.
If no options are specified, head shall act as if -n 10 had been specified.
OPERANDS
The following operand shall be supported:
file
A pathname of an input file. If no file operands are specified, the standard input shall be used.
STDIN
The standard input shall be used if no file operands are specified, and shall be used if a file operand is
'-' and the implementation treats the '-' as meaning standard input. Otherwise, the standard input shall not be
used. See the INPUT FILES section.
INPUT FILES
If the -c option is specified, the input files can contain arbitrary data; otherwise, the input files shall be text
files, but the line length shall not be restricted to {LINE_MAX} bytes.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of head:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
The standard output shall contain designated portions of the input files.
If multiple file operands are specified, head shall precede the output for each with the header:
"\n==> %s
except that the first header written shall not include the initial .
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
When using head to process pathnames, it is recommended that LC_ALL, or at least LC_CTYPE and LC_COLLATE, are set to
POSIX or C in the environment, since pathnames can contain byte sequences that do not form valid characters in some locales, in
which case the utility's behavior would be undefined. In the POSIX locale each byte is a valid single-byte character, and therefore
this problem is avoided.
EXAMPLES
To write the first ten lines of all files (except those with a leading period) in the directory:
head -- *
RATIONALE
Although it is possible to simulate head with sed 10q for a single file, the
standard developers decided that the popularity of head on historical BSD systems warranted its inclusion alongside tail.
POSIX.1-2024 version of head follows the Utility Syntax Guidelines. The -n option was added to this new interface
so that head and tail would be more logically related. Earlier versions of this
standard allowed a -number option. This form is no longer specified by POSIX.1-2024 but may be present in some
implementations.
The head and tail utilities have not historically been symmetric. For
example, this standard only requires tail to support at most one file operand, while
head must operate on multiple files. Conversely, this standard requires tail to
be able to start at a position relative to the start of a file, but head need not support stopping at a position relative to
the end of the file. Implementations may choose to make head and tail symmetric
as an extension, but applications should not rely on this.
Older implementations of head did not support -c number, but emulating this via dd ibs=1
count=number is much less efficient and emulating via dd obs=pipe_buf | dd ibs=size count=number_of_blocks is
cumbersome, somewhat less efficient, and can only be used if the number of bytes to be copied is a multiple of a suitable block
size less than or equal to {PIPE_BUF}.
FUTURE DIRECTIONS
If this utility is directed to display a pathname that contains any bytes that have the encoded value of a
character when  is a terminator or separator in the output format being used, implementations are encouraged to
treat this as an error. A future version of this standard may require implementations to treat this as an error.
SEE ALSO
dd, sed, tail
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 4.
Issue 6
The obsolescent -number form is removed.
The normative text is reworded to avoid use of the term "must" for application requirements.
The DESCRIPTION is updated to clarify that when a file contains less than the number of lines requested, the entire file is
copied to standard output.
Issue 7
Austin Group Interpretations 1003.1-2001 #027 and #092 are applied.
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
The APPLICATION USAGE section is removed and the EXAMPLES section is corrected.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0107 [663] is applied.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to report an error if a utility is directed to display a
pathname that contains any bytes that have the encoded value of a  character when  is a terminator or
separator in the output format being used.
Austin Group Defect 407 is applied, adding the -c number option.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/cat.html =====
cat
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
cat — concatenate and print files
SYNOPSIS
cat [-u] [file...]
DESCRIPTION
The cat utility shall read files in sequence and shall write their contents to the standard output in the same
sequence.
OPTIONS
The cat utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following option shall be supported:
-u
Write bytes from the input file to the standard output without delay as each is read.
OPERANDS
The following operand shall be supported:
file
A pathname of an input file. If no file operands are specified, the standard input shall be used. If a file is
'-', the cat utility shall read from the standard input at that point in the sequence. The cat utility shall
not close and reopen standard input when it is referenced in this way, but shall accept multiple occurrences of '-' as a
file operand.
STDIN
The standard input shall be used only if no file operands are specified, or if a file operand is '-'. See
the INPUT FILES section.
INPUT FILES
The input files can be any file type.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of cat:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
The standard output shall contain the sequence of bytes read from the input files. Nothing else shall be written to the standard
output. If the standard output is a regular file, and is the same file as any of the input file operands, the implementation may
treat this as an error.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
All input files were output successfully.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
The -u option has value in prototyping non-blocking reads from FIFOs. The intent is to support the following
sequence:
mkfifo foo
cat -u foo > /dev/tty13 &
cat -u > foo
It is unspecified whether standard output is or is not buffered in the default case. This is sometimes of interest when standard
output is associated with a terminal, since buffering may delay the output. The presence of the -u option guarantees that
unbuffered I/O is available. It is implementation-defined whether the cat utility buffers output if the -u option is
not specified. Traditionally, the -u option is implemented using the equivalent of the setvbuf() function defined in the System Interfaces volume of POSIX.1-2024.
EXAMPLES
The following command:
cat myfile
writes the contents of the file myfile to standard output.
The following command:
cat doc1 doc2 > doc.all
concatenates the files doc1 and doc2 and writes the result to doc.all.
Because of the shell language mechanism used to perform output redirection, a command such as this:
cat doc doc.end > doc
causes the original data in doc to be lost before cat even begins execution. This is true whether the cat
command fails with an error or silently succeeds (the specification allows both behaviors). In order to append the contents of
doc.end without losing the original contents of doc, this command should be used instead:
cat doc.end >> doc
The command:
cat start - middle - end > file
when standard input is a terminal, gets two arbitrary pieces of input from the terminal with a single invocation of cat.
Note, however, that if standard input is a regular file, this would be equivalent to the command:
cat start - middle /dev/null end > file
because the entire contents of the file would be consumed by cat the first time '-' was used as a file
operand and an end-of-file condition would be detected immediately when '-' was referenced the second time.
RATIONALE
Historical versions of the cat utility include the -e, -t, and -v, options which permit the ends of
lines,  characters, and invisible characters, respectively, to be rendered visible in the output. The standard
developers omitted these options because they provide too fine a degree of control over what is made visible, and similar output
can be obtained using a command such as:
sed -n l pathname
The latter also has the advantage that its output is unambiguous, whereas the output of historical cat -etv is
not.
The -s option was omitted because it corresponds to different functions in BSD and System V-based systems. The BSD
-s option to squeeze blank lines can be accomplished by the shell script shown in the following example:
sed -n '
# Write non-empty lines.
/./   {
p
d
}
# Write a single empty line, then look for more empty lines.
/^$/  p
# Get next line, discard the held  (empty line),
# and look for more empty lines.
:Empty
/^$/  {
N
s/.//
b Empty
}
# Write the non-empty line before going back to search
# for the first in a set of empty lines.
p
'
The System V -s option to silence error messages can be accomplished by redirecting the standard error. Note that the BSD
documentation for cat uses the term "blank line" to mean the same as the POSIX "empty line": a line consisting only of a
.
The BSD -n option was omitted because similar functionality can be obtained from the -n option of the pr utility.
FUTURE DIRECTIONS
None.
SEE ALSO
more
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
XSH setvbuf()
CHANGE HISTORY
First released in Issue 2.
Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
SD5-XCU-ERN-174 is applied, changing the RATIONALE.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0073 [876] is applied.
Issue 8
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/times.html =====
Shell Command Language
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
Please enable javascript in your browser to automatically redirect to the target page, otherwise select the link below.
2.15 Special Built-In Utilities
break
colon
continue
dot
eval
exec
exit
export
readonly
return
set
shift
times
trap
unset
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
===== susv5-html/utilities/sleep.html =====
sleep
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
sleep — suspend execution for an interval
SYNOPSIS
sleep time
DESCRIPTION
The sleep utility shall suspend execution for at least the integral number of seconds specified by the time
operand.
OPTIONS
None.
OPERANDS
The following operand shall be supported:
time
A non-negative decimal integer specifying the number of seconds for which to suspend execution.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of sleep:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
If the sleep utility receives a SIGALRM signal, one of the following actions shall be taken:
Terminate normally with a zero exit status.
Effectively ignore the signal.
Provide the default behavior for signals described in the ASYNCHRONOUS EVENTS section of 1.4 Utility Description Defaults. This could include terminating with a
non-zero exit status.
The sleep utility shall take the standard action for all other signals.
STDOUT
Not used.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
The execution was successfully suspended for at least time seconds, or a SIGALRM signal was received. See the
ASYNCHRONOUS EVENTS section.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
None.
EXAMPLES
The sleep utility can be used to execute a command after a certain amount of time, as in:
(sleep 105; command) &
or to execute a command every so often, as in:
while true
do
command
sleep 37
done
RATIONALE
The exit status is allowed to be zero when sleep is interrupted by the SIGALRM signal because most implementations of
this utility rely on the arrival of that signal to notify them that the requested finishing time has been successfully attained.
Such implementations thus do not distinguish this situation from the successful completion case. Other implementations are allowed
to catch the signal and go back to sleep until the requested time expires or to provide the normal signal termination
procedures.
As with all other utilities that take integral operands and do not specify subranges of allowed values, sleep is required
by this volume of POSIX.1-2024 to deal with time requests of up to 2147483647 seconds. This may mean that some
implementations have to make multiple calls to the delay mechanism of the underlying operating system if its argument range is less
than this.
FUTURE DIRECTIONS
None.
SEE ALSO
wait
XBD 8. Environment Variables
XSH alarm(), sleep()
CHANGE HISTORY
First released in Issue 2.
Issue 8
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/ulimit.html =====
ulimit
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ulimit — report or set resource limits
SYNOPSIS
ulimit [-H|-S] -a
[XSI] ulimit [-H|-S] [-c|-d|-f|-n|-s|-t|-v] [newlimit]
DESCRIPTION
The ulimit utility shall report or set the resource limits in effect in the process in which it is executed.
Soft limits can be changed by a process to any value that is less than or equal to the hard limit. A process can (irreversibly)
lower its hard limit to any value that is greater than or equal to the soft limit. Only a process with appropriate privileges can
raise a hard limit.
The value unlimited for a resource shall be considered to be larger than any other limit value. When a resource has this
limit value, the implementation shall not enforce limits on that resource. In locales other than the POSIX locale, ulimit
may support additional non-numeric values with the same meaning as unlimited.
The behavior when resource limits are exceeded shall be as described in the System Interfaces volume of POSIX.1-2024 for the
setrlimit() function.
OPTIONS
The ulimit utility shall conform to XBD 12.2 Utility Syntax
Guidelines, except that:
The order in which options other than -H, -S, and -a are specified may be significant.
Conforming applications shall specify each option separately; that is, grouping option letters (for example, -fH) need
not be recognized by all implementations.
The following options shall be supported:
-H
Report hard limit(s) or set only a hard limit.
-S
Report soft limit(s) or set only a soft limit.
-a
Report the limit value for all of the resources named below and for any implementation-specific additional resources.
-c
Report, or set if the newlimit operand is present, the core image size limit(s) in units of 512 bytes.
[RLIMIT_CORE]
-d
Report, or set if the newlimit operand is present, the data segment size limit(s) in units of 1024 bytes.
[RLIMIT_DATA]
-f
Report, or set if the newlimit operand is present, the file size limit(s) in units of 512 bytes. [RLIMIT_FSIZE]
-n
Report, or set if the newlimit operand is present, the limit(s) on the number of open file descriptors, given as a
number one greater than the maximum value that the system assigns to a newly-created descriptor. [RLIMIT_NOFILE]
-s
Report, or set if the newlimit operand is present, the stack size limit(s) in units of 1024 bytes. [RLIMIT_STACK]
-t
[XSI]
Report, or set if the newlimit operand is present, the per-process CPU time limit(s) in units of seconds. [RLIMIT_CPU]
-v
Report, or set if the newlimit operand is present, the address space size limit(s) in units of 1024 bytes.
[RLIMIT_AS]
Where an option description is followed by [RLIMIT_name] it indicates which resource for the getrlimit() and setrlimit() functions,
defined in the System Interfaces volume of POSIX.1-2024, the option corresponds to.
If neither the -H nor -S option is specified:
If the newlimit operand is present, it shall be used as the new value for both the hard and soft limits.
If the newlimit operand is not present, -S shall be the default.
If no options other than -H or -S are specified, the behavior shall be as if the -f option was (also)
specified.
If any option other than -H or -S is repeated, the behavior is unspecified.
OPERANDS
The following operand shall be supported:
newlimit
Either an integer value to use as the new limit(s) for the specified resource, in the units specified in OPTIONS, or a
non-numeric string indicating no limit, as described in the DESCRIPTION section. Numerals in the range 0 to the maximum limit value
supported by the implementation for any resource shall be syntactically recognized as numeric values.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of ulimit:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
The standard output shall be used when no newlimit operand is present.
If the -a option is specified, the output written for each resource shall consist of one line that includes:
A short phrase identifying the resource (for example "file size").
An indication of the units used for the resource, if the corresponding option description in OPTIONS specifies the units to be
used.
The ulimit option used to specify the resource.
The limit value.
The format used within each line is unspecified, except that the format used for the limit value shall be as described below for
the case where a single limit value is written.
If a single limit value is to be written; that is, the -a option is not specified and at most one option other than
-H or -S is specified:
If the resource being reported has a numeric limit, the limit value shall be written in the following format:
"%1d\n",
where  is the value of the limit in the units specified in OPTIONS.
If the resource being reported does not have a numeric limit, in the POSIX locale the following format shall be used:
"unlimited\n"
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
A request for a higher limit was rejected or an error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
This utility is required to be intrinsic. See 1.7 Intrinsic Utilities
for details.
Since ulimit affects the current shell execution environment, it is always provided as a shell regular built-in. If it is
called with an operand in a separate utility execution environment, such as one of the following:
nohup ulimit -f 10000
env ulimit -S -c 10000
it does not affect the limit(s) in the caller's environment.
See also the APPLICATION USAGE for getrlimit().
EXAMPLES
Set the hard and soft file size limits to 51200 bytes:
ulimit -f 100
Save and restore a soft resource limit (where X is an option letter specifying a resource):
saved=$(ulimit -X)
...
ulimit -X -S "$saved"
Execute a utility with a CPU limit of 5 minutes (using an asynchronous subshell to ensure the limit is set in a child
process):
(ulimit -t 300; exec utility_name >>
===== susv5-html/utilities/fold.html =====
fold
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
fold — filter for folding lines
SYNOPSIS
fold [-bs] [-w width] [file...]
DESCRIPTION
The fold utility is a filter that shall fold lines from its input files, breaking the lines to have a maximum of
width column positions (or bytes, if the -b option is specified). Lines shall be broken by the insertion of a
such that each output line (referred to later in this section as a segment) is the maximum width possible
that does not exceed the specified number of column positions (or bytes). A line shall not be broken in the middle of a character.
The behavior is undefined if width is less than the number of columns any single character in the input would occupy.
If the , , or  characters are encountered in the input, and the -b
option is not specified, they shall be treated specially:
The current count of line width shall be decremented by one, although the count never shall become negative. The fold
utility shall not insert a  immediately before or after any , unless the following character has a
width greater than 1 and would cause the line width to exceed width.
The current count of line width shall be set to zero. The fold utility shall not insert a  immediately before
or after any .
Each  encountered shall advance the column position pointer to the next tab stop. Tab stops shall be at each column
position n such that n modulo 8 equals 1.
OPTIONS
The fold utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following options shall be supported:
-b
Count width in bytes rather than column positions.
-s
If a segment of a line contains a  within the first width column positions (or bytes), break the line after
the last such  meeting the width constraints. If there is no  meeting the requirements, the -s
option shall have no effect for that output segment of the input line.
-w width
Specify the maximum line length, in column positions (or bytes if -b is specified). The results are unspecified if
width is not a positive decimal number. The default value shall be 80.
OPERANDS
The following operand shall be supported:
file
A pathname of a text file to be folded. If no file operands are specified, the standard input shall be used.
STDIN
The standard input shall be used if no file operands are specified, and shall be used if a file operand is
'-' and the implementation treats the '-' as meaning standard input. Otherwise, the standard input shall not be
used. See the INPUT FILES section.
INPUT FILES
If the -b option is specified, the input files shall be text files except that the lines are not limited to {LINE_MAX}
bytes in length. If the -b option is not specified, the input files shall be text files.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of fold:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files), and for the determination of the width in column positions each
character would occupy on a constant-width font output device.
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
The standard output shall be a file containing a sequence of characters whose order shall be preserved from the input files,
possibly with inserted  characters.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
All input files were processed successfully.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
The cut and fold utilities can be used to create text files out of files with
arbitrary line lengths. The cut utility should be used when the number of lines (or
records) needs to remain constant. The fold utility should be used when the contents of long lines need to be kept
contiguous.
The fold utility is frequently used to send text files to printers that truncate, rather than fold, lines wider than the
printer is able to print (usually 80 or 132 column positions).
EXAMPLES
An example invocation that submits a file of possibly long lines to the printer (under the assumption that the user knows the
line width of the printer to be assigned by lp):
fold -w 132 bigfile | lp
RATIONALE
Although terminal input in canonical processing mode requires the erase character (frequently set to ) to erase
the previous character (not byte or column position), terminal output is not buffered and is extremely difficult, if not
impossible, to parse correctly; the interpretation depends entirely on the physical device that actually displays/prints/stores the
output. In all known internationalized implementations, the utilities producing output for mixed column-width output assume that a
character backs up one column position and outputs enough  characters to return to the start of
the character when  is used to provide local line motions to support underlining and emboldening operations. Since
fold without the -b option is dealing with these same constraints,  is always treated as backing up
one column position rather than backing up one character.
Historical versions of the fold utility assumed 1 byte was one character and occupied one column position when written
out. This is no longer always true. Since the most common usage of fold is believed to be folding long lines for output to
limited-length output devices, this capability was preserved as the default case. The -b option was added so that
applications could fold files with arbitrary length lines into text files that could then be processed by the standard
utilities. Note that although the width for the -b option is in bytes, a line is never split in the middle of a character.
(It is unspecified what happens if a width is specified that is too small to hold a single character found in the input followed by
a .)
The tab stops are hardcoded to be every eighth column to meet historical practice. No new method of specifying other tab stops
was invented.
FUTURE DIRECTIONS
None.
SEE ALSO
cut
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 4.
Issue 6
The normative text is reworded to avoid use of the term "must" for application requirements.
Issue 7
Austin Group Interpretation 1003.1-2001 #092 is applied.
Austin Group Interpretation 1003.1-2001 #204 is applied, updating the DESCRIPTION to clarify when a  can be
inserted before or after a .
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
Issue 8
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/V3_chap02.html =====
Shell Command Language
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
2. Shell Command Language
This chapter contains the definition of the Shell Command Language.
2.1 Shell Introduction
The shell is a command language interpreter. This chapter describes the syntax of that command language as it is used by the
sh utility and the system() and popen() functions defined in the System Interfaces volume of POSIX.1-2024.
The shell operates according to the following general overview of operations. The specific details are included in the cited
sections of this chapter.
The shell reads its input from a file (see sh), from the -c option or from the
system() and popen() functions defined
in the System Interfaces volume of POSIX.1-2024. If the first line of a file of shell commands starts with the characters
"#!", the results are unspecified.
The shell breaks the input into tokens: words and operators; see 2.3 Token Recognition.
The shell parses the input into simple commands (see 2.9.1 Simple Commands) and compound commands
(see 2.9.4 Compound Commands).
For each word within a command, the shell processes -escape sequences inside dollar-single-quotes (see 2.2.4 Dollar-Single-Quotes) and then performs various word expansions (see 2.6 Word
Expansions). In the case of a simple command, the results usually include a list of pathnames and fields to be treated as a
command name and arguments; see 2.9 Shell Commands.
The shell performs redirection (see 2.7 Redirection) and removes redirection operators and their
operands from the parameter list.
The shell executes a function (see 2.9.5 Function Definition Command), built-in (see 2.15 Special Built-In Utilities), executable file, or script, giving the names of the arguments as positional
parameters numbered 1 to n, and the name of the command (or in the case of a function within a script, the name of the
script) as special parameter 0 (see 2.9.1.4 Command Search and Execution).
The shell optionally waits for the command to complete and collects the exit status (see 2.8.2 Exit
Status for Commands).
2.2 Quoting
Quoting is used to remove the special meaning of certain characters or words to the shell. Quoting can be used to preserve the
literal meaning of the special characters in the next paragraph, prevent reserved words from being recognized as such, and prevent
parameter expansion and command substitution within here-document processing (see 2.7.4 Here-Document
).
The application shall quote the following characters if they are to represent themselves:
|  &  ;    (  )  $  `  \  "  '
and the following might need to be quoted under certain circumstances. That is, these characters are sometimes special depending
on conditions described elsewhere in this volume of POSIX.1-2024:
*  ?  [  ]  ^  -  !  #  ~  =  %  {  ,  }
Note:
A future version of this standard may extend the conditions under which these characters are special. Therefore applications
should quote them whenever they are intended to represent themselves. This does not apply to  ('-')
since it is in the portable filename character set.
The various quoting mechanisms are the escape character, single-quotes, double-quotes, and dollar-single-quotes. The
here-document represents another form of quoting; see 2.7.4 Here-Document.
2.2.1 Escape Character (Backslash)
A  that is not quoted shall preserve the literal value of the following character, with the exception of a
. If a  immediately follows the , the shell shall interpret this as line
continuation. The  and  shall be removed before splitting the input into tokens. Since the escaped
is removed entirely from the input and is not replaced by any white space, it cannot serve as a token
separator.
2.2.2 Single-Quotes
Enclosing characters in single-quotes ('') shall preserve the literal value of each character within the single-quotes.
A single-quote cannot occur within single-quotes.
2.2.3 Double-Quotes
Enclosing characters in double-quotes ("") shall preserve the literal value of all characters within the double-quotes,
with the exception of the characters backquote, , and , as follows:
$
The  shall retain its special meaning introducing parameter expansion (see 2.6.2
Parameter Expansion), a form of command substitution (see 2.6.3 Command Substitution), and
arithmetic expansion (see 2.6.4 Arithmetic Expansion), but shall not retain its special meaning
introducing the dollar-single-quotes form of quoting (see 2.2.4 Dollar-Single-Quotes).
The input characters within the quoted string that are also enclosed between "$(" and the matching ')' shall
not be affected by the double-quotes, but rather shall define the command(s) whose output replaces the "$(...)" when the
word is expanded. The tokenizing rules in 2.3 Token Recognition shall be applied recursively to find the
matching ')'.
For the four varieties of parameter expansion that provide for substring processing (see 2.6.2 Parameter
Expansion), within the string of characters from an enclosed "${" to the matching '}', the double-quotes
within which the expansion occurs shall have no effect on the handling of any special characters.
For parameter expansions other than the four varieties that provide for substring processing, within the string of characters
from an enclosed "${" to the matching '}', the double-quotes within which the expansion occurs shall preserve the
literal value of all characters, with the exception of the characters double-quote, backquote, , and
. If any unescaped double-quote characters occur within the string, other than in embedded command substitutions,
the behavior is unspecified. The backquote and  characters shall follow the same rules as for characters in
double-quotes described in this section. The  character shall follow the same rules as for characters in
double-quotes described in this section except that it shall additionally retain its special meaning as an escape character when
followed by '}' and this shall prevent the escaped '}' from being considered when determining the matching
'}' (using the rule in 2.6.2 Parameter Expansion).
`
The backquote shall retain its special meaning introducing the other form of command substitution (see 2.6.3 Command Substitution). The portion of the quoted string from the initial backquote and the characters up
to the next backquote that is not preceded by a , having escape characters removed, defines that command whose
output replaces "`...`" when the word is expanded. Either of the following cases produces undefined results:
A quoted (single-quoted, double-quoted, or dollar-single-quoted) string that begins, but does not end, within the
"`...`" sequence
A "`...`" sequence that begins, but does not end, within the same double-quoted string
\
Outside of "$(...)" and "${...}" the  shall retain its special meaning as an escape
character (see 2.2.1 Escape Character (Backslash)) only when immediately followed by one of the
following characters:
$   `   \
or by a double-quote character that would otherwise be considered special (see 2.6.4 Arithmetic
Expansion and 2.7.4 Here-Document).
When double-quotes are used to quote a parameter expansion, command substitution, or arithmetic expansion, the literal value of
all characters within the result of the expansion shall be preserved.
The application shall ensure that a double-quote that is not within "$(...)" nor within "${...}" is
immediately preceded by a  in order to be included within double-quotes. The parameter '@' has special
meaning inside double-quotes and is described in 2.5.2 Special Parameters.
2.2.4 Dollar-Single-Quotes
A sequence of characters starting with a  immediately followed by a single-quote ($') shall preserve
the literal value of all characters up to an unescaped terminating single-quote ('), with the exception of certain
-escape sequences, as follows:
\" yields a  (double-quote) character, but note that  can be included
unescaped.
\' yields an  (single-quote) character.
\\ yields a  character.
\a yields an  character.
\b yields a  character.
\e yields an  character.
\f yields a  character.
\n yields a  character.
\r yields a  character.
\t yields a  character.
\v yields a  character.
\cX yields the control character listed in the Value column of Values for cpio c_mode Field in the OPERANDS section of the stty utility when X is one of the characters listed in the ^c column of the same
table, except that \c\\ yields the  control character since the  character has to be
escaped.
\xXX yields the byte whose value is the hexadecimal value XX (one or more hexadecimal digits). If more
than two hexadecimal digits follow \x, the results are unspecified.
\ddd yields the byte whose value is the octal value ddd (one to three octal digits).
The behavior of an unescaped  immediately followed by any other character, including , is
unspecified.
In cases where a variable number of characters can be used to specify an escape sequence (\xXX and
\ddd), the escape sequence shall be terminated by the first character that is not of the expected type or, for
\ddd sequences, when the maximum number of characters specified has been found, whichever occurs first.
These -escape sequences shall be processed (replaced with the bytes or characters they yield) immediately prior
to word expansion (see 2.6 Word Expansions) of the word in which the dollar-single-quotes sequence
occurs.
If a \xXX or \ddd escape sequence yields a byte whose value is 0, it is unspecified whether that
null byte is included in the result or if that byte and any following regular characters and escape sequences up to the terminating
unescaped single-quote are evaluated and discarded.
If the octal value specified by \ddd will not fit in a byte, the results are unspecified.
If a \e or \cX escape sequence specifies a character that does not have an encoding in the locale in
effect when these -escape sequences are processed, the result is implementation-defined. However, implementations
shall not replace an unsupported character with bytes that do not form valid characters in that locale's character set.
If a -escape sequence represents a single-quote character (for example \'), that sequence shall not
terminate the dollar-single-quote sequence.
2.3 Token Recognition
The shell shall read its input in terms of lines. (For details about how the shell reads its input, see the description of
sh.) The input lines can be of unlimited length. These lines shall be parsed using two
major modes: ordinary token recognition and processing of here-documents.
When an io_here token has been recognized by the grammar (see 2.10 Shell Grammar), one or more
of the subsequent lines immediately following the next NEWLINE token form the body of a here-document and shall be parsed
according to the rules of 2.7.4 Here-Document. Any non-NEWLINE tokens (including more
io_here tokens) that are recognized while searching for the next NEWLINE token shall be saved for processing after
the here-document has been parsed. If a saved token is an io_here token, the corresponding here-document shall start on the
line immediately following the line containing the trailing delimiter of the previous here-document. If any saved token includes a
character, the behavior is unspecified.
When it is not processing an io_here, the shell shall break its input into tokens by applying the first applicable rule
below to each character in turn in its input. At the start of input or after a previous token has just been delimited, the first or
next token, respectively, shall start with the first character that has not already been included in a token and is not discarded
according to the rules below. Once a token has started, zero or more characters from the input shall be appended to the token until
the end of the token is delimited according to one of the rules below. When both the start and end of a token have been delimited,
the characters forming the token shall be exactly those in the input between the two delimiters, including any quoting characters.
If a rule below indicates that a token is delimited, and no characters have been included in the token, that empty token shall be
discarded.
If the end of input is recognized, the current token (if any) shall be delimited.
If the previous character was used as part of an operator and the current character is not quoted and can be used with the
previous characters to form an operator, it shall be used as part of that (operator) token.
If the previous character was used as part of an operator and the current character cannot be used with the previous characters
to form an operator, the operator containing the previous character shall be delimited.
If the current character is an unquoted , single-quote, or double-quote or is the first character of an
unquoted  single-quote sequence, it shall affect quoting for subsequent characters up to the end of the quoted
text. The rules for quoting are as described in 2.2 Quoting. During token recognition no substitutions
shall be actually performed, and the result token shall contain exactly the characters that appear in the input unmodified,
including any embedded or enclosing quotes or substitution operators, between the start and the end of the quoted text. The token
shall not be delimited by the end of the quoted field.
If the current character is an unquoted '$' or '`', the shell shall identify the start of any candidates for
parameter expansion ( 2.6.2 Parameter Expansion), command substitution ( 2.6.3
Command Substitution), or arithmetic expansion ( 2.6.4 Arithmetic Expansion) from their
introductory unquoted character sequences: '$' or "${", "$(" or '`', and "$((",
respectively. The shell shall read sufficient input to determine the end of the unit to be expanded (as explained in the cited
sections). While processing the characters, if instances of expansions or quoting are found nested within the substitution, the
shell shall recursively process them in the manner specified for the construct that is found. For "$(" and '`'
only, if instances of io_here tokens are found nested within the substitution, they shall be parsed according to the rules
of 2.7.4 Here-Document; if the terminating ')' or '`' of the substitution occurs
before the NEWLINE token marking the start of the here-document, the behavior is unspecified. The characters found from the
beginning of the substitution to its end, allowing for any recursion necessary to recognize embedded constructs, shall be included
unmodified in the result token, including any embedded or enclosing substitution operators or quotes. The token shall not be
delimited by the end of the substitution.
If the current character is not quoted and can be used as the first character of a new operator, the current token (if any)
shall be delimited. The current character shall be used as the beginning of the next (operator) token.
If the current character is an unquoted , any token containing the previous character is delimited and the current
character shall be discarded.
If the previous character was part of a word, the current character shall be appended to that word.
If the current character is a '#', it and all subsequent characters up to, but excluding, the next
shall be discarded as a comment. The  that ends the line is not considered part of the comment.
The current character is used as the start of a new word.
Once a token is delimited, it is categorized as required by the grammar in 2.10 Shell Grammar.
In situations where the shell parses its input as a program, once a complete_command has been recognized by the
grammar (see 2.10 Shell Grammar), the complete_command shall be executed before the next
complete_command is tokenized and parsed.
2.3.1 Alias Substitution
After a token has been categorized as type TOKEN (see 2.10.1 Shell Grammar Lexical
Conventions), including (recursively) any token resulting from an alias substitution, the TOKEN shall be subject to
alias substitution if all of the following conditions are true:
The TOKEN does not contain any quoting characters.
The TOKEN is a valid alias name (see XBD 3.10 Alias Name).
An alias with that name is in effect.
The TOKEN did not either fully or, optionally, partially result from an alias substitution of the same alias name at any
earlier recursion level.
Either the TOKEN is being considered for alias substitution because it follows an alias substitution whose replacement
value ended with a  (see below) or the TOKEN could be parsed as the command name word of a simple command (see
2.10 Shell Grammar), based on this TOKEN and the tokens (if any) that preceded it, but ignoring
whether any subsequent characters would allow that.
except that if the TOKEN meets the above conditions and would be recognized as a reserved word (see 2.4
Reserved Words) if it occurred in an appropriate place in the input, it is unspecified whether the TOKEN is subject to
alias substitution.
When a TOKEN is subject to alias substitution, the value of the alias shall be processed as if it had been read from the
input instead of the TOKEN, with token recognition (see 2.3 Token Recognition) resuming at the
start of the alias value. When the end of the alias value is reached, the shell may behave as if an additional
character had been read from the input after the TOKEN that was replaced. If it does not add this , it is
unspecified whether the current token is delimited before token recognition is applied to the character (if any) that followed the
TOKEN in the input.
Note:
A future version of this standard may disallow adding this .
If the value of the alias replacing the TOKEN ends in a  that would be unquoted after
substitution, and optionally if it ends in a  that would be quoted after substitution, the shell shall check the next
token in the input, if it is a TOKEN, for alias substitution; this process shall continue until a TOKEN is found that
is not a valid alias or an alias value does not end in such a .
An implementation may defer the effect of a change to an alias but the change shall take effect no later than the completion of
the currently executing complete_command (see 2.10 Shell Grammar). Changes to aliases shall not
take effect out of order. Implementations may provide predefined aliases that are in effect when the shell is invoked.
When used as specified by this volume of POSIX.1-2024, alias definitions shall not be inherited by separate invocations of the
shell or by the utility execution environments invoked by the shell; see 2.13 Shell Execution Environment
.
2.4 Reserved Words
Reserved words are words that have special meaning to the shell; see 2.9 Shell Commands. The following
words shall be recognized as reserved words:
!
{
}
case
do
done
elif
else
esac
fi
for
if
in
then
until
while
This recognition shall only occur when none of the characters is quoted and when the word is used as:
The first word of a command
The first word following one of the reserved words other than case, for, or in
The third word in a case command (only in is valid in this case)
The third word in a for command (only in and do are valid in this case)
See the grammar in 2.10 Shell Grammar.
When used in circumstances where reserved words are recognized (described above), the following words may be
recognized as reserved words, in which case the results are unspecified except as described below for time:
[[
]]
function
namespace
select
time
When the word time is recognized as a reserved word in circumstances where it would, if it were not a
reserved word, be the command name (see 2.9.1.1 Order of Processing) of a simple command that would
execute the time utility in a manner other than one for which time states that the results are unspecified, the behavior shall be as specified for
the time utility.
When used in circumstances where reserved words are recognized (described above), all words whose final character
is a  (':') are reserved; their use in those circumstances produces unspecified results.
2.5 Parameters and Variables
A parameter can be denoted by a name, a number, or one of the special characters listed in 2.5.2 Special Parameters. A variable is a parameter denoted by a name.
A parameter is set if it has an assigned value (null is a valid value). Once a variable is set, it can only be
unset by using the unset special built-in command.
Parameters can contain arbitrary byte sequences, except for the null byte. The shell shall process their values as
characters only when performing operations that are described in this standard in terms of characters.
2.5.1 Positional Parameters
A positional parameter is a parameter denoted by a decimal representation of a positive integer. The digits
denoting the positional parameters shall always be interpreted as a decimal value, even if there is a leading zero. When a
positional parameter with more than one digit is specified, the application shall enclose the digits in braces (see 2.6.2 Parameter Expansion).
Examples:
"$8", "${8}", "${08}", "${008}", etc. all expand to the value of the eighth
positional parameter.
"${10}" expands to the value of the tenth positional parameter.
"$10" expands to the value of the first positional parameter followed by the character '0'.
Note:
0 is a special parameter, not a positional parameter, and therefore the results of expanding ${00} are
unspecified.
Positional parameters are initially assigned when the shell is invoked (see sh), temporarily replaced when a shell function is invoked (see 2.9.5
Function Definition Command), and can be reassigned with the set special built-in command.
2.5.2 Special Parameters
Listed below are the special parameters and the values to which they shall expand. Only the values of the special
parameters are listed; see 2.6 Word Expansions for a detailed summary of all the stages involved in
expanding words.
@
Expands to the positional parameters, starting from one, initially producing one field for each positional parameter that is
set. When the expansion occurs in a context where field splitting will be performed, any empty fields may be discarded and each of
the non-empty fields shall be further split as described in 2.6.5 Field Splitting. When the expansion
occurs within double-quotes, the behavior is unspecified unless one of the following is true:
Field splitting as described in 2.6.5 Field Splitting would be performed if the
expansion were not within double-quotes (regardless of whether field splitting would have any effect; for example, if IFS is
null).
The double-quotes are within the word of a ${parameter:-word} or a
${parameter:+word} expansion (with or without the ; see 2.6.2 Parameter
Expansion) which would have been subject to field splitting if parameter had been expanded instead of word.
If one of these conditions is true, the initial fields shall be retained as separate fields, except that if the
parameter being expanded was embedded within a word, the first field shall be joined with the beginning part of the original word
and the last field shall be joined with the end part of the original word. In all other contexts the results of the expansion are
unspecified. If there are no positional parameters, the expansion of '@' shall generate zero fields, even when
'@' is within double-quotes; however, if the expansion is embedded within a word which contains one or more other parts
that expand to a quoted null string, these null string(s) shall still produce an empty field, except that if the other parts are
all within the same double-quotes as the '@', it is unspecified whether the result is zero fields or one empty field.
*
Expands to the positional parameters, starting from one, initially producing one field for each positional parameter that is
set. When the expansion occurs in a context where field splitting will be performed, any empty fields may be discarded and each of
the non-empty fields shall be further split as described in 2.6.5 Field Splitting. When the expansion
occurs in a context where field splitting will not be performed, the initial fields shall be joined to form a single field with the
value of each parameter separated by the first character of the IFS variable if IFS contains at least one character,
or separated by a  if IFS is unset, or with no separation if IFS is set to a null string.
#
Expands to the shortest representation of the decimal number of positional parameters. The command name (parameter 0) shall not
be counted in the number given by '#' because it is a special parameter, not a positional parameter.
?
Expands to the shortest representation of the decimal exit status (see 2.8.2 Exit Status for
Commands) of the pipeline (see 2.9.2 Pipelines) executed from the current shell execution
environment (not a subshell environment) that most recently either terminated or, optionally but only if the shell is interactive
and job control is enabled, was stopped by a signal. If this pipeline terminated, the status value shall be its exit status;
otherwise, the status value shall be the same as the exit status that would have resulted if the pipeline had been terminated by a
signal with the same number as the signal that stopped it. The value of the special parameter '?' shall be set to 0 during
initialization of the shell. When a subshell environment is created, the value of the special parameter '?' from the
invoking shell environment shall be preserved in the subshell.
Note:
In var=$(some_command); echo $? the output is the exit status of some_command, which is executed in a
subshell environment, but this is because its exit status becomes the exit status of the assignment command
var=$(some_command) (see 2.9.1 Simple Commands) and this assignment command is the most
recently completed pipeline. Likewise for any pipeline consisting entirely of a simple command that has no command word, but
contains one or more command substitutions. (See 2.9.1 Simple Commands.)
-
(Hyphen.) Expands to the current option flags (the single-letter option names concatenated into a string) as specified on
invocation, by the set special built-in command, or implicitly by the shell. It is unspecified whether
the -c and -s options are included in the expansion of "$-". The -i option shall be included in
"$-" if the shell is interactive, regardless of whether it was specified on invocation.
$
Expands to the shortest representation of the decimal process ID of the invoked shell. In a subshell (see 2.13 Shell Execution Environment), '$' shall expand to the same value as that of the current shell.
!
Expands to the shortest representation of the decimal process ID associated with the most recent asynchronous AND-OR list (see
2.9.3.1 Asynchronous AND-OR Lists) executed from the current shell execution environment, or to the
shortest representation of the decimal process ID of the last command specified in the currently executing pipeline in the
job-control background job that most recently resumed execution through the use of bg,
whichever is the most recent.
0
(Zero.) Expands to the name of the shell or shell script. See sh for a detailed
description of how this name is derived.
See the description of the IFS variable in 2.5.3 Shell Variables.
2.5.3 Shell Variables
Variables shall be initialized from the environment (as defined by XBD 8. Environment Variables and the exec function in the System Interfaces
volume of POSIX.1-2024) and can be given new values with variable assignment commands. Shell variables shall be initialized only
from environment variables that have valid names. If a variable is initialized from the environment, it shall be marked for export
immediately; see the export special built-in. New variables can be defined and initialized with
variable assignments, with the read or getopts utilities, with the name parameter in a for loop, with the
${name=word} expansion, or with other mechanisms provided as implementation extensions.
The following variables shall affect the execution of the shell:
ENV
[UP]
The processing of the ENV shell variable shall be supported if the system supports the User Portability Utilities option.
This variable, when and only when an interactive shell is invoked, shall be subjected to parameter expansion (see
2.6.2 Parameter Expansion) by the shell and the resulting value shall be used as a pathname of a file.
Before any interactive commands are read, the shell shall tokenize (see 2.3 Token Recognition) the
contents of the file, parse the tokens as a program (see 2.10 Shell Grammar), and execute the
resulting commands in the current environment. (In other words, the contents of the ENV file are not parsed as a single
compound_list. This distinction matters because it influences when aliases take effect.) The file need not be executable. If
the expanded value of ENV is not an absolute pathname, the results are unspecified. ENV shall be ignored if the
user's real and effective user IDs or real and effective group IDs are different.
HOME
The pathname of the user's home directory. The contents of HOME are used in tilde expansion (see 2.6.1 Tilde Expansion).
IFS
A string treated as a list of characters that is used for field splitting, expansion of the '*' special parameter, and
to split lines into fields with the read utility. If the value of IFS includes
any bytes that do not form part of a valid character, the results of field splitting, expansion of '*', and use of the
read utility are unspecified.
If IFS is not set, it shall behave as normal for an unset variable, except that field splitting by the shell
and line splitting by the read utility shall be performed as if the value of IFS
is ; see 2.6.5 Field Splitting.
The shell shall set IFS to  when it is invoked.
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
The value of this variable overrides the LC_* variables and LANG , as described in XBD 8. Environment Variables.
LC_COLLATE
Determine the behavior of range expressions, equivalence classes, and multi-character collating elements within pattern
matching.
LC_CTYPE
Determine the interpretation of sequences of bytes of text data as characters (for example, single-byte as opposed to
multi-byte characters), which characters are defined as letters (character class alpha) and  characters
(character class blank), and the behavior of character classes within pattern matching. Changing the value of
LC_CTYPE after the shell has started shall not affect the lexical processing of shell commands in the current shell
execution environment or its subshells. Invoking a shell script or performing exec sh subjects the new shell to the changes in LC_CTYPE .
LC_MESSAGES
Determine the language in which messages should be written.
LINENO
[UP]
The processing of the LINENO shell variable shall be supported if the system supports the User Portability Utilities option.
Set by the shell to a decimal number representing the current sequential line number (numbered starting with 1)
within a script or function before it executes each command. If the user unsets or resets LINENO , the variable may lose its
special meaning for the life of the shell. If the shell is not currently executing a script or function, the value of LINENO
is unspecified.
NLSPATH
[XSI]
Determine the location of message catalogs for the processing of LC_MESSAGES .
PATH
A string formatted as described in XBD 8. Environment Variables, used
to effect command interpretation; see 2.9.1.4 Command Search and Execution.
PPID
Set by the shell to the decimal value of its parent process ID during initialization of the shell. In a subshell (see 2.13 Shell Execution Environment), PPID shall be set to the same value as that of the parent of the
current shell. For example, echo $PPID and (echo $PPID ) would produce the same value.
PS1
[UP]
The processing of the PS1 shell variable shall be supported if the system supports the User Portability Utilities option.
Each time an interactive shell is ready to read a command, the value of this variable shall be subjected to
parameter expansion (see 2.6.2 Parameter Expansion) and exclamation-mark expansion (see below).
Whether the value is also subjected to command substitution (see 2.6.3 Command Substitution) or
arithmetic expansion (see 2.6.4 Arithmetic Expansion) or both is unspecified. After expansion, the
value shall be written to standard error.
The expansions shall be performed in two passes, where the result of the first pass is input to the second pass.
One of the passes shall perform only the exclamation-mark expansion described below. The other pass shall perform the other
expansion(s) according to the rules in 2.6 Word Expansions. Which of the two passes is performed first is
unspecified.
The default value shall be "$ ". For users who have specific additional implementation-defined
privileges, the default may be another, implementation-defined value.
Exclamation-mark expansion: The shell shall replace each instance of the  character
('!') with the history file number (see Command History List)
of the next command to be typed. An  character escaped by another  character (that
is, "!!") shall expand to a single  character.
PS2
[UP]
The processing of the PS2 shell variable shall be supported if the system supports the User Portability Utilities option.
Each time the user enters a  prior to completing a command line in an interactive shell, the value
of this variable shall be subjected to parameter expansion (see 2.6.2 Parameter Expansion). Whether
the value is also subjected to command substitution (see 2.6.3 Command Substitution) or arithmetic
expansion (see 2.6.4 Arithmetic Expansion) or both is unspecified. After expansion, the value shall be
written to standard error. The default value shall be "> ".
PS4
[UP]
The processing of the PS4 shell variable shall be supported if the system supports the User Portability Utilities option.
When an execution trace (set -x) is being performed, before each line in the
execution trace, the value of this variable shall be subjected to parameter expansion (see 2.6.2 Parameter
Expansion). Whether the value is also subjected to command substitution (see 2.6.3 Command
Substitution) or arithmetic expansion (see 2.6.4 Arithmetic Expansion) or both is unspecified.
After expansion, the value shall be written to standard error. The default value shall be "+ ".
PWD
Set by the shell and by the cd utility. In the shell the value shall be initialized
from the environment as follows. If a value for PWD is passed to the shell in the environment when it is executed, the value
is an absolute pathname of the current working directory that is no longer than {PATH_MAX} bytes including the terminating null
byte, and the value does not contain any components that are dot or dot-dot, then the shell shall set PWD to the value from
the environment. Otherwise, if a value for PWD is passed to the shell in the environment when it is executed, the value is
an absolute pathname of the current working directory, and the value does not contain any components that are dot or dot-dot, then
it is unspecified whether the shell sets PWD to the value from the environment or sets PWD to the pathname that would
be output by pwd -P. Otherwise, the sh
utility sets PWD to the pathname that would be output by pwd -P. In cases
where PWD is set to the value from the environment, the value can contain components that refer to files of type symbolic
link. In cases where PWD is set to the pathname that would be output by pwd
-P, if there is insufficient permission on the current working directory, or on any parent of that directory, to determine
what that pathname would be, the value of PWD is unspecified. Assignments to this variable may be ignored. If an application
sets or unsets the value of PWD , the behaviors of the cd and pwd utilities are unspecified.
2.6 Word Expansions
This section describes the various expansions that are performed on words. Not all expansions are performed on
every word, as explained in the following sections and elsewhere in this chapter. The expansions that are performed for a given
word shall be performed in the following order:
Tilde expansion (see 2.6.1 Tilde Expansion), parameter expansion (see 2.6.2 Parameter Expansion), command substitution (see 2.6.3 Command Substitution
), and arithmetic expansion (see 2.6.4 Arithmetic Expansion) shall be performed, beginning to end. See
item 5 in 2.3 Token Recognition.
Field splitting (see 2.6.5 Field Splitting) shall be performed on the portions of the
fields generated by step 1.
Pathname expansion (see 2.6.6 Pathname Expansion) shall be performed, unless set -f is in effect.
Quote removal (see 2.6.7 Quote Removal), if performed, shall always be performed
last.
Tilde expansions, parameter expansions, command substitutions, arithmetic expansions, and quote removals that occur
within a single word shall expand to a single field, except as described below. The shell shall create multiple fields or no fields
from a single word only as a result of field splitting, pathname expansion, or the following cases:
Parameter expansion of the special parameters '@' and '*', as described in 2.5.2 Special Parameters, can create multiple fields or no fields from a single word.
When the expansion occurs in a context where field splitting will be performed, a word that contains all of the
following somewhere within it, before any expansions are applied, in the order specified:
an unquoted  ('{') that is not immediately preceded by an unquoted
('$')
one or more unquoted  (',') characters or a sequence that consists of two adjacent
('.') characters surrounded by other characters (which can also be  characters)
an unquoted  ('}')
may be subject to an additional implementation-defined form of expansion that can create multiple fields from a
single word. This expansion, if supported, shall be applied before all the other word expansions are applied. The other expansions
shall then be applied to each field that results from this expansion.
When the expansions in this section are performed other than in the context of preparing a command for execution,
they shall be carried out in the current shell execution environment.
When expanding words for a command about to be executed, and the word will be the command name or an argument to
the command, the expansions shall be carried out in the current shell execution environment. (The environment for the command to be
executed is unknown until the command word is known.)
When expanding the words in a command about to be executed that are used with variable assignments or redirections,
it is unspecified whether the expansions are carried out in the current execution environment or in the environment of the command
about to be executed.
The '$' character is used to introduce parameter expansion, command substitution, or arithmetic
evaluation. If a '$' that is neither within single-quotes nor escaped by a  is immediately followed by a
character that is not a , not a , not a , and is not one of the following:
A numeric character
The name of one of the special parameters (see 2.5.2 Special Parameters)
A valid first character of a variable name
A  ('{')
A
A single-quote
the result is unspecified. If a '$' that is neither within single-quotes nor escaped by a
is immediately followed by a , , or a , or is not followed by any
character, the '$' shall be treated as a literal character.
2.6.1 Tilde Expansion
A "tilde-prefix" consists of an unquoted  character at the beginning of a word, followed by all of
the characters preceding the first unquoted  in the word, or all the characters in the word if there is no
. In an assignment (see XBD 4.26 Variable Assignment),
multiple tilde-prefixes can be used: one at the beginning of the word (that is, following the  of the
assignment), or one following any unquoted , or both. A tilde-prefix in an assignment is terminated by the first
unquoted  or , or the end of the assignment word.
If the tilde-prefix consists of only the  character, it shall be replaced by the value of the variable
HOME . If HOME is unset, the results are unspecified.
Otherwise, the characters in the tilde-prefix following the  shall be treated as a possible login name
from the user database. If these characters do not form a portable login name (see the description of the LOGNAME
environment variable in XBD 8.3 Other Environment Variables), the
results are unspecified.
Note:
Since the tilde-prefix is not subject to further word expansions after the  is removed to obtain the login name,
none of the following has a portable login name following the :
~"string"
~'string'
~$var
~\/bin
owing to the presence of '"', '\'', '$', '\\', and '/' characters in
the login name.
If the characters in the tilde-prefix following the  form a portable login name, the tilde-prefix
shall be replaced by a pathname of the initial working directory associated with the login name. The pathname shall be obtained as
if by using the getpwnam() function as defined in the System Interfaces volume of
POSIX.1-2024. If the system does not recognize the login name, the results are unspecified.
The pathname that replaces the tilde-prefix shall be treated as if quoted to prevent it being altered by field
splitting and pathname expansion; if a  follows the tilde-prefix and the pathname ends with a , the
trailing  from the pathname should be omitted from the replacement. If the word being expanded consists of only the
character and HOME is set to the null string, this produces an empty field (as opposed to zero fields) as the
expanded word.
Note:
A future version of this standard may require that if a  follows the tilde-prefix and the pathname ends with a
, the trailing  from the pathname is omitted from the replacement.
2.6.2 Parameter Expansion
The format for parameter expansion is as follows:
${expression}
where expression consists of all characters until the matching '}'. Any '}' escaped by a
or within a quoted string, and characters in embedded arithmetic expansions, command substitutions, and variable
expansions, shall not be examined in determining the matching '}'.
The simplest form for parameter expansion is:
${parameter}
The value, if any, of parameter shall be substituted.
The parameter name or symbol can be enclosed in braces, which are optional except for positional parameters with
more than one digit or when parameter is a name and is followed by a character that could be interpreted as part of the
name.
For a parameter that is not enclosed in braces:
If the parameter is a name, the expansion shall use the longest valid name (see XBD 3.216 Name), whether or not the variable denoted by that name exists.
Otherwise, the parameter is a single-character symbol, and behavior is unspecified if that character is neither a
digit nor one of the special parameters (see 2.5.2 Special Parameters).
In addition, a parameter expansion can be modified by using one of the following formats. In each case that a value
of word is needed (based on the state of parameter, as described below), word shall be subjected to tilde
expansion, parameter expansion, command substitution, arithmetic expansion, and quote removal. If word is not needed, it
shall not be expanded. The '}' character that delimits the following parameter expansion modifications shall be determined
as described previously in this section and in 2.2.3 Double-Quotes. If parameter is
'*' or '@', the result of the expansion is unspecified.
${parameter:-[word]}
Use Default Values. If parameter is unset or null, the expansion of word (or an empty string if
word is omitted) shall be substituted; otherwise, the value of parameter shall be substituted.
${parameter:=[word]}
Assign Default Values. If parameter is unset or null, quote removal shall be performed on the expansion of
word and the result (or an empty string if word is omitted) shall be assigned to parameter. In all cases, the
final value of parameter shall be substituted. Only variables, not positional parameters or special parameters, can be
assigned in this way.
${parameter:?[word]}
Indicate Error if Null or Unset. If parameter is unset or null, the expansion of word (or a message
indicating it is unset if word is omitted) shall be written to standard error and the shell exits with a non-zero exit
status. Otherwise, the value of parameter shall be substituted. An interactive shell need not exit.
${parameter:+[word]}
Use Alternative Value. If parameter is unset or null, null shall be substituted; otherwise, the expansion of
word (or an empty string if word is omitted) shall be substituted.
In the parameter expansions shown previously, use of the  in the format shall result in a test for a
parameter that is unset or null; omission of the  shall result in a test for a parameter that is only unset. If
parameter is '#' and the colon is omitted, the application shall ensure that word is specified (this is necessary
to avoid ambiguity with the string length expansion). The following table summarizes the effect of the :
parameter Set and Not Null
parameter Set But Null
parameter Unset
${parameter:-word}
substitute parameter
substitute word
substitute word
${parameter-word}
substitute parameter
substitute null
substitute word
${parameter:=word}
substitute parameter
assign word
assign word
${parameter=word}
substitute parameter
substitute null
assign word
${parameter:?word}
substitute parameter
error, exit
error, exit
${parameter?word}
substitute parameter
substitute null
error, exit
${parameter:+word}
substitute word
substitute null
substitute null
${parameter+word}
substitute word
substitute word
substitute null
In all cases shown with "substitute", the expression is replaced with the value shown. In all cases shown with
"assign", parameter is assigned that value, which also replaces the expression.
${#parameter}
String Length. The shortest decimal representation of the length in characters of the value of parameter shall be
substituted. If parameter is '*' or '@', the result of the expansion is unspecified. If parameter
is unset and set -u is in effect, the expansion shall fail.
The following four varieties of parameter expansion provide for character substring processing. In each case,
pattern matching notation (see 2.14 Pattern Matching Notation), rather than regular expression notation,
shall be used to evaluate the patterns. If parameter is '#', '*', or '@', the result of the
expansion is unspecified. If parameter is unset and set -u is in effect, the expansion
shall fail. Enclosing the full parameter expansion string in double-quotes shall not cause the following four varieties of pattern
characters to be quoted, whereas quoting characters within the braces shall have this effect. In each variety, if word is
omitted, the empty pattern shall be used.
${parameter%[word]}
Remove Smallest Suffix Pattern. The word shall be expanded to produce a pattern. The parameter expansion shall
then result in parameter, with the smallest portion of the suffix matched by the pattern deleted. If present,
word shall not begin with an unquoted '%'.
${parameter%%[word]}
Remove Largest Suffix Pattern. The word shall be expanded to produce a pattern. The parameter expansion shall
then result in parameter, with the largest portion of the suffix matched by the pattern deleted.
${parameter#[word]}
Remove Smallest Prefix Pattern. The word shall be expanded to produce a pattern. The parameter expansion shall
then result in parameter, with the smallest portion of the prefix matched by the pattern deleted. If present,
word shall not begin with an unquoted '#'.
${parameter##[word]}
Remove Largest Prefix Pattern. The word shall be expanded to produce a pattern. The parameter expansion shall
then result in parameter, with the largest portion of the prefix matched by the pattern deleted.
The following sections are informative.
Examples
${parameter}
In this example, the effects of omitting braces are demonstrated.
a=1
set 2
echo ${a}b-$ab-${1}0-${10}-$10
1b--20--20
${parameter-word}
This example demonstrates the difference between unset and set to the empty string, as well as the rules for finding the delimiting
close brace.
foo=asdf
echo ${foo-bar}xyz}
asdfxyz}
foo=
echo ${foo-bar}xyz}
xyz}
unset foo
echo ${foo-bar}xyz}
barxyz}
${parameter:-word}
In this example, ls is executed only if x is null or unset. (The $(ls) command substitution notation is explained in 2.6.3 Command
Substitution.)
${x:-$(ls)}
${parameter:=word}
unset X
echo ${X:=abc}
abc
${parameter:?word}
unset posix
echo ${posix:?}
sh: posix: parameter null or not set
${parameter:+word}
set a b c
echo ${3:+posix}
posix
${#parameter}
HOME=/usr/posix
echo ${#HOME}
10
${parameter%word}
x=file.c
echo ${x%.c}.o
file.o
${parameter%%word}
x=posix/src/std
echo ${x%%/*}
posix
${parameter#word}
x=$HOME/src/cmd
echo ${x#$HOME}
/src/cmd
${parameter##word}
x=/one/two/three
echo ${x##*/}
three
The double-quoting of patterns is different depending on where the double-quotes are placed:
"${x#*}"
The  is a pattern character.
${x#"*"}
The literal  is quoted and not special.
End of informative text.
2.6.3 Command Substitution
Command substitution allows the output of one or more commands to be substituted in place of the commands
themselves. Command substitution shall occur when command(s) are enclosed as follows:
$(commands)
or (backquoted version):
`commands`
The shell shall expand the command substitution by executing commands in a subshell environment (see
2.13 Shell Execution Environment) and replacing the command substitution (the text of the commands
string plus the enclosing "$()" or backquotes) with the standard output of the command(s); if the output ends with one or
more bytes that have the encoded value of a  character, they shall not be included in the replacement. Any such
bytes that occur elsewhere shall be included in the replacement; however, they might be treated as field delimiters and eliminated
during field splitting, depending on the value of IFS and quoting that is in effect. If the output contains any null bytes,
the behavior is unspecified.
Within the backquoted style of command substitution, if the command substitution is not within double-quotes,
shall retain its literal meaning, except when followed by: '$', '`', or . See
2.2.3 Double-Quotes for the handling of  when the command substitution is within
double-quotes. The search for the matching backquote shall be satisfied by the first unquoted non-escaped backquote; during this
search, if a non-escaped backquote is encountered within a shell comment, a here-document, an embedded command substitution of the
$(commands) form, or a quoted string, undefined results occur. A quoted string that begins, but does not end, within the
"`...`" sequence produces undefined results.
With the $(commands) form, all characters following the open parenthesis to the matching closing parenthesis
constitute the commands string.
With both the backquoted and $(commands) forms, the commands string shall be tokenized (see 2.3 Token Recognition) and parsed (see 2.10 Shell Grammar). It is unspecified whether
the commands string is parsed and executed incrementally as a program (as for a shell script), or is parsed as a
single compound_list that is executed after the string has been completely parsed. In addition, it is unspecified whether
the terminating ')' of the $(commands) form can result from alias substitution. With the $(commands) form
any syntactically correct program can be used for commands, except that:
If the commands string consists solely of redirections, the results are unspecified.
If the commands string is parsed as a single compound_list, before any commands are executed,
alias and unalias commands in
commands have no effect during parsing (see 2.3.1 Alias Substitution). Strictly conforming
applications shall ensure that the commands string does not depend on alias changes taking effect incrementally as would be
the case if parsed and executed as a program.
The behavior is unspecified if the terminating ')' is not present in the token containing the command
substitution; that is, if the ')' is expected to result from alias substitution.
The results of command substitution shall not be processed for further tilde expansion, parameter expansion,
command substitution, or arithmetic expansion.
Command substitution can be nested. To specify nesting within the backquoted version, the application shall precede
the inner backquotes with  characters; for example:
\`commands\`
The syntax of the shell command language has an ambiguity for expansions beginning with "$((", which can
introduce an arithmetic expansion or a command substitution that starts with a subshell. Arithmetic expansion has precedence; that
is, the shell shall first determine whether it can parse the expansion as an arithmetic expansion and shall only parse the
expansion as a command substitution if it determines that it cannot parse the expansion as an arithmetic expansion. The shell need
not evaluate nested expansions when performing this determination. If it encounters the end of input without already having
determined that it cannot parse the expansion as an arithmetic expansion, the shell shall treat the expansion as an incomplete
arithmetic expansion and report a syntax error. A conforming application shall ensure that it separates the "$(" and
'(' into two tokens (that is, separate them with white space) in a command substitution that starts with a subshell. For
example, a command substitution containing a single subshell could be written as:
$( (commands) )
2.6.4 Arithmetic Expansion
Arithmetic expansion provides a mechanism for evaluating an arithmetic expression and substituting its value. The
format for arithmetic expansion shall be as follows:
$((expression))
The expression shall be treated as if it were in double-quotes, except that a double-quote inside the expression is
not treated specially. The shell shall expand all tokens in the expression for parameter expansion, command substitution, and quote
removal.
arithmetic expression shall be processed according to the rules given in 1.1.2.1 Arithmetic Precision and Operations, with the following
exceptions:
Only signed long integer arithmetic is required.
Only the decimal-constant, octal-constant, and hexadecimal-constant constants specified in the ISO C
standard, Section 6.4.4.1 are required to be recognized as constants.
The sizeof() operator and the prefix and postfix "++" and "--" operators are not
required.
Selection, iteration, and jump statements are not supported.
All changes to variables in an arithmetic expression shall be in effect after the arithmetic expansion, as in the
parameter expansion "${x=value}".
If the shell variable x contains a value that forms a valid integer constant, optionally including a leading
or , then the arithmetic expansions "$((x))" and "$(($x))" shall return the
same value.
As an extension, the shell may recognize arithmetic expressions beyond those listed. The shell may use a signed
integer type with a rank larger than the rank of signed long. The shell may use a real-floating type instead of signed
long as long as it does not affect the results in cases where there is no overflow. If the expression is invalid, or the
contents of a shell variable used in the expression are not recognized by the shell, the expansion fails and the shell shall write
a diagnostic message to standard error indicating the failure.
The following sections are informative.
Examples
A simple example using arithmetic expansion:
# repeat a command 100 times
x=100
while [ $x -gt 0 ]
do
command
x=$(($x-1))
done
End of informative text.
2.6.5 Field Splitting
After parameter expansion ( 2.6.2 Parameter Expansion), command substitution (
2.6.3 Command Substitution), and arithmetic expansion ( 2.6.4 Arithmetic
Expansion), if the shell variable IFS (see 2.5.3 Shell Variables) is set and its value is
not empty, or if IFS is unset, the shell shall scan each field containing results of expansions and substitutions that did
not occur in double-quotes for field splitting; zero, one or multiple fields can result.
For the remainder of this section, any reference to the results of an expansion, or results of expansions, shall be
interpreted to mean the results from one or more unquoted variable or arithmetic expansions, or unquoted command substitutions.
If the IFS variable is set and has an empty string as its value, no field splitting shall occur. However, if
an input field which contained the results of an expansion is entirely empty, it shall be removed. Note that this occurs before
quote removal; any input field that contains any quoting characters can never be empty at this point. After the removal of any such
fields from the input, the possibly modified input field list shall become the output.
Each input field shall be considered in sequence, first to last, with the results of the algorithm described in
this section causing output fields to be generated, which shall remain in the same order as the input fields from which they
originated.
Fields which contain no results from expansions shall not be affected by field splitting, and shall remain
unaltered, simply moving from the list of input fields to be next in the list of output fields.
In the remainder of this description, it is assumed that there is present in the field at least one expansion
result; this assumption will not be restated. Field splitting only ever alters those parts of the field.
For the purposes of this section, the term "IFS white space" is used to mean any of the white-space bytes
(see XBD 3.413 White Space, 3.414 White-Space Byte, and 3.415 White-Space Character) , , or
from the portable character set (see XBD 6.1 Portable Character Set)
which are present in the value of the IFS variable, and perhaps other white-space characters. It is implementation-defined
whether other white-space characters which appear in the value of IFS are also considered as "IFS white space". The
three characters above specified as IFS white-space bytes are always IFS white space, when they occur in the value of
IFS , regardless of whether they are white-space characters in any relevant locale. For other locale-specific white-space
characters allowed by the implementation it is unspecified whether the character is considered as IFS white space if it is
white space at the time it is assigned to the IFS variable, or if it is white space at the time field splitting occurs. (The
locale might have changed between those events.)
If the IFS variable is unset, then for the purposes of this section, but without altering the value of the
variable, its value shall be considered to contain the three single-byte characters , , and
from the portable character set, all of which are IFS white-space characters.
The shell shall use the byte sequences that form the characters in the value of the IFS variable as
delimiters. Each of the characters , , and  which appears in the value of IFS shall
be a single-byte delimiter. The shell shall use these delimiters as field terminators to split the results of expansions, along
with other adjacent bytes, into separate fields, as described below. Note that these delimiters terminate a field; they do not, of
themselves, cause a new field to start—subsequent bytes that are not from the results of an expansion, or that do not form
IFS white-space characters are required for a new field to begin.
Note that the shell processes arbitrary bytes from the input fields; there is no requirement that those bytes form
valid characters.
If the results of the algorithm are that no fields are delimited; that is, if the input field is wholly empty or
consists entirely of IFS white space, the result shall be zero fields (rather than an empty field).
For the purposes of this section, when a field is said to be delimited, then the candidate field, as generated
below shall become an output field. When the algorithm transforms a candidate into an output field it shall be appended to the
current list of output fields.
Each field containing the results from an expansion shall be processed in order, intermixed with fields not
containing the results of expansions, processed as described above, as if by using the following algorithm, examining bytes in the
input field, from beginning to end:
Begin with an empty candidate field and the input as specified above.
When instructed to start the next iteration of the loop, this is the start of the loop. While the input (as
modified by earlier iterations of this loop) is not empty:
Consider the leading remaining byte or byte sequence of the input. No such byte sequence shall contain data such
that some bytes in the sequence resulted from an expansion, and others did not, nor which contains bytes resulting from the results
of more than one expansion. If the byte or sequence of bytes is:
A byte (or sequence of bytes) in the input which did not result from an expansion:
Append this byte (or sequence) to the candidate, and remove it from the input. Start the next iteration of the
loop.
A byte sequence in the input which resulted from an expansion and which does not form a character in IFS :
Append the first byte of the sequence to the candidate, and remove that byte from the input. Start the next
iteration of the loop.
A byte sequence in the input which resulted from an expansion and which forms an IFS white space character:
Remove that byte sequence from the input, consider the new leading input byte sequence, and repeat this step.
A byte sequence in the input which resulted from an expansion and which forms an IFS character that is not
IFS white space:
Remove that byte sequence from the input, but note it was observed.
At this point, if the candidate is not empty, or if a sequence of bytes representing an IFS character that
is not IFS white space was seen at step 4, then a field is said to have been delimited, and the candidate shall become an
output field.
Empty (clear) the candidate, and start the next iteration of the loop.
Once the input is empty, the candidate shall become an output field if and only if it is not empty.
The ordered list of output fields so produced, which might be empty, shall replace the list of input fields.
2.6.6 Pathname Expansion
After field splitting, if set -f is not in effect, each field in the resulting
command line shall be expanded using the algorithm described in 2.14 Pattern Matching Notation, qualified
by the rules in 2.14.3 Patterns Used for Filename Expansion.
2.6.7 Quote Removal
The quote character sequence  single-quote and the single-character quote characters
(, single-quote, and double-quote) that were present in the original word shall be removed unless they have
themselves been quoted. Note that the single-quote character that terminates a  single-quote sequence is itself
a single-character quote character.
Note:
After quote removal the shell still remembers which characters were quoted. This is necessary for purposes such as matching
patterns in a case conditional construct (see 2.9.4.3 Case Conditional Construct and 2.14 Pattern Matching Notation).
2.7 Redirection
Redirection is used to open and close files for the current shell execution environment (see 2.13 Shell Execution Environment) or for any command. Redirection operators can be used with numbers representing
file descriptors (see XBD 3.141 File Descriptor) as described
below.
The overall format used for redirection is:
[n]redir-op word
The number n is an optional one or more digit decimal number designating the file descriptor number; the
application shall ensure it is delimited from any preceding text and immediately precedes the redirection operator redir-op
(with no intervening  characters allowed). If n is quoted, the number shall not be recognized as part of the
redirection expression. For example:
echo \2>a
writes the character 2 into file a. If any part of redir-op is quoted, no redirection expression is
recognized. For example:
echo 2\>a
writes the characters 2>a to standard output. The optional number, redirection operator, and word
shall not appear in the arguments provided to the command to be executed (if any).
The shell may support an additional format used for redirection:
{location}redir-op word
where location is non-empty and indicates a location where an integer value can be stored, such as the name
of a shell variable. If this format is supported its behavior is implementation-defined.
The largest file descriptor number supported in shell redirections is implementation-defined; however, all
implementations shall support at least 0 to 9, inclusive, for use by the application.
If the redirection operator is "word
[n]>|word
where the optional n represents the file descriptor number. If the number is omitted, the redirection shall
refer to standard output (file descriptor 1).
Output redirection using the '>' format shall fail if the noclobber option is set (see the
description of set -C) and the file named by the expansion of word exists and is either a
regular file or a symbolic link that resolves to a regular file; it may also fail if the file is a symbolic link that does not
resolve to an existing file. The check for existence, file creation, and open operations shall be performed atomically as is done
by the open() function as defined in System Interfaces volume of POSIX.1-2024 when the
O_CREAT and O_EXCL flags are set, except that if the file exists and is a symbolic link, the open operation need not fail with
[EEXIST] unless the symbolic link resolves to an existing regular file. Performing these operations atomically ensures that the
creation of lock files and unique (often temporary) files is reliable, with important caveats detailed in C.2.7.2 Redirecting Output. The check for the type of the file need not be
performed atomically with the check for existence, file creation, and open operations. If not, there is a potential race condition
that may result in a misleading shell diagnostic message when redirection fails. See XRAT C.2.7.2 Redirecting Output for more details.
In all other cases (noclobber not set, redirection using '>' does not fail for the reasons
stated above, or redirection using the ">|" format), output redirection shall cause the file whose name results from
the expansion of word to be opened for output on the designated file descriptor, or standard output if none is specified. If
the file does not exist, it shall be created as an empty file; otherwise, it shall be opened as if the open() function was called with the O_TRUNC flag set.
2.7.3 Appending Redirected Output
Appended output redirection shall cause the file whose name results from the expansion of word to be opened for
output on the designated file descriptor. The file shall be opened as if the open()
function as defined in the System Interfaces volume of POSIX.1-2024 was called with the O_APPEND flag set. If the file does not
exist, it shall be created.
The general format for appending redirected output is as follows:
[n]>>word
where the optional n represents the file descriptor number. If the number is omitted, the redirection refers
to standard output (file descriptor 1).
2.7.4 Here-Document
The redirection operators ", with no  characters in between. Then the
next here-document starts, if there is one. For the purposes of locating this terminating line, the end of a command_string
operand (see sh) shall be treated as a  character, and the end of the
commands string in $(commands) and `commands` may be treated as a . If the
end of input is reached without finding the terminating line, the shell should, but need not, treat this as a redirection error.
The format is as follows:
[n] for line continuation (see 2.2.1 Escape
Character (Backslash)) shall be performed during the search for the trailing delimiter. (As a consequence, the trailing
delimiter is not recognized immediately after a  that was removed by line continuation.) It is unspecified whether
the line containing the trailing delimiter is itself subject to this line continuation.
All lines of the here-document shall be expanded, when the redirection operator is evaluated but after the
trailing delimiter for the here-document has been located, for parameter expansion, command substitution, and arithmetic expansion.
If the redirection operator is never evaluated (because the command it is part of is not executed), the here-document shall be read
without performing any expansions.
Any  characters in the input shall behave as the  inside double-quotes (see
2.2.3 Double-Quotes). However, the double-quote character ('"') shall not be treated
specially within a here-document, except when the double-quote appears within "$()", "``", or
"${}".
If the redirection operator is " characters shall be stripped from
input lines after  line continuation (when it applies) has been performed, and from the line
containing the trailing delimiter. Stripping of leading  characters shall occur as the here-document is read from the
shell input (and consequently does not affect any  characters that result from expansions).
If more than one "&word
shall duplicate one output file descriptor from another, or shall close one. If word evaluates to one or
more digits, the file descriptor denoted by n, or standard output if n is not specified, shall be made to be a copy
of the file descriptor denoted by word; if the digits in word do not represent an already open file descriptor, a
redirection error shall result (see 2.8.1 Consequences of Shell Errors); if the file descriptor
denoted by word represents an open file descriptor that is not open for output, a redirection error may result. If
word evaluates to '-', file descriptor n, or standard output if n is not specified, is closed.
Attempts to close a file descriptor that is not open shall not constitute an error. If word evaluates to something else, the
behavior is unspecified.
2.7.7 Open File Descriptors for Reading and Writing
The redirection operator:
[n]<>word
shall cause the file whose name is the expansion of word to be opened for both reading and writing on the
file descriptor denoted by n, or standard input if n is not specified. If the file does not exist, it shall be
created.
2.8 Exit Status and Errors
2.8.1 Consequences of Shell Errors
Certain errors shall cause the shell to write a diagnostic message to standard error and exit as shown in the
following table:
Error
Non-Interactive
Shell
Interactive Shell
Shell Diagnostic
Message Required
Shell language syntax error
shall exit
shall not exit
yes
Special built-in utility error
shall exit1
shall not exit
no2
Other utility (not a special
built-in) error
shall not exit
shall not exit
no3
Redirection error with
special built-in utilities
shall exit
shall not exit
yes
Redirection error with
compound commands
shall not exit
shall not exit
yes
Redirection error with
function execution
shall not exit
shall not exit
yes
Redirection error with other
utilities (not special built-ins)
shall not exit
shall not exit
yes
Variable assignment error
shall exit
shall not exit
yes
Expansion error
shall exit
shall not exit
yes
Command not found
may exit
shall not exit
yes
Unrecoverable read error
when reading commands
shall exit4
shall exit4
yes
Notes:
The shell shall exit only if the special built-in utility is executed directly. If it is executed via the command utility, the shell shall not exit.
Although special built-ins are part of the shell, a diagnostic message written by a special built-in is not
considered to be a shell diagnostic message, and can be redirected like any other utility.
The shell is not required to write a diagnostic message, but the utility itself shall write a diagnostic message
if required to do so.
If an unrecoverable read error occurs when reading commands, other than from the file operand of the
dot special built-in, the shell shall execute no further commands (including any already successfully
read but not yet executed) other than any specified in a previously defined EXIT trap action. An
unrecoverable read error while reading from the file operand of the dot special built-in shall be
treated as a special built-in utility error.
An expansion error is one that occurs when the shell expansions defined in 2.6 Word
Expansions are carried out (for example, "${x!y}", because '!' is not a valid operator); an implementation
may treat these as syntax errors if it is able to detect them during tokenization, rather than during expansion.
If any of the errors shown as "shall exit" or "may exit" occur in a subshell environment, the shell shall
(respectively, may) exit from the subshell environment with a non-zero status and continue in the environment from which that
subshell environment was invoked.
In all of the cases shown in the table where an interactive shell is required not to exit and a non-interactive
shell is required to exit, an interactive shell shall not perform any further processing of the command in which the error
occurred.
2.8.2 Exit Status for Commands
Each command has an exit status that can influence the behavior of other shell commands. The exit status of
commands that are not utilities is documented in this section. The exit status of the standard utilities is documented in their
respective sections.
The exit status of a command shall be determined as follows:
If the command is not found, the exit status shall be 127.
Otherwise, if the command name is found, but it is not an executable utility, the exit status shall be 126.
Otherwise, if the command terminated due to the receipt of a signal, the shell shall assign it an exit status
greater than 128. The exit status shall identify, in an implementation-defined manner, which signal terminated the command. Note
that shell implementations are permitted to assign an exit status greater than 255 if a command terminates due to a signal.
Otherwise, the exit status shall be the value obtained by the equivalent of the WEXITSTATUS macro applied to the
status obtained by the wait() function (as defined in the System Interfaces volume of
POSIX.1-2024). Note that for C programs, this value is equal to the result of performing a modulo 256 operation on the value passed
to _Exit(), _exit(), or exit() or returned from main().
2.9 Shell Commands
This section describes the basic structure of shell commands. The following command descriptions each describe a
format of the command that is only used to aid the reader in recognizing the command type, and does not formally represent the
syntax. In particular, the representations include spacing between tokens in some places where s would not be
necessary (when one of the tokens is an operator). Each description discusses the semantics of the command; for a formal definition
of the command language, consult 2.10 Shell Grammar.
A command is one of the following:
Simple command (see 2.9.1 Simple Commands)
Pipeline (see 2.9.2 Pipelines)
List compound-list (see 2.9.3 Lists)
Compound command (see 2.9.4 Compound Commands)
Function definition (see 2.9.5 Function Definition Command)
Unless otherwise stated, the exit status of a command shall be that of the last simple command executed by the
command. There shall be no limit on the size of any shell command other than that imposed by the underlying system (memory
constraints, {ARG_MAX}, and so on).
2.9.1 Simple Commands
A "simple command" is a sequence of optional variable assignments and redirections, in any sequence, optionally
followed by words and redirections.
2.9.1.1 Order of Processing
When a given simple command is required to be executed (that is, when any conditional construct such as an AND-OR
list or a case statement has not bypassed the simple command), the following expansions, assignments, and redirections shall
all be performed from the beginning of the command text to the end:
The words that are recognized as variable assignments or redirections according to 2.10.2
Shell Grammar Rules are saved for processing in steps 3 and 4.
The first word (if any) that is not a variable assignment or redirection shall be expanded. If any fields remain
following its expansion, the first field shall be considered the command name. If no fields remain, the next word (if any) shall be
expanded, and so on, until a command name is found or no words remain. If there is a command name and it is recognized as a
declaration utility, then any remaining words after the word that expanded to produce the command name, that would be recognized as
a variable assignment in isolation, shall be expanded as a variable assignment (tilde expansion after the first
and after any unquoted , parameter expansion, command substitution, arithmetic expansion, and quote removal, but no
field splitting or pathname expansion); while remaining words that would not be a variable assignment in isolation shall be subject
to regular expansion (tilde expansion for only a leading , parameter expansion, command substitution, arithmetic
expansion, field splitting, pathname expansion, and quote removal). For all other command names, words after the word that produced
the command name shall be subject only to regular expansion. All fields resulting from the expansion of the word that produced the
command name and the subsequent words, except for the field containing the command name, shall be the arguments for the
command.
Redirections shall be performed as described in 2.7 Redirection.
Each variable assignment shall be expanded for tilde expansion, parameter expansion, command substitution,
arithmetic expansion, and quote removal prior to assigning the value.
In the preceding list, the order of steps 3 and 4 may be reversed if no command name results from step 2 or if the
command name matches the name of a special built-in utility; see 2.15 Special Built-In Utilities.
When determining whether a command name is a declaration utility, an implementation may use only lexical analysis.
It is unspecified whether assignment context will be used if the command name would only become recognized as a declaration utility
after word expansions.
2.9.1.2 Variable Assignments
Variable assignments shall be performed as follows:
If no command name results, variable assignments shall affect the current execution environment.
If the command name is not a special built-in utility or function, the variable assignments shall be exported for
the execution environment of the command and shall not affect the current execution environment except as a side-effect of the
expansions performed in step 4. In this case it is unspecified:
Whether or not the assignments are visible for subsequent expansions in step 4
Whether variable assignments made as side-effects of these expansions are visible for subsequent expansions in
step 4, or in the current shell execution environment, or both
If the command name is a standard utility implemented as a function (see XBD 4.25 Utility), the effect of variable assignments shall be as if the utility was
not implemented as a function.
If the command name is a special built-in utility, variable assignments shall affect the current execution
environment before the utility is executed and remain in effect when the command completes; if an assigned variable is further
modified by the utility, the modifications made by the utility shall persist. Unless the set -a
option is on (see set), it is unspecified:
Whether or not the variables gain the export attribute during the execution of the special built-in
utility
Whether or not export attributes gained as a result of the variable assignments persist after the
completion of the special built-in utility
If the command name is a function that is not a standard utility implemented as a function, variable assignments
shall affect the current execution environment during the execution of the function. It is unspecified:
Whether or not the variable assignments persist after the completion of the function
Whether or not the variables gain the export attribute during the execution of the function
Whether or not export attributes gained as a result of the variable assignments persist after the
completion of the function (if variable assignments persist after the completion of the function)
If any of the variable assignments attempt to assign a value to a variable for which the readonly attribute
is set in the current shell environment (regardless of whether the assignment is made in that environment), a variable assignment
error shall occur. See 2.8.1 Consequences of Shell Errors for the consequences of these errors.
2.9.1.3 Commands with no Command Name
If a simple command has no command name after word expansion (see 2.9.1.1 Order of
Processing), any redirections shall be performed in a subshell environment; it is unspecified whether this subshell
environment is the same one as that used for a command substitution within the command. (To affect the current execution
environment, see the exec special built-in.) If any of the redirections performed in the current shell
execution environment fail, the command shall immediately fail with an exit status greater than zero, and the shell shall write an
error message indicating the failure. See 2.8.1 Consequences of Shell Errors for the consequences of
these failures on interactive and non-interactive shells.
Additionally, if there is no command name but the command contains a command substitution, the command shall
complete with the exit status of the command substitution whose exit status was the last to be obtained. Otherwise, the command
shall complete with a zero exit status.
2.9.1.4 Command Search and Execution
If a simple command has a command name and an optional list of arguments after word expansion (see 2.9.1.1 Order of Processing), the following actions shall be performed:
If the command name does not contain any  characters, the first successful step in the following
sequence shall occur:
If the command name matches the name of a special built-in utility, that special built-in utility shall be
invoked.
If the command name matches the name of a utility listed in the following table, the results are unspecified.
alloc
autoload
bind
bindkey
builtin
bye
caller
cap
chdir
clone
comparguments
compcall
compctl
compdescribe
compfiles
compgen
compgroups
complete
compound
compquote
comptags
comptry
compvalues
declare
dirs
disable
disown
dosh
echotc
echoti
enum
float
help
history
hist
integer
let
local
login
logout
map
mapfile
nameref
popd
print
pushd
readarray
repeat
savehistory
source
shopt
stop
suspend
typeset
whence
If the command name matches the name of a function known to this shell, the function shall be invoked as described
in 2.9.5 Function Definition Command. If the implementation has provided a standard utility in the
form of a function, and that function definition still exists (i.e. has not been removed using unset
-f or replaced via another function definition with the same name), it shall not be recognized at this point. It shall be
invoked in conjunction with the path search in step 1e.
If the command name matches the name of an intrinsic utility (see 1.7 Intrinsic Utilities), that utility shall be invoked.
Otherwise, the command shall be searched for using the PATH environment variable as described in XBD
8. Environment Variables:
If the search is successful:
If the system has implemented the utility as a built-in or as a shell function, and the built-in or function is
associated with the directory that was most recently tested during the successful PATH search, that built-in or function
shall be invoked.
Otherwise, the shell shall execute a non-built-in utility as described in 2.9.1.6
Non-built-in Utility Execution.
Once a utility has been searched for and found (either as a result of this specific search or as part of an
unspecified shell start-up activity), an implementation may remember its location and need not search for the utility again unless
the PATH variable has been the subject of an assignment. If the remembered location fails for a subsequent invocation, the
shell shall repeat the search to find the new location for the utility, if any.
If the search is unsuccessful, the command shall fail with an exit status of 127 and the shell shall write an
error message.
If the command name contains at least one , the shell shall execute a non-built-in utility as
described in 2.9.1.6 Non-built-in Utility Execution.
2.9.1.5 Standard File Descriptors
If the utility would be executed with file descriptor 0, 1, or 2 closed, implementations may execute the utility
with the file descriptor open to an unspecified file. If a standard utility or a conforming application is executed with file
descriptor 0 not open for reading or with file descriptor 1 or 2 not open for writing, the environment in which the utility or
application is executed shall be deemed non-conforming, and consequently the utility or application might not behave as described
in this standard.
2.9.1.6 Non-built-in Utility Execution
When the shell executes a non-built-in utility, if the execution is not being made via the exec special
built-in utility, the shell shall execute the utility in a separate utility environment (see 2.13 Shell
Execution Environment).
If the execution is being made via the exec special built-in utility, the shell shall
not create a separate utility environment for this execution; the new process image shall replace the current shell execution
environment. If the current shell environment is a subshell environment, the new process image shall replace the subshell
environment and the shell shall continue in the environment from which that subshell environment was invoked.
In either case, execution of the utility in the specified environment shall be performed as follows:
If the command name does not contain any  characters, the command name shall be searched for using
the PATH environment variable as described in XBD 8. Environment
Variables:
If the search is successful, the shell shall execute the utility with actions equivalent to calling the execl() function as defined in the System Interfaces volume of POSIX.1-2024 with the
path argument set to the pathname resulting from the search, arg0 set to the command name, and the remaining execl() arguments set to the command arguments (if any) and the null terminator.
If the execl() function fails due to an error equivalent to the
[ENOEXEC] error defined in the System Interfaces volume of POSIX.1-2024, the shell shall execute a command equivalent to having a
shell invoked with the pathname resulting from the search as its first operand, with any remaining arguments passed to the new
shell, except that the value of "$0" in the new shell may be set to the command name. The shell may apply a heuristic
check to determine if the file to be executed could be a script and may bypass this command execution if it determines that the
file cannot be a script. In this case, it shall write an error message, and the command shall fail with an exit status of 126.
Note:
A common heuristic for rejecting files that cannot be a script is locating a NUL byte prior to a  byte within a
fixed-length prefix of the file. Since sh is required to accept input files with
unlimited line lengths, the heuristic check cannot be based on line length.
It is unspecified whether environment variables that were passed to the shell when it was invoked, but were not
used to initialize shell variables (see 2.5.3 Shell Variables) because they had invalid names, are
included in the environment passed to execl() and (if execl() fails as described above) to the new shell.
If the search is unsuccessful, the command shall fail with an exit status of 127 and the shell shall write an
error message.
If the command name contains at least one :
If the named utility exists, the shell shall execute the utility with actions equivalent to calling the execl() function defined in the System Interfaces volume of POSIX.1-2024 with the path
and arg0 arguments set to the command name, and the remaining execl() arguments
set to the command arguments (if any) and the null terminator.
If the execl() function fails due to an error equivalent to the
[ENOEXEC] error, the shell shall execute a command equivalent to having a shell invoked with the command name as its first operand,
with any remaining arguments passed to the new shell. The shell may apply a heuristic check to determine if the file to be executed
could be a script and may bypass this command execution if it determines that the file cannot be a script. In this case, it shall
write an error message, and the command shall fail with an exit status of 126.
Note:
A common heuristic for rejecting files that cannot be a script is locating a NUL byte prior to a  byte within a
fixed-length prefix of the file. Since sh is required to accept input files with
unlimited line lengths, the heuristic check cannot be based on line length.
It is unspecified whether environment variables that were passed to the shell when it was invoked, but were not
used to initialize shell variables (see 2.5.3 Shell Variables) because they had invalid names, are
included in the environment passed to execl() and (if execl() fails as described above) to the new shell.
If the named utility does not exist, the command shall fail with an exit status of 127 and the shell shall write
an error message.
2.9.2 Pipelines
A pipeline is a sequence of one or more commands separated by the control operator '|'. For each
command but the last, the shell shall connect the standard output of the command to the standard input of the next command as if by
creating a pipe and passing the write end of the pipe as the standard output of the command and the read end of the pipe as the
standard input of the next command.
The format for a pipeline is:
[!] command1 [ | command2 ...]
If the pipeline begins with the reserved word ! and command1 is a subshell command, the application
shall ensure that the ( operator at the beginning of command1 is separated from the ! by one or more
characters. The behavior of the reserved word ! immediately followed by the ( operator is
unspecified.
The standard output of command1 shall be connected to the standard input of command2. The standard
input, standard output, or both of a command shall be considered to be assigned by the pipeline before any redirection specified by
redirection operators that are part of the command (see 2.7 Redirection).
If the pipeline is not in the background (see 2.9.3.1 Asynchronous AND-OR Lists and
2.11 Job Control), the shell shall wait for the last command specified in the pipeline to complete, and
may also wait for all commands to complete.
Exit Status
The exit status of a pipeline shall depend on whether or not the pipefail option (see set) is enabled and whether or not the pipeline begins with the ! reserved word, as described in the
following table. The pipefail option determines which command in the pipeline the exit status is derived from; the !
reserved word causes the exit status to be the logical NOT of the exit status of that command. The shell shall use the
pipefail setting at the time it begins execution of the pipeline, not the setting at the time it sets the exit status of the
pipeline. (For example, in command1 | set -o pipefail the exit status of command1 has no effect on the exit
status of the pipeline, even if the shell executes set -o pipefail in the current shell environment.)
pipefail Enabled
Begins with !
Exit Status
no
no
The exit status of the last (rightmost) command specified in the pipeline.
no
yes
Zero, if the last (rightmost) command in the pipeline returned a non-zero exit status; otherwise, 1.
yes
no
Zero, if all commands in the pipeline returned an exit status of 0; otherwise, the exit status of the last
(rightmost) command specified in the pipeline that returned a non-zero exit status.
yes
yes
Zero, if any command in the pipeline returned a non-zero exit status; otherwise, 1.
2.9.3 Lists
An AND-OR list is a sequence of one or more pipelines separated by the operators "&&" and
"||".
A list is a sequence of one or more AND-OR lists separated by the operators ';' and
'&'.
The operators "&&" and "||" shall have equal precedence and shall be evaluated with left
associativity. For example, both of the following commands write solely bar to standard output:
false && echo foo || echo bar
true || echo foo && echo bar
A ';' separator or a ';' or  terminator shall cause the preceding AND-OR list to
be executed sequentially; an '&' separator or terminator shall cause asynchronous execution of the preceding AND-OR
list.
The term "compound-list" is derived from the grammar in 2.10 Shell Grammar; it is
equivalent to a sequence of lists, separated by  characters, that can be preceded or followed by an arbitrary
number of  characters.
The following sections are informative.
Examples
The following is an example that illustrates  characters in compound-lists:
while
# a couple of s
# a list
date && who || ls; cat file
# a couple of s
# another list
wc file > output & true
do
# 2 lists
ls
cat file
done
End of informative text.
2.9.3.1 Asynchronous AND-OR Lists
If an AND-OR list is terminated by the control operator  ('&'), the shell shall
execute the AND-OR list asynchronously in a subshell environment. This subshell shall execute in the background; that is, the shell
shall not wait for the subshell to terminate before executing the next command (if any); if there are no further commands to
execute, the shell shall not wait for the subshell to terminate before exiting.
If job control is enabled (see set, -m), the AND-OR list shall become a
job-control background job and a job number shall be assigned to it. If job control is disabled, the AND-OR list may become a
non-job-control background job, in which case a job number shall be assigned to it; if no job number is assigned it shall become a
background command but not a background job.
A job-control background job can be controlled as described in 2.11 Job Control.
The process ID associated with the asynchronous AND-OR list shall become known in the current shell execution
environment; see 2.13 Shell Execution Environment. This process ID shall remain known until any one of
the following occurs (and, unless otherwise specified, may continue to remain known after it occurs).
The process terminates and the application waits for the process ID or the corresponding job ID (see wait).
If the asynchronous AND-OR list did not become a background job: another asynchronous AND-OR list is invoked
before "$!" (corresponding to the previous asynchronous AND-OR list) is expanded in the current shell execution
environment.
If the asynchronous AND-OR list became a background job: the jobs
utility reports the termination status of that job.
If the shell is interactive and the asynchronous AND-OR list became a background job: a message indicating
completion of the corresponding job is written to standard error. If set -b is enabled, it is
unspecified whether the process ID is removed from the list of known process IDs when the message is written or immediately prior
to when the shell writes the next prompt for input.
The implementation need not retain more than the {CHILD_MAX} most recent entries in its list of known process IDs
in the current shell execution environment.
If, and only if, job control is disabled, the standard input for the subshell in which an asynchronous AND-OR list
is executed shall initially be assigned to an open file description that behaves as if /dev/null had been opened for reading
only. This initial assignment shall be overridden by any explicit redirection of standard input within the AND-OR list.
If the shell is interactive and the asynchronous AND-OR list became a background job, the job number and the
process ID associated with the job shall be written to standard error using the format:
"[%d] %d\n", ,
If the shell is interactive and the asynchronous AND-OR list did not become a background job, the process ID
associated with the asynchronous AND-OR list shall be written to standard error in an unspecified format.
Exit Status
The exit status of an asynchronous AND-OR list shall be zero.
The exit status of the subshell in which the AND-OR list is asynchronously executed can be obtained using the
wait utility.
2.9.3.2 Sequential AND-OR Lists
AND-OR lists that are separated by a  (';') shall be executed sequentially. The format
for executing AND-OR lists sequentially shall be:
aolist1 [; aolist2] ...
Each AND-OR list shall be expanded and executed in the order specified.
If job control is enabled, the AND-OR lists shall form all or part of a foreground job that can be controlled as
described in 2.11 Job Control.
Exit Status
The exit status of a sequential AND-OR list shall be the exit status of the last pipeline in the AND-OR list that
is executed.
2.9.3.3 AND Lists
The control operator "&&" denotes an AND list. The format shall be:
command1 [ && command2] ...
First command1 shall be executed. If its exit status is zero, command2 shall be executed, and so on,
until a command has a non-zero exit status or there are no more commands left to execute. The commands are expanded only if they
are executed.
Exit Status
The exit status of an AND list shall be the exit status of the last command that is executed in the list.
2.9.3.4 OR Lists
The control operator "||" denotes an OR List. The format shall be:
command1 [ || command2] ...
First, command1 shall be executed. If its exit status is non-zero, command2 shall be executed, and so
on, until a command has a zero exit status or there are no more commands left to execute.
Exit Status
The exit status of an OR list shall be the exit status of the last command that is executed in the list.
2.9.4 Compound Commands
The shell has several programming constructs that are "compound commands", which provide control flow for
commands. Each of these compound commands has a reserved word or control operator at the beginning, and a corresponding terminator
reserved word or operator at the end. In addition, each can be followed by redirections on the same line as the terminator. Each
redirection shall apply to all the commands within the compound command that do not explicitly override that redirection.
In the descriptions below, the exit status of some compound commands is stated in terms of the exit status of a
compound-list. The exit status of a compound-list shall be the value that the special parameter '?' (see
2.5.2 Special Parameters) would have immediately after execution of the compound-list.
2.9.4.1 Grouping Commands
The format for grouping commands is as follows:
( compound-list )
Execute compound-list in a subshell environment; see 2.13 Shell Execution Environment.
Variable assignments and built-in commands that affect the environment shall not remain in effect after the list finishes.
If a character sequence beginning with "((" would be parsed by the shell as an arithmetic expansion if
preceded by a '$', shells which implement an extension whereby "((expression))" is evaluated as an
arithmetic expression may treat the "((" as introducing as an arithmetic evaluation instead of a grouping command. A
conforming application shall ensure that it separates the two leading '(' characters with white space to prevent the shell
from performing an arithmetic evaluation.
{ compound-list ; }
Execute compound-list in the current process environment. The semicolon shown here is an example of a control operator
delimiting the } reserved word. Other delimiters are possible, as shown in 2.10 Shell Grammar; a
is frequently used.
Exit Status
The exit status of a grouping command shall be the exit status of compound-list.
2.9.4.2 The for Loop
The for loop shall execute a sequence of commands for each member in a list of items. The for
loop requires that the reserved words do and done be used to delimit the sequence of commands.
The format for the for loop is as follows:
for name [ in [word ... ]]
do
compound-list
done
First, the list of words following in shall be expanded to generate a list of items. Then, the variable
name shall be set to each item, in turn, and the compound-list executed each time. If no items result from the
expansion, the compound-list shall not be executed. Omitting:
in word ...
shall be equivalent to:
in "$@"
Exit Status
If there is at least one item in the list of items, the exit status of a for command shall be the exit
status of the last compound-list executed. If there are no items, the exit status shall be zero.
2.9.4.3 Case Conditional Construct
The conditional construct case shall execute the compound-list corresponding to the first
pattern (see 2.14 Pattern Matching Notation), if any are present, that is matched by the string
resulting from the tilde expansion, parameter expansion, command substitution, arithmetic expansion, and quote removal of the given
word. The reserved word in shall denote the beginning of the patterns to be matched. Multiple patterns with the same
compound-list shall be delimited by the '|' symbol. The control operator ')' terminates a list of patterns
corresponding to a given action. The terminated pattern list and the following compound-list is called a case
statement clause. Each case statement clause, with the possible exception of the last, shall be terminated with
either ";;" or ";&". The case construct terminates with the reserved word esac (case
reversed).
The format for the case construct is as follows:
case word in
[[(] pattern[ | pattern] ... ) compound-list terminator] ...
[[(] pattern[ | pattern] ... ) compound-list]
esac
Where terminator is either ";;" or ";&" and is optional for the last
compound-list.
In order from the beginning to the end of the case statement, each pattern that labels a
compound-list shall be subjected to tilde expansion, parameter expansion, command substitution, and arithmetic expansion,
and the result of these expansions shall be compared against the expansion of word, according to the rules described in
2.14 Pattern Matching Notation (which also describes the effect of quoting parts of the pattern). After
the first match, no more patterns in the case statement shall be expanded, and the compound-list of the matching
clause shall be executed. If the case statement clause is terminated by ";;", no further clauses shall be examined.
If the case statement clause is terminated by ";&", then the compound-list (if any) of each subsequent
clause shall be executed, in order, until either a clause terminated by ";;" is reached and its compound-list (if
any) executed or there are no further clauses in the case statement. The order of expansion and comparison of multiple
patterns that label a compound-list statement is unspecified.
Exit Status
The exit status of case shall be zero if no patterns are matched. Otherwise, the exit status shall be the
exit status of the compound-list of the last clause to be executed.
2.9.4.4 The if Conditional Construct
The if command shall execute a compound-list and use its exit status to determine whether to execute
another compound-list.
The format for the if construct is as follows:
if compound-list
then
compound-list
[elif compound-list
then
compound-list] ...
[else
compound-list]
fi
The if compound-list shall be executed; if its exit status is zero, the then
compound-list shall be executed and the command shall complete. Otherwise, each elif compound-list shall be
executed, in turn, and if its exit status is zero, the then compound-list shall be executed and the command shall
complete. Otherwise, the else compound-list shall be executed.
Exit Status
The exit status of the if command shall be the exit status of the then or else
compound-list that was executed, or zero, if none was executed.
Note:
Although the exit status of the if or elif compound-list is ignored when determining the exit status of
the if command, it is available through the special parameter '?' (see 2.5.2 Special
Parameters) during execution of the next then, elif, or else compound-list (if any is executed) in
the normal way.
2.9.4.5 The while Loop
The while loop shall continuously execute one compound-list as long as another compound-list
has a zero exit status.
The format of the while loop is as follows:
while compound-list-1
do
compound-list-2
done
The compound-list-1 shall be executed, and if it has a non-zero exit status, the while command shall
complete. Otherwise, the compound-list-2 shall be executed, and the process shall repeat.
Exit Status
The exit status of the while loop shall be the exit status of the last compound-list-2 executed, or
zero if none was executed.
Note:
Since the exit status of compound-list-1 is ignored when determining the exit status of the while command, it is
not possible to obtain the status of the command that caused the loop to exit, other than via the special parameter '?'
(see 2.5.2 Special Parameters) during execution of compound-list-1, for example:
while some_command; st=$?; false; do ...
The exit status of compound-list-1 is available through the special parameter '?' during execution
of compound-list-2, but is known to be zero at that point anyway.
2.9.4.6 The until Loop
The until loop shall continuously execute one compound-list as long as another compound-list
has a non-zero exit status.
The format of the until loop is as follows:
until compound-list-1
do
compound-list-2
done
The compound-list-1 shall be executed, and if it has a zero exit status, the until command completes.
Otherwise, the compound-list-2 shall be executed, and the process repeats.
Exit Status
The exit status of the until loop shall be the exit status of the last compound-list-2 executed, or
zero if none was executed.
Note:
Although the exit status of compound-list-1 is ignored when determining the exit status of the until command, it
is available through the special parameter '?' (see 2.5.2 Special Parameters) during
execution of compound-list-2 in the normal way.
2.9.5 Function Definition Command
A function is a user-defined name that is used as a simple command to call a compound command with new positional
parameters. A function is defined with a "function definition command".
The format of a function definition command is as follows:
fname ( ) compound-command [io-redirect ...]
The function is named fname; the application shall ensure that it is a name (see XBD 3.216 Name) and that it is not the name of a special built-in utility. An
implementation may allow other characters in a function name as an extension. The implementation shall maintain separate name
spaces for functions and variables.
The argument compound-command represents a compound command, as described in 2.9.4
Compound Commands.
When the function is declared, none of the expansions in 2.6 Word Expansions shall be
performed on the text in compound-command or io-redirect; all expansions shall be performed as normal each time the
function is called. Similarly, the optional io-redirect redirections and any variable assignments within
compound-command shall be performed during the execution of the function itself, not the function definition. See 2.8.1 Consequences of Shell Errors for the consequences of failures of these operations on interactive and
non-interactive shells.
When a function is executed, it shall have the syntax-error properties described for special built-in utilities in
the first item in the enumerated list at the beginning of 2.15 Special Built-In Utilities.
The compound-command shall be executed whenever the function name is specified as the name of a simple
command (see 2.9.1.4 Command Search and Execution). The operands to the command temporarily shall
become the positional parameters during the execution of the compound-command; the special parameter '#' also shall
be changed to reflect the number of operands. The special parameter 0 shall be unchanged. When the function completes, the values
of the positional parameters and the special parameter '#' shall be restored to the values they had before the function
was executed. If the special built-in return (see return) is executed in the
compound-command, the function completes and execution shall resume with the next command after the function call.
Exit Status
The exit status of a function definition shall be zero if the function was declared successfully; otherwise, it
shall be greater than zero. The exit status of a function invocation shall be the exit status of the last command executed by the
function.
2.10 Shell Grammar
The following grammar defines the Shell Command Language. This formal syntax shall take precedence over the
preceding text syntax description.
2.10.1 Shell Grammar Lexical Conventions
The input language to the shell shall be first recognized at the character level. The resulting tokens shall be
classified by their immediate context according to the following rules (applied in order). These rules shall be used to determine
what a "token" is that is subject to parsing at the token level. The rules for token recognition in 2.3
Token Recognition shall apply.
If the token is an operator, the token identifier for that operator shall result.
If the string consists solely of digits and the delimiter character is one of '',
the token identifier IO_NUMBER shall result.
If the string contains at least three characters, begins with a  ('{') and ends
with a  ('}'), and the delimiter character is one of '', the
token identifier IO_LOCATION may result; if the result is not IO_LOCATION, the token identifier TOKEN shall
result.
Otherwise, the token identifier TOKEN shall result.
Further distinction on TOKEN is context-dependent. It may be that the same TOKEN yields WORD,
a NAME, an ASSIGNMENT_WORD, or one of the reserved words below, dependent upon the context. Some of the productions
in the grammar below are annotated with a rule number from the following list. When a TOKEN is seen where one of those
annotated productions could be used to reduce the symbol, the applicable rule shall be applied to convert the token identifier type
of the TOKEN to:
The token identifier of the recognized reserved word, for rule 1
A token identifier acceptable at that point in the grammar, for all other rules
The reduction shall then proceed based upon the token identifier type yielded by the rule applied. When more than
one rule applies, the highest numbered rule shall apply (which in turn may refer to another rule). (Note that except in rule 7, the
presence of an '=' in the token has no effect.)
The WORD tokens shall have the word expansion rules applied to them immediately before the associated
command is executed, not at the time the command is parsed.
2.10.2 Shell Grammar Rules
[Command Name]
When the TOKEN is exactly a reserved word, the token identifier for that reserved word shall result.
Otherwise, the token WORD shall be returned. Also, if the parser is in any state where only a reserved word could be the
next correct token, proceed as above.
Note:
Because at this point quoting characters (, single-quote, , and the
single-quote sequence) are retained in the token, quoted strings cannot be recognized as reserved words. This rule also implies
that reserved words are not recognized except in certain positions in the input, such as after a  or
; the grammar presumes that if the reserved word is intended, it is properly delimited by the user, and does not
attempt to reflect that requirement directly. Also note that line joining is done before tokenization, as described in 2.2.1 Escape Character (Backslash), so escaped  characters are already removed at this
point.
Rule 1 is not directly referenced in the grammar, but is referred to by other rules, or applies globally.
[Redirection to or from filename]
The expansions specified in 2.7 Redirection shall occur. As specified there, exactly one
field can result (or the result is unspecified), and there are additional requirements on pathname expansion.
[Redirection from here-document]
Quote removal shall be applied to the word to determine the delimiter that is used to find the end of the
here-document that begins after the next .
[Case statement termination]
When the TOKEN is exactly the reserved word esac, the token identifier for esac shall result.
Otherwise, the token WORD shall be returned.
[NAME in for]
When the TOKEN meets the requirements for a name (see XBD 3.216 Name), the token identifier NAME shall result. Otherwise, the
token WORD shall be returned.
[Third word of for and case]
[case only]
When the TOKEN is exactly the reserved word in, the token identifier for in shall result.
Otherwise, the token WORD shall be returned.
[for only]
When the TOKEN is exactly the reserved word in or do, the token identifier for in or
do shall result, respectively. Otherwise, the token WORD shall be returned.
(For a. and b.: As indicated in the grammar, a linebreak precedes the tokens in and do. If
characters are present at the indicated location, it is the token after them that is treated in this fashion.)
[Assignment preceding command name]
[When the first word]
If the TOKEN is exactly a reserved word, the token identifier for that reserved word shall result.
Otherwise, 7b shall be applied.
[Not the first word]
If the TOKEN contains an unquoted (as determined while applying rule 4 from 2.3 Token
Recognition)  character that is not part of an embedded parameter expansion, command substitution, or
arithmetic expansion construct (as determined while applying rule 5 from 2.3 Token Recognition):
If the TOKEN begins with '=', then the token WORD shall be returned.
If all the characters in the TOKEN preceding the first such  form a valid name (see XBD
3.216 Name), the token ASSIGNMENT_WORD shall be returned.
Otherwise, it is implementation-defined whether the token WORD or ASSIGNMENT_WORD is returned, or
the TOKEN is processed in some other way.
Otherwise, the token WORD shall be returned.
If a returned ASSIGNMENT_WORD token begins with a valid name, assignment of the value after the first
to the name shall occur as specified in 2.9.1 Simple Commands. If a returned
ASSIGNMENT_WORD token does not begin with a valid name, the way in which the token is processed is unspecified.
[NAME in function]
When the TOKEN is exactly a reserved word, the token identifier for that reserved word shall result.
Otherwise, when the TOKEN meets the requirements for a name, the token identifier NAME shall result. Otherwise, rule
7 applies.
[Body of function]
Word expansion and assignment shall never occur, even when required by the rules above, when this rule is being
parsed. Each TOKEN that might either be expanded or have assignment applied to it shall instead be returned as a single
WORD consisting only of characters that are exactly the token described in 2.3 Token Recognition
.
/* -------------------------------------------------------
The grammar symbols
------------------------------------------------------- */
%token  WORD
%token  ASSIGNMENT_WORD
%token  NAME
%token  NEWLINE
%token  IO_NUMBER
%token  IO_LOCATION
/* The following are the operators (see XBD 3.243 Operator)
containing more than one character. */
%token  AND_IF    OR_IF    DSEMI    SEMI_AND
/*      '&&'      '||'     ';;'     ';&'   */
%token  DLESS  DGREAT  LESSAND  GREATAND  LESSGREAT  DLESSDASH
/*      '>'    '&'      '<>'       '|'   */
/* The following are the reserved words. */
%token  If    Then    Else    Elif    Fi    Do    Done
/*      'if'  'then'  'else'  'elif'  'fi'  'do'  'done'   */
%token  Case    Esac    While    Until    For
/*      'case'  'esac'  'while'  'until'  'for'   */
/* These are reserved words, not operator tokens, and are
recognized when reserved words are recognized. */
%token  Lbrace    Rbrace    Bang
/*      '{'       '}'       '!'   */
%token  In
/*      'in'   */
/* -------------------------------------------------------
The Grammar
------------------------------------------------------- */
%start program
%%
program          : linebreak complete_commands linebreak
| linebreak
;
complete_commands: complete_commands newline_list complete_command
|                                complete_command
;
complete_command : list separator_op
| list
;
list             : list separator_op and_or
|                   and_or
;
and_or           :                         pipeline
| and_or AND_IF linebreak pipeline
| and_or OR_IF  linebreak pipeline
;
pipeline         :      pipe_sequence
| Bang pipe_sequence
;
pipe_sequence    :                             command
| pipe_sequence '|' linebreak command
;
command          : simple_command
| compound_command
| compound_command redirect_list
| function_definition
;
compound_command : brace_group
| subshell
| for_clause
| case_clause
| if_clause
| while_clause
| until_clause
;
subshell         : '(' compound_list ')'
;
compound_list    : linebreak term
| linebreak term separator
;
term             : term separator and_or
|                and_or
;
for_clause       : For name                                      do_group
| For name                       sequential_sep do_group
| For name linebreak in          sequential_sep do_group
| For name linebreak in wordlist sequential_sep do_group
;
name             : NAME                     /* Apply rule 5 */
;
in               : In                       /* Apply rule 6 */
;
wordlist         : wordlist WORD
|          WORD
;
case_clause      : Case WORD linebreak in linebreak case_list    Esac
| Case WORD linebreak in linebreak case_list_ns Esac
| Case WORD linebreak in linebreak              Esac
;
case_list_ns     : case_list case_item_ns
|           case_item_ns
;
case_list        : case_list case_item
|           case_item
;
case_item_ns     : pattern_list ')' linebreak
| pattern_list ')' compound_list
;
case_item        : pattern_list ')' linebreak     DSEMI linebreak
| pattern_list ')' compound_list DSEMI linebreak
| pattern_list ')' linebreak     SEMI_AND linebreak
| pattern_list ')' compound_list SEMI_AND linebreak
;
pattern_list     :                  WORD    /* Apply rule 4 */
|              '(' WORD    /* Do not apply rule 4 */
| pattern_list '|' WORD    /* Do not apply rule 4 */
;
if_clause        : If compound_list Then compound_list else_part Fi
| If compound_list Then compound_list           Fi
;
else_part        : Elif compound_list Then compound_list
| Elif compound_list Then compound_list else_part
| Else compound_list
;
while_clause     : While compound_list do_group
;
until_clause     : Until compound_list do_group
;
function_definition : fname '(' ')' linebreak function_body
;
function_body    : compound_command                /* Apply rule 9 */
| compound_command redirect_list  /* Apply rule 9 */
;
fname            : NAME                            /* Apply rule 8 */
;
brace_group      : Lbrace compound_list Rbrace
;
do_group         : Do compound_list Done           /* Apply rule 6 */
;
simple_command   : cmd_prefix cmd_word cmd_suffix
| cmd_prefix cmd_word
| cmd_prefix
| cmd_name cmd_suffix
| cmd_name
;
cmd_name         : WORD                   /* Apply rule 7a */
;
cmd_word         : WORD                   /* Apply rule 7b */
;
cmd_prefix       :            io_redirect
| cmd_prefix io_redirect
|            ASSIGNMENT_WORD
| cmd_prefix ASSIGNMENT_WORD
;
cmd_suffix       :            io_redirect
| cmd_suffix io_redirect
|            WORD
| cmd_suffix WORD
;
redirect_list    :               io_redirect
| redirect_list io_redirect
;
io_redirect      :             io_file
| IO_NUMBER   io_file
| IO_LOCATION io_file /* Optionally supported */
|             io_here
| IO_NUMBER   io_here
| IO_LOCATION io_here /* Optionally supported */
;
io_file          : ''       filename
| GREATAND  filename
| DGREAT    filename
| LESSGREAT filename
| CLOBBER   filename
;
filename         : WORD                      /* Apply rule 2 */
;
io_here          : DLESS     here_end
| DLESSDASH here_end
;
here_end         : WORD                      /* Apply rule 3 */
;
newline_list     :              NEWLINE
| newline_list NEWLINE
;
linebreak        : newline_list
| /* empty */
;
separator_op     : '&'
| ';'
;
separator        : separator_op linebreak
| newline_list
;
sequential_sep   : ';' linebreak
| newline_list
;
2.11 Job Control
Job control is defined (see XBD 3.181 Job Control) as a
facility that allows users selectively to stop (suspend) the execution of processes and continue (resume) their execution at a
later point. It is jointly supplied by the terminal I/O driver and a command interpreter. The shell is one such command interpreter
and job control in the shell is enabled by set -m (which is enabled by default in interactive
shells). The remainder of this section describes the job control facility provided by the shell. Requirements relating to
background jobs stated in this section only apply to job-control background jobs.
If the shell has a controlling terminal and it is the controlling process for the terminal session, it shall
initially set the foreground process group ID associated with the terminal to its own process group ID. Otherwise, if it has a
controlling terminal, it shall initially perform the following steps if interactive and may perform them if non-interactive:
If its process group is the foreground process group associated with the terminal, the shell shall set its process
group ID to its process ID (if they are not already equal) and set the foreground process group ID associated with the terminal to
its process group ID.
If its process group is not the foreground process group associated with the terminal (which would result from it
being started by a job-control shell as a background job), the shell shall either stop itself by sending itself a SIGTTIN signal
or, if interactive, attempt to read from standard input (which generates a SIGTTIN signal if standard input is the controlling
terminal). If it is stopped, then when it continues execution (after receiving a SIGCONT signal) it shall repeat these steps.
Subsequently, the shell shall change the foreground process group associated with its controlling terminal when a
foreground job is running as noted in the description below.
When job control is enabled, the shell shall create one or more jobs when it executes a list (see 2.9.3 Lists) that has one of the following forms:
A single asynchronous AND-OR list
One or more sequentially executed AND-OR lists followed by at most one asynchronous AND-OR list
For the purposes of job control, a list that includes more than one asynchronous AND-OR list shall be treated as if
it were split into multiple separate lists, each ending with an asynchronous AND-OR list.
When a job consisting of a single asynchronous AND-OR list is created, it shall form a background job and
the associated process ID shall be that of a child process that is made a process group leader, with all other processes (if any)
that the shell creates to execute the AND-OR list initially having this process ID as their process group ID.
For a list consisting of one or more sequentially executed AND-OR lists followed by at most one asynchronous AND-OR
list, the whole list shall form a single foreground job up until the sequentially executed AND-OR lists have all completed
execution, at which point the asynchronous AND-OR list (if any) shall form a background job as described above.
For each pipeline in a foreground job, if the pipeline is executed while the list is still a foreground job, the
set of processes comprising the pipeline, and any processes descended from it, shall all be in the same process group, unless the
shell executes some of the commands in the pipeline in the current shell execution environment and others in a subshell
environment; in this case the process group ID of the current shell need not change (or cannot change if it is the session leader),
and consequently the process group ID that the other processes all share may differ from the process group ID of the current shell
(which means that a SIGSTOP, SIGTSTP, SIGTTIN, or SIGTTOU signal sent to one of those process groups does not cause the whole
pipeline to stop).
A background job that was created on execution of an asynchronous AND-OR list can be brought into the foreground by
means of the fg utility (if supported); in this case the entire job shall become a single
foreground job. If a process that the shell subsequently waits for is part of this foreground job and is stopped by a signal, the
entire job shall become a suspended job and the behavior shall be as if the process had been stopped while the job was running in
the background.
When a foreground job is created, or a background job is brought into the foreground by the fg utility, if the shell has a controlling terminal it shall set the foreground process group ID
associated with the terminal as follows:
If the job was originally created as a background job, the foreground process group ID shall be set to the process
ID of the process that the shell made a process group leader when it executed the asynchronous AND-OR list.
If the job was originally created as a foreground job, the foreground process group ID shall be set as follows
when each pipeline in the job is executed:
If the shell is not itself executing, in the current shell execution environment, all of the commands in the
pipeline, the foreground process group ID shall be set to the process group ID that is shared by the other processes executing the
pipeline (see above).
If all of the commands in the pipeline are being executed by the shell itself in the current shell execution
environment, the foreground process group ID shall be set to the process group ID of the shell.
When a foreground job terminates, or becomes a suspended job (see below), if the shell has a controlling terminal
it shall set the foreground process group ID associated with the terminal to the process group ID of the shell.
Each background job (whether suspended or not) shall have associated with it a job number and a process ID that is
known in the current shell execution environment. When a background job is brought into the foreground by means of the fg utility, the associated job number shall be removed from the shell's background jobs list and
the associated process ID shall be removed from the list of process IDs known in the current shell execution environment.
If a process that the shell is waiting for is part of a foreground job that was started as a foreground job and is
stopped by a catchable signal (SIGTSTP, SIGTTIN, or SIGTTOU):
If the currently executing AND-OR list within the list comprising the foreground job consists of a single pipeline
in which all of the commands are simple commands, the shell shall either create a suspended job consisting of at least that AND-OR
list and the remaining (if any) AND-OR lists in the same list, or create a suspended job consisting of just that AND-OR list and
discard the remaining (if any) AND-OR lists in the same list.
Otherwise, the shell shall create a suspended job consisting of a set of commands, from within the list comprising
the foreground job, that is unspecified except that the set shall include at least the pipeline to which the stopped process
belongs. Commands in the foreground job that have not already completed and are not included in the suspended job shall be
discarded.
Note:
Although only a pipeline of simple commands is guaranteed to remain intact if started in the foreground and subsequently
suspended, it is possible to ensure that a complex AND-OR list will remain intact when suspended by starting it in the background
and immediately bringing it into the foreground. For example:
command1 && command2 | { command3 || command4; } & fg
If a process that the shell is waiting for is part of a foreground job that was started as a foreground job and is
stopped by a SIGSTOP signal, the behavior shall be as described above for a catchable signal unless the shell was executing a
built-in utility in the current shell execution environment when the SIGSTOP was delivered, resulting in the shell itself being
stopped by the signal, in which case if the shell subsequently receives a SIGCONT signal and has one or more child processes that
remain stopped, the shell shall create a suspended job as if only those child processes had been stopped.
When a suspended job is created as a result of a foreground job being stopped, it shall be assigned a job number,
and an interactive shell shall write, and a non-interactive shell may write, a message to standard error, formatted as described by
the jobs utility (without the -l option) for a suspended job. The message may
indicate that the commands comprising the job include commands that have already completed; in this case the completed commands
shall not be repeated if execution of the job is subsequently continued. If the shell is interactive, it shall save the terminal
settings before changing them to the settings it needs to read further commands.
When a process associated with a background job is stopped by a SIGSTOP, SIGTSTP, SIGTTIN, or SIGTTOU signal, the
shell shall convert the (non-suspended) background job into a suspended job and an interactive shell shall write a message to
standard error, formatted as described by the jobs utility (without the -l
option) for a suspended job, at the following time:
If set -b is enabled, the message shall be written either immediately after the
job became suspended or immediately prior to writing the next prompt for input.
If set -b is disabled, the message shall be written immediately prior to writing
the next prompt for input.
Execution of a suspended job can be continued as a foreground job by means of the fg utility (if supported), or as a (non-suspended) background job either by means of the bg utility (if supported) or by sending the stopped processes a SIGCONT signal. The fg and bg utilities shall send a SIGCONT signal to the
process group of the process(es) whose stopped wait status caused the shell to suspend the job. If the shell has a controlling
terminal, the fg utility shall send the SIGCONT signal after it has set the foreground
process group ID associated with the terminal (see above). If the fg utility is used from
an interactive shell to bring into the foreground a suspended job that was created from a foreground job, before it sends the
SIGCONT signal the fg utility shall restore the terminal settings to the ones that the
shell saved when the job was suspended.
When a background job completes or is terminated by a signal, an interactive shell shall write a message to
standard error, formatted as described by the jobs utility (without the -l
option) for a job that completed or was terminated by a signal, respectively, at the following time:
If set -b is enabled, the message shall be written immediately after the job
completes or is terminated.
If set -b is disabled, the message shall be written immediately prior to writing
the next prompt for input.
In each case above where an interactive shell writes a message immediately prior to writing the next prompt for
input, the same message may also be written by a non-interactive shell, at any of the following times:
After the next time a foreground job terminates or is suspended
Before the shell parses further input
Before the shell exits
2.12 Signals and Error Handling
If job control is disabled (see the description of set -m) when the shell executes
an asynchronous AND-OR list, the commands in the list shall inherit from the shell a signal action of ignored (SIG_IGN) for the
SIGINT and SIGQUIT signals. In all other cases, commands executed by the shell shall inherit the same signal actions as those
inherited by the shell from its parent unless a signal action is modified by the trap special built-in
(see trap)
When a signal for which a trap has been set is received while the shell is waiting for the completion of a utility
executing a foreground command, the trap associated with that signal shall not be executed until after the foreground command has
completed. When the shell is waiting, by means of the wait utility, for asynchronous
commands to complete, the reception of a signal for which a trap has been set shall cause the wait utility to return immediately with an exit status >128, immediately after which the
trap associated with that signal shall be taken.
If multiple signals are pending for the shell for which there are associated trap actions, the order of execution
of trap actions is unspecified.
2.13 Shell Execution Environment
A shell execution environment consists of the following:
Open files inherited upon invocation of the shell, plus open files controlled by exec
Working directory as set by cd
File creation mask set by umask
File size limit as set by ulimit
Current traps set by trap
Shell parameters that are set by variable assignment (see the set special built-in) or
from the System Interfaces volume of POSIX.1-2024 environment inherited by the shell when it begins (see the export special built-in)
Shell functions; see 2.9.5 Function Definition Command
Options turned on at invocation or by set
Background jobs and their associated process IDs, and process IDs of child processes created to execute
asynchronous AND-OR lists while job control is disabled; together these process IDs constitute the process IDs "known to this
shell environment". If the implementation supports non-job-control background jobs, the list of known process IDs and the list of
background jobs may form a single list even though this standard describes them as being updated separately. See 2.9.3.1 Asynchronous AND-OR Lists
Shell aliases; see 2.3.1 Alias Substitution
Utilities other than the special built-ins (see 2.15 Special Built-In Utilities) shall be
invoked in a separate environment that consists of the following. The initial value of these objects shall be the same as that for
the parent shell, except as noted below.
Open files inherited on invocation of the shell, open files controlled by the exec
special built-in plus any modifications, and additions specified by any redirections to the utility
Current working directory
File creation mask
If the utility is a shell script, traps caught by the shell shall be set to the default values and traps ignored
by the shell shall be set to be ignored by the utility; if the utility is not a shell script, the trap actions (default or ignore)
shall be mapped into the appropriate signal handling actions for the utility
Variables with the export attribute, along with those explicitly exported for the
duration of the command, shall be passed to the utility environment variables
It is unspecified whether environment variables that were passed to the invoking shell when it was invoked itself,
but were not used to initialize shell variables (see 2.5.3 Shell Variables) because they had invalid
names, are included in the invoked utility's environment.
The environment of the shell process shall not be changed by the utility unless explicitly specified by the utility
description (for example, cd and umask).
A subshell environment shall be created as a duplicate of the shell environment, except that:
Unless specified otherwise (see trap), traps that are not being ignored shall be set to
the default action.
If the shell is interactive, the subshell shall behave as a non-interactive shell in all respects except:
The expansion of the special parameter '-' may continue to indicate that it is interactive.
The set -n option may be ignored.
Changes made to the subshell environment shall not affect the shell environment. Command substitution, commands
that are grouped with parentheses, and asynchronous AND-OR lists shall be executed in a subshell environment. Additionally, each
command of a multi-command pipeline is in a subshell environment; as an extension, however, any or all commands in a pipeline may
be executed in the current environment. Except where otherwise stated, all other commands shall be executed in the current shell
environment.
2.14 Pattern Matching Notation
The pattern matching notation described in this section is used to specify patterns for matching character strings
in the shell. This notation is also used by some other utilities (find, pax, and optionally make) and by some system
interfaces (fnmatch(), glob(), and
wordexp()). Historically, pattern matching notation is related to, but slightly
different from, the regular expression notation described in XBD 9. Regular
Expressions. For this reason, the description of the rules for this pattern matching notation are based on the description
of regular expression notation, modified to account for the differences.
If an attempt is made to use pattern matching notation to match a string that contains one or more bytes that do
not form part of a valid character, the behavior is unspecified. Since pathnames can contain such bytes, portable applications need
to ensure that the current locale is the C or POSIX locale when performing pattern matching (or expansion) on arbitrary
pathnames.
2.14.1 Patterns Matching a Single Character
The following patterns shall match a single character: ordinary characters, special pattern characters, and pattern
bracket expressions. The pattern bracket expression also shall match a single collating element.
In a pattern, or part of one, where a shell-quoting  can be used, a  character
shall escape the following character as described in 2.2.1 Escape Character (Backslash), regardless of
whether or not the  is inside a bracket expression. (The sequence "\\" represents one literal
.)
In a pattern, or part of one, where a shell-quoting  cannot be used to preserve the literal value
of a character that would otherwise be treated as special:
A  character that is not inside a bracket expression shall preserve the literal value of the
following character, unless the following character is in a part of the pattern where shell quoting can be used and is a shell
quoting character, in which case the behavior is unspecified.
For the shell only, it is unspecified whether or not a  character inside a bracket expression
preserves the literal value of the following character.
All of the requirements and effects of quoting on ordinary, shell special, and special pattern characters shall
apply to escaping in this context, except where specified otherwise. (Situations where this applies include word expansions when a
pattern used in pathname expansion is not present in the original word but results from an earlier expansion, or the argument to
the find -name or -path primary as passed to find, or the pattern argument to the fnmatch() and glob() functions when FNM_NOESCAPE
or GLOB_NOESCAPE is not set in flags, respectively.)
If a pattern ends with an unescaped , the behavior is unspecified.
An ordinary character is a pattern that shall match itself. In a pattern, or part of one, where a shell-quoting
can be used, an ordinary character can be any character in the supported character set except for NUL, those
special shell characters in 2.2 Quoting that require quoting, and the three special pattern characters
described below. In a pattern, or part of one, where a shell-quoting  cannot be used to preserve the literal value
of a character that would otherwise be treated as special, an ordinary character can be any character in the supported character
set except for NUL and the three special pattern characters described below. Matching shall be based on the bit pattern used for
encoding the character, not on the graphic representation of the character. If any character (ordinary, shell special, or pattern
special) is quoted, or escaped with a , that pattern shall match the character itself. The application shall
ensure that it quotes or escapes any character that would otherwise be treated as special, in order for it to be matched as an
ordinary character.
When unquoted, unescaped, and not inside a bracket expression, the following three characters shall have special
meaning in the specification of patterns:
?
A  is a pattern that shall match any character.
*
An  is a pattern that shall match multiple characters, as described in 2.14.2 Patterns
Matching Multiple Characters.
[
A  shall introduce a bracket expression if the characters following it meet the requirements for
bracket expressions stated in XBD 9.3.5 RE Bracket Expression, except
that the  character ('!') shall replace the  character ('^') in its
role in a non-matching list in the regular expression notation. A bracket expression starting with an unquoted
character produces unspecified results. A  that does not introduce a valid bracket expression shall
match the character itself.
2.14.2 Patterns Matching Multiple Characters
The following rules are used to construct patterns matching multiple characters from patterns matching a single
character:
The  ('*') is a pattern that shall match any string, including the null string.
The concatenation of patterns matching a single character is a valid pattern that shall match the concatenation of
the single characters or collating elements matched by each of the concatenated patterns.
The concatenation of one or more patterns matching a single character with one or more  characters
is a valid pattern. In such patterns, each  shall match a string of zero or more characters, matching the greatest
possible number of characters that still allows the remainder of the pattern to match the string.
2.14.3 Patterns Used for Filename Expansion
The rules described so far in 2.14.1 Patterns Matching a Single Character and 2.14.2 Patterns Matching Multiple Characters are qualified by the following rules that apply when pattern
matching notation is used for filename expansion:
The  character in a pathname shall be explicitly matched by using one or more
characters in the pattern; it shall neither be matched by the  or  special characters nor by a
bracket expression.  characters in the pattern shall be identified before bracket expressions; thus, a
cannot be included in a pattern bracket expression used for filename expansion. If a  character is found following an
unescaped  character before a corresponding  is found, the open bracket
shall be treated as an ordinary character. For example, the pattern "a[b/c]d" does not match such pathnames as abd
or a/d. It only matches a pathname of literally a[b/c]d.
If a filename begins with a  ('.'), the  shall be explicitly matched by using
a  as the first character of the pattern or immediately following a  character. The leading
shall not be matched by:
The  or  special characters
A bracket expression containing a non-matching list, such as "[!a]", a range expression, such as
"[%-0]", or a character class expression, such as "[[:punct:]]"
It is unspecified whether an explicit  in a bracket expression matching list, such as
"[.abc]", can match a leading  in a filename.
If a specified pattern contains any '*', '?' or '[' characters that will be treated as
special (see 2.14.1 Patterns Matching a Single Character), it shall be matched against existing
filenames and pathnames, as appropriate; if directory entries for dot and dot-dot exist, they may be ignored. Each component that
contains any such characters shall require read permission in the directory containing that component. Each component that contains
a  that will be treated as special may require read permission in the directory containing that component. Any
component, except the last, that does not contain any '*', '?' or '[' characters that will be treated as
special shall require search permission. If these permissions are denied, or if an attempt to open or search a pathname as a
directory, or an attempt to read an opened directory, fails because of an error condition that is related to file system contents,
this shall not be considered an error and pathname expansion shall continue as if the pathname had named an existing directory
which had been successfully opened and read, or searched, and no matching directory entries had been found in it. For other error
conditions it is unspecified whether pathname expansion fails or they are treated the same as when permission is denied.
For example, given the pattern:
/foo/bar/x*/bam
search permission is needed for directories / and foo, search and read permissions are needed for
directory bar, and search permission is needed for each x* directory.
If the pattern matches any existing filenames or pathnames, the pattern shall be replaced with those filenames and
pathnames, sorted according to the collating sequence in effect in the current locale. If this collating sequence does not have a
total ordering of all characters (see XBD 7.3.2 LC_COLLATE), any
filenames or pathnames that collate equally shall be further compared byte-by-byte using the collating sequence for the POSIX
locale.
If the pattern contains an open bracket ('[') that does not introduce a bracket expression as in XBD
9.3.5 RE Bracket Expression, it is unspecified whether other unquoted
'*', '?', '[' or  characters within the same slash-delimited component of the pattern
retain their special meanings or are treated as ordinary characters. For example, the pattern "a*[/b*" may match all
filenames beginning with 'b' in the directory "a*[" or it may match all filenames beginning with 'b' in
all directories with names beginning with 'a' and ending with '['.
If the pattern does not match any existing filenames or pathnames, the pattern string shall be left unchanged.
Note:
A future version of this standard may require that directory entries for dot and dot-dot are ignored (if they exist) when
matching patterns against existing filenames. For example, when expanding the pattern ".*" the result would not include
dot and dot-dot.
If a specified pattern does not contain any '*', '?' or '[' characters that will be
treated as special, the pattern string shall be left unchanged.
2.15 Special Built-In Utilities
The following "special built-in" utilities shall be supported in the shell command language. The output of each
command, if any, shall be written to standard output, subject to the normal redirection and piping possible with all commands.
The term "built-in" implies that there is no need to execute a separate executable file because the utility is
implemented in the shell itself. An implementation may choose to make any utility a built-in; however, the special built-in
utilities described here differ from regular built-in utilities in two respects:
An error in a special built-in utility may cause a shell executing that utility to abort, while an error in a
regular built-in utility shall not cause a shell executing that utility to abort. (See 2.8.1 Consequences
of Shell Errors for the consequences of errors on interactive and non-interactive shells.) If a special built-in utility
encountering an error does not abort the shell, its exit value shall be non-zero.
As described in 2.9.1 Simple Commands, variable assignments preceding the invocation
of a special built-in utility affect the current execution environment; this shall not be the case with a regular built-in or other
utility.
The special built-in utilities in this section need not be provided in a manner accessible via the exec
family of functions defined in the System Interfaces volume of POSIX.1-2024.
Some of the special built-ins are described as conforming to XBD 12.2 Utility Syntax Guidelines. For those that are not, the requirement in
1.4 Utility Description Defaults that "--" be recognized as a
first argument to be discarded does not apply and a conforming application shall not use that argument.
>>
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
NAME
break — exit from for, while, or until loop
SYNOPSIS
break [n]
DESCRIPTION
If n is specified, the break utility shall exit from the nth enclosing for,
while, or until loop. If n is not specified, break shall behave as if n was
specified as 1. Execution shall continue with the command immediately following the exited loop. The application shall ensure that
the value of n is a positive decimal integer. If n is greater than the number of enclosing loops, the outermost
enclosing loop shall be exited. If there is no enclosing loop, the behavior is unspecified.
A loop shall enclose a break or continue command if the loop lexically encloses the command. A loop
lexically encloses a break or continue command if the command is:
Executing in the same execution environment (see 2.13 Shell Execution Environment) as
the compound-list of the loop's do-group (see 2.10.2 Shell Grammar Rules), and
Contained in a compound-list associated with the loop (either in the compound-list of the loop's do-group or, if
the loop is a while or until loop, in the compound-list following the while or until reserved word),
and
Not in the body of a function whose function definition command (see 2.9.5 Function
Definition Command) is contained in a compound-list associated with the loop.
If n is greater than the number of lexically enclosing loops and there is a non-lexically enclosing loop in
progress in the same execution environment as the break or continue command, it is unspecified whether that loop
encloses the command.
OPTIONS
None.
OPERANDS
See the DESCRIPTION.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
None.
ASYNCHRONOUS EVENTS
Default.
STDOUT
Not used.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
0
Successful completion.
>0
The n value was not an unsigned decimal integer greater than or equal to 1.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
None.
EXAMPLES
for i in *
do
if test -d "$i"
then break
fi
done
The results of running the following example are unspecified: there are two loops in progress when the break command is executed, and they are in the same execution environment, but neither loop is lexically
enclosing the break command. (There are no loops lexically enclosing the continue commands, either.)
foo() {
for j in 1 2; do
echo 'break 2' >/tmp/do_break
echo "  sourcing /tmp/do_break ($j)..."
# the behavior of the break from running the following command
# results in unspecified behavior:
. /tmp/do_break
do_continue() { continue 2; }
echo "  running do_continue ($j)..."
# the behavior of the continue in the following function call
# results in unspecified behavior (if execution reaches this
# point):
do_continue
trap 'continue 2' USR1
echo "  sending SIGUSR1 to self ($j)..."
# the behavior of the continue in the trap invoked from the
# following signal results in unspecified behavior (if
# execution reaches this point):
kill -s USR1 $$
sleep 1
done
}
for i in 1 2; do
echo "running foo ($i)..."
foo
done
RATIONALE
In early proposals, consideration was given to expanding the syntax of break and continue to refer to a label associated with the appropriate loop as a preferable alternative to the
n method. However, this volume of POSIX.1-2024 does reserve the name space of command names ending with a . It
is anticipated that a future implementation could take advantage of this and provide something like:
outofloop: for i in a b c d e
do
for j in 0 1 2 3 4 5 6 7 8 9
do
if test -r "${i}${j}"
then break outofloop
fi
done
done
and that this might be standardized after implementation experience is achieved.
FUTURE DIRECTIONS
None.
SEE ALSO
2.15 Special Built-In Utilities
CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as
described in the Utility Description Defaults ( 1.4 Utility Description
Defaults). No change in behavior is intended.
Issue 7
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0046 [842] is applied.
Issue 8
Austin Group Defect 1058 is applied, clarifying that the requirement for n to be a positive decimal integer is a
requirement on the application.
End of informative text.
>>
NAME
colon — null utility
SYNOPSIS
: [argument...]
DESCRIPTION
This utility shall do nothing except return a 0 exit status. It is used when a command is needed, as in the then
condition of an if command, but nothing is to be done by the command.
OPTIONS
This utility shall not recognize the "--" argument in the manner specified by Guideline 10 of XBD 12.2 Utility Syntax Guidelines.
Implementations shall not support any options.
OPERANDS
See the DESCRIPTION.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
None.
ASYNCHRONOUS EVENTS
Default.
STDOUT
Not used.
STDERR
Not used.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
Zero.
CONSEQUENCES OF ERRORS
None.
The following sections are informative.
APPLICATION USAGE
See the APPLICATION USAGE for true.
EXAMPLES
: "${X=abc}"
if     false
then   :
else   printf '%s\n' "$X"
fi
abc
As with any of the special built-ins, the null utility can also have variable assignments and redirections
associated with it, such as:
x=y : > z
which sets variable x to the value y (so that it persists after the null utility completes) and
creates or truncates file z; if the file cannot be created or truncated, a non-interactive shell exits (see 2.8.1 Consequences of Shell Errors).
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.15 Special Built-In Utilities, true
CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as
described in the Utility Description Defaults ( 1.4 Utility Description
Defaults). No change in behavior is intended.
Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
Issue 8
Austin Group Defect 1272 is applied, clarifying that the null utility does not process its arguments, does not recognize the
"--" end-of-options delimiter, does not support any options, and does not write to standard error.
Austin Group Defect 1640 is applied, changing the APPLICATION USAGE section.
End of informative text.
>>
NAME
continue — continue for, while, or until loop
SYNOPSIS
continue [n]
DESCRIPTION
If n is specified, the continue utility shall return to the top of the nth
enclosing for, while, or until loop. If n is not specified, continue
shall behave as if n was specified as 1. Returning to the top of the loop involves repeating the condition list of a
while or until loop or performing the next assignment of a for loop, and re-executing the loop if
appropriate.
The application shall ensure that the value of n is a positive decimal integer. If n is greater than
the number of enclosing loops, the outermost enclosing loop shall be used. If there is no enclosing loop, the behavior is
unspecified.
The meaning of "enclosing" shall be as specified in the description of the break
utility.
OPTIONS
None.
OPERANDS
See the DESCRIPTION.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
None.
ASYNCHRONOUS EVENTS
Default.
STDOUT
Not used.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
0
Successful completion.
>0
The n value was not an unsigned decimal integer greater than or equal to 1.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
None.
EXAMPLES
for i in *
do
if test -d "$i"
then continue
fi
printf '"%s" is not a directory.\n' "$i"
done
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.15 Special Built-In Utilities
CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as
described in the Utility Description Defaults ( 1.4 Utility Description
Defaults). No change in behavior is intended.
Issue 7
The example is changed to use the printf utility rather than echo.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0046 [842] is applied.
Issue 8
Austin Group Defect 1058 is applied, clarifying that the requirement for n to be a positive decimal integer is a
requirement on the application.
End of informative text.
>>
NAME
dot — execute commands in the current environment
SYNOPSIS
. file
DESCRIPTION
The shell shall tokenize (see 2.3 Token Recognition) the contents of the file, parse the tokens
(see 2.10 Shell Grammar), and execute the resulting commands in the current environment. It is
unspecified whether the commands are parsed and executed as a program (as for a shell script) or are parsed as a single
compound_list that is executed after the entire file has been parsed.
If file does not contain a , the shell shall use the search path specified by PATH to
find the directory containing file. Unlike normal command search, however, the file searched for by the dot utility need not be executable. If no readable file is found, a non-interactive shell shall abort; an
interactive shell shall write a diagnostic message to standard error.
The dot special built-in shall support XBD 12.2 Utility Syntax Guidelines, except for Guidelines 1 and 2.
OPTIONS
None.
OPERANDS
See the DESCRIPTION.
STDIN
Not used.
INPUT FILES
See the DESCRIPTION.
ENVIRONMENT VARIABLES
See the DESCRIPTION.
ASYNCHRONOUS EVENTS
Default.
STDOUT
Not used.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
If no readable file was found or if the commands in the file could not be parsed, and the shell is interactive (and therefore
does not abort; see 2.8.1 Consequences of Shell Errors), the exit status shall be non-zero. Otherwise,
return the value of the last command executed, or a zero exit status if no command is executed.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
None.
EXAMPLES
cat foobar
foo=hello bar=world
. ./foobar
echo $foo $bar
hello world
RATIONALE
Some older implementations searched the current directory for the file, even if the value of PATH disallowed it.
This behavior was omitted from this volume of POSIX.1-2024 due to concerns about introducing the susceptibility to trojan horses
that the user might be trying to avoid by leaving dot out of PATH .
The KornShell version of dot takes optional arguments that are set to the positional
parameters. This is a valid extension that allows a dot script to behave identically to a function.
FUTURE DIRECTIONS
None.
SEE ALSO
2.15 Special Built-In Utilities, return
CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as
described in the Utility Description Defaults ( 1.4 Utility Description
Defaults). No change in behavior is intended.
Issue 7
SD5-XCU-ERN-164 is applied.
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0038 [114] and XCU/TC1-2008/0039 [214] are applied.
Issue 8
Austin Group Defect 252 is applied, adding a requirement for dot to support XBD 12.2 Utility Syntax Guidelines (except for Guidelines 1 and 2, since the
utility's name is '.').
Austin Group Defect 953 is applied, clarifying how the commands in the file are parsed.
Austin Group Defect 1265 is applied, updating the DESCRIPTION to align with the changes made to 2.8.1 Consequences of Shell Errors between Issue 6 and Issue 7.
End of informative text.
>>
NAME
eval — construct command by concatenating arguments
SYNOPSIS
eval [argument...]
DESCRIPTION
The eval utility shall construct a command string by concatenating arguments together,
separating each with a  character. The constructed command string shall be tokenized (see 2.3
Token Recognition), parsed (see 2.10 Shell Grammar), and executed by the shell in the current
environment. It is unspecified whether the commands are parsed and executed as a program (as for a shell script) or are
parsed as a single compound_list that is executed after the entire constructed command string has been parsed.
OPTIONS
None.
OPERANDS
See the DESCRIPTION.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
None.
ASYNCHRONOUS EVENTS
Default.
STDOUT
Not used.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
If there are no arguments, or only null arguments, eval shall return a zero exit
status; otherwise, it shall return the exit status of the command defined by the string of concatenated arguments separated
by  characters, or a non-zero exit status if the concatenation could not be parsed as a command and the shell is
interactive (and therefore did not abort).
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
Since eval is not required to recognize the "--" end of options delimiter, in cases where
the argument(s) to eval might begin with '-' it is recommended that the first argument is
prefixed by a string that will not alter the commands to be executed, such as a  character:
eval " $commands"
or:
eval " $(some_command)"
EXAMPLES
foo=10 x=foo
y='$'$x
echo $y
$foo
eval y='$'$x
echo $y
10
RATIONALE
This standard allows, but does not require, eval to recognize "--". Although this means
applications cannot use "--" to protect against options supported as an extension (or errors reported for unsupported
options), the nature of the eval utility is such that other means can be used to provide this protection
(see APPLICATION USAGE above).
FUTURE DIRECTIONS
None.
SEE ALSO
2.15 Special Built-In Utilities
CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as
described in the Utility Description Defaults ( 1.4 Utility Description
Defaults). No change in behavior is intended.
Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0040 [114], XCU/TC1-2008/0041 [163], and XCU/TC1-2008/0042
[163] are applied.
Issue 8
Austin Group Defect 953 is applied, clarifying how the commands in the constructed command string are parsed.
End of informative text.
>>
NAME
exec — perform redirections in the current shell or execute a utility
SYNOPSIS
exec [utility [argument...]]
DESCRIPTION
If exec is specified with no operands, any redirections associated with the exec command shall be made in the current shell execution environment. If any file descriptors with numbers
greater than 2 are opened by those redirections, it is unspecified whether those file descriptors remain open when the shell
invokes another utility. Scripts concerned that child shells could misuse open file descriptors can always close them explicitly,
as shown in one of the following examples. If the result of the redirections would be that file descriptor 0, 1, or 2 is closed,
implementations may open the file descriptor to an unspecified file.
If exec is specified with a utility operand, the shell shall execute a
non-built-in utility as described in 2.9.1.6 Non-built-in Utility Execution with utility as
the command name and the argument operands (if any) as the command arguments.
If the exec command fails, a non-interactive shell shall exit from the current shell
execution environment; [UP]   an interactive shell may exit from a subshell environment but shall not exit if the current
shell environment is not a subshell environment.
If the exec command fails and the shell does not exit, any redirections associated with
the exec command that were successfully made shall take effect in the current shell execution
environment.
The exec special built-in shall support XBD 12.2 Utility Syntax Guidelines.
OPTIONS
None.
OPERANDS
See the DESCRIPTION.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variable shall affect the execution of exec:
PATH
Determine the search path when looking for the utility given as the utility operand; see XBD 8.3 Other Environment Variables.
ASYNCHRONOUS EVENTS
Default.
STDOUT
Not used.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
If utility is specified and is executed, exec shall not return to the shell; rather, the exit
status of the current shell execution environment shall be the exit status of utility. If utility is specified and an
attempt to execute it as a non-built-in utility fails, the exit status shall be as described in 2.9.1.6
Non-built-in Utility Execution. If a redirection error occurs (see 2.8.1 Consequences of Shell
Errors), the exit status shall be a value in the range 1-125. Otherwise, exec shall return a zero
exit status.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
None.
EXAMPLES
Open readfile as file descriptor 3 for reading:
exec 3 writefile
Make file descriptor 5 a copy of file descriptor 0:
exec 5>>
NAME
exit — cause the shell to exit
SYNOPSIS
exit [n]
DESCRIPTION
The exit utility shall cause the shell to exit from its current execution environment. If the current
execution environment is a subshell environment, the shell shall exit from the subshell environment and continue in the environment
from which that subshell environment was invoked; otherwise, the shell utility shall terminate. The wait status of the shell or
subshell shall be determined by the unsigned decimal integer n, if specified.
If n is specified and has a value between 0 and 255 inclusive, the wait status of the shell or subshell
shall indicate that it exited with exit status n. If n is specified and has a value greater than 256 that corresponds
to an exit status the shell assigns to commands terminated by a valid signal (see 2.8.2 Exit Status for
Commands), the wait status of the shell or subshell shall indicate that it was terminated by that signal. No other actions
associated with the signal, such as execution of trap actions or creation of a core image, shall be
performed by the shell.
If n is specified and is not an unsigned decimal integer, or has a value of 256, or has a value greater than
256 but not corresponding to an exit status the shell assigns to commands terminated by a valid signal, the wait status of the
shell or subshell is unspecified.
If n is not specified, the result shall be as if n were specified with the current value of the
special parameter '?' (see 2.5.2 Special Parameters), except that if the exit command would cause the end of execution of a trap action, the value for the
special parameter '?' that is considered "current" shall be the value it had immediately preceding the trap action.
A trap action on EXIT shall be executed before the shell terminates, except when
the exit utility is invoked in that trap action itself, in which case the
shell shall exit immediately. It is unspecified whether setting a new trap action on EXIT during
execution of a trap action on EXIT will cause the new trap action to
be executed before the shell terminates.
OPTIONS
None.
OPERANDS
See the DESCRIPTION.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
None.
ASYNCHRONOUS EVENTS
Default.
STDOUT
Not used.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The exit utility causes the shell to exit from its current execution environment, and therefore does
not itself return an exit status.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
As explained in other sections, certain exit status values have been reserved for special uses and should be used by
applications only for those purposes:
126
A file to be executed was found, but it was not an executable utility.
127
A utility to be executed was not found.
128
An unrecoverable read error was detected by the shell while reading commands, except from the file operand of the
dot special built-in.
>128
A command was interrupted by a signal.
EXAMPLES
Exit with a true value:
exit 0
Exit with a false value:
exit 1
Propagate error handling from within a subshell:
(
command1 || exit 1
command2 || exit 1
exec command3
) > outputfile || exit 1
echo "outputfile created successfully"
RATIONALE
The behavior of exit when given an invalid argument or unknown option is unspecified, because of
differing practices in the various historical implementations. A value larger than 255 might be truncated by the shell, and be
unavailable even to a parent process that uses waitid() to get the full exit value.
It is recommended that implementations that detect any usage error should cause a non-zero exit status (or, if the shell is
interactive and the error does not cause the shell to abort, store a non-zero value in "$?"), but even this was not done
historically in all shells.
See also C.2.8.2 Exit Status for Commands.
FUTURE DIRECTIONS
None.
SEE ALSO
2.15 Special Built-In Utilities
CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as
described in the Utility Description Defaults ( 1.4 Utility Description
Defaults). No change in behavior is intended.
Issue 7
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0047 [717], XCU/TC2-2008/0048 [960], XCU/TC2-2008/0049 [717], and
XCU/TC2-2008/0050 [960] are applied.
Issue 8
Austin Group Defect 51 is applied, specifying the behavior when n has a value greater than 256 that corresponds to an
exit status the shell assigns to commands terminated by a valid signal.
Austin Group Defect 1029 is applied, changing "trap" to "trap action" in the DESCRIPTION section.
Austin Group Defect 1309 is applied, changing the EXIT STATUS section.
Austin Group Defect 1425 is applied, clarifying the requirements for a trap action on
EXIT.
Austin Group Defect 1602 is applied, clarifying the behavior of exit in a trap action.
Austin Group Defect 1629 is applied, adding exit status 128 to the APPLICATION USAGE section.
End of informative text.
>>
NAME
export — set the export attribute for variables
SYNOPSIS
export name[=word]...
export -p
DESCRIPTION
The shell shall give the export attribute to the variables corresponding to the specified
names, which shall cause them to be in the environment of subsequently executed commands. If the name of a variable is
followed by =word, then the value of that variable shall be set to word.
The export special built-in shall be a declaration utility. Therefore, if
export is recognized as the command name of a simple command, then subsequent words of the form name=word
shall be expanded in an assignment context. See 2.9.1.1 Order of Processing.
The export special built-in shall support XBD 12.2 Utility Syntax Guidelines.
When -p is specified, export shall write to the standard output the names and
values of all exported variables, in the following format:
"export %s=%s\n", ,
if name is set, and:
"export %s\n",
if name is unset.
The shell shall format the output, including the proper use of quoting, so that it is suitable for reinput to the
shell as commands that achieve the same exporting results, except:
Read-only variables with values cannot be reset.
Variables that were unset at the time they were output need not be reset to the unset state if a value is assigned
to the variable between the time the state was saved and the time at which the saved output is reinput to the shell.
When no arguments are given, the results are unspecified.
OPTIONS
See the DESCRIPTION.
OPERANDS
See the DESCRIPTION.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
None.
ASYNCHRONOUS EVENTS
Default.
STDOUT
See the DESCRIPTION.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
0
Successful completion.
>0
At least one operand could not be processed as requested, such as a name operand that could not be exported or an
attempt to modify a readonly variable using a name=word operand, or the -p option was specified and a
write error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
Note that, unless X was previously marked readonly, the value of "$?" after:
export X=$(false)
will be 0 (because export successfully set X to the empty string) and that
execution continues, even if set -e is in effect. In order to detect command substitution
failures, a user must separate the assignment from the export, as in:
X=$(false)
export X
In shells that support extended assignment syntax, for example to allow an array to be populated with a single
assignment, such extensions can typically only be used in assignments specified as arguments to export
if the command word is literally export, and not if it is some other word that expands to export. For example:
# Shells that support array assignment as an extension generally
# support this:
export x=(1 2 3); echo ${x[0]}  # outputs 1
# But generally do not support this:
e=export; $e x=(1 2 3); echo ${x[0]}  # syntax error
EXAMPLES
Export PWD and HOME variables:
export PWD HOME
Set and export the PATH variable:
export PATH="/local/bin:$PATH"
Save and restore all exported variables:
export -p > temp-file
unset a lot of variables
... processing
. ./temp-file
Note:
If LANG, LC_CTYPE or LC_ALL are left altered or unset in the above example prior to sourcing temp-file, the results
may be undefined.
RATIONALE
Some historical shells use the no-argument case as the functional equivalent of what is required here with -p. This
feature was left unspecified because it is not historical practice in all shells, and some scripts may rely on the now-unspecified
results on their implementations. Attempts to specify the -p output as the default case were unsuccessful in achieving
consensus. The -p option was added to allow portable access to the values that can be saved and then later restored using;
for example, a dot script.
Some implementations extend the shell's assignment syntax, for example to allow an array to be populated with a
single assignment, and in order for such an extension to be usable in assignments specified as arguments to export these shells have export as a separate token in their grammar. This standard only permits an
extension of this nature when the input to the shell would contain a syntax error according to the standard grammar. Note that
although export can be a separate token in the shell's grammar, it cannot be a reserved word since export is a
candidate for alias substitution whereas reserved words are not (see 2.3.1 Alias Substitution).
FUTURE DIRECTIONS
None.
SEE ALSO
2.9.1.1 Order of Processing, 2.15 Special Built-In Utilities
XBD 12.2 Utility Syntax Guidelines
CHANGE HISTORY
Issue 6
IEEE PASC Interpretation 1003.2 #203 is applied, clarifying the format when a variable is unset.
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections
use terms as described in the Utility Description Defaults ( 1.4 Utility
Description Defaults). No change in behavior is intended.
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/6 is applied, adding the following text to the end
of the first paragraph of the DESCRIPTION: "If the name of a variable is followed by =word, then the value of that variable
shall be set to word.". The reason for this change is that the SYNOPSIS for export
includes:
export name[=word]...
but the meaning of the optional "=word" is never explained in the text.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0043 [352] is applied.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0051 [654] and XCU/TC2-2008/0052 [960] are applied.
Issue 8
Austin Group Defect 351 is applied, requiring export to be a declaration utility.
Austin Group Defect 367 is applied, changing the EXIT STATUS section.
Austin Group Defect 1258 is applied, changing the EXAMPLES section.
Austin Group Defect 1393 is applied, changing the APPLICATION USAGE and RATIONALE sections.
End of informative text.
>>
NAME
readonly — set the readonly attribute for variables
SYNOPSIS
readonly name[=word]...
readonly -p
DESCRIPTION
The variables whose names are specified shall be given the readonly attribute. The values
of variables with the readonly attribute cannot be changed by subsequent assignment or use of the
export, getopts, readonly, or read utilities, nor can those variables be unset by
the unset utility. As described in XBD 8.1
Environment Variable Definition, conforming applications shall not request to mark a variable as readonly if it is
documented as being manipulated by a shell built-in utility, as it may render those utilities unable to complete successfully. If
the name of a variable is followed by =word, then the value of that variable shall be set to word.
The readonly special built-in shall be a declaration utility. Therefore, if
readonly is recognized as the command name of a simple command, then subsequent words of the form name=word
shall be expanded in an assignment context. See 2.9.1.1 Order of Processing.
The readonly special built-in shall support XBD 12.2 Utility Syntax Guidelines.
When -p is specified, readonly writes to the standard output the names and
values of all read-only variables, in the following format:
"readonly %s=%s\n", ,
if name is set, and
"readonly %s\n",
if name is unset.
The shell shall format the output, including the proper use of quoting, so that it is suitable for reinput to the
shell as commands that achieve the same value and readonly attribute-setting results in a shell execution environment in
which:
Variables with values at the time they were output do not have the readonly attribute set.
Variables that were unset at the time they were output do not have a value at the time at which the saved output
is reinput to the shell.
When no arguments are given, the results are unspecified.
OPTIONS
See the DESCRIPTION.
OPERANDS
See the DESCRIPTION.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
None.
ASYNCHRONOUS EVENTS
Default.
STDOUT
See the DESCRIPTION.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
0
Successful completion.
>0
At least one operand could not be processed as requested, such as a name operand that could not be marked
readonly or an attempt to modify an already readonly variable using a name=word operand, or the
-p option was specified and a write error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
In shells that support extended assignment syntax, for example to allow an array to be populated with a single assignment, such
extensions can typically only be used in assignments specified as arguments to readonly if the
command word is literally readonly, and not if it is some other word that expands to readonly. For example:
# Shells that support array assignment as an extension generally
# support this:
readonly x=(1 2 3); echo ${x[0]}  # outputs 1
# But generally do not support this:
r=readonly; $r x=(1 2 3); echo ${x[0]}  # syntax error
EXAMPLES
readonly HOME
RATIONALE
Some historical shells preserve the readonly attribute across separate invocations. This volume of POSIX.1-2024 allows
this behavior, but does not require it.
The -p option allows portable access to the values that can be saved and then later restored using, for
example, a dot script. Also see the RATIONALE for export for a description of
the no-argument and -p output cases and a related example.
Read-only functions were considered, but they were omitted as not being historical practice or particularly useful.
Furthermore, functions must not be read-only across invocations to preclude "spoofing" (spoofing is the term for the practice of
creating a program that acts like a well-known utility with the intent of subverting the real intent of the user) of administrative
or security-relevant (or security-conscious) shell scripts.
Attempts to set the readonly attribute on certain variables, such as PWD , may have surprising
results. Either readonly will reject the attempt, or the attempt will succeed but the shell will
continue to alter the contents of PWD during the cd utility, or the attempt will
succeed and render the cd utility inoperative (since it must not change directories if it
cannot also update PWD ).
Some implementations extend the shell's assignment syntax, for example to allow an array to be populated with a
single assignment, and in order for such an extension to be usable in assignments specified as arguments to readonly these shells have readonly as a separate token in their grammar. This standard only permits
an extension of this nature when the input to the shell would contain a syntax error according to the standard grammar. Note that
although readonly can be a separate token in the shell's grammar, it cannot be a reserved word since readonly is a
candidate for alias substitution whereas reserved words are not (see 2.3.1 Alias Substitution).
FUTURE DIRECTIONS
None.
SEE ALSO
2.9.1.1 Order of Processing, 2.15 Special Built-In Utilities
XBD 12.2 Utility Syntax Guidelines
CHANGE HISTORY
Issue 6
IEEE PASC Interpretation 1003.2 #203 is applied, clarifying the format when a variable is unset.
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections
use terms as described in the Utility Description Defaults ( 1.4 Utility
Description Defaults). No change in behavior is intended.
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/7 is applied, adding the following text to the end
of the first paragraph of the DESCRIPTION: "If the name of a variable is followed by =word, then the value of that variable
shall be set to word.". The reason for this change is that the SYNOPSIS for readonly
includes:
readonly name[=word]...
but the meaning of the optional "=word" is never explained in the text.
Issue 7
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0052 [960] is applied.
Issue 8
Austin Group Defect 351 is applied, requiring readonly to be a declaration utility.
Austin Group Defect 367 is applied, clarifying that the values of readonly variables cannot be changed by
subsequent use of the export, getopts, readonly, or read utilities, and changing the EXIT STATUS,
EXAMPLES and RATIONALE sections.
Austin Group Defect 1393 is applied, changing the APPLICATION USAGE and RATIONALE sections.
End of informative text.
>>
NAME
return — return from a function or dot script
SYNOPSIS
return [n]
DESCRIPTION
The return utility shall cause the shell to stop executing the current function or dot script. If the shell is not currently executing a function or dot script, the
results are unspecified.
OPTIONS
None.
OPERANDS
See the DESCRIPTION.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
None.
ASYNCHRONOUS EVENTS
Default.
STDOUT
Not used.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The exit status shall be n, if specified, except that the behavior is unspecified if n is not an unsigned decimal
integer or is greater than 255. If n is not specified, the result shall be as if n were specified with the current
value of the special parameter '?' (see 2.5.2 Special Parameters), except that if the
return command would cause the end of execution of a trap action, the value
for the special parameter '?' that is considered "current" shall be the value it had immediately preceding the trap action.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
None.
EXAMPLES
None.
RATIONALE
The behavior of return when not in a function or dot script differs
between the System V shell and the KornShell. In the System V shell this is an error, whereas in the KornShell, the effect is the
same as exit.
The results of returning a number greater than 255 are undefined because of differing practices in the various
historical implementations. Some shells AND out all but the low-order 8 bits; others allow larger values, but not of unlimited
size.
See the discussion of appropriate exit status values under exit.
FUTURE DIRECTIONS
None.
SEE ALSO
2.9.5 Function Definition Command, 2.15 Special Built-In Utilities,
dot
CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as
described in the Utility Description Defaults ( 1.4 Utility Description
Defaults). No change in behavior is intended.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0044 [214] and XCU/TC1-2008/0045 [214] are applied.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0052 [960] is applied.
Issue 8
Austin Group Defect 1309 is applied, changing the EXIT STATUS section.
Austin Group Defect 1602 is applied, clarifying the behavior of return in a trap action.
End of informative text.
>>
NAME
set — set or unset options and positional parameters
SYNOPSIS
set [-abCefhmnuvx] [-o option] [argument...]
set [+abCefhmnuvx] [+o option] [argument...]
set -- [argument...]
set -o
set +o
DESCRIPTION
If no options or arguments are specified, set shall write the names and values of all
shell variables in the collation sequence of the current locale. Each name shall start on a separate line, using the
format:
"%s=%s\n", ,
The value string shall be written with appropriate quoting; see the description of shell quoting in 2.2 Quoting. The output shall be suitable for reinput to the shell, setting or resetting, as far as possible, the
variables that are currently set; read-only variables cannot be reset.
When options are specified, they shall set or unset attributes of the shell, as described below. When
arguments are specified, they cause positional parameters to be set or unset, as described below. Setting or unsetting
attributes and positional parameters are not necessarily related actions, but they can be combined in a single invocation of
set.
The set special built-in shall support XBD 12.2 Utility Syntax Guidelines except that options can be specified with either a
leading  (meaning enable the option) or  (meaning disable it) unless otherwise specified.
Implementations shall support the options in the following list in both their  and
forms. These options can also be specified as options to sh.
-a
Set the export attribute for all variable assignments. When this option is on, whenever a value is assigned to a
variable in the current shell execution environment, the export attribute shall be set for the variable. This applies to all
forms of assignment, including those made as a side-effect of variable expansions or arithmetic expansions, and those made as a
result of the operation of the cd, getopts, or read utilities.
Note:
As discussed in 2.9.1 Simple Commands, not all variable assignments happen in the current
execution environment. When an assignment happens in a separate execution environment the export attribute is still set for
the variable, but that does not affect the current execution environment.
-b
This option shall be supported if the implementation supports the User Portability Utilities option. When job control and
-b are both enabled, the shell shall write asynchronous notifications of background job completions (including termination
by a signal), and may write asynchronous notifications of background job suspensions. See 2.11 Job Control
for details. When job control is disabled, the -b option shall have no effect. Asynchronous notification shall not be
enabled by default.
-C
(Uppercase C.) Prevent existing regular files from being overwritten by the shell's '>' redirection operator (see
2.7.2 Redirecting Output); the ">|" redirection operator shall override this
noclobber option for an individual file.
-e
When this option is on, when any command fails (for any of the reasons listed in 2.8.1 Consequences of
Shell Errors or by returning an exit status greater than zero), the shell immediately shall exit, as if by executing the
exit special built-in utility with no arguments, with the following exceptions:
The failure of any individual command in a multi-command pipeline, or of any subshell environments in which
command substitution was performed during word expansion, shall not cause the shell to exit. Only the failure of the pipeline
itself shall be considered.
The -e setting shall be ignored when executing the compound list following the while, until,
if, or elif reserved word, a pipeline beginning with the ! reserved word, or any command of an AND-OR list
other than the last.
If the exit status of a compound command other than a subshell command was the result of a failure while -e
was being ignored, then -e shall not apply to this command.
This requirement applies to the shell environment and each subshell environment separately. For example, in:
set -e; (false; echo one) | cat; echo two
the false command causes the subshell to exit without executing
echo one; however, echo two is executed because the exit status of the pipeline (false; echo one) | cat
is zero.
In
set -e; echo $(false; echo one) two
the false command causes the subshell in which the command
substitution is performed to exit without executing echo one; the exit status of the subshell is ignored and the shell
then executes the word-expanded command echo two.
-f
The shell shall disable pathname expansion.
-h
[OB]
Setting this option may speed up PATH searches (see XBD 8. Environment
Variables). This option may be enabled by default.
-m
This option shall be supported if the implementation supports the User Portability Utilities option. When this option is
enabled, the shell shall perform job control actions as described in 2.11 Job Control. This option shall
be enabled by default for interactive shells.
-n
The shell shall read commands but does not execute them; this can be used to check for shell script syntax errors. Interactive
shells and subshells of interactive shells, recursively, may ignore this option.
-o
Write the current settings of the options to standard output in an unspecified format.
+o
Write the current option settings to standard output in a format that is suitable for reinput to the shell as commands that
achieve the same options settings.
-o option
Set various options, many of which shall be equivalent to the single option letters. The following values of option shall be
supported:
allexport
Equivalent to -a.
errexit
Equivalent to -e.
ignoreeof
Prevent an interactive shell from exiting on end-of-file. This setting prevents accidental logouts when -D is
entered. A user shall explicitly exit to leave the interactive shell. This option shall be supported if
the system supports the User Portability Utilities option.
monitor
Equivalent to -m. This option shall be supported if the system supports the User Portability Utilities option.
noclobber
Equivalent to -C (uppercase C).
noglob
Equivalent to -f.
noexec
Equivalent to -n.
nolog
[OB]
Prevent the entry of function definitions into the command history; see Command
History List. This option may have no effect; it is kept for compatibility with previous versions of the standard. This
option shall be supported if the system supports the User Portability Utilities option.
notify
Equivalent to -b.
nounset
Equivalent to -u.
pipefail
Derive the exit status of a pipeline from the exit statuses of all of the commands in the pipeline, not just the last
(rightmost) command, as described in 2.9.2 Pipelines.
verbose
Equivalent to -v.
vi
Allow shell command line editing using the built-in vi editor. Enabling vi mode shall disable any other command line editing mode provided as an implementation
extension. This option shall be supported if the system supports the User Portability Utilities option.
It need not be possible to set vi mode on for certain block-mode
terminals.
xtrace
Equivalent to -x.
-u
When the shell tries to expand, in a parameter expansion or an arithmetic expansion, an unset parameter other than the
'@' and '*' special parameters, it shall write a message to standard error and the expansion shall fail with the
consequences specified in 2.8.1 Consequences of Shell Errors.
-v
The shell shall write its input to standard error as it is read.
-x
The shell shall write to standard error a trace for each command after it expands the command and before it executes it. It is
unspecified whether the command that turns tracing off is traced.
The default for all these options shall be off (unset) unless stated otherwise in the description of the option or
unless the shell was invoked with them on; see sh.
The remaining arguments shall be assigned in order to the positional parameters. The special parameter '#'
shall be set to reflect the number of positional parameters. All positional parameters shall be unset before any new values are
assigned.
If the first argument is '-', the results are unspecified.
The special argument "--" immediately following the set command name can be used
to delimit the arguments if the first argument begins with '+' or '-', or to prevent inadvertent listing of all
shell variables when there are no arguments. The command set -- without argument shall
unset all positional parameters and set the special parameter '#' to zero.
OPTIONS
See the DESCRIPTION.
OPERANDS
See the DESCRIPTION.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
None.
ASYNCHRONOUS EVENTS
Default.
STDOUT
See the DESCRIPTION.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
0
Successful completion.
>0
An invalid option was specified, or an error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
Application writers should avoid relying on set -e within functions. For example, in the
following script:
set -e
start() {
some_server
echo some_server started successfully
}
start || echo >&2 some_server failed
the -e setting is ignored within the function body (because the function is a command in an AND-OR list
other than the last). Therefore, if some_server fails, the function carries on to echo "some_server started
successfully", and the exit status of the function is zero (which means "some_server failed" is not output).
Use of set -n causes the shell to parse the rest of the script without executing
any commands, meaning that set +n cannot be used to undo the effect. Syntax checking is more
commonly done via sh -n script_name.
EXAMPLES
Write out all variables and their values:
set
Set $1, $2, and $3 and set "$#" to 3:
set c a b
Turn on the -x and -v options:
set -xv
Unset all positional parameters:
set --
Set $1 to the value of x, even if it begins with '-' or '+':
set -- "$x"
Set the positional parameters to the expansion of x, even if x expands with a leading '-' or
'+':
set -- $x
RATIONALE
The set -- form is listed specifically in the SYNOPSIS even though this usage is implied by the
Utility Syntax Guidelines. The explanation of this feature removes any ambiguity about whether the set --
form might be misinterpreted as being equivalent to set without any options or arguments. The
functionality of this form has been adopted from the KornShell. In System V, set -- only unsets
parameters if there is at least one argument; the only way to unset all parameters is to use shift.
Using the KornShell version should not affect System V scripts because there should be no reason to issue it without arguments
deliberately; if it were issued as, for example:
set -- "$@"
and there were in fact no arguments resulting from "$@", unsetting the parameters would have no
result.
The set + form in early proposals was omitted as being an unnecessary duplication of
set alone and not widespread historical practice.
The noclobber option was changed to allow set -C as well as the set -o noclobber option. The single-letter version was added so that the historical "$-"
paradigm would not be broken; see 2.5.2 Special Parameters.
The description of the -e option is intended to match the behavior of the 1988 version of the KornShell.
The -h option is related to command name hashing. See hash.
The normative description is deliberately vague because the way this option works varies between shell implementations.
Earlier versions of this standard specified -h as a way to locate and remember utilities to be invoked by
functions as those functions are defined (the utilities are normally located when the function is executed). However, this did not
match existing practice in most shells.
The following set options were omitted intentionally with the following rationale:
-k
The -k option was originally added by the author of the Bourne shell to make it easier for users of pre-release versions
of the shell. In early versions of the Bourne shell the construct set name=value had to be
used to assign values to shell variables. The problem with -k is that the behavior affects parsing, virtually precluding
writing any compilers. To explain the behavior of -k, it is necessary to describe the parsing algorithm, which is
implementation-defined. For example:
set -k; echo name=value
and:
set -k
echo name=value
behave differently. The interaction with functions is even more complex. What is more, the -k option is
never needed, since the command line could have been reordered.
-t
The -t option is hard to specify and almost never used. The only known use could be done with here-documents. Moreover,
the behavior with ksh and sh differs. The reference page says that it exits after
reading and executing one command. What is one command? If the input is date;date, sh executes both date commands while ksh does
only the first.
Consideration was given to rewriting set to simplify its confusing syntax. A specific
suggestion was that the unset utility should be used to unset options instead of using the non-getopt()-able +option syntax. However, the conclusion was reached that the historical
practice of using +option was satisfactory and that there was no compelling reason to modify such widespread historical
practice.
The -o option was adopted from the KornShell to address user needs. In addition to its generally friendly
interface, -o is needed to provide the vi command line editing mode, for which
historical practice yields no single-letter option name. (Although it might have been possible to invent such a letter, it was
recognized that other editing modes would be developed and -o provides ample name space for describing such extensions.)
Historical implementations are inconsistent in the format used for -o option status reporting. The +o
format without an option-argument was added to allow portable access to the options that can be saved and then later restored
using, for instance, a dot script.
Historically, sh did trace the command set
+x, but ksh did not.
The ignoreeof setting prevents accidental logouts when the end-of-file character (typically
-D) is entered. A user shall explicitly exit to leave the interactive shell.
The set -m option was added to apply only to the UPE because it applies primarily
to interactive use, not shell script applications.
The ability to do asynchronous notification became available in the 1988 version of the KornShell. To have it
occur, the user had to issue the command:
trap "jobs -n" CLD
The C shell provides two different levels of an asynchronous notification capability. The environment variable
notify is analogous to what is done in set -b or set -o
notify. When set, it notifies the user immediately of background job completions. When unset, this capability is turned
off.
The other notification ability comes through the built-in utility notify. The syntax is:
notify [%job ... ]
By issuing notify with no operands, it causes the C shell to notify the user asynchronously when the state
of the current job changes. If given operands, notify asynchronously informs the user of changes in the states of the
specified jobs.
To add asynchronous notification to the POSIX shell, neither the KornShell extensions to trap, nor the C shell notify environment variable seemed appropriate (notify is not a proper POSIX
environment variable name).
The set -b option was selected as a compromise.
The notify built-in was considered to have more functionality than was required for simple asynchronous
notification.
Historically, some shells applied the -u option to all parameters including $@ and $*. The
standard developers felt that this was a misfeature since it is normal and common for $@ and $* to be used in
shell scripts regardless of whether they were passed any arguments. Treating these uses as an error when no arguments are passed
reduces the value of -u for its intended purpose of finding spelling mistakes in variable names and uses of unset positional
parameters.
FUTURE DIRECTIONS
A future version of this standard may remove the -o nolog option.
SEE ALSO
2.15 Special Built-In Utilities, hash
XBD 4.26 Variable Assignment, 12.2 Utility Syntax Guidelines
CHANGE HISTORY
Issue 6
The obsolescent set command name followed by '-' has been removed.
The following new requirements on POSIX implementations derive from alignment with the Single UNIX
Specification:
The nolog option is added to set -o.
IEEE PASC Interpretation 1003.2 #167 is applied, clarifying that the options default also takes into account the
description of the option.
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections
use terms as described in the Utility Description Defaults ( 1.4 Utility
Description Defaults). No change in behavior is intended.
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/8 is applied, changing the square brackets in the
example in RATIONALE to be in bold, which is the typeface used for optional items.
Issue 7
Austin Group Interpretation 1003.1-2001 #027 is applied, clarifying the behavior if the first argument is '-'.
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
XSI shading is removed from the -h functionality.
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0046 [52], XCU/TC1-2008/0047 [155,280], XCU/TC1-2008/0048 [52],
XCU/TC1-2008/0049 [52], and XCU/TC1-2008/0050 [155,430] are applied.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0053 [584], XCU/TC2-2008/0054 [717], XCU/TC2-2008/0055 [717],
and XCU/TC2-2008/0056 [960] are applied.
Issue 8
Austin Group Defect 559 is applied, changing the description of the -u option.
Austin Group Defect 789 is applied, adding -o pipefail.
Austin Group Defect 981 is applied, changing the description of the -o nolog option and the FUTURE
DIRECTIONS section.
Austin Group Defects 1009 and 1555 are applied, changing the description of the -a option.
Austin Group Defect 1016 is applied, changing the description of the -C option.
Austin Group Defect 1055 is applied, adding a paragraph about the -n option to the APPLICATION USAGE
section.
Austin Group Defect 1063 is applied, changing the description of the -h option.
Austin Group Defect 1150 is applied, changing the description of the -e option.
Austin Group Defect 1207 is applied, clarifying which option-arguments of the -o option are related to the
User Portability Utilities option.
Austin Group Defect 1254 is applied, changing the descriptions of the -b and -m options.
Austin Group Defect 1384 is applied, allowing subshells of interactive shells to ignore the -n option.
End of informative text.
>>
NAME
shift — shift positional parameters
SYNOPSIS
shift [n]
DESCRIPTION
The positional parameters shall be shifted. Positional parameter 1 shall be assigned the value of parameter (1+n),
parameter 2 shall be assigned the value of parameter (2+n), and so on. The parameters represented by the numbers
"$#" down to "$#-n+1" shall be unset, and the parameter '#' is updated to reflect the new number of
positional parameters.
The value n shall be an unsigned decimal integer less than or equal to the value of the special parameter
'#'. If n is not given, it shall be assumed to be 1. If n is 0, the positional and special parameters are
not changed.
OPTIONS
None.
OPERANDS
See the DESCRIPTION.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
None.
ASYNCHRONOUS EVENTS
Default.
STDOUT
Not used.
STDERR
The standard error shall be used only for diagnostic messages and the warning message specified in EXIT STATUS.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
If the n operand is invalid or is greater than "$#", this may be treated as an error and a non-interactive shell
may exit; if the shell does not exit in this case, a non-zero exit status shall be returned and a warning message shall be written
to standard error. Otherwise, zero shall be returned.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
None.
EXAMPLES
$
set a b c d e
$
shift 2
$
echo $*
c d e
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
2.15 Special Built-In Utilities
CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as
described in the Utility Description Defaults ( 1.4 Utility Description
Defaults). No change in behavior is intended.
Issue 7
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0051 [459] is applied.
Issue 8
Austin Group Defect 1265 is applied, updating the EXIT STATUS and STDERR sections to align with the changes made to 2.8.1 Consequences of Shell Errors between Issue 6 and Issue 7.
End of informative text.
>>
NAME
times — write process times
SYNOPSIS
times
DESCRIPTION
The times utility shall write the accumulated user and system times for the shell and for all of its
child processes, in the following POSIX locale format:
"%dm%fs %dm%fs\n%dm%fs %dm%fs\n", ,
, ,
, ,
, ,
The four pairs of times shall correspond to the members of the  tms structure (defined in XBD 14. Headers) as returned by times():
tms_utime, tms_stime, tms_cutime, and tms_cstime, respectively.
OPTIONS
None.
OPERANDS
None.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
None.
ASYNCHRONOUS EVENTS
Default.
STDOUT
See the DESCRIPTION.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
None.
EXAMPLES
$
times
0m0.43s 0m1.11s
8m44.18s 1m43.23s
RATIONALE
The times special built-in from the Single UNIX Specification is now required for all conforming
shells.
FUTURE DIRECTIONS
None.
SEE ALSO
2.15 Special Built-In Utilities
XBD
CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/9 is applied, changing text in the DESCRIPTION from: "Write the
accumulated user and system times for the shell and for all of its child processes ..." to: "The times utility shall write the accumulated user and system times for the shell and for all of its child
processes ...".
Issue 7
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0056 [960] is applied.
End of informative text.
>>
NAME
trap — trap signals
SYNOPSIS
trap n [condition...]
trap -p [condition...]
trap [action condition...]
DESCRIPTION
If the -p option is not specified and the first operand is an unsigned decimal integer, the shell shall treat all
operands as conditions, and shall reset each condition to the default value. Otherwise, if the -p option is not specified
and there are operands, the first operand shall be treated as an action and the remaining as conditions.
If action is '-', the shell shall reset each condition to the default value. If
action is null (""), the shell shall ignore each specified condition if it arises. Otherwise, the argument
action shall be read and executed by the shell when one of the corresponding conditions arises. The action of trap shall override a previous action (either default action or one explicitly set). The value of "$?"
after the trap action completes shall be the value it had before the trap
action was executed.
The condition can be EXIT, 0 (equivalent to EXIT), or a signal specified using a symbolic name, without the SIG
prefix, as listed in the tables of signal names in the  header
defined in XBD 14. Headers; for example, HUP, INT, QUIT, TERM.
Implementations may permit names with the SIG prefix or ignore case in signal names as an extension. Setting a trap for SIGKILL or
SIGSTOP produces undefined results.
The EXIT condition shall occur when the shell terminates normally (exits), and may occur when the shell terminates
abnormally as a result of delivery of a signal (other than SIGKILL) whose trap action is the
default.
The environment in which the shell executes a trap action on EXIT shall be identical to
the environment immediately after the last command executed before the trap action on EXIT was
executed.
If action is neither '-' nor the empty string, then each time a matching condition arises,
the action shall be executed in a manner equivalent to:
eval action
Signals that were ignored on entry to a non-interactive shell cannot be trapped or reset, although no error need be
reported when attempting to do so. An interactive shell may reset or catch signals ignored on entry. Traps shall remain in place
for a given shell until explicitly changed with another trap command.
When a subshell is entered, traps that are not being ignored shall be set to the default actions, except in the
case of a command substitution containing only a single trap command, when the traps need not be
altered. Implementations may check for this case using only lexical analysis; for example, if `trap` and $( trap --
) do not alter the traps in the subshell, cases such as assigning var=trap and then using $($var) may still
alter them. This does not imply that the trap command cannot be used within the subshell to set new
traps.
The trap command with no operands shall write to standard output a list of commands
associated with each of a set of conditions; if the -p option is not specified, this set shall contain only the conditions
that are not in the default state (including signals that were ignored on entry to a non-interactive shell); if the -p
option is specified, the set shall contain all conditions, except that it is unspecified whether conditions corresponding to the
SIGKILL and SIGSTOP signals are included in the set. If the command is executed in a subshell, the implementation does not perform
the optional check described above for a command substitution containing only a single trap command, and
no trap commands with operands have been executed since entry to the subshell, the list shall contain
the commands that were associated with each condition immediately before the subshell environment was entered. Otherwise, the list
shall contain the commands currently associated with each condition. The format shall be:
"trap -- %s %s ...\n", ,  ...
The shell shall format the output, including the proper use of quoting, so that it is suitable for reinput to the
shell as commands that achieve the same trapping results for the set of conditions included in the output, except for signals that
were ignored on entry to the shell as described above. If this set includes conditions corresponding to the SIGKILL and SIGSTOP
signals, the shell shall accept them when the output is reinput to the shell (where accepting them means they do not cause a
non-zero exit status, a diagnostic message, or undefined behavior). For example:
save_traps=$(trap -p)
...
eval "$save_traps"
or:
save_traps=$(trap -p INT QUIT)
trap "some command" INT QUIT
...
eval "$save_traps"
[XSI]  XSI-conformant systems also allow numeric signal numbers for the conditions corresponding to the following signal
names:
1
SIGHUP
2
SIGINT
3
SIGQUIT
6
SIGABRT
9
SIGKILL
14
SIGALRM
15
SIGTERM
If an invalid signal name [XSI]   or number  is specified, the trap utility shall write a warning message to standard error.
The trap special built-in shall conform to XBD 12.2 Utility Syntax Guidelines.
OPTIONS
The following option shall be supported:
-p
Write to standard output a list of commands associated with each condition operand. The behavior when there are no
operands is specified in the DESCRIPTION section.
The shell shall format the output, including the proper use of quoting, so that it is suitable for reinput to the
shell as commands that achieve the same trapping results for the specified set of conditions. If a condition operand is a
condition corresponding to the SIGKILL or SIGSTOP signal, and trap -p without any operands would
not include it in the set of conditions for which it writes output, the behavior is undefined if the output is reinput to the
shell.
OPERANDS
See the DESCRIPTION.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
None.
ASYNCHRONOUS EVENTS
Default.
STDOUT
See the DESCRIPTION.
STDERR
The standard error shall be used only for diagnostic messages and warning messages about invalid signal names [XSI]   or numbers.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
If the trap name [XSI]   or number  is invalid, a non-zero
exit status shall be returned; otherwise, zero shall be returned. For both interactive and non-interactive shells, invalid signal
names [XSI]   or numbers  shall not be considered an error and shall
not cause the shell to abort.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
When the -p option is not used, since trap with no operands does not output commands to
restore traps that are currently set to default, these need to be restored separately. The RATIONALE section shows examples and
describes their drawbacks.
EXAMPLES
Write out a list of all traps and actions:
trap
Set a trap so the logout utility in the directory referred to by the HOME environment variable
executes when the shell terminates:
trap '"$HOME"/logout' EXIT
or:
trap '"$HOME"/logout' 0
Unset traps on INT, QUIT, TERM, and EXIT:
trap - INT QUIT TERM EXIT
RATIONALE
Implementations may permit lowercase signal names as an extension. Implementations may also accept the names with the SIG
prefix; no known historical shell does so. The trap and kill
utilities in this volume of POSIX.1-2024 are now consistent in their omission of the SIG prefix for signal names. Some kill implementations do not allow the prefix, and kill -l lists the signals without prefixes.
Trapping SIGKILL or SIGSTOP is syntactically accepted by some historical implementations, but it has no effect.
Portable POSIX applications cannot attempt to trap these signals.
The output format is not historical practice. Since the output of historical trap
commands is not portable (because numeric signal values are not portable) and had to change to become so, an opportunity was taken
to format the output in a way that a shell script could use to save and then later reuse a trap if it wanted.
The KornShell uses an ERR trap that is triggered whenever set -e would
cause an exit. This is allowable as an extension, but was not mandated, as other shells have not used it.
The text about the environment for the EXIT trap invalidates the behavior of some historical versions of
interactive shells which, for example, close the standard input before executing a trap on 0. For example, in some historical
interactive shell sessions the following trap on 0 would always print "--":
trap 'read foo; echo "-$foo-"' 0
The command:
trap 'eval " $cmd"' 0
causes the contents of the shell variable cmd to be executed as a command when the shell exits. Using:
trap '$cmd' 0
does not work correctly if cmd contains any special characters such as quoting or redirections. Using:
trap " $cmd" 0
also works (the leading  character protects against unlikely cases where cmd is a decimal
integer or begins with '-'), but it expands the cmd variable when the trap command is
executed, not when the exit action is executed.
The -p option was added because without it the method used to restore traps needs to include special
handling of traps that are set to default when trap with no operands is used to save the current traps.
One example is:
save_traps=$(trap)
trap "some command" INT QUIT
save_traps="trap - INT QUIT; $save_traps"
...
eval "$save_traps"
but this method relies on hard-coding the commands to reset the traps that are being set. It also has a race
condition if INT or QUIT was not set to default when saved, since it first sets them to default and then restores the saved traps.
A more general approach would be:
save_traps=$(trap)
...
for sig in EXIT $( kill -l )
do
case "$sig" in
SIGKILL | KILL | sigkill | kill | SIGSTOP | STOP | sigstop | stop)
;;
*) trap - $sig
;;
esac
done
eval "$save_traps"
This has the same race condition since it first sets all traps (that can be set) to default and then restores those
that were not previously set to default.
Historically, some shells behaved the same with and without -p when there are no operands. This standard
requires that the set of conditions differs between the two cases: with -p it is all conditions (except possibly SIGKILL and
SIGSTOP); without -p it is only the conditions that are not in the default state.
FUTURE DIRECTIONS
None.
SEE ALSO
2.15 Special Built-In Utilities
XBD 12.2 Utility Syntax Guidelines,
CHANGE HISTORY
Issue 6
XSI-conforming implementations provide the mapping of signal names to numbers given above (previously this had been marked
obsolescent). Other implementations need not provide this optional mapping.
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections
use terms as described in the Utility Description Defaults ( 1.4 Utility
Description Defaults). No change in behavior is intended.
Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
Austin Group Interpretation 1003.1-2001 #116 is applied.
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0052 [53,268,440], XCU/TC1-2008/0053 [53,268,440],
XCU/TC1-2008/0054 [163], XCU/TC1-2008/0055 [163], and XCU/TC1-2008/0056 [163] are applied.
Issue 8
Austin Group Defect 621 is applied, clarifying when the EXIT condition occurs.
Austin Group Defect 1029 is applied, clarifying the execution of trap actions.
Austin Group Defects 1211 and 1212 are applied, adding the -p option and clarifying that, when -p is
not specified, the output of trap with no operands does not list conditions that are in the default
state.
Austin Group Defect 1265 is applied, updating the DESCRIPTION, STDERR and EXIT STATUS sections to align with the
changes made to 2.8.1 Consequences of Shell Errors between Issue 6 and Issue 7.
Austin Group Defect 1285 is applied, inserting a blank line between the two SYNOPSIS lines.
End of informative text.
>>
NAME
unset — unset values and attributes of variables and functions
SYNOPSIS
unset [-fv] name...
DESCRIPTION
The unset utility shall unset each variable or function definition specified by name that
does not have the readonly attribute and remove any attributes other than readonly that have been given to
name (see 2.15 Special Built-In Utilities export and readonly).
If -v is specified, name refers to a variable name and the shell shall unset it and remove it from
the environment. Read-only variables cannot be unset.
If -f is specified, name refers to a function and the shell shall unset the function definition.
If neither -f nor -v is specified, name refers to a variable; if a variable by that name does
not exist, it is unspecified whether a function by that name, if any, shall be unset.
Unsetting a variable or function that was not previously set shall not be considered an error and does not cause
the shell to abort.
The unset special built-in shall support XBD 12.2 Utility Syntax Guidelines.
Note that:
VARIABLE=
is not equivalent to an unset of VARIABLE; in the example, VARIABLE is
set to "". Also, the variables that can be unset should not be misinterpreted to include the
special parameters (see 2.5.2 Special Parameters).
OPTIONS
See the DESCRIPTION.
OPERANDS
See the DESCRIPTION.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
None.
ASYNCHRONOUS EVENTS
Default.
STDOUT
Not used.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
0
All name operands were successfully unset.
>0
At least one name could not be unset.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
None.
EXAMPLES
Unset VISUAL variable:
unset -v VISUAL
Unset the functions foo and bar:
unset -f foo bar
RATIONALE
Consideration was given to omitting the -f option in favor of an unfunction utility, but the standard developers
decided to retain historical practice.
The -v option was introduced because System V historically used one name space for both variables and
functions. When unset is used without options, System V historically unset either a function or a
variable, and there was no confusion about which one was intended. A portable POSIX application can use unset without an option to unset a variable, but not a function; the -f option must be used.
FUTURE DIRECTIONS
None.
SEE ALSO
2.15 Special Built-In Utilities
XBD 12.2 Utility Syntax Guidelines
CHANGE HISTORY
Issue 6
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/5 is applied so that the reference page sections use terms as
described in the Utility Description Defaults ( 1.4 Utility Description
Defaults). No change in behavior is intended.
Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
Issue 8
Austin Group Defect 1075 is applied, clarifying that unset removes attributes, other than
readonly, from the variables it unsets.
End of informative text.
>>
===== susv5-html/utilities/cp.html =====
cp
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
cp — copy files
SYNOPSIS
cp [-Pfip] source_file target_file
cp [-Pfip] source_file... target
cp -R [-H|-L|-P] [-fip] source_file... target
DESCRIPTION
The first synopsis form is denoted by two operands, neither of which are existing files of type directory. The cp utility
shall copy the contents of source_file (or, if source_file is a file of type symbolic link, the contents of the file
referenced by source_file) to the destination path named by target_file.
The second synopsis form is denoted by two or more operands where the -R option is not specified and the first synopsis
form is not applicable. It shall be an error if any source_file is a file of type directory, if target does not
exist, or if target does not name a directory. The cp utility shall copy the contents of each source_file (or,
if source_file is a file of type symbolic link, the contents of the file referenced by source_file) to the
destination path named by the concatenation of target, a single  character if target did not end in a
, and the last component of source_file.
The third synopsis form is denoted by two or more operands where the -R option is specified. The cp utility shall
copy each file in the file hierarchy rooted in each source_file to a destination path named as follows:
If target exists and names an existing directory, the name of the corresponding destination path for each file in the
file hierarchy shall be the concatenation of target, a single  character if target did not end in a
, and the pathname of the file relative to the directory containing source_file.
If target does not exist and two operands are specified, the name of the corresponding destination path for
source_file shall be target; the name of the corresponding destination path for all other files in the file hierarchy
shall be the concatenation of target, a  character, and the pathname of the file relative to
source_file.
It shall be an error if target does not exist and more than two operands are specified, or if target exists and
does not name a directory.
In the following description, the term dest_file refers to the file named by the destination path. The term
source_file refers to the file that is being copied, whether specified as an operand or a file in a file hierarchy rooted in
a source_file operand. If source_file is a file of type symbolic link:
If the -R option was not specified, cp shall take actions based on the type and contents of the file referenced by
the symbolic link, and not by the symbolic link itself, unless the -P option was specified.
If the -R option was specified:
If none of the options -H, -L, nor -P were specified, it is unspecified which of -H, -L, or
-P will be used as a default.
If the -H option was specified, cp shall take actions based on the type and contents of the file referenced by any
symbolic link specified as a source_file operand.
If the -L option was specified, cp shall take actions based on the type and contents of the file referenced by any
symbolic link specified as a source_file operand or any symbolic links encountered during traversal of a file hierarchy.
If the -P option was specified, cp shall copy any symbolic link specified as a source_file operand and any
symbolic links encountered during traversal of a file hierarchy, and shall not follow any symbolic links.
For each source_file, the following steps shall be taken:
If source_file references the same file as dest_file, cp may write a diagnostic message to standard error;
it shall do nothing more with source_file and shall go on to any remaining files.
If source_file is of type directory, the following steps shall be taken:
If the -R option was not specified, cp shall write a diagnostic message to standard error, do nothing more with
source_file, and go on to any remaining files.
If source_file was not specified as an operand and source_file is dot or dot-dot, cp shall do nothing more
with source_file and go on to any remaining files.
If dest_file exists and it is a file type not specified by the System Interfaces volume of POSIX.1-2024, the behavior is
implementation-defined.
If dest_file exists and it is not of type directory, cp shall write a diagnostic message to standard error, do
nothing more with source_file or any files below source_file in the file hierarchy, and go on to any remaining
files.
If the directory dest_file does not exist, it shall be created with file permission bits set to the same value as those
of source_file, modified by the file creation mask of the user if the -p option was not specified, and then
bitwise-inclusively OR'ed with S_IRWXU. If dest_file cannot be created, cp shall write a diagnostic message to
standard error, do nothing more with source_file, and go on to any remaining files. It is unspecified if cp attempts
to copy files in the file hierarchy rooted in source_file.
The files in the directory source_file shall be copied to the directory dest_file, taking the four steps (1 to 4)
listed here with the files as source_files.
If dest_file was created, its file permission bits shall be changed (if necessary) to be the same as those of
source_file, modified by the file creation mask of the user if the -p option was not specified.
The cp utility shall do nothing more with source_file and go on to any remaining files.
If source_file is of type regular file, the following steps shall be taken:
The behavior is unspecified if dest_file exists and was written by a previous step. Otherwise, if dest_file
exists, the following steps shall be taken:
If the -i option is in effect, the cp utility shall write a prompt to the standard error and read a line from the
standard input. If the response is not affirmative, cp shall do nothing more with source_file and go on to any
remaining files.
A file descriptor for dest_file shall be obtained by performing actions equivalent to the open() function defined in the System Interfaces volume of POSIX.1-2024 called using
dest_file as the path argument, and the bitwise-inclusive OR of O_WRONLY and O_TRUNC as the oflag
argument.
If the attempt to obtain a file descriptor fails and the -f option is in effect, cp shall attempt to remove the
file by performing actions equivalent to the unlink() function defined in the System
Interfaces volume of POSIX.1-2024 called using dest_file as the path argument. If this attempt succeeds, cp
shall continue with step 3b.
If dest_file does not exist, a file descriptor shall be obtained by performing actions equivalent to the open() function defined in the System Interfaces volume of POSIX.1-2024 called using
dest_file as the path argument, and the bitwise-inclusive OR of O_WRONLY and O_CREAT as the oflag argument.
The file permission bits of source_file shall be the mode argument.
If the attempt to obtain a file descriptor fails, cp shall write a diagnostic message to standard error, do nothing more
with source_file, and go on to any remaining files.
The contents of source_file shall be written to the file descriptor. Any write errors shall cause cp to write a
diagnostic message to standard error and continue to step 3e.
The file descriptor shall be closed.
The cp utility shall do nothing more with source_file. If a write error occurred in step 3d, it is unspecified if
cp continues with any remaining files. If no write error occurred in step 3d, cp shall go on to any remaining
files.
Otherwise, the -R option was specified, and the following steps shall be taken:
The dest_file shall be created with the same file type as source_file.
If source_file is a file of type FIFO, the file permission bits shall be the same as those of source_file,
modified by the file creation mask of the user if the -p option was not specified. Otherwise, the permissions, owner ID, and
group ID of dest_file are implementation-defined.
If this creation fails for any reason, cp shall write a diagnostic message to standard error, do nothing more with
source_file, and go on to any remaining files.
If source_file is a file of type symbolic link, and the options require the symbolic link itself to be acted upon, the
pathname contained in dest_file shall be the same as the pathname contained in source_file.
If this fails for any reason, cp shall write a diagnostic message to standard error, do nothing more with
source_file, and go on to any remaining files.
If the implementation provides additional or alternate access control mechanisms (see XBD 4.7 File Access Permissions), their effect on copies of files is
implementation-defined.
OPTIONS
The cp utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following options shall be supported:
-f
If a file descriptor for a destination file cannot be obtained, as described in step 3.a.ii., attempt to unlink the destination
file and proceed.
-H
Take actions based on the type and contents of the file referenced by any symbolic link specified as a source_file
operand.
-i
Write a prompt to standard error before copying to any existing non-directory destination file. If the response from the
standard input is affirmative, the copy shall be attempted; otherwise, it shall not.
-L
Take actions based on the type and contents of the file referenced by any symbolic link specified as a source_file
operand or any symbolic links encountered during traversal of a file hierarchy.
-P
Take actions on any symbolic link specified as a source_file operand or any symbolic link encountered during traversal
of a file hierarchy.
-p
Duplicate the following characteristics of each source file in the corresponding destination file:
The time of last data modification and time of last access. If this duplication fails for any reason, cp shall write a
diagnostic message to standard error.
The user ID and group ID. If this duplication fails for any reason, it is unspecified whether cp writes a diagnostic
message to standard error.
The file permission bits and the S_ISUID and S_ISGID bits. Other, implementation-defined, bits may be duplicated as well. If
this duplication fails for any reason, cp shall write a diagnostic message to standard error.
If the user ID or the group ID cannot be duplicated, the file permission bits S_ISUID and S_ISGID shall be cleared. If these
bits are present in the source file but are not duplicated in the destination file, it is unspecified whether cp writes a
diagnostic message to standard error.
The order in which the preceding characteristics are duplicated is unspecified. The dest_file shall not be deleted if
these characteristics cannot be preserved.
-R
Copy file hierarchies.
Specifying more than one of the mutually-exclusive options -H, -L, and -P shall not be considered an error.
The last option specified shall determine the behavior of the utility.
OPERANDS
The following operands shall be supported:
source_file
A pathname of a file to be copied. If a source_file operand is '-', it shall refer to a file named -;
implementations shall not treat it as meaning standard input.
target_file
A pathname of an existing or nonexistent file, used for the output when a single file is copied. If a target_file
operand is '-', it shall refer to a file named -; implementations shall not treat it as meaning standard
output.
target
A pathname of a directory to contain the copied files.
STDIN
The standard input shall be used to read an input line in response to each prompt specified in the STDERR section. Otherwise,
the standard input shall not be used.
INPUT FILES
The input files specified as operands may be of any file type.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of cp:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_COLLATE
Determine the locale for the behavior of ranges, equivalence classes, and multi-character collating elements used in the extended
regular expression defined for the yesexpr locale keyword in the LC_MESSAGES category.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files) and the behavior of character classes used in the extended regular
expression defined for the yesexpr locale keyword in the LC_MESSAGES category.
LC_MESSAGES
Determine the locale used to process affirmative responses, and the locale used to affect the format and contents of diagnostic
messages and prompts written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
Not used.
STDERR
A prompt shall be written to standard error under the conditions specified in the DESCRIPTION section. The prompt shall contain
the destination pathname, but its format is otherwise unspecified. Otherwise, the standard error shall be used only for diagnostic
messages.
OUTPUT FILES
The output files may be of any type.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
All requested files (excluding files where a non-affirmative response was given to a request for confirmation) were
successfully copied.
>0
An error occurred.
CONSEQUENCES OF ERRORS
If cp is prematurely terminated by a signal or error, files or file hierarchies may be only partially copied and files
and directories may have incorrect permissions or access and modification times.
The following sections are informative.
APPLICATION USAGE
The set-user-ID and set-group-ID bits are explicitly cleared when files are created. This is to prevent users from creating
programs that are set-user-ID or set-group-ID to them when copying files or to make set-user-ID or set-group-ID files accessible to
new groups of users. For example, if a file is set-user-ID and the copy has a different group ID than the source, a new group of
users has execute permission to a set-user-ID program than did previously. In particular, this is a problem for superusers copying
users' trees.
EXAMPLES
None.
RATIONALE
The -i option exists on BSD systems, giving applications and users a way to avoid accidentally removing files when
copying. Although the 4.3 BSD version does not prompt if the standard input is not a terminal, the standard developers decided that
use of -i is a request for interaction, so when the destination path exists, the utility takes instructions from whatever
responds on standard input.
The exact format of the interactive prompts is unspecified. Only the general nature of the contents of prompts are specified
because implementations may desire more descriptive prompts than those used on historical implementations. Therefore, an
application using the -i option relies on the system to provide the most suitable dialog directly with the user, based on
the behavior specified.
The -p option is historical practice on BSD systems, duplicating the time of last data modification and time of last
access. This volume of POSIX.1-2024 extends it to preserve the user and group IDs, as well as the file permissions. This
requirement has obvious problems in that the directories are almost certainly modified after being copied. This volume of
POSIX.1-2024 requires that the modification times be preserved. The statement that the order in which the characteristics are
duplicated is unspecified is to permit implementations to provide the maximum amount of security for the user. Implementations
should take into account the obvious security issues involved in setting the owner, group, and mode in the wrong order or creating
files with an owner, group, or mode different from the final value.
It is unspecified whether cp writes diagnostic messages when the user and group IDs cannot be set due to the widespread
practice of users using -p to duplicate some portion of the file characteristics, indifferent to the duplication of others.
Historic implementations only write diagnostic messages on errors other than [EPERM].
Earlier versions of this standard included support for the -r option to copy file hierarchies. The -r option is
historical practice on BSD and BSD-derived systems. This option is no longer specified by POSIX.1-2024 but may be present in some
implementations. The -R option was added as a close synonym to the -r option, selected for consistency with all other
options in this volume of POSIX.1-2024 that do recursive directory descent.
The difference between -R and the removed -r option is in the treatment by cp of file types other than
regular and directory. It was implementation-defined how the - option treated special files to allow both historical
implementations and those that chose to support -r with the same abilities as -R defined by this volume of
POSIX.1-2024. The original -r flag, for historic reasons, did not handle special files any differently from regular files,
but always read the file and copied its contents. This had obvious problems in the presence of special file types; for example,
character devices, FIFOs, and sockets.
When a failure occurs during the copying of a file hierarchy, cp is required to attempt to copy files that are on the
same level in the hierarchy or above the file where the failure occurred. It is unspecified if cp shall attempt to copy
files below the file where the failure occurred (which cannot succeed in any case).
Permissions, owners, and groups of created special file types have been deliberately left as implementation-defined. This is to
allow systems to satisfy special requirements (for example, allowing users to create character special devices, but requiring them
to be owned by a certain group). In general, it is strongly suggested that the permissions, owner, and group be the same as if the
user had run the historical mknod, ln, or other utility to create the file. It is
also probable that additional privileges are required to create block, character, or other implementation-defined special file
types.
Additionally, the -p option explicitly requires that all set-user-ID and set-group-ID permissions be discarded if any of
the owner or group IDs cannot be set. This is to keep users from unintentionally giving away special privilege when copying
programs.
When creating regular files, historical versions of cp use the mode of the source file as modified by the file mode
creation mask. Other choices would have been to use the mode of the source file unmodified by the creation mask or to use the same
mode as would be given to a new file created by the user (plus the execution bits of the source file) and then modify it by the
file mode creation mask. In the absence of any strong reason to change historic practice, it was in large part retained.
When creating directories, historical versions of cp use the mode of the source directory, plus read, write, and search
bits for the owner, as modified by the file mode creation mask. This is done so that cp can copy trees where the user has
read permission, but the owner does not. A side-effect is that if the file creation mask denies the owner permissions, cp
fails. Also, once the copy is done, historical versions of cp set the permissions on the created directory to be the same as
the source directory, unmodified by the file creation mask.
This behavior has been modified so that cp is always able to create the contents of the directory, regardless of the file
creation mask. After the copy is done, the permissions are set to be the same as the source directory, as modified by the file
creation mask. This latter change from historical behavior is to prevent users from accidentally creating directories with
permissions beyond those they would normally set and for consistency with the behavior of cp in creating files.
It is not a requirement that cp detect attempts to copy a file to itself; however, implementations are strongly
encouraged to do so. Historical implementations have detected the attempt in most cases.
There are two methods of copying subtrees in this volume of POSIX.1-2024. The other method is described as part of the pax utility (see pax). Both methods are historical
practice. The cp utility provides a simpler, more intuitive interface, while pax
offers a finer granularity of control. Each provides additional functionality to the other; in particular, pax maintains the hard-link structure of the hierarchy, while cp does not. It is the
intention of the standard developers that the results be similar (using appropriate option combinations in both utilities). The
results are not required to be identical; there seemed insufficient gain to applications to balance the difficulty of
implementations having to guarantee that the results would be exactly identical.
The wording allowing cp to copy a directory to implementation-defined file types not specified by the System Interfaces
volume of POSIX.1-2024 is provided so that implementations supporting symbolic links are not required to prohibit copying
directories to symbolic links. Other extensions to the System Interfaces volume of POSIX.1-2024 file types may need to use this
loophole as well.
FUTURE DIRECTIONS
If this utility is directed to create a new directory entry that contains any bytes that have the encoded value of a
character, implementations are encouraged to treat this as an error. A future version of this standard may require
implementations to treat this as an error.
SEE ALSO
mv, find, ln, pax
XBD 4.7 File Access Permissions, 8. Environment Variables, 12.2
Utility Syntax Guidelines
XSH open(), unlink()
CHANGE HISTORY
First released in Issue 2.
Issue 6
The -r option is marked obsolescent.
The new options -H, -L, and -P are added to align with the IEEE P1003.2b draft standard. These options
affect the processing of symbolic links.
IEEE PASC Interpretation 1003.2 #194 is applied, adding a description of the -P option.
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/18 is applied, correcting an error in the SEE ALSO section.
Issue 7
Austin Group Interpretation 1003.1-2001 #126 is applied, changing the description of the LC_MESSAGES environment
variable.
Austin Group Interpretations 1003.1-2001 #092, #164, #165, and #168 are applied.
SD5-XCU-ERN-31 and SD5-XCU-ERN-42 are applied, updating the DESCRIPTION.
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
SD5-XCU-ERN-102 is applied, clarifying the -i option within the OPTIONS section.
The obsolescent -r option is removed.
The -P option is added to the SYNOPSIS and to the DESCRIPTION with respect to the -R option.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to disallow the creation of filenames containing any bytes that
have the encoded value of a  character.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
Austin Group Defect 1732 is applied, changing the EXIT STATUS section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/ipcs.html =====
ipcs
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ipcs — report XSI interprocess communication facilities status
SYNOPSIS
[XSI]  ipcs [-qms] [-a|-bcopt]
DESCRIPTION
The ipcs utility shall write information about active interprocess communication facilities.
Without options, information shall be written in short format for message queues, shared memory segments, and semaphore sets
that are currently active in the system. Otherwise, the information that is displayed is controlled by the options specified.
OPTIONS
The ipcs utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The ipcs utility accepts the following options:
-q
Write information about active message queues.
-m
Write information about active shared memory segments.
-s
Write information about active semaphore sets.
If -q, -m, or -s are specified, only information about those facilities shall be written. If none of these
three are specified, information about all three shall be written subject to the following options:
-a
Use all print options. (This is a shorthand notation for -b, -c, -o, -p, and -t.)
-b
Write information on maximum allowable size. (Maximum number of bytes in messages on queue for message queues, size of segments
for shared memory, and number of semaphores in each set for semaphores.)
-c
Write creator's user name and group name; see below.
-o
Write information on outstanding usage. (Number of messages on queue and total number of bytes in messages on queue for message
queues, and number of processes attached to shared memory segments.)
-p
Write process number information. (Process ID of the last process to send a message and process ID of the last process to
receive a message on message queues, process ID of the creating process, and process ID of the last process to attach or detach on
shared memory segments.)
-t
Write time information. (Time of the last control operation that changed the access permissions for all facilities, time of the
last msgsnd() and msgrcv() operations
on message queues, time of the last shmat() and shmdt() operations on shared memory, and time of the last semop() operation on semaphores.)
OPERANDS
None.
STDIN
Not used.
INPUT FILES
The group database
The user database
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of ipcs:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
Determine the location of messages objects and message catalogs.
TZ
Determine the timezone for the date and time strings written by ipcs. If TZ is unset or null, an unspecified
default timezone shall be used.
ASYNCHRONOUS EVENTS
Default.
STDOUT
An introductory line shall be written with the format:
"IPC status from %s as of %s\n", ,
where  indicates the source used to gather the statistics and  is the information that
would be produced by the date command when invoked in the POSIX locale.
The ipcs utility then shall create up to three reports depending upon the -q, -m, and -s options.
The first report shall indicate the status of message queues, the second report shall indicate the status of shared memory
segments, and the third report shall indicate the status of semaphore sets.
If the corresponding facility is not installed or has not been used since the last reboot, then the report shall be written out
in the format:
"%s facility not in system.\n",
where  is Message Queue, Shared Memory, or Semaphore, as appropriate. If the
facility has been installed and has been used since the last reboot, column headings separated by one or more
characters and followed by a  shall be written as indicated below followed by the facility name written out using
the format:
"%s:\n",
where  is Message Queues, Shared Memory, or Semaphores, as appropriate. On the
second and third reports the column headings need not be written if the last column headings written already provide column
headings for all information in that report.
The column headings provided in the first column below and the meaning of the information in those columns shall be given in
order below; the letters in parentheses indicate the options that shall cause the corresponding column to appear; "all" means
that the column shall always appear. Each column is separated by one or more  characters. Note that these options only
determine what information is provided for each report; they do not determine which reports are written.
T (all)
Type of facility:
q
Message queue.
m
Shared memory segment.
s
Semaphore.
This field is a single character written using the format %c.
ID (all)
The identifier for the facility entry. This field shall be written using the format %d.
KEY (all)
The key used as an argument to msgget(), semget(), or shmget() to create the facility
entry.
Note:
The key of a shared memory segment is changed to IPC_PRIVATE when the segment has been removed until all processes attached to
the segment detach it.
This field shall be written using the format 0x%x.
MODE (all)
The facility access modes and flags. The mode shall consist of 11 characters that are interpreted as follows.
The first character shall be:
S
If a process is waiting on a msgsnd() operation.
-
If the above is not true.
The second character shall be:
R
If a process is waiting on a msgrcv() operation.
C or -
If the associated shared memory segment is to be cleared when the first attach operation is executed.
-
If none of the above is true.
The next nine characters shall be interpreted as three sets of three bits each. The first set refers to the owner's permissions;
the next to permissions of others in the usergroup of the facility entry; and the last to all others. Within each set, the first
character indicates permission to read, the second character indicates permission to write or alter the facility entry, and the
last character is a  ('-').
The permissions shall be indicated as follows:
r
If read permission is granted.
w
If write permission is granted.
a
If alter permission is granted.
-
If the indicated permission is not granted.
The first character following the permissions specifies if there is an alternate or additional access control method associated
with the facility. If there is no alternate or additional access control method associated with the facility, a single
shall be written; otherwise, another printable character is written.
OWNER (all)
The user name of the owner of the facility entry. If the user name of the owner is found in the user database, at least the
first eight column positions of the name shall be written using the format %s. Otherwise, the user ID of the owner shall
be written using the format %d.
GROUP (all)
The group name of the owner of the facility entry. If the group name of the owner is found in the group database, at least the
first eight column positions of the name shall be written using the format %s. Otherwise, the group ID of the owner shall
be written using the format %d.
The following nine columns shall be only written out for message queues:
CREATOR (a,c)
The user name of the creator of the facility entry. If the user name of the creator is found in the user database, at least the
first eight column positions of the name shall be written using the format %s. Otherwise, the user ID of the creator shall
be written using the format %d.
CGROUP (a,c)
The group name of the creator of the facility entry. If the group name of the creator is found in the group database, at least
the first eight column positions of the name shall be written using the format %s. Otherwise, the group ID of the creator
shall be written using the format %d.
CBYTES (a,o)
The number of bytes in messages currently outstanding on the associated message queue. This field shall be written using the
format %d.
QNUM (a,o)
The number of messages currently outstanding on the associated message queue. This field shall be written using the format
%d.
QBYTES (a,b)
The maximum number of bytes allowed in messages outstanding on the associated message queue. This field shall be written using
the format %d.
LSPID (a,p)
The process ID of the last process to send a message to the associated queue. This field shall be written using the format:
"%d",
where  is 0 if no message has been sent to the corresponding message queue; otherwise,
shall be the process ID of the last process to send a message to the queue.
LRPID (a,p)
The process ID of the last process to receive a message from the associated queue. This field shall be written using the
format:
"%d",
where  is 0 if no message has been received from the corresponding message queue; otherwise,
shall be the process ID of the last process to receive a message from the queue.
STIME (a,t)
The time the last message was sent to the associated queue. If a message has been sent to the corresponding message queue, the
hour, minute, and second of the last time a message was sent to the queue shall be written using the format
%d:%2.2d:%2.2d. Otherwise, the format " no-entry" shall be written.
RTIME (a,t)
The time the last message was received from the associated queue. If a message has been received from the corresponding message
queue, the hour, minute, and second of the last time a message was received from the queue shall be written using the format
%d:%2.2d:%2.2d. Otherwise, the format " no-entry" shall be written.
The following eight columns shall be only written out for shared memory segments.
CREATOR (a,c)
The user of the creator of the facility entry. If the user name of the creator is found in the user database, at least the
first eight column positions of the name shall be written using the format %s. Otherwise, the user ID of the creator shall
be written using the format %d.
CGROUP (a,c)
The group name of the creator of the facility entry. If the group name of the creator is found in the group database, at least
the first eight column positions of the name shall be written using the format %s. Otherwise, the group ID of the creator
shall be written using the format %d.
NATTCH (a,o)
The number of processes attached to the associated shared memory segment. This field shall be written using the format
%d.
SEGSZ (a,b)
The size of the associated shared memory segment. This field shall be written using the format %d.
CPID (a,p)
The process ID of the creator of the shared memory entry. This field shall be written using the format %d.
LPID (a,p)
The process ID of the last process to attach or detach the shared memory segment. This field shall be written using the format:
"%d",
where  is 0 if no process has attached the corresponding shared memory segment; otherwise,
shall be the process ID of the last process to attach or detach the segment.
ATIME (a,t)
The time the last attach on the associated shared memory segment was completed. If the corresponding shared memory segment has
ever been attached, the hour, minute, and second of the last time the segment was attached shall be written using the format
%d:%2.2d:%2.2d. Otherwise, the format " no-entry" shall be written.
DTIME (a,t)
The time the last detach on the associated shared memory segment was completed. If the corresponding shared memory segment has
ever been detached, the hour, minute, and second of the last time the segment was detached shall be written using the format
%d:%2.2d:%2.2d. Otherwise, the format " no-entry" shall be written.
The following four columns shall be only written out for semaphore sets:
CREATOR (a,c)
The user of the creator of the facility entry. If the user name of the creator is found in the user database, at least the
first eight column positions of the name shall be written using the format %s. Otherwise, the user ID of the creator shall
be written using the format %d.
CGROUP (a,c)
The group name of the creator of the facility entry. If the group name of the creator is found in the group database, at least
the first eight column positions of the name shall be written using the format %s. Otherwise, the group ID of the creator
shall be written using the format %d.
NSEMS (a,b)
The number of semaphores in the set associated with the semaphore entry. This field shall be written using the format
%d.
OTIME (a,t)
The time the last semaphore operation on the set associated with the semaphore entry was completed. If a semaphore operation
has ever been performed on the corresponding semaphore set, the hour, minute, and second of the last semaphore operation on the
semaphore set shall be written using the format %d:%2.2d:%2.2d. Otherwise, the format
" no-entry" shall be written.
The following column shall be written for all three reports when it is requested:
CTIME (a,t)
The time the associated entry was created or changed. The hour, minute, and second of the time when the associated entry was
created shall be written using the format %d:%2.2d:%2.2d.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
Things can change while ipcs is running; the information it gives is guaranteed to be accurate only when it was
retrieved.
EXAMPLES
None.
RATIONALE
None.
FUTURE DIRECTIONS
If this utility is directed to display a pathname that contains any bytes that have the encoded value of a
character when  is a terminator or separator in the output format being used, implementations are encouraged to
treat this as an error. A future version of this standard may require implementations to treat this as an error.
SEE ALSO
ipcrm
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
XSH msgrcv(), msgsnd(), semget(), semop(), shmat(), shmdt(), shmget()
CHANGE HISTORY
First released in Issue 5.
Issue 6
The Open Group Corrigendum U020/1 is applied, correcting the SYNOPSIS.
The Open Group Corrigenda U032/1 and U032/2 are applied, clarifying the output format.
The Open Group Base Resolution bwg98-004 is applied.
Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
SD5-XCU-ERN-139 is applied, adding the ipcrm utility to the SEE ALSO section.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0108 [584] is applied.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to report an error if a utility is directed to display a
pathname that contains any bytes that have the encoded value of a  character when  is a terminator or
separator in the output format being used.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/make.html =====
make
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
make — maintain, update, and regenerate files (DEVELOPMENT)
SYNOPSIS
[SD]  make [-einpqrst] [-f makefile]...
[-j maxjobs] [-k|-S]
[macro[::[:]]=value...]
[target_name...]
DESCRIPTION
The make utility shall update files that are derived from other files. A typical case is one where object files are
derived from the corresponding source files. The make utility examines time relationships and shall update those derived
files (called targets) that have modified times earlier than the modified times of the files (called prerequisites) from which they
are derived. A description file (makefile) contains a description of the relationships between files, and the commands that need to
be executed to update the targets to reflect changes in their prerequisites. Each specification, or rule, shall consist of a
target, optional prerequisites, and optional commands to be executed when a prerequisite is newer than the target. There are two
kinds of rule:
Inference rules, which have one target name with at least one  ('.') and no
('/')
Target rules, which can have more than one target name
In addition, make shall have a collection of built-in macros and inference rules that infer prerequisite relationships to
simplify maintenance of programs.
To receive exactly the behavior described in this section, a portable makefile shall:
Include the special target .POSIX
Omit any special target reserved for implementations (a leading period followed by uppercase letters) that has not been
specified by this section
The behavior of make is unspecified if either or both of these conditions are not met.
OPTIONS
The make utility shall conform to XBD 12.2 Utility Syntax
Guidelines, except for Guideline 9.
The following options shall be supported:
-e
Cause environment variables, including those with null values, to override macro assignments within makefiles.
-f makefile
Specify a different makefile. The argument makefile is a pathname of a description file, which is also referred to as
the makefile. A pathname of '-' shall denote the standard input. There can be multiple instances of this option,
and they shall be processed in the order specified. The effect of specifying the same option-argument more than once is
unspecified.
-i
Ignore error codes returned by invoked commands. This mode shall be the same as if the special target .IGNORE were
specified without prerequisites.
-j maxjobs
Set the maximum number of targets that can be updated concurrently. If this option is specified multiple times, the last value
of maxjobs specified shall take precedence. If this option is not specified, or if maxjobs is 1, only one target
shall be updated at a time (no parallelization). If the value of maxjobs is non-positive, the behavior is unspecified. When
maxjobs is greater than 1, make shall create a pool of up to maxjobs - 1 tokens. (Note that implementations
are not required to create a pool of exactly maxjobs - 1 tokens. For example, an implementation could limit the pool size
based on the number of processors available.) If the size of the token pool would be 0, make need not implement a token
pool.
When all of the following are true:
There is a target with commands that is not up-to-date
The target's prerequisites (if any) are up-to-date
make is not waiting to bring the target up-to-date (see .WAIT)
make is currently bringing a different target with commands up-to-date
make is not currently bringing maxjobs targets up-to-date in parallel
The special target .NOTPARALLEL is not specified
The token pool is not empty
then make may attempt to remove one token from the pool. If a token is successfully removed, it shall attempt to bring
this target up-to-date in parallel, and after this processing completes shall return the token to the pool. When make is
bringing a target without commands up-to-date, it need not remove a token from the pool.
If a rule invokes a sub-make either via the MAKE macro or via a command line that begins with '+', the
sub-make is the same implementation as the make that invoked the sub-make, and the -j option is passed
to the sub-make via the MAKEFLAGS environment variable with the same maxjobs value and is not overridden by a
maxjobs value from another source (even if it has the same value), the sub-make shall use the same token pool as its
invoking make rather than create a new token pool. Otherwise, it is unspecified whether the sub-make uses the same
token pool as its invoking make or creates a new token pool. If a rule executes multiple sub-make processes
asynchronously the behavior is unspecified.
-k
Continue to update other targets that do not depend on the current target if a non-ignored error occurs while executing the
commands to bring a target up-to-date.
-n
Write commands that would be executed on standard output, but do not execute them. However, lines with a
('+') prefix, lines that expand the MAKE macro, and lines being processed in order to create an include file or to
bring it up-to-date (see Include Lines in the EXTENDED DESCRIPTION section) shall be executed. In this mode, lines with a
('@') character prefix shall be written to standard output.
-p
Write to standard output the complete set of macro definitions and target descriptions. The output format is unspecified.
-q
Return a zero exit value if the target file is up-to-date; otherwise, return an exit value of 1. Targets shall not be updated
if this option is specified. However, a makefile command line (associated with the targets) with a  ('+')
prefix shall be executed and it is unspecified whether command lines that do not have a  prefix and either expand
the MAKE macro or are being processed in order to create an include file or to bring it up-to-date (see Include Lines
in the EXTENDED DESCRIPTION section) are executed.
-r
Clear the suffix list and do not use the built-in rules.
-S
Terminate make if an error occurs while executing the commands to bring a target up-to-date. This shall be the default
and the opposite of -k.
-s
Do not write makefile execution lines (see Makefile Execution) or touch messages (see
-t) to standard output before executing. This mode shall be the same as if the special target .SILENT were specified
without prerequisites.
-t
Update the modification time of each target as though a touch target had
been executed. Targets that have prerequisites but no commands (see Target Rules), or that are
already up-to-date, shall not be touched in this manner. Write messages to standard output for each target file indicating the name
of the file and that it was touched. Normally, the makefile command lines associated with each target are not executed.
However, a command line with a  ('+') prefix shall be executed and it is unspecified whether command
lines that do not have a  prefix and either expand the MAKE macro or are being processed in order to create
an include file or to bring it up-to-date (see Include Lines in the EXTENDED DESCRIPTION section) are executed.
Any options specified in the MAKEFLAGS environment variable shall be evaluated before any options specified on the
make utility command line. If the -k and -S options are both specified on the make utility command line
or by the MAKEFLAGS environment variable, the last option specified shall take precedence. If the -f or -p
options appear in the MAKEFLAGS environment variable, the result is undefined.
OPERANDS
The following operands shall be supported:
target_name
Target names, as defined in the EXTENDED DESCRIPTION section. If no target is specified, while make is processing the
makefiles, the first target that make encounters that is not a special target or an inference rule shall be used.
macro=value
macro::=value
macro:::=value
Delayed and immediate expansion macro definitions, as defined in Macros.
Delayed and immediate expansion macro definitions can be intermixed, and shall be processed in the order specified. If any macro
definition appears after a target_name operand on the make utility command line, the results are unspecified.
STDIN
The standard input shall be used only if the makefile option-argument is '-'. See the INPUT FILES section.
INPUT FILES
The input file, otherwise known as the makefile, is a text file containing rules, macro definitions, include lines, and
comments. See the EXTENDED DESCRIPTION section.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of make:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
MAKEFLAGS
This variable shall be interpreted as a character string representing a series of option characters to be used as the default
options. The implementation shall accept both of the following formats (but need not accept them when intermixed):
The characters are option letters without the leading  characters or  separation used on a
make utility command line.
The characters are formatted in a manner similar to the use of the make utility in shell commands: options are preceded
by  characters and -separated as described in XBD 12.2 Utility Syntax Guidelines. The macro=value macro definition
operands can also be included. The difference between the contents of MAKEFLAGS and the use of the make utility in
shell commands is that the contents of the variable shall not be subjected to the word expansions (see 2.6 Word Expansions) associated with parsing shell command lines.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
PROJECTDIR
[XSI]
Provide a directory to be used to search for SCCS files not found in the current directory. In all of the following cases, the
search for SCCS files is made in the directory SCCS in the identified directory. If the value of PROJECTDIR begins
with a , it shall be considered an absolute pathname; otherwise, the value of PROJECTDIR is treated as a user
name and that user's initial working directory shall be examined for a subdirectory src or source. If such a
directory is found, it shall be used. Otherwise, the value is used as a relative pathname.
If PROJECTDIR is not set or has a null value, the search for SCCS files shall be made in the directory SCCS in the
current directory.
The setting of PROJECTDIR affects all files listed in the remainder of this utility description for files with a
component named SCCS.
The value of the SHELL environment variable shall not be used as a macro and shall not be modified by defining the
SHELL macro in a makefile or on the command line. All other environment variables, including those with null values, shall
be used as macros, as defined in Macros.
ASYNCHRONOUS EVENTS
For SIGHUP, SIGINT, SIGQUIT, and SIGTERM signals, if the signal was not inherited as ignored, none of the -n, -p,
or -q options was specified, make is currently processing a target or inference rule, and the current target is
neither a directory nor a prerequisite of the special targets .PHONY or .PRECIOUS:
The make utility shall catch the signal and, if the time of last data modification of the current target has changed
since make began processing the rule to bring that target up to date, remove that target; it may also remove that target if the
time of last data modification has not changed. Any targets removed in this manner shall be reported in diagnostic or informational
messages of unspecified format, written to standard error.
If make writes a diagnostic message to standard error, it shall exit with a status that indicates an error occurred;
otherwise, it shall set the signal to default and re-signal itself.
In all other circumstances, make shall take the standard action for all signals; see 1.4 Utility Description Defaults.
STDOUT
If make is invoked without any work needing to be done, it may write a message to standard output indicating that no
action was taken. Otherwise, the make utility shall write all commands to be executed (and the filenames of files touched
for the -t option in a message of unspecified format) to standard output unless the -s option was specified, the
command is prefixed with a  ('@'), or the special target .SILENT has either the current target
as a prerequisite or has no prerequisites.
STDERR
The standard error shall be used for diagnostic messages and may be used for informational messages about target removals (see
ASYNCHRONOUS EVENTS).
OUTPUT FILES
Files can be created when the -t option is present. Additional files can also be created by the utilities invoked by
make.
EXTENDED DESCRIPTION
The make utility attempts to perform the actions, specified in one or more makefiles, required to ensure that specified
targets are up-to-date. By default, the following files shall be tried in sequence: ./makefile and ./Makefile. If
neither ./makefile nor ./Makefile is found, other implementation-defined files may also be tried. [XSI]   On
XSI-conformant systems, the additional files ./s.makefile, SCCS/s.makefile, ./s.Makefile, and
SCCS/s.Makefile shall also be tried.   The -f
option shall direct make to ignore any of these default files and use the specified option-argument as a makefile instead.
If this option-argument is '-', standard input shall be used.
The term makefile is used to refer to any makefile contents provided by the user, whether in ./makefile or its
variants, or specified by the -f option.
A target shall be considered up-to-date if it exists and is newer than all of its prerequisites, or if it has already been made
up-to-date by the current invocation of make (regardless of the target's existence or age), except that targets that are
made up-to-date in order for them to be processed as include line pathnames (see Include Lines below) need not be considered
up-to-date during later processing. A target may also be considered up-to-date if it exists, is the same age as one or more of its
prerequisites, and is newer than the remaining prerequisites (if any). The make utility shall treat all prerequisites as
targets themselves and recursively ensure that they are up-to-date, processing them in the order in which they appear in the rule.
The make utility shall use the modification times of files to determine whether the corresponding targets are
out-of-date.
To ensure that a target is up-to-date, make shall ensure that all of the prerequisites of the target are up-to-date, then
check to see if the target itself is up-to-date. If the target is not up-to-date, the target shall be made up-to-date by executing
the rule's commands (if any). If the target does not exist after the target has been successfully made up-to-date, the target shall
be treated as being newer than any target for which it is a prerequisite.
If a target exists and there is neither a target rule nor an inference rule for the target, the target shall be considered
up-to-date. It shall be an error if make attempts to ensure that a target is up-to-date but the target does not exist and
there is neither a target rule nor an inference rule for the target.
Makefile Syntax
A makefile can contain rules, macro definitions (see Macros), include lines, and comments. There
are two kinds of rules: target rules, including special targets (see Target Rules), and
inference rules (see Inference Rules). The make utility shall contain a set of
built-in inference rules. If the -r option is present, the built-in rules shall not be used and the suffix list shall be
cleared. Additional rules of both kinds can be specified in a makefile. If a rule is defined more than once, the value of the rule
shall be that of the last one specified. Macros can also be defined more than once, and the value of the macro is specified in
Macros. There are three kinds of comments: blank lines, empty lines, and a
('#') and all following characters up to the first unescaped  character. Blank lines, empty lines, and
lines with  ('#') as the first character on the line are also known as comment lines.
Target and inference rules can contain command lines. Command lines can have a prefix that shall be removed before
execution (see Makefile Execution).
When an escaped  (one preceded by a ) is found anywhere in the makefile except in a command line
after macro expansion, an include line, or a line immediately preceding an include line, it shall be replaced, along with any
leading white space on the next line, with a single . After all macro expansion is complete, when an escaped
is found in a command line in a makefile, the command line that is executed shall contain the ,
the , and the next line, except that the first character of the next line shall not be included if it is a
. When an escaped  is found in an include line or in a line immediately preceding an include line, the
behavior is unspecified.
Include Lines
If the word include, optionally prefixed with a  character, appears at the beginning of a line and is
followed by one or more  characters, the string formed by the remainder of the line shall be processed as follows to
produce one or more pathnames:
The trailing , any  characters immediately preceding a comment, and any comment shall be discarded.
If the resulting string contains any double-quote characters ('"' ) the behavior is unspecified.
The resulting string shall be processed for macro expansion (see Macros).
Any  characters that appear after the first non- shall be used as separators to divide the
macro-expanded string into fields. It is unspecified whether pathname expansion (see 2.14 Pattern Matching Notation) is also performed.
If the processing of separators and optional pathname expansion results in zero non-empty fields, the behavior is unspecified.
If it results in at least one non-empty field, these fields are taken as pathnames.
For each pathname so identified, in the order specified:
If the pathname does not begin with a '/', it shall be treated as relative to the current working directory of the
process, not relative to the directory containing the makefile.
The make utility shall use one of the following two methods to attempt to create the file or bring it up-to-date:
The "immediate remaking" method
If make uses this method, any target rules or inference rules for the pathname that were parsed before the include line
was parsed shall be used to attempt to create the file or to bring it up-to-date before opening the file.
The "delayed remaking" method
If make uses this method, no attempt shall be made to create the file or bring it up-to-date until after the makefile(s)
have been read. During processing of the include line, make shall read the current contents of the file, if it exists, or
treat it as an empty file if it does not exist. Once the makefile(s) have been read, make shall use any applicable target
rule or inference rule for the pathname, regardless of whether it is parsed before or after the include line, when creating the
file or bringing it up-to-date. Additionally in this case, the new contents of the file, if it is successfully created or updated,
shall be used when processing rules for the following targets after the makefile(s) have been read:
The target_name operands, if any.
The first target make encounters that is not a special target or an inference rule, if no target_name operands are
specified.
All targets that are prerequisites, directly or recursively, of the above targets.
If the pathname is relative, the file does not exist, and an attempt to create it using a rule has not been made and will not be
made, it is unspecified whether additional directories are searched for an existing file of the same relative pathname.
If, after proceeding as described above, the file still cannot be opened:
If the word include was prefixed with a  character, the file shall be ignored.
Otherwise, an error shall occur.
The contents of the file specified by the pathname shall be read and processed as if they appeared in the makefile in place of
the include line. If the file ends with an escaped  the behavior is unspecified.
The file may itself contain further include lines. Implementations shall support nesting of include files up to a depth of at
least 16.
Makefile Execution
Makefile command lines shall be processed one at a time.
Makefile command lines can have one or more of the following prefixes: a  ('-'), a
('@'), or a  ('+'). These shall modify the way in which make
processes the command.
-
If the command prefix contains a , or the -i option is present, or the special target .IGNORE
has either the current target as a prerequisite or has no prerequisites, any error found while executing the command shall be
ignored.
@
If the command prefix contains a  and the make utility command line -n option is not
specified, or the -s option is present, or the special target .SILENT has either the current target as a prerequisite
or has no prerequisites, the command shall not be written to standard output before it is executed.
+
If the command prefix contains a , the command shall be executed even if -n, -q, or -t is
specified.
An execution line is built from the command line by removing any prefix characters. Except as described under the
('@') prefix, the execution line shall be written to the standard output, optionally preceded by a
. The execution line shall then be executed by a shell as if it were passed as the argument to the system() interface, except that if errors are not being ignored then the shell -e
option shall also be in effect. If errors are being ignored for the command (as a result of the -i option, a '-'
command prefix, or a .IGNORE special target), the shell -e option shall not be in effect. The environment for the
command being executed shall contain all of the variables in the environment of make.
By default, when make receives a non-zero status from the execution of a command, it shall terminate with an error
message to standard error.
Target Rules
Target rules are formatted as follows:
target [target...]: [prerequisite...][;command]
[command
command
...]
Target entries are specified by a -separated, non-null list of targets, then a , then a
-separated, possibly empty list of prerequisites. Text following a , if any, and all following lines
that begin with a , are makefile command lines to be executed to update the target. The first non-empty line that does
not begin with a  or '#' shall begin a new entry. Any comment line may begin a new entry.
Applications shall select target names from the set of characters consisting solely of slashes, hyphens, periods, underscores,
digits, and alphabetics from the portable character set (see XBD 6.1 Portable
Character Set). Implementations may allow other characters in target names as extensions. The interpretation of targets
containing the characters '%' and '"' is implementation-defined.
A target that has prerequisites, but does not have any commands, can be used to add to the prerequisite list for that target.
Only one target rule for any given target can contain commands.
Lines that begin with one of the following are called special targets and control the operation of make:
.DEFAULT
If the makefile contains this special target, the application shall ensure that it is specified with commands, but without
prerequisites. The commands shall be used by make if there are no other rules available to build a target.
.IGNORE
Prerequisites of this special target are targets themselves; this shall cause errors from commands associated with them to be
ignored in the same manner as specified by the -i option. Subsequent occurrences of .IGNORE shall add to the list of
targets ignoring command errors. If no prerequisites are specified, make shall behave as if the -i option had been
specified and errors from all commands associated with all targets shall be ignored.
.NOTPARALLEL
The application shall ensure that this special target is specified without prerequisites or commands. When specified, make
shall update one target at a time, regardless of whether the -j maxjobs option is specified. If the -j
maxjobs option is specified, the option shall continue to be passed unchanged to sub-make invocations via
MAKEFLAGS .
.PHONY
Prerequisites of this special target are targets themselves; these targets (known as phony targets) shall be considered
always out-of-date when the make utility begins executing. If a phony target's commands are executed, that phony target
shall then be considered up-to-date until the execution of make completes. Subsequent occurrences of .PHONY shall add
to the list of phony targets. A .PHONY special target with no prerequisites shall be ignored. If the -t option is
specified, phony targets shall not be touched. Phony targets shall not be removed if make receives one of the asynchronous
events explicitly described in the ASYNCHRONOUS EVENTS section.
.POSIX
The application shall ensure that this special target is specified without prerequisites or commands. If it appears as the
first non-comment line in the makefile, make shall process the makefile as specified by this section; otherwise, the
behavior of make is unspecified.
.PRECIOUS
Prerequisites of this special target shall not be removed if make receives one of the asynchronous events explicitly
described in the ASYNCHRONOUS EVENTS section. Subsequent occurrences of .PRECIOUS shall add to the list of precious files.
If no prerequisites are specified, all targets in the makefile shall be treated as if specified with .PRECIOUS.
.SCCS_GET
[XSI]
The application shall ensure that this special target is specified without prerequisites. If this special target is included in a
makefile, the commands specified with this target shall replace the default commands associated with this special target (see
Default Rules). The commands specified with this target are used to get all SCCS files that are not
found in the current directory.
When source files are named in a list of prerequisites, make shall treat them just like any other target. Because the
source file is presumed to be present in the directory, there is no need to add an entry for it to the makefile. When a target has
no prerequisites, but is present in the directory, make shall assume that that file is up-to-date. If, however, an SCCS file
named SCCS/s.source_file is found for a target source_file, make compares the timestamp of the target
file with that of the SCCS/s.source_file to ensure the target is up-to-date. If the target is missing, or if the SCCS file
is newer, make shall automatically issue the commands specified for the .SCCS_GET special target to retrieve the most
recent version. However, if the target is writable by anyone, make shall not retrieve a new version.
.SILENT
Prerequisites of this special target are targets themselves; this shall cause commands associated with them not to be written
to the standard output before they are executed. Subsequent occurrences of .SILENT shall add to the list of targets with
silent commands. If no prerequisites are specified, make shall behave as if the -s option had been specified and no
commands or touch messages associated with any target shall be written to standard output.
.SUFFIXES
Prerequisites of .SUFFIXES shall be appended to the list of known suffixes and are used in conjunction with the
inference rules (see Inference Rules). If .SUFFIXES does not have any prerequisites, the
list of known suffixes shall be cleared.
.WAIT
The application shall ensure that this special target, if specified as a target, is specified without prerequisites or
commands. When .WAIT appears as a target, it shall have no effect. When .WAIT appears in a target rule as a
prerequisite, it shall not itself be treated as a prerequisite; however, make shall not recursively process the
prerequisites (if any) to the right of the .WAIT until the prerequisites (if any) to the left of it have been brought
up-to-date. Implementations may also enforce the same ordering between the affected prerequisites while processing other target
rules that have some or all of the same affected prerequisites.
The special targets .IGNORE, .NOTPARALLEL, .PHONY, .POSIX, .PRECIOUS, .SILENT,
.SUFFIXES, and .WAIT shall be specified without commands.
Targets and prerequisites consisting of a leading  followed by the uppercase letters "POSIX" and then any
other characters are reserved for future standardization. Targets and prerequisites consisting of a leading  followed
by one or more uppercase letters, that are not described above, are reserved for implementation extensions.
Macros
A macro can be one of two flavors, delayed-expansion or immediate-expansion.
The following form defines a delayed-expansion macro (replacing any previous definition of the macro named by
string1):
string1 = [string2]
The following form defines an immediate-expansion macro (replacing any previous definition of the macro named by
string1):
string1 ::= [string2]
The following form defines a delayed-expansion macro (replacing any previous definition of the macro named by
string1):
string1 :::= [string2]
by immediately expanding macros in string2, if any, before assigning the value.
The following form defines a delayed-expansion macro (replacing any previous definition of the macro named by
string1):
string1 != [string2]
by immediately expanding macros in string2, if any, and then executing the result as a shell command as if it were passed
as the argument to the system() interface. The make utility shall capture the
standard output from the shell execution and shall remove all white space at the beginning, remove a single trailing
character (if there is one), and then replace all remaining  characters with
characters to produce the value assigned to the macro named by string1. It shall not be an error if the shell command has
non-zero exit status.
The following form defines a delayed-expansion macro, but only if the macro named by string1 is not already defined:
string1 ?= [string2]
The following form (the append form) appends additional text to the value of a macro:
string1 += [string2]
When using the append form:
If the macro named by string1 does not exist, this form shall be equivalent to the delayed-expansion form
string1 = [string2]
If the macro named by string1 exists and is an immediate-expansion macro, then a  or  character
followed by the evaluation of string2 shall be appended to the value currently assigned to the macro named by
string1.
If the macro named by string1 exists and is a delayed-expansion macro, then a  or  character
followed by the unevaluated string2 shall be appended to the value currently assigned to the macro named by
string1.
In all cases the value of string1 is defined as all characters from the first non- character to the last
non- character, inclusive, before the =, ::=, :::=, !=, ?=, or
+=. Portable applications shall ensure that a  precedes the ::=, :::=, !=,
?=, or += in those forms to avoid any parsing ambiguity with implementations that permit ,
, , or  in macro names as extensions. The value of string2 is
defined as all characters from the first non- character, if any, after the , up to but not
including a comment character ('#') or an unescaped .
Portable applications shall select macro names from the set of characters consisting solely of characters from the portable
filename character set. Implementations may allow other characters in macro names as extensions; however, a macro name shall not
contain an , , or control character.
Macro expansions in string1 of macro definition lines shall be evaluated when read. Macro expansions in string2 of
macro definition lines shall be performed according to the form of macro definition used. In immediate-expansion forms (including
appending to an existing immediate-expansion macro), they shall be expanded in the macro definition line and the result of the
expansion shall not be scanned for further macros when the macro identified by string1 is expanded. In delayed-expansion
forms (including appending to an existing delayed-expansion macro, and conditional assignment to a macro not previously existing),
they shall not be expanded in the macro definition line; they shall be expanded when the macro identified by string1 is
expanded, and the result of the expansion shall be scanned for further macros. Implementations shall support at least 100 levels of
indirection.
Macros can appear anywhere in the makefile. Macro expansions using the forms $(string1) or ${string1} shall be
replaced by string2, as follows:
Macros in target lines shall be evaluated when the target line is read.
Macros in makefile command lines shall be evaluated when the command is executed.
Macros in the string before the  in a macro definition shall be evaluated when the macro assignment is
made.
Immediate-expansion macros shall be evaluated immediately when the macro assignment is made, and this value shall be used as the
replacement until the immediate-expansion macro is redefined.
Delayed-expansion macros after the  in macro definitions other than the :::=, !=, and
+= forms, and after the  in += form macro definitions where the macro named by string1
exists and is a delayed-expansion macro, shall only be evaluated when the defined macro is expanded.
The parentheses or braces are optional if string1 is a single character. The string "$$" shall be replaced by
the single character '$', except during the immediate expansion performed for the :::= operator, where it shall
be left unmodified. If string1 in a macro expansion contains a macro expansion, that inner macro expansion shall be
performed first and the result substituted into string1 to produce the macro name used for the outer macro expansion.
Macro expansions using the forms $(string1:subst1=[subst2]) or
${string1:subst1=[subst2]} can be used to replace all occurrences of subst1 with
subst2 when the macro substitution is performed. The subst1 to be replaced shall be recognized when it is a suffix at
the end of a word in string1 (where a word, in this context, is defined to be a string delimited by the beginning of
the value, a , or a ). If string1 in a macro expansion contains a macro expansion, that inner
macro expansion shall be performed as described above and the result substituted into string1 to produce the macro name used
for the outer macro expansion.
Macro expansions using the forms
$(string1:[op]%[os]=[np][%][ns]) or
${string1:[op]%[os]=[np][%][ns]} are called pattern macro
expansions, where op is the old prefix, os is the old suffix, np is the new prefix and ns is the new
suffix. Any item inside square brackets is optional. With this form, when the macro string1 is expanded each
white-space-separated word that completely matches the [op]%[os] pattern on the left-hand side
of the  ('='), where the  ('%') character matches zero or more characters,
shall be replaced by the right-hand side of the  and shall then be further modified according to the use of
characters as described below. Any words that do not match shall be unmodified in the expansion.
If more than one  character appears on the left-hand side of the  ('='), the second
and subsequent  characters shall be treated as literal characters in os.
If no  character appears on the right-hand side of the , no further modification of the word
shall be performed. If a single  character appears on the right-hand side, the  character in the word
shall be replaced with the characters matched by the  on the left-hand side. If more than one
character appears on the right-hand side, it is unspecified whether the first  character in the word is replaced
with the characters matched by the  on the left-hand side and all remaining  characters are left
unchanged, or each  character is replaced with the characters matched by the  on the left-hand
side.
In both macro expansion forms, any macro expansions on the right-hand side of the  shall be recursively expanded
before further examination. If this results in more than one  after the , the first one shall be
the separator.
In all forms of macro expansion, if the value of the macro named by string1 is an empty string, or if the macro named by
string1 does not exist, the final result shall be an empty string.
Note:
It is not safe to assume that a macro which has not intentionally been set to a specific value will not exist. See APPLICATION
USAGE for more information.
Macro definitions shall be taken from the following sources, in the following logical order, before the makefile(s) are
read.
Macros specified on the make utility command line, in the order specified on the command line. It is unspecified whether
the internal macros defined in Internal Macros are accepted from this source.
Macros defined by the MAKEFLAGS environment variable, in the order specified in the environment variable. It is
unspecified whether the internal macros defined in Internal Macros are accepted from this
source.
The contents of the environment, excluding the MAKEFLAGS and SHELL variables and including the variables with null
values.
Macros defined in the inference rules built into make.
Macro definitions from these sources shall not override macro definitions from a lower-numbered source. Macro definitions from a
single source (for example, the make utility command line, the MAKEFLAGS environment variable, or the other
environment variables) shall override previous macro definitions from the same source.
Macros defined in the makefile(s) shall override macro definitions that occur before them in the makefile(s) and macro
definitions from source 4. If the -e option is not specified, macros defined in the makefile(s) shall override macro
definitions from source 3. Macros defined in the makefile(s) shall not override macro definitions from source 1 or source 2.
Before the makefile(s) are read, all of the make utility command line options (except -f and -p) and
make utility command line macro definitions (except any for the MAKEFLAGS macro), not already included in the
MAKEFLAGS macro, shall be added to the MAKEFLAGS macro, quoted in an implementation-defined manner such that when
MAKEFLAGS is read by another instance of the make command, the original macro's value is recovered. Other
implementation-defined options and macros, with the exception of the CURDIR macro, may also be added to the MAKEFLAGS
macro. If this modifies the value of the MAKEFLAGS macro, or, if the MAKEFLAGS macro is modified at any subsequent
time, the MAKEFLAGS environment variable shall be modified to match the new value of the MAKEFLAGS macro. The result
of setting MAKEFLAGS in the Makefile is unspecified.
Before the makefile(s) are read, all of the make utility command line macro definitions (except the MAKEFLAGS
macro or the SHELL macro) shall be added to the environment of make. Other implementation-defined variables may also
be added to the environment of make. Macros defined by the MAKEFLAGS environment variable and macros defined in the
makefile(s) shall not be added to the environment of make if they are not already in its environment. With the exception of
SHELL (see below), it is unspecified whether macros defined in these ways update the value of an environment variable that
already exists in the environment of make.
The MAKE macro shall be treated specially. If MAKE is not defined in the environment, the MAKE macro shall
be provided by make and set to the value of argv[0] passed to main() (or equivalent, if make is not a C
program). If this value contains at least one  and is a relative pathname, make shall convert it to an absolute
pathname. If MAKE is defined in the makefile or is specified on the command line, it shall replace the original value of the
MAKE macro.
The SHELL macro shall be treated specially. It shall be provided by make and set to the pathname of the shell
command language interpreter (see sh). The SHELL environment variable shall not
affect the value of the SHELL macro. If SHELL is defined in the makefile or is specified on the command line, it
shall replace the original value of the SHELL macro, but shall not affect the SHELL environment variable. Other
effects of defining SHELL in the makefile or on the command line are implementation-defined.
The CURDIR macro shall be treated specially. It shall be provided by make and set to an absolute pathname of the
current working directory when make is executed. The value shall be the same as the pathname that would be output by the
pwd utility with either the -L or -P option; if they differ, it is
unspecified which value is used. The CURDIR environment variable shall not affect the value of the CURDIR macro
unless the -e option is specified. If the -e option is not specified, there is a CURDIR environment variable
set, and its value is different from the CURDIR macro value, the environment variable value shall be set to the macro value.
If CURDIR is defined in the makefile, present in the MAKEFLAGS environment variable, or specified on the command
line, it shall replace the original value of the CURDIR macro in accordance with the logical order described above, but
shall not cause make to change its current working directory.
Inference Rules
Inference rules are formatted as follows:
target:
command
[command]
...
line that does not begin with  or #
The application shall ensure that the target portion is a valid target name (see Target
Rules) of the form .s2 or .s1.s2 (where .s1 and .s2 are suffixes that have been given as
prerequisites of the .SUFFIXES special target and s1 and s2 do not contain any  or  characters.)
If there is only one  in the target, it is a single-suffix inference rule. Targets with two periods are double-suffix
inference rules. Inference rules can have only one target before the .
The application shall ensure that the makefile does not specify prerequisites for inference rules; no characters other than
white space shall follow the  in the first line, except when creating the empty rule, described below.
Prerequisites are inferred, as described below.
Inference rules can be redefined. A target that matches an existing inference rule shall overwrite the old inference rule. An
empty rule can be created with a command consisting of simply a  (that is, the rule still exists and is found
during inference rule search, but since it is empty, execution has no effect). The empty rule can also be formatted as follows:
rule: ;
where zero or more  characters separate the  and .
The make utility uses the suffixes of targets and their prerequisites to infer how a target can be made up-to-date. A
list of inference rules defines the commands to be executed. By default, make contains a built-in set of inference rules.
Additional rules can be specified in the makefile.
The special target .SUFFIXES contains as its prerequisites a list of suffixes that shall be used by the inference rules.
The order in which the suffixes are specified defines the order in which the inference rules for the suffixes are used. New
suffixes shall be appended to the current list by specifying a .SUFFIXES special target in the makefile. A .SUFFIXES
target with no prerequisites shall clear the list of suffixes. An empty .SUFFIXES target followed by a new .SUFFIXES
list is required to change the order of the suffixes.
Normally, the user would provide an inference rule for each suffix. The inference rule to update a target with a suffix
.s1 from a prerequisite with a suffix .s2 is specified as a target .s2.s1. The internal macros provide the
means to specify general inference rules (see Internal Macros).
When no target rule with commands is found to update a target, the inference rules shall be checked. The suffix of the target
(.s1) to be built shall be compared to the list of suffixes specified by the .SUFFIXES special targets. If the
.s1 suffix is found in .SUFFIXES, the inference rules shall be searched in the order defined for the first
.s2.s1 rule whose prerequisite file ($*.s2) exists. If the target is out-of-date with respect to this prerequisite,
the commands for that inference rule shall be executed. Prerequisites added by target rules without commands shall not affect the
selection of the applicable inference rule.
If the target to be built does not contain a suffix and there is no rule for the target, the single-suffix inference rules shall
be checked. The single-suffix inference rules define how to build a target if a file is found with a name that matches the target
name with one of the single suffixes appended. A rule with one suffix .s2 is the definition of how to build target from
target.s2. The other suffix (.s1) is treated as null.
[XSI]  A
('~') in the above rules refers to an SCCS file in the current directory. Thus, the rule .c~.o would
transform an SCCS C-language source file into an object file (.o). Because the s. of the SCCS files is a prefix, it
is incompatible with make's suffix point of view. Hence, the '~' is a way of changing any file reference into an
SCCS file reference.
Libraries
If a target or prerequisite contains parentheses, it shall be treated as a member of an archive library. For the
lib(member.o) expression lib refers to the name of the archive library and member.o to
the member name. The application shall ensure that the member is an object file with the .o suffix. The modification time of
the expression is the modification time for the member as kept in the archive library; see ar. The .a suffix shall refer to an archive library. The .s2.a rule shall be used
to update a member in the library from a file with a suffix .s2.
Internal Macros
The make utility shall maintain a set of internal macros that can be used in the commands of target and inference rules,
as described below. In order to clearly define the meaning of these macros, some clarification of the terms target rule,
inference rule, target, and prerequisite is necessary.
Target rules are specified by the user in a makefile for a particular target. Inference rules are user-specified or
make-specified rules for a particular class of target name. Explicit prerequisites are those prerequisites specified in a
makefile on target lines. Implicit prerequisites are those prerequisites that are generated when inference rules are used.
Inference rules are applied to implicit prerequisites or to explicit prerequisites that do not have target rules defined for them
in the makefile. Target rules are applied to targets specified in the makefile.
Before any target in the makefile is updated, each of its prerequisites (both explicit and implicit) shall be updated. This
shall be accomplished by recursively processing each prerequisite. Upon recursion, each prerequisite shall become a target itself.
Its prerequisites in turn shall be processed recursively until a target is found that has no prerequisites, or further recursion
would require applying two inference rules one immediately after the other, at which point the recursion shall stop. As an
extension, implementations may continue recursion when two or more successive inference rules need to be applied; however, if there
are multiple different chains of such rules that could be used to create the target, it is unspecified which chain is used. The
recursion shall then back up, updating each target as it goes.
In the definitions that follow, the word target refers to one of:
A target specified in the makefile
An explicit prerequisite specified in the makefile that becomes the target when make processes it during recursion
An implicit prerequisite that becomes a target when make processes it during recursion
In the definitions that follow, the word prerequisite refers to one of:
An explicit prerequisite specified in the makefile for a particular target
An implicit prerequisite generated as a result of locating an appropriate inference rule and corresponding file that matches the
suffix of the target
The internal macros are:
$@
The $@ macro shall evaluate to the full target name of the current target, or the archive filename part of a library archive
target. It shall be evaluated for both target and inference rules.
For example, in the .c.a inference rule, $@ represents the out-of-date .a file to be built. Similarly, in a
makefile target rule to build lib.a from file.c, $@ represents the out-of-date lib.a.
$%
The $% macro shall be evaluated only when the current target is an archive library member of the form
libname(member.o). In these cases, $@ shall evaluate to libname and $% shall evaluate to
member.o. The $% macro shall be evaluated for both target and inference rules.
For example, in a makefile target rule to build lib.a(file.o), $% represents file.o, as opposed to $@,
which represents lib.a.
$^
The $^ macro shall evaluate to the list of prerequisites for the current target, with any duplicates (except the first)
removed. It shall be evaluated for both target and inference rules. If the list of prerequisites of the target contains any
.WAIT special targets, the results of expanding $^ are unspecified.
For example, in a makefile target rule to build prog from file1.o, file2.o, and file3.o, and
regardless of which prerequisites prog is out-of-date with respect to, $^ represents file1.o, file2.o, and
file3.o.
$+
The $+ macro shall be equivalent to $^, except that duplicates shall not be removed; all prerequisites shall appear in the
order they were listed in the makefile.
$?
The $? macro shall evaluate to the list of prerequisites that are newer than the current target. It shall be evaluated for both
target and inference rules.
For example, in a makefile target rule to build prog from file1.o, file2.o, and file3.o, and where
prog is not out-of-date with respect to file1.o, but is out-of-date with respect to file2.o and
file3.o, $? represents file2.o and file3.o.
$; for the current directory, the directory part is
'.'. When the $? macro contains more than one prerequisite filename, the $(?D) and $(?F) (or ${?D} and ${?F}) macros
expand to a list of directory name parts and filename parts respectively.
For the target lib(member.o) and the .s2.a rule, the internal macros shall be defined as:
$ $*.c
$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $*.c
.sh~:
$(GET) $(GFLAGS) -p $ $*.sh
cp $*.sh $@
chmod a+x $@
DOUBLE-SUFFIX RULES
.c.o:
$(CC) $(CFLAGS) -c $ $*.c
$(CC) $(CFLAGS) -c $*.c
.y~.o:
$(GET) $(GFLAGS) -p $ $*.y
$(YACC) $(YFLAGS) $*.y
$(CC) $(CFLAGS) -c y.tab.c
rm -f y.tab.c
mv y.tab.o $@
.l~.o:
$(GET) $(GFLAGS) -p $ $*.l
$(LEX) $(LFLAGS) $*.l
$(CC) $(CFLAGS) -c lex.yy.c
rm -f lex.yy.c
mv lex.yy.o $@
.y~.c:
$(GET) $(GFLAGS) -p $ $*.y
$(YACC) $(YFLAGS) $*.y
mv y.tab.c $@
.l~.c:
$(GET) $(GFLAGS) -p $ $*.l
$(LEX) $(LFLAGS) $*.l
mv lex.yy.c $@
.c.a:
$(CC) -c $(CFLAGS) $1
An error occurred.
When the -q option is not specified, the make utility shall exit with one of the following values:
0
All specified targets were already up-to-date, or all commands executed to bring targets up-to-date either exited with status 0
or had a non-zero exit status that was specified (via the -i option, the special target .IGNORE, or a '-'
command prefix) to be ignored.
>0
An error occurred, or at least one command executed to bring a target up-to-date exited with a non-zero exit status that was
not specified to be ignored.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
If there is a source file (such as ./source.c) and there are two SCCS files corresponding to it (./s.source.c and
./SCCS/s.source.c), on XSI-conformant systems make uses the SCCS file in the current directory. However, users are
advised to use the underlying SCCS utilities (admin, delta, get, and so on) or the sccs utility for all source files in a given directory. If both forms are used for a given
source file, future developers are very likely to be confused.
It is incumbent upon portable makefiles to specify the .POSIX special target in order to guarantee that they are not
affected by local extensions.
The -k and -S options are both present so that the relationship between the command line, the MAKEFLAGS
variable, and the makefile can be controlled precisely. If the k flag is passed in MAKEFLAGS and a command is of the
form:
$(MAKE) -S foo
then the default behavior is restored for the child make.
When the -n option is specified, it is always added to MAKEFLAGS . This allows a recursive make -n
target to be used to see all of the actions that would be taken to update target.
Because of widespread historical practice, interpreting a  ('#') inside a variable as the start of a
comment has the unfortunate side-effect of making it impossible to place a  in a variable, thus forbidding
something like:
CFLAGS = -D "COMMENT_CHAR='#'"
Many historical make utilities stop chaining together inference rules when an intermediate target is nonexistent. For
example, it might be possible for a make to determine that both .y.c and .c.o could be used to convert a
.y to a .o. Instead, in this case, make requires the use of a .y.o rule.
The standard set of default rules uses only features provided by other parts of this volume of POSIX.1-2024. They include rules
for optional utilities in this volume of POSIX.1-2024, but only rules pertaining to utilities that are provided are needed in an
implementation's default set.
Although make expands macros that do not exist to an empty string, it is not safe to assume that a macro which has not
intentionally been set to a specific value will expand to an empty string for everyone who uses the makefile. There are two reasons
for this:
When another user executes make, they might happen to have an environment variable of the same name (which they have set
for some unrelated purpose) with a non-empty value.
A different implementation of make (or a later version of the same implementation) might have a non-empty value for the
macro in its default set.
This is one aspect of a more general problem, which is that any macro that is not one for which this standard requires a default
value, and is not explicitly set either in the makefile or on the make command line, can have an unexpected value (or
unexpectedly not exist) when the makefile is used by a different user or with a different make implementation.
For this reason, it is recommended that makefile authors do not design makefile schemes in which values for non-standard macros
are obtained from the user's environment variables. Safer methods of allowing users to configure macro values include:
Setting the macros to default values in a make include file where the user can edit the values.
Executing make from one or more wrapper scripts which set macro values on the command line (and which do not obtain those
values from environment variables).
Makefile authors who follow this recommendation may wish to check for any macros they have overlooked by using a make
implementation that provides, as an extension, a command-line option that causes make to report attempts to expand (or
append to) macros that do not exist. Users of makefiles written by others can also benefit from the use of such an option to detect
the opposite problem (where the author had a macro being set from an environment variable but the user does not have the variable
set). This can avoid misbehaviors that would otherwise be hard to debug, such as a file-processing utility reading from standard
input because it was not given any pathnames to process.
Makefile authors who choose not to follow the recommendation can minimize the risk of misbehavior by ensuring all non-standard
macros have names that begin with a suitable project-specific prefix.
Use of the -e option is strongly discouraged, as it makes the problem discussed above even more likely by introducing the
possibility of unexpected values occurring even for macros set in the makefile. If a specific macro needs a value from the
environment to override a value set in the makefile, it is safer to set just that macro on the command line, using for example
make MYPROJ_FOO="$MYPROJ_FOO". Alternatively, the makefile can be modified to use the ?= assignment operator
for that macro.
Delayed-expansion macros are evaluated when they are used rather than when they are defined. Therefore:
MACRO = value1
Immed ::= $(MACRO)
DELAY = $(MACRO)
MACRO = value2
target:
echo $(Immed) $(DELAY)
would produce "value1 value2", since Immed was expanded while MACRO was value1, but DELAY
was not expanded until it was needed in the echo command line when MACRO was
value2.
Because the behavior of the += assignment differs depending on whether the macro being appended to is a
delayed-expansion macro or an immediate-expansion macro, it is recommended that when both macro types are used in a set of multiple
makefiles and include files, a naming convention is adopted to distinguish the two macro types. This avoids any confusion about
whether += will append the expanded or unexpanded value. A suitable convention might be to name delayed-expansion macros
using uppercase and underscore characters and immediate-expansion macros using a name that contains at least one lowercase
character.
Some historical applications have been known to intermix target_name and macro=name operands on the command line,
expecting that all of the macros are processed before any of the targets are dealt with. Conforming applications do not do this,
although some backwards-compatibility support may be included in some implementations.
The following characters in filenames may give trouble: '=', ':', '`', single-quote, and
'@'. In include filenames, pattern matching characters and '"' should also be avoided, as they may be treated as
special by some implementations.
For inference rules, the descriptions of $ should be removed, or
another macro should be used, as in:
INCLUDE_NAME = include
$(INCLUDE_NAME) =foo.mk
On the other hand, if the intent is to include a file which starts with an , either the filename should be
changed to ./=foo.mk, or the makefile should be written as:
INCLUDE_FILE = =foo.mk
include $(INCLUDE_FILE)
It is important to be careful when using parallel execution (the -j option) and archives. If multiple $(AR)
commands run at the same time on the same archive file, they will not know about each other and can corrupt the file. If the
-j option is used, it is necessary to use .WAIT in between archive member prerequisites to prevent this (see
EXAMPLES).
EXAMPLES
The following command:
make
makes the first target found in the makefile.
The following command:
make junk
makes the target junk.
The following makefile says that pgm depends on two files, a.o and b.o, and that they in turn depend on
their corresponding source files (a.c and b.c), and a common file incl.h:
.POSIX:
pgm: a.o b.o
c17 a.o b.o -o pgm
a.o: incl.h a.c
c17 -c a.c
b.o: incl.h b.c
c17 -c b.c
The following is an extended version of the previous example that generates make include files containing the
prerequisites for each object file. The include file also defines its own prerequisites, and the makefile arranges that these are
used by including the file twice. With implementations of make that create include files during parsing, the first time
make is run the file does not exist but the use of the  prefix on the first include line means it is
ignored and is then generated by the rule preceding the second include line. On subsequent runs, if any of the source or header
files previously identified has changed, the include file will be updated. There are other ways of updating the include file when
headers change, but they involve recursive execution of make.
.POSIX:
.SUFFIXES: .c .d
OFILES = a.o b.o
pgm: $(OFILES)
c17 $(OFILES) -o pgm
a.o:
c17 -c a.c
b.o:
c17 -c b.c
-include $(OFILES:.o=.d)
.c.d:
+{ \
set -o pipefail; cfile=$ $@
include $(OFILES:.o=.d)
This example does not cope with a header file being removed (make will complain that
it does not know how to make it), necessitating that *.d be removed and the make run again. Alternatively, this can
be handled by updating the commands which generate the .d file so that they add an empty target rule for each of its
prerequisites.
An example for making optimized .o files from .c files is:
.c.o:
c17 -c -O 1 $*.c
or:
.c.o:
c17 -c -O 1 $ characters throughout the makefile is historical practice. For example, the inference
rule:
.c.o\
:
works, and the macro:
f=  bar baz\
biz
a:
echo ==$f==
echoes "==bar baz biz==".
If $? were:
/usr/include/stdio.h /usr/include/unistd.h foo.h
then $(?D) would be:
/usr/include /usr/include .
and $(?F) would be:
stdio.h unistd.h foo.h
The contents of the built-in rules can be viewed by running:
make -p -f /dev/null 2>/dev/null
With the following makefile, make -j 10 all may bring one and two up-to-date in parallel despite the
.WAIT in the prerequisite list for foo. This is because the .WAIT does not stop make from recursively
processing bar and its prerequisites in parallel. However, if only foo is specified (make -j 10 foo),
make will wait for one to be brought up-to-date before bringing two up-to-date. Note also that the
.WAIT does not create a prerequisite relationship between one and two, so make -j 10 two will not
build one.
all: foo bar
foo: one .WAIT two
bar: one two
foo bar one two: ; @echo $@
RATIONALE
The make utility described in this volume of POSIX.1-2024 is intended to provide the means for changing portable source
code into executables that can be run on a POSIX.1-2024-conforming system. It reflects the most common features present in System V
and BSD makes.
Historically, the make utility has been an especially fertile ground for vendor and research organization-specific syntax
modifications and extensions. Examples include:
Syntax supporting parallel execution (such as from various multi-processor vendors, GNU, and others)
Additional "operators" separating targets and their prerequisites (System V, BSD, and others)
Modifications of the meaning of internal macros when referencing libraries (BSD and others)
Using a single instance of the shell for all of the command lines of the target (BSD and others)
Allowing  characters as well as  characters to delimit command lines (BSD)
Adding C preprocessor-style "include" and "ifdef" constructs (System V, GNU, BSD, and others)
Remote execution of command lines (Sprite and others)
Specifying additional special targets (BSD, System V, and most others)
Specifying an alternate shell to use to process commands.
Additionally, many vendors and research organizations have rethought the basic concepts of make, creating vastly
extended, as well as completely new, syntaxes. Each of these versions of make fulfills the needs of a different community of
users; it is unreasonable for this volume of POSIX.1-2024 to require behavior that would be incompatible (and probably inferior) to
historical practice for such a community.
In similar circumstances, when the industry has enough sufficiently incompatible formats as to make them irreconcilable, this
volume of POSIX.1-2024 has followed one or both of two courses of action. Commands have been renamed (cksum, echo, and pax) and/or command line options have been provided to select the desired behavior (grep, od, and pax).
Because the syntax specified for the make utility was, by and large, a subset of the syntaxes accepted by almost all
versions of make when the original IEEE Std 1003.2-1992 shell and utilities standard was being developed, it was
decided that it would be counter-productive to change the name. And since the makefile itself is a basic unit of portability, it
would not be completely effective to reserve a new option letter, such as make -P, to achieve the portable behavior.
Therefore, the special target .POSIX was added to the makefile, allowing users to specify "standard" behavior. This
special target does not preclude extensions in the make utility, nor does it preclude such extensions being used by the
makefile specifying the target; it does, however, preclude any extensions from being applied that could alter the behavior of
previously valid syntax; such extensions must be controlled via command line options or new special targets. It is incumbent upon
portable makefiles to specify the .POSIX special target in order to guarantee that they are not affected by local
extensions.
The portable version of make described in this reference page is not intended to be the state-of-the-art software
generation tool and, as such, some newer and more leading-edge features have not been included. An attempt has been made to
describe the portable makefile in a manner that does not preclude such extensions as long as they do not disturb the portable
behavior described here.
When the -n option is specified, it is always added to MAKEFLAGS . This allows a recursive make -n
target to be used to see all of the actions that would be taken to update target.
The definition of MAKEFLAGS allows both the System V letter string and the BSD command line formats. The two formats are
sufficiently different to allow implementations to support both without ambiguity.
Early proposals stated that an "unquoted"  was treated as the start of a comment. The make utility
does not pay any attention to quotes. A  starts a comment regardless of its surroundings.
The text about "other implementation-defined pathnames may also be tried" in addition to ./makefile and
./Makefile is to allow such extensions as SCCS/s.Makefile and other variations. It was made an implementation-defined
requirement (as opposed to unspecified behavior) to highlight surprising implementations that might select something unexpected
like /etc/Makefile. XSI-conformant systems also try ./s.makefile, SCCS/s.makefile, ./s.Makefile, and
SCCS/s.Makefile.
The default rules are based on System V. The default CC= value is c17 instead
of cc because this volume of POSIX.1-2024 does not standardize the utility named cc. Thus, every conforming
application would be required to define CC=c17 to expect to run. There is no
advantage conferred by the hope that the makefile might hit the "preferred" compiler because this cannot be guaranteed to work.
Also, since the portable makescript can only use the c17 options, no advantage is
conferred in terms of what the script can do. It is a quality-of-implementation issue as to whether c17 is as valuable as cc.
Implementations are permitted to include any macro of their choosing in the default set. However, they are encouraged to keep
such additions to a minimum in order to reduce the risk of name clashes with user macros.
Implementations are encouraged to provide, as an extension, a command-line option that causes make to report attempts to
expand (or append to) macros that do not exist. See APPLICATION USAGE for the intended use cases of such an option.
The -d option to make is frequently used to produce debugging information, but is too implementation-defined to
add to this volume of POSIX.1-2024.
The -p option is not passed in MAKEFLAGS on most historical implementations and to change this would cause many
implementations to break without sufficiently increased portability.
Commands that begin with a  ('+') are executed even if the -n option is present. Based on the
GNU version of make, the behavior of -n when the  prefix is encountered has been extended to apply
to -q and -t as well. The System V convention of forcing command execution with -n when the command line of a
target expands the MAKE macro was not adopted in earlier versions of this standard, but it is now required because it has
become widespread existing practice.
The double  in the target rule format is supported in BSD systems to allow more than one target line containing the
same target name to have commands associated with it. Since this is not functionality described in the SVID or XPG3 it has been
allowed as an extension, but not mandated.
The default rules are provided with text specifying that the built-in rules shall be the same as if the listed set were used.
The intent is that implementations should be able to use the rules without change, but will be allowed to alter them in ways that
do not affect the primary behavior.
One point of discussion was whether to drop the default rules list from this volume of POSIX.1-2024. They provide convenience,
but do not enhance portability of applications. The prime benefit is in portability of users who wish to type make
command and have the command build from a command.c file.
The historical MAKESHELL feature, and related features provided by other make implementations, were omitted. In
some implementations it is used to let a user override the shell to be used to run make commands. This was confusing; for a
portable make, the shell should be chosen by the makefile writer. Further, a makefile writer cannot require an alternate
shell to be used and still consider the makefile portable. While it would be possible to standardize a mechanism for specifying an
alternate shell, existing implementations do not agree on such a mechanism, and makefile writers can already invoke an alternate
shell by specifying the shell name in the rule for a target; for example:
python -c "foo"
The make utilities in most historical implementations process the prerequisites of a target in left-to-right order, and
the makefile format requires this. It supports the standard idiom used in many makefiles that produce yacc programs; for example:
foo: y.tab.o lex.o main.o
$(CC) $(CFLAGS) -o $@ y.tab.o lex.o main.o
In this example, if make chose any arbitrary order, the lex.o might not be made with the correct y.tab.h.
Although there may be better ways to express this relationship, it is widely used historically. Implementations that desire to
update prerequisites in parallel should require an explicit extension to make or the makefile format to accomplish it, as
described previously.
The algorithm for determining a new entry for target rules is partially unspecified. Some historical makes allow comment
lines (including blank and empty lines) within the collection of commands marked by leading  characters. A conforming
makefile must ensure that each command starts with a , but implementations are free to ignore comments without
triggering the start of a new entry.
The ASYNCHRONOUS EVENTS section includes having SIGTERM and SIGHUP, along with the more traditional SIGINT and SIGQUIT, remove
the current target unless directed not to do so. SIGTERM and SIGHUP were added to parallel other utilities that have historically
cleaned up their work as a result of these signals. When make receives any signal other than SIGQUIT, it is required to
resend itself the signal it received so that it exits with a status that reflects the signal. The results from SIGQUIT are
partially unspecified because, on systems that create a file named core upon receipt of SIGQUIT, the core file from
make would conflict with a core file from the command that was running when the SIGQUIT arrived. The main concern was
to prevent damaged files from appearing up-to-date when make is rerun.
The .PRECIOUS special target was extended to affect all targets globally (by specifying no prerequisites). The
.IGNORE and .SILENT special targets were extended to allow prerequisites; it was judged to be more useful in some
cases to be able to turn off errors or echoing for a list of targets than for the entire makefile. These extensions to make
in System V were made to match historical practice from the BSD make.
Macros are not exported to the environment of commands to be run. This was never the case in any historical make and
would have serious consequences. The environment is the same as the environment to make except that MAKEFLAGS and
macros defined on the make command line are added, and except that macros defined by the MAKEFLAGS environment
variable and macros defined in the makefile(s) may update the value of an existing environment variable (other than SHELL
).
Some implementations do not use system() for all command lines, as required by the
portable makefile format; as a performance enhancement, they select lines without shell metacharacters for direct execution by
execve(). There is no requirement that system() be used specifically, but merely that the same results be achieved. The
metacharacters typically used to bypass the direct execve() execution have been any
of:
=  |  ^  (  )  ;  &    *  ?  [  ]  :  $  `  '  "  \  \n
The default in some advanced versions of make is to group all the command lines for a target and execute them using a
single shell invocation; the System V method is to pass each line individually to a separate shell. The single-shell method has the
advantages in performance and the lack of a requirement for many continued lines. However, converting to this newer method has
caused portability problems with many historical makefiles, so the behavior with the POSIX makefile is specified to be the same as
that of System V. It is suggested that the special target .ONESHELL be used as an implementation extension to achieve the
single-shell grouping for a target or group of targets.
Novice users of make have had difficulty with the historical need to start commands with a . Since it is often
difficult to discern differences between  and  characters on terminals or printed listings, confusing bugs
can arise. In early proposals, an attempt was made to correct this problem by allowing leading  characters instead of
characters. However, implementors reported many makefiles that failed in subtle ways following this change, and it is
difficult to implement a make that unambiguously can differentiate between macro and command lines. There is extensive
historical practice of allowing leading  characters before macro definitions. Forcing macro lines into column 1 would
be a significant backwards-compatibility problem for some makefiles. Therefore, historical practice was restored.
There is substantial variation in the handling of include lines by different implementations. However, there is enough
commonality for the standard to be able to specify a minimum set of requirements that allow the feature to be used portably. Known
variations have been explicitly called out as unspecified behavior in the description.
The System V dynamic dependency feature was not included. It would support:
cat: $$@.c
that would expand to;
cat: cat.c
This feature exists only in the new version of System V make and, while useful, is not in wide usage. This means that
macros are expanded twice for prerequisites: once at makefile parse time and once at target update time.
Consideration was given to adding metarules to the POSIX make. This would make %.o: %.c the same as
.c.o:. This is quite useful and available from some vendors, but it would cause too many changes to this make to
support. It would have introduced rule chaining and new substitution rules. However, the rules for target names have been set to
reserve the '%' and '"' characters. These are traditionally used to implement metarules and quoting of target
names, respectively. Implementors are strongly encouraged to use these characters only for these purposes.
A request was made to extend the suffix delimiter character from a  to any character. The metarules feature in
newer makes solves this problem in a more general way. This volume of POSIX.1-2024 is staying with the more conservative
historical definition.
The standard output format for the -p option is not described because it is primarily a debugging option and because the
format is not generally useful to programs. In historical implementations the output is not suitable for use in generating
makefiles. The -p format has been variable across historical implementations. Therefore, the definition of -p was
only to provide a consistently named option for obtaining make script debugging information.
Some historical implementations have not cleared the suffix list with -r.
Implementations should be aware that some historical applications have intermixed target_name and
macro=value operands on the command line, expecting that all of the macros are processed before any of the targets
are dealt with. Conforming applications do not do this, but some backwards-compatibility support may be warranted.
Empty inference rules are specified with a  command rather than omitting all commands, as described in an early
proposal. The latter case has no traditional meaning and is reserved for implementation extensions, such as in GNU make.
Earlier versions of this standard defined comment lines only as lines with '#' as the first character. Many places then
talked about comments, blank lines, and empty lines; but some places inadvertently only mentioned comments when blank lines and
empty lines had also been accepted in all known implementations. The standard now defines comment lines to be blank lines, empty
lines, and lines starting with a '#' character and explicitly lists cases where blank lines and empty lines are not
acceptable.
On most historic systems, the make utility considered a target with a prerequisite that had an identical timestamp as
up-to-date. One implementation of make treated it as out-of-date. Note that up-to-date and out-of-date are antonyms. The
standard now allows either behavior, but implementations are encouraged to treat such targets as out-of-date. This is especially
important on file systems where the timestamp resolution is the minimum (1 second) required by the standard. All implementations of
make should make full use of the finest timestamp resolution available on the file systems holding targets and prerequisites
to ensure that targets are up-to-date even for prerequisite files with timestamps that were updated within the same second.
However, if the timestamp resolutions of the file systems containing a target and a prerequisite are different, the timestamp with
the more precise resolution should be rounded down to the resolution of the less precise timestamp for the comparison.
The traditional semantics of delayed-expansion macros have often been the source of subtle bugs for makefile writers not aware
of those semantics. Furthermore, in implementations that support an extension of assigning the output of an arbitrary command to a
macro definition, the use of delayed-expansion macros could result in an undesirable growth in execution time, as each use of the
macro would re-run the arbitrary command. Historically, several implementations independently developed a form of immediate
expansion, usually via the operator ":=", so that execution of an arbitrary command happens once at the definition of the
macro rather than each use of the macro; however, there are subtle differences in the expansion rules of those various
implementations when the expanded value of string2 contained a '$'. Other implementations used the operator
":=" for conditional expansion, altogether unrelated to immediate-expansion macro definition.
The standard developers felt that immediate-expansion semantics were useful enough to standardize, but requiring the semantics
of any one implementation of ":=" would cause confusion in makefiles written for other implementation semantics,
necessitating a reader to determine if .POSIX: had been specified at the beginning of the file (or worse, at the beginning
of some other file that then includes the fragment in question) to know which semantics would be in use. Therefore, the standard
developers opted to require two new operators, "::=" and ":::=", with specific semantics; the "::="
operator has semantics closest to the GNU make implementation of ":=", where '$' characters occurring in
the immediate expansion of string2 are not further expanded in subsequent use of the macro, and the ":::=" operator
has semantics closest to the BSD make and smake implementations of ":=", where immediate expansion is
performed when assigning to a delayed-expansion macro and "$$" is preserved. It was felt that other implementations could
easily support the required semantics.
Implementations that previously provided ":=" as an extension are encouraged to leave this extension intact, with no
change in the implementation's particular semantics, to avoid breaking non-portable makefiles that had been targeting that
particular implementation. A portable makefile, with .POSIX: specified at the beginning, should not use the ":="
operator.
Traditionally, constructs such as
DIR: FORCE
(commands)
FORCE:
were used to allow make DIR to always run (commands); however, this depended on the user never creating a file
named FORCE. The addition of the .B~.PHONY special target provides a more efficient manner of providing a target whose
commands are always run, and where the user cannot create a file that influences the behavior in an unexpected manner.
This standard allows two different methods of creating include files or bringing them up-to-date, reflecting established
practice in SunPro make and GNU make. The former performs this action during parsing, before the include file is
opened. The latter delays performing the action until after all makefiles have been read. Implementors who opt for the "delayed
remaking" method should be aware of the following potential issues:
Diagnostic messages about missing include files must be deferred until the final exit status is known. Note that this is a
conformance issue, not just a quality of implementation issue.
If the way make handles using updated include file contents is to start over after include files have been made
up-to-date, it is possible for a poorly written makefile to cause make to enter a sequence of restarts where nothing changes
each time, resulting in the sequence continuing indefinitely unless the situation is detected. Implementors are encouraged to
include a mechanism for detecting and reporting this, rather than allowing make to consume an arbitrary amount of system
resource until it is forcibly terminated.
If make uses this start-over method, makefile contents read from a pipe on standard input or from a FIFO must be copied
to a temporary file, and when make starts over it must use this file instead.
If make starts over by executing itself using the exec family of functions, the need to replace '-' or
the pathnames of FIFOs with the pathnames of temporary files can lead to the exec call failing with an [E2BIG] error if the
original execution was close to the {ARG_MAX} limit. Although this is a quality of implementation issue, not a conformance issue
(since the general rules for utility errors allow utilities to fail when they encounter a variety of internal errors - see 1.4 Utility Description Defaults), implementors are encouraged to explore ways
to prevent it, such as passing information via a temporary file instead of on the command line when an [E2BIG] error has occurred.
Another solution might be to jump (e.g. using siglongjmp()) back to the start of
main() as the way to start over. Making a recursive call to main() is not recommended, as that would run into the
stack limit if sufficiently many restarts are needed.
This standard specifies that a non-existent include file is first created if possible, and only if not possible can other
directories be searched. Historical versions of GNU make first searched the include directories, then attempted to create
the include file. This behavior was not considered suitable for standardization as it means writers of portable applications have
to use absolute pathnames for all include files that need to be created via a rule (because they can never be sure what relative
pathnames are safe to use, since a file with the same relative pathname might happen to exist in one of the searched directories
when installing the application on a new system). Note, however, that this only applies to directories searched by default. If an
application uses an extension to specify that one or more directories are searched, this standard does not place any constraints on
when the specified directories are searched.
This standard specifies a way for portable applications to request parallel updating of targets with commands by using the
-j maxjobs option. This feature is described in terms of a token pool initially containing up to maxjobs - 1
tokens. Note that this is not intended to prescribe a particular implementation design; the usual "as if" rule applies.
Implementations are permitted to silently limit the pool size for a few reasons, including:
Implementations that do not support parallelism can support the -j option by simply ignoring the option (other than
passing it to sub-make invocations via the MAKEFLAGS environment variable). In effect, such an implementation
silently restricts the size of the token pool to zero (and therefore need not create a token pool).
Some historical implementations dynamically limit the token pool size based on the current system load to avoid overloading the
system.
Implementations may want to limit the token pool size based on the number of processors available.
Implementations may want to limit the token pool size based on resource limits.
Limiting the pool size does not change the value of maxjobs that is passed to sub-make invocations via the
MAKEFLAGS environment variable.
When a different maxjobs value is passed to a sub-make, some historical make implementations created a
separate pool of tokens while other historical make implementations continued to obtain tokens from the invoking make
but limited the number of tokens held at a time to the new value of maxjobs - 1. Both behaviors are believed to have merit
in different situations: the former gives a sub-make complete control the amount of parallelism, while the latter allows the
user to control the overall system load. This standard permits either behavior.
This standard calls for a token pool of size maxjobs - 1, and for removal from that pool only for the second and
subsequent tasks in a set of parallel tasks. This design was chosen because this is effectively what existing implementations do,
and also because the token consumed by a parallel task that invokes a sub-make is effectively lent to the sub-make.
Lending the token to the sub-make has the following advantages:
It prevents the sub-make from being completely idle due to token starvation, allowing it to always make some progress
regardless of how many tokens other sub-make invocations have consumed.
It prevents token pool exhaustion caused by a long chain of sub-make invocations. If the token consumed by the invoking
rule was not effectively lent to the sub-make, then the pool would be exhausted by a chain of sub-make invocations
that is maxjobs long. Such a chain would never accomplish any work, and would thus never complete.
When a rule invokes multiple sub-make processes asynchronously (for example by using an asynchronous list in the shell),
some implementations allow each sub-make to execute at least one rule even though this would cause the total number of
parallel rule executions across all make instances to exceed maxjobs (after discounting the rules that execute
sub-make processes). This behavior may not be ideal, but it is easier to implement and is unlikely to cause problems in
practice because applications typically do not have any rules that invoke multiple sub-make processes asynchronously. For
this reason the behavior is unspecified if a rule executes multiple sub-make processes asynchronously.
When multiple sub-make processes are running in parallel there is no requirement placed on the ordering of output from
these processes. Some implementations of make attempt to serialize output from each sub-make; others make no such
attempt. If diagnostic messages from failed commands are intermixed, the usual way to deal with this is to repeat the make
without -j (or with -j 1) so that intermixing will not occur.
FUTURE DIRECTIONS
If this utility is directed to create a new directory entry that contains any bytes that have the encoded value of a
character, implementations are encouraged to treat this as an error. A future version of this standard may require
implementations to treat this as an error.
Some implementations of make include an export directive to add specified make variables to the
environment. This may be considered for standardization in a future version.
A future version of this standard may add a command-line option that causes make to report attempts to expand (or append
to) macros that do not exist.
A future version of this standard may require that a target with a prerequisite with an identical timestamp is considered
out-of-date.
SEE ALSO
2. Shell Command Language, ar, c17, get, lex, sccs, sh, yacc
XBD 6.1 Portable Character Set, 8. Environment Variables, 12.2
Utility Syntax Guidelines
XSH exec, system()
CHANGE HISTORY
First released in Issue 2.
Issue 5
The FUTURE DIRECTIONS section is added.
Issue 6
This utility is marked as part of the Software Development Utilities option.
The Open Group Corrigendum U029/1 is applied, correcting a typographical error in the SPECIAL TARGETS section.
In the ENVIRONMENT VARIABLES section, the PROJECTDIR description is updated from "otherwise, the home directory of a
user of that name is examined" to "otherwise, the value of PROJECTDIR is treated as a user name and that user's initial
working directory is examined".
It is specified whether the command line is related to the makefile or to the make command, and the macro processing
rules are updated to align with the IEEE P1003.2b draft standard.
The normative text is reworded to avoid use of the term "must" for application requirements.
PASC Interpretation 1003.2 #193 is applied.
Issue 7
SD5-XCU-ERN-6 is applied, clarifying that Guideline 9 of the Utility Syntax Guidelines does not apply.
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
Include lines in makefiles are introduced.
Austin Group Interpretation 1003.1-2001 #131 is applied, changing the Makefile Execution section.
POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0121 [257] is applied.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0122 [509], XCU/TC2-2008/0123 [584], XCU/TC2-2008/0124 [857],
XCU/TC2-2008/0125 [505], XCU/TC2-2008/0126 [584], XCU/TC2-2008/0127 [505], XCU/TC2-2008/0128 [865], XCU/TC2-2008/0129 [693],
XCU/TC2-2008/0130 [602], XCU/TC2-2008/0131 [848], XCU/TC2-2008/0132 [763], XCU/TC2-2008/0133 [857], XCU/TC2-2008/0134 [866],
XCU/TC2-2008/0135 [525], XCU/TC2-2008/0136 [848], XCU/TC2-2008/0137 [769], XCU/TC2-2008/0138 [525], XCU/TC2-2008/0139 [769],
XCU/TC2-2008/0140 [505], XCU/TC2-2008/0141 [693], XCU/TC2-2008/0142 [505], XCU/TC2-2008/0143 [857], and XCU/TC2-2008/0144 [693,865]
are applied.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to disallow the creation of filenames containing any bytes that
have the encoded value of a  character.
Austin Group Defects 330, 1417, 1422, 1709, and 1710 are applied, adding new forms of macro assignment using the "::=",
"?=", and "+=" operators.
Austin Group Defect 333 is applied, adding support for "silent includes" using -include.
Austin Group Defects 336 and 1711 are applied, specifying the behavior when string1 in a macro expansion contains a macro
expansion.
Austin Group Defect 337 is applied, adding a new form of macro assignment using the "!=" operator.
Austin Group Defects 373 and 1417 are applied, changing the set of characters that portable applications can use in macro names
to the entire portable filename character set (thus adding  to the set that could previously be used).
Austin Group Defects 514 and 1520 are applied, adding the $+ and $^ internal macros.
Austin Group Defect 518 is applied, allowing multiple files to be specified on an include line.
Austin Group Defects 519, 1712, and 1715 are applied, adding support for pattern macro expansions.
Austin Group Defects 523, 1708, and 1749 are applied, adding the .B~.PHONY special target.
Austin Group Defect 875 is applied, clarifying the requirements for inference rules.
Austin Group Defect 1104 is applied, changing "s2.a" to ".s2.a".
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
Austin Group Defect 1141 is applied, changing "core files" to "a file named core".
Austin Group Defect 1155 is applied, clarifying the handling of the MAKE macro.
Austin Group Defect 1325 is applied, adding requirements relating to the creation of include files.
Austin Group Defect 1330 is applied, removing obsolescent interfaces.
Austin Group Defect 1419 is applied, updating the .SCCS_GET default rule.
Austin Group Defect 1420 is applied, clarifying where internal macros can be used.
Austin Group Defect 1421 is applied, changing the APPLICATION USAGE section.
Austin Group Defects 1424, 1658, 1690, 1701, 1702, 1703, 1704, 1707, 1719, 1720, 1721, 1722, and 1750 are applied, making
various minor editorial wording changes.
Austin Group Defects 1436, 1437, 1652, 1660, 1661, and 1733 are applied, adding the -j maxjobs option and the
.NOTPARALLEL and .WAIT special targets, and changing the -n option.
Austin Group Defects 1471 and 1513 are applied, adding a new form of macro assignment using the ":::=" operator.
Austin Group Defect 1479 is applied, clarifying the requirements for default rules and macro values.
Austin Group Defect 1492 is applied, changing the EXIT STATUS section.
Austin Group Defect 1505 is applied, clarifying the requirements for expansion of macros that do not exist.
Austin Group Defect 1510 is applied, correcting a typographic error in the RATIONALE section.
Austin Group Defect 1549 is applied, clarifying the requirements for an escaped  in a command line.
Austin Group Defect 1615 is applied, allowing target names to contain slashes and hyphens.
Austin Group Defect 1626 is applied, adding the CURDIR macro.
Austin Group Defect 1631 is applied, adding information about use of the -j option with the .c.a default rule to
the APPLICATION USAGE and EXAMPLES sections.
Austin Group Defect 1650 is applied, changing the few occurrences of "dependencies" to use the more common
"prerequisites".
Austin Group Defect 1653 is applied, clarifying the difference between how MAKEFLAGS is parsed compared to shell commands
that use the make utility.
Austin Group Defects 1654 and 1655 are applied, changing the APPLICATION USAGE section.
Austin Group Defect 1656 is applied, changing the NAME section.
Austin Group Defect 1657 is applied, moving some requirements unrelated to makefile syntax from the Makefile Syntax subsection
to the beginning of the EXTENDED DESCRIPTION section.
Austin Group Defect 1689 is applied, removing some redundant wording from the DESCRIPTION section.
Austin Group Defect 1692 is applied, allowing make, when invoked with the -q or -t option, to execute
command lines (without a  prefix) that expand the MAKE macro.
Austin Group Defect 1693 is applied, changing "command lines" to "execution lines" in the description of the -s
option.
Austin Group Defect 1694 is applied, changing "in the order they appear" to "in the order specified" in the OPERANDS
section.
Austin Group Defect 1696 is applied, changing the STDOUT section.
Austin Group Defect 1697 is applied, changing the RATIONALE and FUTURE DIRECTIONS sections.
Austin Group Defect 1698 is applied, changing "of a target" to "of the target" in the EXTENDED DESCRIPTION section.
Austin Group Defect 1699 is applied, addressing some inconsistencies in the use of the term "rules".
Austin Group Defect 1706 is applied, removing a line from the format specified for target rules.
Austin Group Defect 1714 is applied, changing "beginning of the line" to "beginning of the value".
Austin Group Defect 1716 is applied, changing the typographic convention used for variable elements within target names, in
particular the inference rule suffixes s1 and s2.
Austin Group Defect 1723 is applied, adding historical context to a paragraph in the RATIONALE section.
Austin Group Defect 1772 is applied, clarifying the ASYNCHRONOUS EVENTS section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/exec.html =====
Shell Command Language
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
Please enable javascript in your browser to automatically redirect to the target page, otherwise select the link below.
2.15 Special Built-In Utilities
break
colon
continue
dot
eval
exec
exit
export
readonly
return
set
shift
times
trap
unset
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
===== susv5-html/utilities/return.html =====
Shell Command Language
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
Please enable javascript in your browser to automatically redirect to the target page, otherwise select the link below.
2.15 Special Built-In Utilities
break
colon
continue
dot
eval
exec
exit
export
readonly
return
set
shift
times
trap
unset
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
===== susv5-html/utilities/write.html =====
write
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
write — write to another user
SYNOPSIS
write user_name [terminal]
DESCRIPTION
The write utility shall read lines from the standard input and write them to the terminal of the specified user. When
first invoked, it shall write the message:
Message from sender-login-id (sending-terminal) [date]...
to user_name. When it has successfully completed the connection, the sender's terminal shall be alerted twice to indicate
that what the sender is typing is being written to the recipient's terminal.
If the recipient wants to reply, this can be accomplished by typing:
write sender-login-id [sending-terminal]
upon receipt of the initial message. Whenever a line of input as delimited by an NL, EOF, or EOL special character (see XBD
11. General Terminal Interface) is accumulated while in canonical input
mode, the accumulated data shall be written on the other user's terminal. Characters shall be processed as follows:
Typing  shall write the  character to the recipient's terminal.
Typing the erase and kill characters shall affect the sender's terminal in the manner described by the termios interface
in XBD 11. General Terminal Interface.
Typing the interrupt or end-of-file characters shall cause write to write an appropriate message ("EOT\n" in the
POSIX locale) to the recipient's terminal and exit.
Typing characters from LC_CTYPE classifications print or space shall cause those characters to be sent to
the recipient's terminal.
When and only when the stty iexten local mode is enabled, the existence and
processing of additional special control characters and multi-byte or single-byte functions is implementation-defined.
Typing other non-printable characters shall cause implementation-defined sequences of printable characters to be written to the
recipient's terminal.
To write to a user who is logged in more than once, the terminal argument can be used to indicate which terminal to write
to; otherwise, the recipient's terminal is selected in an implementation-defined manner and an informational message is written to
the sender's standard output, indicating which terminal was chosen.
Permission to be a recipient of a write message can be denied or granted by use of the mesg utility. However, a user's privilege may further constrain the domain of accessibility of
other users' terminals. The write utility shall fail when the user lacks appropriate privileges to perform the requested
action.
OPTIONS
None.
OPERANDS
The following operands shall be supported:
user_name
Login name of the person to whom the message shall be written. The application shall ensure that this operand is of the form
returned by the who utility.
terminal
Terminal identification in the same format provided by the who utility.
STDIN
Lines to be copied to the recipient's terminal are read from standard input.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of write:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files). If the recipient's locale does not use an LC_CTYPE
equivalent to the sender's, the results are undefined.
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error and
informative messages written to standard output.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
If an interrupt signal is received, write shall write an appropriate message on the recipient's terminal and exit with a
status of zero. It shall take the standard action for all other signals.
STDOUT
An informational message shall be written to standard output if a recipient is logged in more than once.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
The recipient's terminal is used for output.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
The addressed user is not logged on or the addressed user denies permission.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
The talk utility is considered by some users to be a more usable utility on
full-screen terminals.
EXAMPLES
None.
RATIONALE
The write utility was included in this volume of POSIX.1-2024 since it can be implemented on all terminal types. The
standard developers considered the talk utility, which cannot be implemented on certain
terminals, to be a "better" communications interface. Both of these programs are in widespread use on historical implementations.
Therefore, the standard developers decided that both utilities should be specified.
The format of the terminal name is unspecified, but the descriptions of ps, talk, who, and write require that they all
use or accept the same format.
FUTURE DIRECTIONS
None.
SEE ALSO
mesg, talk, who
XBD 8. Environment Variables, 11. General Terminal Interface
CHANGE HISTORY
First released in Issue 2.
Issue 5
The FUTURE DIRECTIONS section is added.
Issue 6
This utility is marked as part of the User Portability Utilities option.
The normative text is reworded to avoid use of the term "must" for application requirements.
Issue 7
The write utility is moved from the User Portability Utilities option to the Base. User Portability Utilities is now an
option for interactive utilities.
Issue 8
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/what.html =====
what
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
what — identify SCCS files (DEVELOPMENT)
SYNOPSIS
[XSI]  what [-s] file...
DESCRIPTION
The what utility shall search the given files for all occurrences of the pattern that get (see get) substitutes for the %Z%
keyword ("@(#)"). The what utility shall write to standard output the identification string that follows up to, but
not including, the first occurrence of one of the following:  ('"' ),
('>'), ,  ('\\'),  ('\0'), or an end-of-file condition on
the input file. If not at end-of-file, the what utility shall then look for the next occurrence of "@(#)" after one
of those characters.
OPTIONS
The what utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following option shall be supported:
-s
Write at most one identification string for each file. After locating and writing to standard output the identification string
following the first pattern (if any) in a file, no further data shall be read from that file and the search shall recommence from
the beginning of the next file, if any.
OPERANDS
The following operands shall be supported:
file
A pathname of a file to search.
STDIN
Not used.
INPUT FILES
The input files shall be of any file type.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of what:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
For each file operand, the standard output shall consist of:
"%s:\n",
followed by zero or more of:
"\t%s\n",
one for each identification string located.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
One or more matches were found and the output specified in STDOUT was successfully written to standard output.
1
No matches were found or an error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
The what utility is intended to be used in conjunction with the SCCS command get, which automatically inserts identifying information, but it can also be used where the
information is inserted by any other means.
When the string "@(#)" is included in a library routine in a shared library, it might not be found in an a.out
file using that library routine.
EXAMPLES
If the C-language program in file f.c contains:
char ident[] = "@(#)identification information";
and f.c is compiled to yield f.o and a.out, then the command:
what f.c f.o a.out
writes:
f.c:
identification information
...
f.o:
identification information
...
a.out:
identification information
...
RATIONALE
This standard requires that when the -s option is used, what does not continue reading from the current file after
writing the first identification string. This might seem an unimportant detail, but applications would experience different
behavior if a file operand named a FIFO special file and what waited for an end-of-file condition rather than closing
the file straight away.
FUTURE DIRECTIONS
If this utility is directed to display a pathname that contains any bytes that have the encoded value of a
character when  is a terminator or separator in the output format being used, implementations are encouraged to
treat this as an error. A future version of this standard may require implementations to treat this as an error.
SEE ALSO
get
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 2.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to report an error if a utility is directed to display a
pathname that contains any bytes that have the encoded value of a  character when  is a terminator or
separator in the output format being used.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
Austin Group Defect 1512 is applied, changing the EXIT STATUS section.
Austin Group Defect 1538 is applied, clarifying the -s option.
Austin Group Defect 1563 is applied, clarifying the output format when the what utility finds multiple identification
strings in one file.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/pr.html =====
pr
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
pr — print files
SYNOPSIS
[XSI] pr [+page]
[-column] [-adfFmprt] [-e[char][gap]] [-h header]
[-i[char][gap]] [-l
lines] [-n[char][width]] [-o offset]
[-s[char]]        [-w width]
[file...]
DESCRIPTION
The pr utility is a printing and pagination filter. If multiple input files are specified, each shall be read, formatted,
and written to standard output. By default, the input shall be separated into 66-line pages, each with:
A 5-line header that includes the page number, date, time, and the pathname of the file
A 5-line trailer consisting of blank lines
If standard output is associated with a terminal, diagnostic messages shall be deferred until the pr utility has
completed processing.
When options specifying multi-column output are specified, output text columns shall be of equal width; input lines that do not
fit into a text column shall be truncated. By default, text columns shall be separated with at least one .
OPTIONS
The pr utility shall conform to XBD 12.2 Utility Syntax
Guidelines, except that: the page option has a '+' delimiter; page and column can be
multi-digit numbers; some of the option-arguments are optional; and some of the option-arguments cannot be specified as separate
arguments from the preceding option letter. In particular, the -s option does not allow the option letter to be separated
from its argument, and the options -e, -i, and -n require that both arguments, if present, not be separated
from the option letter.
The following options shall be supported. In the following option descriptions, column, lines, offset,
page, and width are positive decimal integers; gap is a non-negative decimal integer.
+page
Begin output at page number page of the formatted input.
-column
Produce multi-column output that is arranged in column columns (the default shall be 1) and is written down each column
in the order in which the text is received from the input file. This option should not be used with -m. The options
-e and -i shall be assumed for multiple text-column output. Whether or not text columns are produced with identical
vertical lengths is unspecified, but a text column shall never exceed the length of the page (see the -l option). When used
with -t, use the minimum number of lines to write the output.
-a
Modify the effect of the -column option so that the columns are filled across the page in a round-robin order
(for example, when column is 2, the first input line heads column 1, the second heads column 2, the third is the second line
in column 1, and so on).
-d
Produce output that is double-spaced; append an extra  following every  found in the input.
-e[char][gap]
Expand each input  to the next greater column position specified by the formula n*gap+1, where n is
an integer > 0. If gap is zero or is omitted, it shall default to 8. All  characters in the input shall be
expanded into the appropriate number of  characters. If any non-digit character, char, is specified, it shall
be used as the input . If the first character of the -e option-argument is a digit, the entire option-argument
shall be assumed to be gap.
-f
[XSI]
Use a  for new pages, instead of the default behavior that uses a sequence of  characters. Pause
before beginning the first page if the standard output is associated with a terminal.
-F
Use a  for new pages, instead of the default behavior that uses a sequence of  characters.
-h header
Use the string header to replace the contents of the file operand in the page header.
-i[char][gap]
In output, replace  characters with  characters wherever one or more adjacent  characters
reach column positions gap+1, 2* gap+1, 3* gap+1, and so on. If gap is zero or is omitted, default tab
settings at every eighth column position shall be assumed. If any non-digit character, char, is specified, it shall be used
as the output . If the first character of the -i option-argument is a digit, the entire option-argument shall be
assumed to be gap.
-l lines
Override the 66-line default and reset the page length to lines. If lines is not greater than the sum of both the
header and trailer depths (in lines), the pr utility shall suppress both the header and trailer, as if the -t option
were in effect.
-m
Merge files. Standard output shall be formatted so the pr utility writes one line from each file specified by a
file operand, side by side into text columns of equal fixed widths, in terms of the number of column positions.
Implementations shall support merging of at least nine file operands.
-n[char][width]
Provide width-digit line numbering (default for width shall be 5). The number shall occupy the first width
column positions of each text column of default output or each line of -m output. If char (any non-digit character)
is given, it shall be appended to the line number to separate it from whatever follows (default for char is a
).
-o offset
Each line of output shall be preceded by offset  characters. If the -o option is not specified, the default
offset shall be zero. The space taken is in addition to the output line width (see the -w option below).
-p
Pause before beginning each page if the standard output is directed to a terminal; pr shall write an  to
standard error and wait for a  to be read on /dev/tty.
-r
Write no diagnostic reports on failure to open files.
-s[char]
Separate text columns by the single character char instead of by the appropriate number of  characters
(default for char shall be ).
-t
Write neither the five-line identifying header nor the five-line trailer usually supplied for each page. Quit writing after the
last line of each file without spacing to the end of the page.
-w width
Set the width of the line to width column positions for multiple text-column output only. If the -w option is not
specified and the -s option is not specified, the default width shall be 72. If the -w option is not specified and
the -s option is specified, the default width shall be 512.
For single column output, input lines shall not be truncated.
OPERANDS
The following operand shall be supported:
file
A pathname of a file to be written. If no file operands are specified, or if a file operand is '-', the
standard input shall be used.
STDIN
The standard input shall be used only if no file operands are specified, or if a file operand is '-'. See
the INPUT FILES section.
INPUT FILES
The input files shall be text files. If the -m option is not specified, an empty input file may, but should not, be
treated as an error.
The file /dev/tty shall be used to read responses required by the -p option.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of pr:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files) and which characters are defined as printable (character class
print). Non-printable characters are still written to standard output, but are not counted for the purpose for column-width
and line-length calculations.
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
LC_TIME
Determine the format of the date and time for use in writing header lines.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
TZ
Determine the timezone used to calculate date and time strings written in header lines. If TZ is unset or null, an
unspecified default timezone shall be used.
ASYNCHRONOUS EVENTS
If pr receives an interrupt while writing to a terminal, it shall flush all accumulated error messages to the screen
before terminating.
STDOUT
If the -m option is not specified, the pr utility output shall be as follows:
If an input file is empty and the implementation does not treat this as an error, no output shall be written for that file and
this shall be considered to be successful completion of the processing for that file.
For each non-empty input file, the output shall be a paginated version of the original file.
If the -m option is specified, the pr utility output shall be a paginated version of the merged file contents, as
described in OPTIONS.
In both cases, the pagination shall be accomplished using either  characters or a sequence of
characters, as controlled by the -F [XSI]   or -f  option. Page headers shall be generated unless the -t option is specified, the -l option is specified
with too small a value (see OPTIONS), or the -m option is specified and all of the input files are empty. The page headers
shall be of the form:
"\n\n%s %s Page %d\n\n\n", , ,
In the POSIX locale, the  field shall be equivalent to the output of the following
command:
date "+%b %e %H:%M %Y"
without the trailing , as it would appear if executed at the current time if the -m option is specified,
or at the following time otherwise:
The current time on pages being written from standard input.
The modification time of the file named by the corresponding file operand on pages not being written from standard
input.
When the LC_TIME locale category is not set to the POSIX locale, a different format and order of presentation of this
field may be used.
If the -h option is specified, the  field shall be replaced by the header argument.
Otherwise:
If the -m option is specified, the  field shall be replaced by a null string on all pages.
If the -m option is not specified, the  field shall be replaced by a null string on pages containing
output that was read from standard input.
STDERR
The standard error shall be used for diagnostic messages and for alerting the terminal when -p is specified.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
A conforming application must protect its first operand, if it starts with a , by preceding it with the
"--" argument that denotes the end of the options. For example, pr+x could be interpreted as an invalid page
number or a file operand.
If a file operand contains , , or  characters, or is overly long, and
the pr utility is instructed to include the pathname of that file in the header, pagination may not be handled correctly.
Applications can guard against this by using the -h option (for example, passing a sanitized, truncated form of the pathname
with -h).
EXAMPLES
Print a numbered list of all files in the current directory:
ls -a | pr -n -h "Files in $(pwd)."
Print file1 and file2 as a double-spaced, three-column listing headed by "file list":
pr -3d -h "file list" file1 file2
Write file1 on file2, expanding tabs to columns 10, 19, 28, ...:
pr -e9 -t file2
RATIONALE
This utility is one of those that does not follow the Utility Syntax Guidelines because of its historical origins. The standard
developers could have added new options that obeyed the guidelines (and marked the old options obsolescent) or devised an entirely
new utility; there are examples of both actions in this volume of POSIX.1-2024. Because of its widespread use by historical
applications, the standard developers decided to exempt this version of pr from many of the guidelines.
Implementations are required to accept option-arguments to the -h, -l, -o, and -w options whether
presented as part of the same argument or as a separate argument to pr, as suggested by the Utility Syntax Guidelines. The
-n and -s options, however, are specified as in historical practice because they are frequently specified without
their optional arguments. If a  were allowed before the option-argument in these cases, a file operand could
mistakenly be interpreted as an option-argument in historical applications.
The text about the minimum number of lines in multi-column output was included to ensure that a best effort is made in balancing
the length of the columns. There are known historical implementations in which, for example, 60-line files are listed by pr
-2 as one column of 56 lines and a second of 4. Although this is not a problem when a full page with headers and trailers is
produced, it would be relatively useless when used with -t.
Historical implementations of the pr utility have differed in the action taken for the -f option. BSD uses it as
described here for the -F option; System V uses it to change trailing  characters on each page to a
and, if standard output is a TTY device, sends an  to standard error and reads a line from
/dev/tty before the first page. There were strong arguments from both sides of this issue concerning historical practice and
as a result the -F option was added. XSI-conformant systems support the System V historical actions for the -f
option.
The  field in the -l format is specified only for the POSIX locale. As noted, the
format can be different in other locales. No mechanism for defining this is present in this volume of POSIX.1-2024, as the
appropriate vehicle is a message catalog; that is, the format should be specified as a "message".
Some implementations of pr treat an empty file as an error when -m is not specified, but not when -m is
specified (even if there is only one input file). Implementations are encouraged to eliminate this inconsistency by never treating
an empty file as an error.
FUTURE DIRECTIONS
A future version of this standard may require that an empty file is never treated as an error.
SEE ALSO
expand, lp
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 2.
Issue 6
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
The -p option is added.
The normative text is reworded to avoid use of the term "must" for application requirements.
Issue 7
PASC Interpretation 1003.2-92 #151 (SD5-XCU-ERN-44) is applied.
Austin Group Interpretation 1003.1-2001 #093 is applied.
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
Issue 8
Austin Group Defect 251 is applied, adding a paragraph about problematic pathnames to the APPLICATION USAGE section.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
Austin Group Defect 1433 is applied, changing  to  in the description of the -p
option.
Austin Group Defect 1434 is applied, combining the two option groups in the SYNOPSIS into one.
Austin Group Defect 1590 is applied, clarifying the requirements when an input file is empty and changing the STDOUT
section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/bc.html =====
bc
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
bc — arbitrary-precision arithmetic language
SYNOPSIS
bc [-l] [file...]
DESCRIPTION
The bc utility shall implement an arbitrary precision calculator. It shall take input from any files given, then read
from the standard input. If the standard input and standard output to bc are attached to a terminal, the invocation of
bc shall be considered to be interactive, causing behavioral constraints described in the following sections.
OPTIONS
The bc utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following option shall be supported:
-l
(The letter ell.) Define the math functions and initialize scale to 20, instead of the default zero; see the EXTENDED
DESCRIPTION section.
OPERANDS
The following operand shall be supported:
file
A pathname of a text file containing bc program statements. After all files have been read, bc shall read
the standard input.
STDIN
See the INPUT FILES section.
INPUT FILES
Input files shall be text files containing a sequence of comments, statements, and function definitions that shall be executed
as they are read.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of bc:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
The output of the bc utility shall be controlled by the program read, and consist of zero or more lines containing the
value of all executed expressions without assignments. The radix and precision of the output shall be controlled by the values of
the obase and scale variables; see the EXTENDED DESCRIPTION section.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
Grammar
The grammar in this section and the lexical conventions in the following section shall together describe the syntax for
bc programs. The general conventions for this style of grammar are described in 1.3 Grammar Conventions. A valid program can be represented as the non-terminal
symbol program in the grammar. This formal syntax shall take precedence over the text syntax description.
%token    EOF NEWLINE STRING LETTER NUMBER
%token    MUL_OP
/*        '*', '/', '%'                           */
%token    ASSIGN_OP
/*        '=', '+=', '-=', '*=', '/=', '%=', '^=' */
%token    REL_OP
/*        '==', '=', '!=', ''        */
%token    INCR_DECR
/*        '++', '--'                              */
%token    Define    Break    Quit    Length
/*        'define', 'break', 'quit', 'length'     */
%token    Return    For    If    While    Sqrt
/*        'return', 'for', 'if', 'while', 'sqrt'  */
%token    Scale    Ibase    Obase    Auto
/*        'scale', 'ibase', 'obase', 'auto'       */
%start    program
%%
program              : EOF
| input_item program
;
input_item           : semicolon_list NEWLINE
| function
;
semicolon_list       : /* empty */
| statement
| semicolon_list ';' statement
| semicolon_list ';'
;
statement_list       : /* empty */
| statement
| statement_list NEWLINE
| statement_list NEWLINE statement
| statement_list ';'
| statement_list ';' statement
;
statement            : expression
| STRING
| Break
| Quit
| Return
| Return '(' return_expression ')'
| For '(' expression ';'
relational_expression ';'
expression ')' statement
| If '(' relational_expression ')' statement
| While '(' relational_expression ')' statement
| '{' statement_list '}'
;
function             : Define LETTER '(' opt_define_list ')'
'{' NEWLINE opt_auto_define_list
statement_list '}'
;
opt_define_list      : /* empty */
| define_list
;
opt_auto_define_list : /* empty */
| Auto define_list NEWLINE
| Auto define_list ';'
;
define_list          : LETTER
| LETTER '[' ']'
| define_list ',' LETTER
| define_list ',' LETTER '[' ']'
;
opt_argument_list    : /* empty */
| argument_list
;
argument_list        : expression
| expression ',' argument_list
| LETTER '[' ']'
| LETTER '[' ']' ',' argument_list
;
relational_expression : expression
| expression REL_OP expression
;
return_expression    : /* empty */
| expression
;
expression           : named_expression
| NUMBER
| '(' expression ')'
| LETTER '(' opt_argument_list ')'
| '-' expression
| expression '+' expression
| expression '-' expression
| expression MUL_OP expression
| expression '^' expression
| INCR_DECR named_expression
| named_expression INCR_DECR
| named_expression ASSIGN_OP expression
| Length '(' expression ')'
| Sqrt '(' expression ')'
| Scale '(' expression ')'
;
named_expression     : LETTER
| LETTER '[' expression ']'
| Scale
| Ibase
| Obase
;
Lexical Conventions in bc
The lexical conventions for bc programs, with respect to the preceding grammar, shall be as follows:
Except as noted, bc shall recognize the longest possible token or delimiter beginning at a given point.
A comment shall consist of any characters beginning with the two adjacent characters "/*" and terminated by the next
occurrence of the two adjacent characters "*/". Comments shall have no effect except to delimit lexical tokens.
The  shall be recognized as the token NEWLINE.
The token STRING shall represent a string constant; it shall consist of any characters beginning with the double-quote
character ('"' ) and terminated by another occurrence of the double-quote character. The value of the string is the
sequence of all characters between, but not including, the two double-quote characters. All characters shall be taken literally
from the input, and there is no way to specify a string containing a double-quote character. The length of the value of each string
shall be limited to {BC_STRING_MAX} bytes.
A  shall have no effect except as an ordinary character if it appears within a STRING token, or to delimit a
lexical token other than STRING.
The combination of a  character immediately followed by a  shall have no effect other than to
delimit lexical tokens with the following exceptions:
It shall be interpreted as the character sequence "\" in STRING tokens.
It shall be ignored as part of a multi-line NUMBER token.
The token NUMBER shall represent a numeric constant. It shall be recognized by the following grammar:
NUMBER  : integer
| '.' integer
| integer '.'
| integer '.' integer
;
integer : digit
| integer digit
;
digit   : 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7
| 8 | 9 | A | B | C | D | E | F
;
The value of a NUMBER token shall be interpreted as a numeral in the base specified by the value of the internal register
ibase (described below). Each of the digit characters shall have the value from 0 to 15 in the order listed here, and
the  character shall represent the radix point. The behavior is undefined if digits greater than or equal to the
value of ibase appear in the token. However, note the exception for single-digit values being assigned to ibase and
obase themselves, in Operations in bc.
The following keywords shall be recognized as tokens:
auto
break
define
ibase
if
for
length
obase
quit
return
scale
sqrt
while
Any of the following characters occurring anywhere except within a keyword shall be recognized as the token
LETTER:
a b c d e f g h i j k l m n o p q r s t u v w x y z
The following single-character and two-character sequences shall be recognized as the token ASSIGN_OP:
=   +=   -=   *=   /=   %=   ^=
If an '=' character, as the beginning of a token, is followed by a '-' character with no
intervening delimiter, the behavior is undefined.
The following single-characters shall be recognized as the token MUL_OP:
*   /   %
The following single-character and two-character sequences shall be recognized as the token REL_OP:
==   =   !=
The following two-character sequences shall be recognized as the token INCR_DECR:
++   --
The following single characters shall be recognized as tokens whose names are the character:
(  )  ,  +  -  ;  [  ]  ^  {  }
The token EOF is returned when the end of input is reached.
Operations in bc
There are three kinds of identifiers: ordinary identifiers, array identifiers, and function identifiers. All three
types consist of single lowercase letters. Array identifiers shall be followed by square brackets ("[]"). An array
subscript is required except in an argument or auto list. Arrays are singly dimensioned and can contain up to {BC_DIM_MAX}
elements. Indexing shall begin at zero so an array is indexed from 0 to {BC_DIM_MAX}-1. Subscripts shall be truncated to integers.
The application shall ensure that function identifiers are followed by parentheses, possibly enclosing arguments. The three types
of identifiers do not conflict.
The following table summarizes the rules for precedence and associativity of all operators. Operators on the same
line shall have the same precedence; rows are in order of decreasing precedence.
Table: Operators in bc
Operator
Associativity
++, --
N/A
unary -
N/A
^
Right to left
*, /, %
Left to right
+, binary -
Left to right
=, +=, -=, *=, /=, %=, ^=
Right to left
==, =, !=,
None
Each expression or named expression has a scale, which is the number of decimal digits that shall be
maintained as the fractional portion of the expression.
Named expressions are places where values are stored. Named expressions shall be valid on the left side of
an assignment. The value of a named expression shall be the value stored in the place named. Simple identifiers and array elements
are named expressions; they have an initial value of zero and an initial scale of zero.
The internal registers scale, ibase, and obase are all named expressions. The scale of an
expression consisting of the name of one of these registers shall be zero; values assigned to any of these registers are truncated
to integers. The scale register shall contain a global value used in computing the scale of expressions (as described
below). The value of the register scale is limited to 0  ('-') character shall be output.
One of the following is output, depending on the numerical value:
If the absolute value of the numerical value is greater than or equal to one, the integer portion of the value
shall be output as a series of digits appropriate to obase (as described below), most significant digit first. The most
significant non-zero digit shall be output next, followed by each successively less significant digit.
If the absolute value of the numerical value is less than one but greater than zero and the scale of the numerical
value is greater than zero, it is unspecified whether the character 0 is output.
If the numerical value is zero, the character 0 shall be output.
If the scale of the value is greater than zero and the numeric value is not zero, a  character shall
be output, followed by a series of digits appropriate to obase (as described below) representing the most significant
portion of the fractional part of the value. If s represents the scale of the value being output, the number of digits
output shall be s if obase is 10, less than or equal to s if obase is greater than 10, or greater than
or equal to s if obase is less than 10. For obase values other than 10, this should be the number of digits
needed to represent a precision of 10s.
For obase values from 2 to 16, valid digits are the first obase of the single characters:
0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
which represent the values zero to 15, inclusive, respectively.
For bases greater than 16, each digit shall be written as a separate multi-digit decimal number. Each digit except
the most significant fractional digit shall be preceded by a single . For bases from 17 to 100, bc shall write
two-digit decimal numbers; for bases from 101 to 1000, three-digit decimal strings, and so on. For example, the decimal number 1024
in base 25 would be written as:
Δ01Δ15Δ24
and in base 125, as:
Δ008Δ024
Very large numbers shall be split across lines with 70 characters per line in the POSIX locale; other locales may
split at different character boundaries. Lines that are continued shall end with a .
A function call shall consist of a function name followed by parentheses containing a -separated list
of expressions, which are the function arguments. A whole array passed as an argument shall be specified by the array name followed
by empty square brackets. All function arguments shall be passed by value. As a result, changes made to the formal parameters shall
have no effect on the actual arguments. If the function terminates by executing a return statement, the value of the
function shall be the value of the expression in the parentheses of the return statement or shall be zero if no expression
is provided or if there is no return statement.
The result of sqrt(expression) shall be the square root of the expression. The result shall be
truncated in the least significant decimal place. The scale of the result shall be the scale of the expression or the value of
scale, whichever is larger.
The result of length(expression) shall be the total number of significant decimal digits in the
expression. The scale of the result shall be zero.
The result of scale(expression) shall be the scale of the expression. The scale of the result shall
be zero.
A numeric constant shall be an expression. The scale shall be the number of digits that follow the radix point in
the input representing the constant, or zero if no radix point appears.
The sequence ( expression ) shall be an expression with the same value and scale as
expression. The parentheses can be used to alter the normal precedence.
The semantics of the unary and binary operators are as follows:
-expression
The result shall be the negative of the expression. The scale of the result shall be the scale of expression.
The unary increment and decrement operators shall not modify the scale of the named expression upon which they
operate. The scale of the result shall be the scale of that named expression.
++named-expression
The named expression shall be incremented by one. The result shall be the value of the named expression after incrementing.
--named-expression
The named expression shall be decremented by one. The result shall be the value of the named expression after decrementing.
named-expression++
The named expression shall be incremented by one. The result shall be the value of the named expression before incrementing.
named-expression--
The named expression shall be decremented by one. The result shall be the value of the named expression before decrementing.
The exponentiation operator,  ('^'), shall bind right to left.
expression^expression
The result shall be the first expression raised to the power of the second expression. If the second expression is
not an integer, the behavior is undefined. If a is the scale of the left expression and b is the absolute value of
the right expression, the scale of the result shall be:
if b >= 0 min(a * b, max(scale, a)) if b = expression
shall be equivalent to:
named-expression=named-expression  expression
except that the named-expression shall be evaluated only once.
Unlike all other operators, the relational operators ('', "=", "==", "!=") shall be only valid as the object of an if, while, or inside a
for statement.
expression1expression2
The relation shall be true if the value of expression1 is strictly greater than the value of expression2.
expression1=expression2
The relation shall be true if the value of expression1 is greater than or equal to the value of expression2.
expression1==expression2
The relation shall be true if the values of expression1 and expression2 are equal.
expression1!=expression2
The relation shall be true if the values of expression1 and expression2 are unequal.
There are only two storage classes in bc: global and automatic (local). Only identifiers that are local to a
function need be declared with the auto command. The arguments to a function shall be local to the function. All other
identifiers are assumed to be global and available to all functions. All identifiers, global and local, have initial values of
zero. Identifiers declared as auto shall be allocated on entry to the function and released on returning from the function. They
therefore do not retain values between function calls. Auto arrays shall be specified by the array name followed by empty square
brackets. On entry to a function, the old values of the names that appear as parameters and as automatic variables shall be pushed
onto a stack. Until the function returns, reference to these names shall refer only to the new values.
References to any of these names from other functions that are called from this function also refer to the new
value until one of those functions uses the same name for a local variable.
When a statement is an expression, unless the main operator is an assignment, execution of the statement shall
write the value of the expression followed by a .
When a statement is a string, execution of the statement shall write the value of the string.
Statements separated by  or  characters shall be executed sequentially. In an
interactive invocation of bc, each time a  is read that satisfies the grammatical production:
input_item : semicolon_list NEWLINE
the sequential list of statements making up the semicolon_list shall be executed immediately and any output
produced by that execution shall be written without any delay due to buffering.
In an if statement (if(relation) statement), the statement shall be executed if
the relation is true.
The while statement (while(relation) statement) implements a loop in which the
relation is tested; each time the relation is true, the statement shall be executed and the relation
retested. When the relation is false, execution shall resume after statement.
A for statement(for(expression; relation; expression) statement) shall be
the same as:
first-expression
while (relation) {
statement
last-expression
}
The application shall ensure that all three expressions are present.
The break statement shall cause termination of a for or while statement.
The auto statement (auto identifier [,identifier] ...) shall cause the
values of the identifiers to be pushed down. The identifiers can be ordinary identifiers or array identifiers. Array identifiers
shall be specified by following the array name by empty square brackets. The application shall ensure that the auto
statement is the first statement in a function definition.
A define statement:
define LETTER ( opt_define_list ) {
opt_auto_define_list
statement_list
}
defines a function named LETTER. If a function named LETTER was previously defined, the define
statement shall replace the previous definition. The expression:
LETTER ( opt_argument_list )
shall invoke the function named LETTER. The behavior is undefined if the number of arguments in the
invocation does not match the number of parameters in the definition. Functions shall be defined before they are invoked. A
function shall be considered to be defined within its own body, so recursive calls are valid. The values of numeric constants
within a function shall be interpreted in the base specified by the value of the ibase register when the function is
invoked.
The return statements (return and return(expression)) shall cause termination of a
function, popping of its auto variables, and specification of the result of the function. The first form shall be equivalent to
return(0). The value and scale of the result returned by the function shall be the value and scale of the expression
returned.
The quit statement (quit) shall stop execution of a bc program at the point where the
statement occurs in the input, even if it occurs in a function definition, or in an if, for, or while
statement.
The following functions shall be defined when the -l option is specified:
s( expression )
Sine of argument in radians.
c( expression )
Cosine of argument in radians.
a( expression )
Arctangent of argument.
l( expression )
Natural logarithm of argument.
e( expression )
Exponential function of argument.
j( expression1, expression2 )
Bessel function of expression2 of the first kind of integer order expression1.
The scale of the result returned by these functions shall be the value of the scale register at the time the
function is invoked. The value of the scale register after these functions have completed their execution shall be the same
value it had upon invocation. The behavior is undefined if any of these functions is invoked with an argument outside the domain of
the mathematical function.
EXIT STATUS
The following exit values shall be returned:
0
All input files were processed successfully.
unspecified
An error occurred.
CONSEQUENCES OF ERRORS
If any file operand is specified and the named file cannot be accessed, bc shall write a diagnostic message to
standard error and terminate without any further action.
In an interactive invocation of bc, the utility should print an error message and recover following any
error in the input. In a non-interactive invocation of bc, invalid input causes undefined behavior.
The following sections are informative.
APPLICATION USAGE
Automatic variables in bc do not work in exactly the same way as in either C or PL/1.
For historical reasons, the exit status from bc cannot be relied upon to indicate that an error has
occurred. Returning zero after an error is possible. Therefore, bc should be used primarily by interactive users (who can
react to error messages) or by application programs that can somehow validate the answers returned as not including error
messages.
The bc utility always uses the  ('.') character to represent a radix point,
regardless of any decimal-point character specified as part of the current locale. In languages like C or awk, the  character is used in program source, so it can be portable and
unambiguous, while the locale-specific character is used in input and output. Because there is no distinction between source and
input in bc, this arrangement would not be possible. Using the locale-specific character in bc's input would
introduce ambiguities into the language; consider the following example in a locale with a  as the decimal-point
character:
define f(a,b) {
...
}
...
f(1,2,3)
Because of such ambiguities, the  character is used in input. Having input follow different
conventions from output would be confusing in either pipeline usage or interactive usage, so the  is also used in
output.
EXAMPLES
In the shell, the following assigns an approximation of the first ten digits of 'ℼ' to the variable x:
x=$(printf "%s\n" 'scale = 10; 104348/33215' | bc)
The following bc program prints the same approximation of 'ℼ', with a label, to standard
output:
scale = 10
"pi equals "
104348 / 33215
The following defines a function to compute an approximate value of the exponential function (note that such a
function is predefined if the -l option is specified):
scale = 20
define e(x){
auto a, b, c, i, s
a = 1
b = 1
s = 1
for (i = 1; 1 == 1; i++){
a = a*x
b = b*i
c = a/b
if (c == 0) {
return(s)
}
s = s+c
}
}
The following prints approximate values of the exponential function of the first ten integers:
for (i = 1; i  characters. Since  characters between tokens are not visible at the syntactic level, it is not
possible to recognize the multi-digit "digits" used in the higher bases properly. The ability to recognize input in these bases
was not considered useful enough to require modifying these implementations. Note that the recognition of numeric constants at the
syntactic level is not a problem with conformance to this volume of POSIX.1-2024, as it does not impact the behavior of conforming
applications (and correct bc programs). Historical implementations also accept input with all of the digits
'0'-'9' and 'A'-'F' regardless of the value of ibase; since digits with value greater
than or equal to ibase are not really appropriate, the behavior when they appear is undefined, except for the common case
of:
ibase=8;
/* Process in octal base. */
...
ibase=A
/* Restore decimal base. */
In some historical implementations, if the expression to be written is an uninitialized array element, a leading
and/or up to four leading 0 characters may be output before the character zero. This behavior is considered a bug; it
is unlikely that any currently conforming application relies on:
echo 'b[3]' | bc
returning 00000 rather than 0.
Exact calculation of the number of fractional digits to output for a given value in a base other than 10 can be
computationally expensive. Historical implementations use a faster approximation, and this is permitted. Note that the requirements
apply only to values of obase that this volume of POSIX.1-2024 requires implementations to support (in particular, not to 1,
0, or negative bases, if an implementation supports them as an extension).
Historical implementations of bc did not allow array parameters to be passed as the last parameter to a
function. When bc was first standardized in Issue 4, this restriction was allowed. To make bc more widely useful, and
because there are implementations without this restriction, the allowance for the restriction has been removed.
FUTURE DIRECTIONS
None.
SEE ALSO
1.3 Grammar Conventions, awk
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 4.
Issue 5
The FUTURE DIRECTIONS section is added.
Issue 6
Updated to align with the IEEE P1003.2b draft standard, which included resolution of several interpretations of the
ISO POSIX-2:1993 standard.
The normative text is reworded to avoid use of the term "must" for application requirements.
Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0066 [584] and XCU/TC2-2008/0067 [679] are applied.
Issue 8
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
Austin Group Defect 1230 is applied, changing the EXTENDED DESCRIPTION section to specify that array parameters can
be passed as the last parameter to a function.
Austin Group Defect 1570 is applied, removing extra spacing in "==".
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/kill.html =====
kill
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
kill — terminate or signal processes
SYNOPSIS
kill [-s signal_name] pid...
kill -l [exit_status]
[XSI]  kill [-signal_name] pid...
kill [-signal_number] pid...
DESCRIPTION
The kill utility shall send a signal to the process or processes specified by each pid operand.
For each pid operand, the kill utility shall perform actions equivalent to the kill() function defined in the System Interfaces volume of POSIX.1-2024 called with the
following arguments:
The value of the pid operand shall be used as the pid argument.
The sig argument is the value specified by the -s option, -signal_number option, or the
-signal_name option, or by SIGTERM, if none of these options is specified.
OPTIONS
The kill utility shall conform to XBD 12.2 Utility Syntax
Guidelines, [XSI]   except that in the last two SYNOPSIS forms, the -signal_number and
-signal_name options are usually more than a single character.
The following options shall be supported:
-l
(The letter ell.) Write all values of signal_name supported by the implementation, if no operand is given. If an
exit_status operand is given and it is a value of the '?' shell special parameter (see 2.5.2 Special Parameters and wait) corresponding to a process that was terminated or stopped by a signal, the
signal_name corresponding to the signal that terminated or stopped the process shall be written. If an exit_status
operand is given and it is the unsigned decimal integer value of a signal number, the signal_name (the symbolic constant
name without the SIG prefix defined in the Base Definitions volume of POSIX.1-2024) corresponding to that signal shall be
written. Otherwise, the results are unspecified.
-s signal_name
Specify the signal to send, using one of the symbolic names defined in the  header. Values of signal_name shall be recognized in a
case-independent fashion, without the SIG prefix. In addition, the symbolic name 0 shall be recognized, representing the
signal value zero. The corresponding signal shall be sent instead of SIGTERM.
-signal_name
[XSI]
Equivalent to -s signal_name.
-signal_number
[XSI]
Specify a non-negative decimal integer, signal_number, representing the signal to be used instead of SIGTERM, as the
sig argument in the effective call to kill(). The correspondence between integer
values and the sig value used is shown in the following list.
The effects of specifying any signal_number other than those listed below are undefined.
0
0
1
SIGHUP
2
SIGINT
3
SIGQUIT
6
SIGABRT
9
SIGKILL
14
SIGALRM
15
SIGTERM
If the first argument is a negative integer, it shall be interpreted as a -signal_number option, not as a negative
pid operand specifying a process group.
OPERANDS
The following operands shall be supported:
pid
One of the following:
A decimal integer specifying a process or process group to be signaled. The process or processes selected by positive, negative,
and zero values of the pid operand shall be as described for the kill()
function. If process number 0 is specified, all processes in the current process group shall be signaled. For the effects of
negative pid numbers, see the kill() function defined in the System Interfaces
volume of POSIX.1-2024. If the first pid operand is negative, it should be preceded by "--" to keep it from being
interpreted as an option.
A job ID (see XBD 3.182 Job ID) that identifies a process group in
the case of a job-control background job, or a process ID in the case of a non-job-control background job (if supported), to be
signaled. The job ID notation is applicable only for invocations of kill in the current shell execution environment; see
2.13 Shell Execution Environment.
Note:
The job ID type of pid is only available on systems supporting the User Portability Utilities option or supporting
non-job-control background jobs.
exit_status
A decimal integer specifying a signal number or the exit status of a process terminated by a signal.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of kill:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
When the -l option is not specified, the standard output shall not be used.
When the -l option is specified, the symbolic name of each signal shall be written in the following format:
"%s%c", ,
where the  is in uppercase, without the SIG prefix, and the  shall be
either a  or a . For the last signal written,  shall be a .
When both the -l option and exit_status operand are specified, the symbolic name of the corresponding signal shall
be written in the following format:
"%s\n",
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
The -l option was specified and the output specified in STDOUT was successfully written to standard output; or, the
-l option was not specified, at least one matching process was found for each pid operand, and the specified signal
was successfully processed for at least one matching process.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
This utility is required to be intrinsic. See 1.7 Intrinsic Utilities
for details.
Process numbers can be found by using ps.
The use of job ID notation is not dependent on job control being enabled. When job control has been disabled using set +m, kill can still be used to signal the process group associated with a
job-control background job, or the process ID associated with a non-control background job (if supported), using
kill %
See also the RATIONALE for jobs and wait.
The job ID notation is not required to work as expected when kill is operating in its own utility execution environment.
In either of the following examples:
nohup kill %1 &
system("kill %1");
the kill operates in a different environment and does not share the shell's understanding of job numbers.
EXAMPLES
Any of the commands:
kill -9 100 -165
kill -s kill 100 -165
kill -s KILL 100 -165
sends the SIGKILL signal to the process whose process ID is 100 and to all processes whose process group ID is 165, assuming the
sending process has permission to send that signal to the specified processes, and that they exist.
The System Interfaces volume of POSIX.1-2024 and this volume of POSIX.1-2024 do not require specific signal numbers for any
signal_names. Even the -signal_number option provides symbolic (although numeric) names for signals. If a
process is terminated by a signal, its exit status indicates the signal that killed it, but the exact values are not specified. The
kill -l option, however, can be used to map decimal signal numbers and exit status values into the name of a signal.
The following example reports the status of a terminated job:
job
stat=$?
if [ $stat -eq 0 ]
then
echo job completed successfully.
elif [ $stat -gt 128 ]
then
echo job terminated by signal SIG$(kill -l $stat).
else
echo job terminated with error code $stat.
fi
To send the default signal to a process group (say 123), an application should use a command similar to one of the
following:
kill -s TERM -- -123
kill -- -123
RATIONALE
The -l option originated from the C shell, and is also implemented in the KornShell. The C shell output can consist of
multiple output lines because the signal names do not always fit on a single line on some terminal screens. The KornShell output
also included the implementation-defined signal numbers and was considered by the standard developers to be too difficult for
scripts to parse conveniently. The specified output format is intended not only to accommodate the historical C shell output, but
also to permit an entirely vertical or entirely horizontal listing on systems for which this is appropriate.
An early proposal invented the name SIGNULL as a signal_name for signal 0 (used by the System Interfaces volume of
POSIX.1-2024 to test for the existence of a process without sending it a signal). Since the signal_name 0 can be used in
this case unambiguously, SIGNULL has been removed.
An early proposal also required symbolic signal_names to be recognized with or without the SIG prefix. Historical
versions of kill have not written the SIG prefix for the -l option and have not recognized the SIG
prefix on signal_names. Since neither applications portability nor ease-of-use would be improved by requiring this
extension, it is no longer required.
To avoid an ambiguity of an initial negative number argument specifying either a signal number or a process group, POSIX.1-2024
mandates that it is always considered the former by implementations that support the XSI option. It also requires that conforming
applications always use the "--" options terminator argument when specifying a process group.
The -s option was added in response to international interest in providing some form of kill that meets the
Utility Syntax Guidelines.
The job ID notation is not required to work as expected when kill is operating in its own utility execution environment.
In either of the following examples:
nohup kill %1 &
system("kill %1");
the kill operates in a different environment and does not understand how the shell has managed its job numbers.
FUTURE DIRECTIONS
None.
SEE ALSO
2. Shell Command Language, ps, wait
XBD 3.182 Job ID, 8.
Environment Variables, 12.2 Utility Syntax Guidelines,
XSH kill()
CHANGE HISTORY
First released in Issue 2.
Issue 6
The obsolescent versions of the SYNOPSIS are turned into non-obsolescent features of the XSI option, corresponding to a similar
change in the trap special built-in.
Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
Issue 8
Austin Group Defect 854 is applied, adding a note to the APPLICATION USAGE section that this utility is required to be
intrinsic.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
Austin Group Defect 1254 is applied, clarifying the -l option with regard to an exit_status operand corresponding
to a stopped process, changing "job control job ID" to "job ID", and adding a paragraph to the RATIONALE section.
Austin Group Defect 1260 is applied, changing the SYNOPSIS and EXAMPLES sections in relation to the -s option, and the
RATIONALE section in relation to the use of "--" when specifying a process group.
Austin Group Defect 1504 is applied, changing the EXIT STATUS section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/uucp.html =====
uucp
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
uucp — system-to-system copy
SYNOPSIS
[UU]  uucp [-cCdfjmr] [-n user]
source-file... destination-file
DESCRIPTION
The uucp utility shall copy files named by the source-file argument to the destination-file argument. The
files named can be on local or remote systems.
The uucp utility cannot guarantee support for all character encodings in all circumstances. For example, transmission
data may be restricted to 7 bits by the underlying network, 8-bit data and filenames need not be portable to non-internationalized
systems, and so on. Under these circumstances, it is recommended that only characters defined in the ISO/IEC 646:1991 standard
International Reference Version (equivalent to ASCII) 7-bit range of characters be used, and that only characters defined in the
portable filename character set be used for naming files. The protocol for transfer of files is unspecified by POSIX.1-2024.
Typical implementations of this utility require a communications line configured to use XBD 11. General Terminal Interface, but other communications means may be used. On
systems where there are no available communications means (either temporarily or permanently), this utility shall write an error
message describing the problem and exit with a non-zero exit status.
OPTIONS
The uucp utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following options shall be supported:
-c
Do not copy local file to the spool directory for transfer to the remote machine (default).
-C
Force the copy of local files to the spool directory for transfer.
-d
Make all necessary directories for the file copy (default).
-f
Do not make intermediate directories for the file copy.
-j
Write the job identification string to standard output. This job identification can be used by uustat to obtain the status or terminate a job.
-m
Send mail to the requester when the copy is completed.
-n user
Notify user on the remote system that a file was sent.
-r
Do not start the file transfer; just queue the job.
OPERANDS
The following operands shall be supported:
destination-file, source-file
A pathname of a file to be copied to, or from, respectively. Either name can be a pathname on the local machine, or can have the
form:
system-name!pathname
where system-name is taken from a list of system names that uucp knows about. The destination system-name
can also be a list of names such as:
system-name!system-name!...!system-name!pathname
in which case, an attempt is made to send the file via the specified route to the destination. Care should be taken to ensure
that intermediate nodes in the route are willing to forward information.
The shell pattern matching notation characters '?', '*', and "[...]" appearing in pathname
shall be expanded on the appropriate system.
Pathnames can be one of:
An absolute pathname.
A pathname preceded by ~user where user is a login name on the specified system and is replaced by that user's
login directory. Note that if an invalid login is specified, the default is to the public directory (called PUBDIR; the
actual location of PUBDIR is implementation-defined).
A pathname preceded by ~/destination where destination is appended to PUBDIR.
Note:
This destination is treated as a filename unless more than one file is being transferred by this request or the destination is
already a directory. To ensure that it is a directory, follow the destination with a '/'. For example, ~/dan/ as
the destination makes the directory PUBDIR/dan if it does not exist and puts the requested files in that directory.
Anything else shall be prefixed by the current directory.
If the result is an erroneous pathname for the remote system, the copy shall fail. If the destination-file is a
directory, the last part of the source-file name shall be used.
The read, write, and execute permissions given by uucp are implementation-defined.
STDIN
Not used.
INPUT FILES
The files to be copied are regular files.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of uucp:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_COLLATE
Determine the locale for the behavior of ranges, equivalence classes, and multi-character collating elements within bracketed
filename patterns.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files) and the behavior of character classes within bracketed filename
patterns (for example, "'[[:lower:]]*'").
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error, and
informative messages written to standard output.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
Not used.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
The output files (which may be on other systems) are copies of the input files.
If -m is used, mail files are modified.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
This utility is part of the UUCP Utilities option and need not be supported by all implementations.
The domain of remotely accessible files can (and for obvious security reasons usually should) be severely restricted.
Note that the '!' character in addresses has to be escaped when using csh as a command interpreter because of
its history substitution syntax. For ksh and sh the escape is not necessary, but
may be used.
As noted above, shell metacharacters appearing in pathnames are expanded on the appropriate system. On an internationalized
system, this is done under the control of local settings of LC_COLLATE and LC_CTYPE . Thus, care should be taken when
using bracketed filename patterns, as collation and typing rules may vary from one system to another. Also be aware that certain
types of expression (that is, equivalence classes, character classes, and collating symbols) need not be supported on
non-internationalized systems.
EXAMPLES
None.
RATIONALE
None.
FUTURE DIRECTIONS
If this utility is directed to create a new directory entry that contains any bytes that have the encoded value of a
character, implementations are encouraged to treat this as an error. A future version of this standard may require
implementations to treat this as an error.
SEE ALSO
mailx, uuencode, uustat, uux
XBD 8. Environment Variables, 11. General Terminal Interface, 12.2 Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 2.
Issue 6
The LC_TIME and TZ entries are removed from the ENVIRONMENT VARIABLES section.
The UN margin codes and associated shading are removed from the -C, -f, -j, -n, and -r
options in response to The Open Group Base Resolution bwg2001-003.
Issue 7
SD5-XCU-ERN-46 is applied, moving this utility to the UUCP Utilities Option Group.
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to disallow the creation of filenames containing any bytes that
have the encoded value of a  character.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
Austin Group Defect 1516 is applied, adding XSI shading to text relating to NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/nl.html =====
nl
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
nl — line numbering filter
SYNOPSIS
[XSI]  nl [-p] [-b type] [-d delim]
[-f type] [-h type] [-i incr] [-l
num]        [-n format] [-s
sep] [-v startnum] [-w width] [file]
DESCRIPTION
The nl utility shall read lines from the named file or the standard input if no file is named and shall
reproduce the lines to standard output. Lines shall be numbered on the left. Additional functionality may be provided in accordance
with the command options in effect.
The nl utility views the text it reads in terms of logical pages. Line numbering shall be reset at the start of each
logical page. A logical page consists of a header, a body, and a footer section. Empty sections are valid. Different line numbering
options are independently available for header, body, and footer (for example, no numbering of header and footer lines while
numbering blank lines only in the body).
The starts of logical page sections shall be signaled by input lines containing nothing but the following delimiter
characters:
Line
Start of
\:\:\:
Header
\:\:
Body
\:
Footer
Unless otherwise specified, nl shall assume the text being read is in a single logical page body.
OPTIONS
The nl utility shall conform to XBD 12.2 Utility Syntax
Guidelines. Only one file can be named.
The following options shall be supported:
-b type
Specify which logical page body lines shall be numbered. Recognized types and their meaning are:
a
Number all lines.
t
Number only non-empty lines.
n
No line numbering.
pstring
Number only lines that contain the basic regular expression specified in string.
The default type for logical page body shall be t (text lines numbered).
-d delim
Specify the delimiter characters that indicate the start of a logical page section. These can be changed from the default
characters "\:" to two user-specified characters. If only one character is entered, the second character shall remain the
default character ':'.
-f type
Specify the same as b type except for footer. The default for logical page footer shall be n (no lines
numbered).
-h type
Specify the same as b type except for header. The default type for logical page header shall be n
(no lines numbered).
-i incr
Specify the increment value used to number logical page lines. The default shall be 1.
-l num
Specify the number of blank lines to be considered as one. For example, -l 2 results in only the second adjacent
blank line being numbered (if the appropriate -h a, -b a, or -f a option is set). The default
shall be 1.
-n format
Specify the line numbering format. Recognized values are: ln, left justified, leading zeros suppressed; rn, right
justified, leading zeros suppressed; rz, right justified, leading zeros kept. The default format shall be rn
(right justified).
-p
Specify that numbering should not be restarted at logical page delimiters.
-s sep
Specify the characters used in separating the line number and the corresponding text line. The default sep shall be a
.
-v startnum
Specify the initial value used to number logical page lines. The default shall be 1.
-w width
Specify the number of characters to be used for the line number. The default width shall be 6.
OPERANDS
The following operand shall be supported:
file
A pathname of a text file to be line-numbered.
STDIN
The standard input shall be used if no file operand is specified, and shall be used if the file operand is
'-' and the implementation treats the '-' as meaning standard input. Otherwise, the standard input shall not be
used. See the INPUT FILES section.
INPUT FILES
The input file shall be a text file.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of nl:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_COLLATE
Determine the locale for the behavior of ranges, equivalence classes, and multi-character collating elements within regular
expressions.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files), the behavior of character classes within regular expressions, and
for deciding which characters are in character class graph (for the -b t, -f t, and -h t
options).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
The standard output shall be a text file in the following format:
"%s%s%s", , ,
where  is one of the following numeric formats:
%6d
When the rn format is used (the default; see -n).
%06d
When the rz format is used.
%-6d
When the ln format is used.
When line numbers are suppressed for a portion of the page; the  is also suppressed.
In the preceding list, the number 6 is the default width; the -w option can change this value.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
In using the -d delim option, care should be taken to escape characters that have special meaning to the command
interpreter.
EXAMPLES
The command:
nl -v 10 -i 10 -d \!+ file1
numbers file1 starting at line number 10 with an increment of 10. The logical page delimiter is
"!+". Note that the '!' has to be escaped when using csh as a command interpreter because of its history
substitution syntax. For ksh and sh the escape is not necessary, but does not do
any harm.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
pr
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 2.
Issue 5
The option [-f type] is added to the SYNOPSIS. The option descriptions are presented in alphabetic order. The
description of -bt is changed to "Number only non-empty lines".
Issue 6
The obsolescent behavior allowing the options to be intermingled with the optional file operand is removed.
Issue 7
Austin Group Interpretation 1003.1-2001 #092 is applied.
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
Issue 8
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/echo.html =====
echo
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
echo — write arguments to standard output
SYNOPSIS
echo [string...]
DESCRIPTION
The echo utility writes its arguments to standard output, followed by a . If there are no arguments, only
the  is written.
OPTIONS
The echo utility shall not recognize the "--" argument in the manner specified by Guideline 10 of XBD 12.2 Utility Syntax Guidelines; "--" shall be recognized as a string
operand.
Implementations shall not support any options.
OPERANDS
The following operands shall be supported:
string
A string to be written to standard output. If the first operand consists of a '-' followed by one or more characters
from the set {'e', 'E', 'n'}, or if any of the operands contain a  character, the
results are implementation-defined.
[XSI]
On XSI-conformant systems, if the first operand consists of a '-' followed by one or more characters from the set
{'e', 'E', 'n'}, it shall be treated as a string to be written. The following character sequences shall
be recognized on XSI-conformant systems within any of the arguments:
\a
Write an .
\b
Write a .
\c
Suppress the  that otherwise follows the final argument in the output. All characters following the
'\c' in the arguments shall be ignored.
\f
Write a .
\n
Write a .
\r
Write a .
\t
Write a .
\v
Write a .
\\
Write a  character.
\0num
Write an 8-bit value that is the zero, one, two, or three-digit octal number num.
STDIN
Not used.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of echo:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
[XSI]
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as opposed
to multi-byte characters in arguments).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
The echo utility arguments shall be separated by single  characters and a  character shall
follow the last argument. [XSI]   Output transformations shall occur based on the escape sequences in the input. See the OPERANDS
section.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
It is not possible to use echo portably across all POSIX systems unless escape sequences are omitted, and the first
argument does not consist of a '-' followed by one or more characters from the set {'e', 'E',
'n'}.
The printf utility can be used portably to emulate any of the traditional
behaviors of the echo utility as follows (assuming that IFS has its standard value or is unset):
The historic System V echo and the requirements on XSI implementations in this volume of POSIX.1-2024 are equivalent
to:
printf "%b\n" "$*"
The BSD echo is equivalent to:
if [ "X$1" = "X-n" ]
then
shift
printf "%s" "$*"
else
printf "%s\n" "$*"
fi
New applications are encouraged to use printf instead of echo.
EXAMPLES
None.
RATIONALE
The echo utility has not been made obsolescent because of its extremely widespread use in historical applications.
Conforming applications that wish to do prompting without  characters or that could possibly be expecting to echo a
string consisting of a '-' followed by one or more characters from the set {'e', 'E', 'n'}
should use the printf utility.
At the time that the IEEE Std 1003.2-1992 standard was being developed, the two different historical versions of
echo that were considered for standardization varied in incompatible ways.
The BSD echo checked the first argument for the string -n which caused it to suppress the  that
would otherwise follow the final argument in the output.
The System V echo treated all arguments as strings to be written, but allowed escape sequences within them, as described
for XSI implementations in the OPERANDS section, including \c to suppress a trailing .
Thus the IEEE Std 1003.2-1992 standard said that the behavior was implementation-defined if the first operand is
-n or if any of the operands contain a  character. It also specified that the echo utility does not
support Utility Syntax Guideline 10 because historical applications depended on echo to echo all of its arguments,
except for the -n first argument in the BSD version.
The Single UNIX Specification, Version 1 required the System V behavior, and this became the XSI requirement when Version 2 and
POSIX.2 were merged with POSIX.1 to form the joint IEEE Std 1003.1-2001 / Single UNIX Specification, Version 3
standard.
This standard now treats a first operand of -e or -E the same as -n in recognition that support for them
has become more widespread in non-XSI implementations. Where supported, -e enables processing of escape sequences in the
remaining operands (in situations where it is disabled by default), and -E disables it (in situations where it is enabled by
default). A first operand containing a combination of these three letters, in the same manner as option grouping, also results in
implementation-defined behavior.
FUTURE DIRECTIONS
None.
SEE ALSO
printf
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 2.
Issue 5
In the OPTIONS section, the last sentence is changed to indicate that implementations "do not" support any options; in the
previous issue this said "need not".
Issue 6
The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:
A set of character sequences is defined as string operands.
LC_CTYPE is added to the list of environment variables affecting echo.
In the OPTIONS section, implementations shall not support any options.
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/21 is applied, so that the echo utility can accommodate
historical BSD behavior.
Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
Issue 8
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
Austin Group Defect 1222 is applied, making the results implementation-defined, on systems that are not XSI-conformant, if the
first operand consists of a '-' followed by one or more characters from the set {'e', 'E',
'n'}.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/ed.html =====
ed
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
ed — edit text
SYNOPSIS
ed [-p string] [-s] [file]
DESCRIPTION
The ed utility is a line-oriented text editor that uses two modes: command mode and input mode. In command
mode the input characters shall be interpreted as commands, and in input mode they shall be interpreted as text. See the EXTENDED
DESCRIPTION section.
If an operand is '-', the results are unspecified.
OPTIONS
The ed utility shall conform to XBD 12.2 Utility Syntax
Guidelines, except for the unspecified usage of '-'.
The following options shall be supported:
-p string
Use string as the prompt string when in command mode. By default, there shall be no prompt string.
-s
Suppress the writing of byte counts by e, E, r, and w commands and of the '!' prompt after
a !command.
OPERANDS
The following operand shall be supported:
file
If the file argument is given, ed shall perform the effect of an e command on the pathname file
before accepting commands from the standard input, except that file can contain a , even though this is not
possible for the argument to the e command.
STDIN
The standard input shall be a text file consisting of commands, as described in the EXTENDED DESCRIPTION section.
INPUT FILES
The input files shall be text files.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of ed:
HOME
Determine the pathname of the user's home directory.
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_COLLATE
Determine the locale for the behavior of ranges, equivalence classes, and multi-character collating elements within regular
expressions.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files) and the behavior of character classes within regular
expressions.
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error and
informative messages written to standard output.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
The ed utility shall take the standard action for all signals (see the ASYNCHRONOUS EVENTS section in 1.4 Utility Description Defaults) with the following exceptions:
SIGINT
The ed utility shall interrupt its current activity, write the string "?\n" to standard output, and return to
command mode (see the EXTENDED DESCRIPTION section).
SIGHUP
If the buffer is not empty and the buffer change flag is currently set to either changed or changed-and-warned
(see the EXTENDED DESCRIPTION section), the ed utility shall attempt to write a copy of the buffer in a file. First, the
file named ed.hup in the current directory shall be used; if that fails, the file named ed.hup in the directory named
by the HOME environment variable shall be used. In any case, the ed utility shall exit without writing the file to
the currently remembered pathname and without returning to command mode.
SIGQUIT
The ed utility shall ignore this event.
STDOUT
Various editing commands and the prompting feature (see -p) write to standard output, as described in the EXTENDED
DESCRIPTION section.
STDERR
The standard error shall be used for diagnostic messages and may be used for warning messages.
OUTPUT FILES
The output files shall be text files whose formats are dependent on the editing commands given.
EXTENDED DESCRIPTION
The ed utility shall operate on a copy of the file it is editing; changes made to the copy shall have no effect on the
file until a w (write) command is given. The copy of the text is called the buffer. The ed utility shall keep
track of whether the buffer has been modified. This shall be maintained as if via a tri-state internal flag with the state values
unchanged, changed, and changed-and-warned, which is:
Initially set to unchanged
Set to changed by any command that modifies the buffer
Set to unchanged by an e or E command that reloads (or empties) the buffer, or a w command that
writes the entire buffer
Set to either changed-and-warned or unchanged by an e or q command that warns an attempt was made to
destroy the editor buffer
A command that makes changes to the buffer in such a way that its contents are the same after the command (for example
s/a/a/) shall be considered to have modified the buffer, unless explicitly stated otherwise. In the remainder of the
description, this flag is referred to as the buffer change flag.
Commands to ed have a simple and regular structure: zero, one, or two addresses followed by a single-character
command, possibly followed by parameters to that command. These addresses specify one or more lines in the buffer. Every
command that requires addresses has default addresses, so that the addresses very often can be omitted. If the -p option is
specified, the prompt string shall be written to standard output before each command is read.
In general, only one command can appear on a line. Certain commands allow text to be input. This text is placed in the
appropriate place in the buffer. While ed is accepting text, it is said to be in input mode. In this mode, no
commands shall be recognized; all input is merely collected. Input mode is terminated by entering a line consisting of two
characters: a  ('.') followed by a . This line is not considered part of the input text.
Regular Expressions in ed
The ed utility shall support basic regular expressions, as described in XBD 9.3 Basic Regular Expressions. Since regular expressions in ed are always
matched against single lines (excluding the terminating  characters), never against any larger section of text,
there is no way for a regular expression to match a .
A null RE shall be equivalent to the last RE encountered.
Regular expressions are used in addresses to specify lines, and in some commands (for example, the s substitute command)
to specify portions of a line to be substituted.
The start and end of a regular expression (RE) are marked by a delimiter character (although in some circumstances the end
delimiter can be omitted). In addresses, the delimiter is either  or . In commands, other
characters can be used as the delimiter, as specified in the description of the command. Within the RE (as an ed extension
to the BRE syntax), the delimiter shall not terminate the RE if it is the second character of an escape sequence (see XBD 9.1 Regular Expression Definitions) and the escaped delimiter shall be treated
as that literal character in the RE (losing any special meaning it would have had if it was not used as the delimiter and was not
escaped). In addition, the delimiter character shall not terminate the RE when it appears within a bracket expression, and shall
have its normal meaning in the bracket expression. For example, the command "g%[%]%p" is equivalent to "g/[%]/p",
and the command "s-[0-9]--g" is equivalent to "s/[0-9]//g".
Addresses in ed
Addressing in ed relates to the current line. Generally, the current line is the last line affected by a command. The
current line number is the address of the current line. If the edit buffer is not empty, the initial value for the current line
shall be the last line in the edit buffer; otherwise, zero.
Addresses shall be constructed as follows:
The  character ('.') shall address the current line.
The  character ('$') shall address the last line of the edit buffer.
The positive decimal number n shall address the nth line of the edit buffer.
The -x character pair ("'x") shall address the line marked with the mark name character x,
which shall be a lowercase letter from the portable character set. It shall be an error if the character has not been set to mark a
line or if the line that was marked is not currently present in the edit buffer.
A BRE enclosed by  characters ('/') shall address the first line found by searching forwards from the line
following the current line toward the end of the edit buffer and stopping at the first line for which the line excluding the
terminating  matches the BRE. The BRE consisting of a null BRE delimited by a pair of  characters shall
address the next line for which the line excluding the terminating  matches the last BRE encountered. In addition,
the second  can be omitted at the end of a command line. Within the BRE, a - pair
("\/") shall represent a literal  instead of the BRE delimiter. If necessary, the search shall wrap around to
the beginning of the buffer and continue up to and including the current line, so that the entire buffer is searched.
A BRE enclosed by  characters ('?') shall address the first line found by searching backwards from
the line preceding the current line toward the beginning of the edit buffer and stopping at the first line for which the line
excluding the terminating  matches the BRE. The BRE consisting of a null BRE delimited by a pair of
characters ("??") shall address the previous line for which the line excluding the terminating
matches the last BRE encountered. In addition, the second  can be omitted at the end of a
command line. Within the BRE, a - pair ("\?") shall represent a literal
instead of the BRE delimiter. If necessary, the search shall wrap around to the end of the buffer and
continue up to and including the current line, so that the entire buffer is searched.
A  ('+') or  character ('-') followed by a decimal number shall address
the current line plus or minus the number. A  or  character not followed by a decimal number
shall address the current line plus or minus 1.
Addresses can be followed by zero or more address offsets, optionally -separated. Address offsets are constructed
as follows:
A  or  character followed by a decimal number shall add or subtract, respectively, the
indicated number of lines to or from the address. A  or  character not followed by a decimal
number shall add or subtract 1 to or from the address.
A decimal number shall add the indicated number of lines to the address.
It shall not be an error for an intermediate address value to be less than zero or greater than the last line in the edit
buffer. It shall be an error for the final address value to be less than zero or greater than the last line in the edit buffer. It
shall be an error if a search for a BRE fails to find a matching line.
Commands accept zero, one, or two addresses. If one or more addresses are provided to a command that requires zero addresses, it
shall be an error. Otherwise, if more than the maximum number of accepted addresses are provided to a command, the addresses shall
be evaluated from first to last and then discarded, until the maximum number of accepted addresses for that command remain.
Addresses shall be separated from each other by a  (',') or  character (';'). In
the case of a  separator, the current line ('.') shall be set to the first address, and only then shall
the second address be calculated. This feature can be used to determine the starting line for forwards and backwards searches; see
rules 5. and 6.
Addresses can be omitted on either side of the  or  separator, in which case the resulting address
pairs shall be as follows:
Specified
Resulting
,
1 , $
, addr
1 , addr
addr ,
addr , addr
;
. ; $
; addr
. ; addr
addr ;
addr ; addr
If an address is omitted between two separators, the rule shall be applied to the first separator and the resulting
second address shall be used as the first address for the second separator. For example, with the address list ",," the
first ',' becomes "1,$" and the '$' is treated as the first address for the second ',',
resulting in "1,$,$".
Any  characters included between addresses, address separators, or address offsets shall be
ignored.
Commands in ed
In the following list of ed commands, the default addresses are shown in parentheses. The number of
addresses shown in the default shall be the number expected by the command. The parentheses are not part of the address; they show
that the given addresses are the default.
It is generally invalid for more than one command to appear on a line. However, any command (except e,
E, f, q, Q, r, w, and !) can be suffixed by the letter l, n, or
p; in which case, except for the l, n, and p commands, the command shall be executed and then the new
current line shall be written as described below under the l, n, and p commands. When an l, n,
or p suffix is used with an l, n, or p command, the command shall write to standard output as described
below, but it is unspecified whether the suffix writes the current line again in the requested format or whether the suffix has no
effect. For example, the pl command (base p command with an l suffix) shall either write just the current line
or write it twice—once as specified for p and once as specified for l. Also, the g, G, v, and
V commands shall take a command as a parameter.
Each address component can be preceded by zero or more  characters. The command letter can be preceded
by zero or more  characters. If a suffix letter (l, n, or p) is given, the application shall
ensure that it immediately follows the command.
The e, E, f, r, and w commands shall take an optional file parameter,
separated from the command letter by one or more  characters.
If the buffer change flag is currently set to changed, ed shall warn the user if an attempt is made
to destroy the editor buffer via the e or q commands. The ed utility shall write the string:
"?\n"
(followed by an explanatory message if help mode has been enabled via the H command) to standard
output and shall continue in command mode with the buffer change flag set to either changed-and-warned or unchanged
and the current line number unchanged. If another e or q command is then attempted with no intervening command that
sets the buffer change flag to changed, it shall take effect.
If a terminal disconnect (see XBD 11. General Terminal
Interface, Modem Disconnect and Closing a Device Terminal), is detected:
If accompanied by a SIGHUP signal, the ed utility shall operate as described in the ASYNCHRONOUS EVENTS
section for a SIGHUP signal.
If not accompanied by a SIGHUP signal, the ed utility shall act as if an end-of-file had been detected on
standard input.
If an end-of-file is detected on standard input:
If the ed utility is in input mode, ed shall terminate input mode and return to command mode. It is
unspecified if any partially entered lines (that is, input text without a terminating ) are discarded from the input
text.
If the ed utility is in command mode, it shall act as if a q command had been entered.
In the following commands, if a closing delimiter would be the last character before a  then that
character can be omitted with the behavior shown:
For the g and v commands the addressed line(s) shall be written as if a closing delimiter followed
by a p were appended to the command.
For the G and V commands no additional action shall be taken.
For the s command, only the closing delimiter of the replacement can be omitted, in which case the result
of the substitution shall be written as if the p flag were appended.
For the null command, the addressed line(s) shall be written as if the closing delimiter were appended.
For example, the following pairs of commands are equivalent:
s/s1/s2   s/s1/s2/p
g/s1      g/s1/p
?s1       ?s1?
If an invalid command is entered, ed shall write the string:
"?\n"
(followed by an explanatory message if help mode has been enabled via the H command) to standard
output and shall continue in command mode with the current line number unchanged.
Append Command
Synopsis:
(.)a
.
The a command shall read the given text and append it after the addressed line; the current line number
shall become the address of the last inserted line or, if there were none, the addressed line. Address 0 shall be valid for this
command; it shall cause the appended text to be placed at the beginning of the buffer. If  is empty (that is,
the terminating '.' immediately follows the 'a'), the buffer change flag shall not be altered.
Change Command
Synopsis:
(.,.)c
.
The c command shall delete the addressed lines, then accept input text that replaces these lines; the
current line shall be set to the address of the last line input; or, if there were none, at the line after the last line deleted;
if the lines deleted were originally at the end of the buffer, the current line number shall be set to the address of the new last
line; if no lines remain in the buffer, the current line number shall be set to zero.
Delete Command
Synopsis:
(.,.)d
The d command shall delete the addressed lines from the buffer. The address of the line after the last line
deleted shall become the current line number; if the lines deleted were originally at the end of the buffer, the current line
number shall be set to the address of the new last line; if no lines remain in the buffer, the current line number shall be set to
zero.
Edit Command
Synopsis:
e [file]
The e command shall delete the entire contents of the buffer and then read in the file named by the pathname
file. The current line number shall be set to the address of the last line of the buffer. If no pathname is given, the
currently remembered pathname, if any, shall be used (see the f command). If the pathname names a file that does not exist
and the buffer change flag is currently set to unchanged, it is unspecified whether this is treated as an error, or whether
the resulting buffer is emptied and a warning is written to standard error instead of writing the byte count to standard out. The
number of bytes read shall be written to standard output, unless the -s option was specified, in the following format:
"%d\n",
The name file shall be remembered for possible use as a default pathname in subsequent e, E,
r, and w commands. If file is replaced by '!', the rest of the line shall be taken to be a shell
command line whose output is to be read. Such a shell command line shall not be remembered as the current file. All marks
shall be discarded upon the completion of a successful e command. If the buffer change flag is currently set to
changed, the user shall be warned, as described previously.
Edit Without Checking Command
Synopsis:
E [file]
The E command shall possess all properties and restrictions of the e command except that the editor
shall not check the current state of the buffer change flag.
Filename Command
Synopsis:
f [file]
If file is given, the f command shall change the currently remembered pathname to file,
whether or not file names an existing file; whether the name is changed or not, it shall then write the (possibly new)
currently remembered pathname to the standard output in the following format:
"%s\n",
The current line number shall be unchanged.
Global Command
Synopsis:
(1,$)g/RE/command list
In the g command, the first step shall be to mark every line for which the line excluding the terminating
matches the given RE. Then, going sequentially from the beginning of the file to the end of the file, the given
command list shall be executed for each marked line, with the current line number set to the address of that line. Any line
modified by the command list shall be unmarked. When the g command completes, the current line number shall have the
value assigned by the last command in the command list. If there were no matching lines, the current line number shall not
be changed. A single command or the first of a list of commands shall appear on the same line as the global command. All lines of a
multi-line list except the last line shall be ended with a  preceding the terminating ; the
a, i, and c commands and associated input are permitted. The '.' terminating input mode can be
omitted if it would be the last line of the command list. An empty command list shall be equivalent to the p
command. The use of the g, G, v, V, and ! commands in the command list produces undefined
results. Any character other than , , or  can be used instead of a  to
delimit the RE. Within the RE, in certain circumstances the RE delimiter can be used as a literal character; see Regular Expressions in ed.
Interactive Global Command
Synopsis:
(1,$)G/RE/
In the G command, the first step shall be to mark every line for which the line excluding the terminating
matches the given RE. Then, for every such line, that line shall be written, the current line number shall be set
to the address of that line, and any one command (other than one of the a, c, i, g, G, v,
and V commands) shall be read and executed. A  shall act as a null command (causing no action to be taken on
the current line); an '&' shall cause the re-execution of the most recent non-null command executed within the current
invocation of G. Note that the commands input as part of the execution of the G command can address and affect any
lines in the buffer. Any line modified by the command shall be unmarked. The final value of the current line number shall be the
value set by the last command successfully executed. (Note that the last command successfully executed shall be the G
command itself if a command fails or the null command is specified.) If there were no matching lines, the current line number shall
not be changed. The G command can be terminated by a SIGINT signal. Any character other than ,
, or  can be used instead of a  to delimit the RE. Within the RE, in certain circumstances
the RE delimiter can be used as a literal character; see Regular Expressions in ed.
Help Command
Synopsis:
h
The h command shall write a short message to standard output that explains the reason for the most recent
'?' notification. The current line number shall be unchanged.
Help-Mode Command
Synopsis:
H
The H command shall cause ed to enter a mode in which help messages (see the h command) shall
be written to standard output for all subsequent '?' notifications. The H command alternately shall turn this mode
on and off; it is initially off. If the help-mode is being turned on, the H command also explains the previous '?'
notification, if there was one. The current line number shall be unchanged.
Insert Command
Synopsis:
(.)i
.
The i command shall insert the given text before the addressed line; the current line is set to the last
inserted line or, if there was none, to the addressed line. This command differs from the a command only in the placement of
the input text. Address 0 shall be valid for this command; it is unspecified whether it causes the inserted text to be placed at
the beginning of the buffer or it is interpreted as if address 1 were specified. (These two allowed behaviors differ in the case
that the buffer is empty.) If  is empty (that is, the terminating '.' immediately follows the
'i'), the buffer change flag shall not be altered.
Join Command
Synopsis:
(.,.+1)j
The j command shall join contiguous lines by removing the appropriate  characters. If exactly
one address is given, this command shall do nothing. If lines are joined, the current line number shall be set to the address of
the joined line; otherwise, the current line number shall be unchanged.
Mark Command
Synopsis:
(.)kx
The k command shall mark the addressed line with name x, which the application shall ensure is a
lowercase letter from the portable character set. The address "'x" shall then refer to this line; the current line number
shall be unchanged.
List Command
Synopsis:
(.,.)l
The l command shall write to standard output the addressed lines in a visually unambiguous form. The
characters listed in XBD Escape Sequences and Associated Actions
('\\', '\a', '\b', '\f', '\r', '\t', '\v') shall be written as the
corresponding escape sequence; the '\n' in that table is not applicable. Non-printable characters not in the table shall
be written as one three-digit octal number (with a preceding  character) for each byte in the character (most
significant byte first).
Long lines shall be folded, with the point of folding indicated by  preceded by a ;
the length at which folding occurs is unspecified, but should be appropriate for the output device. The end of each line shall be
marked with a '$', and '$' characters within the text shall be written with a preceding . An
l command can be appended to any other command other than e, E, f, q, Q, r,
w, or !. The current line number shall be set to the address of the last line written.
Move Command
Synopsis:
(.,.)maddress
The m command shall reposition the addressed lines after the line addressed by address. Address 0
shall be valid for address and cause the addressed lines to be moved to the beginning of the buffer. It shall be an error if
address address falls within the range of moved lines. The current line number shall be set to the address of the last line
moved.
Number Command
Synopsis:
(.,.)n
The n command shall write to standard output the addressed lines, preceding each line by its line number and
a ; the current line number shall be set to the address of the last line written. The n command can be appended
to any command other than e, E, f, q, Q, r, w, or !.
Print Command
Synopsis:
(.,.)p
The p command shall write to standard output the addressed lines; the current line number shall be set to
the address of the last line written. The p command can be appended to any command other than e, E, f,
q, Q, r, w, or !.
Prompt Command
Synopsis:
P
The P command shall cause ed to prompt with an  ('*') (or string, if
-p is specified) for all subsequent commands. The P command alternatively shall turn this mode on and off; it shall
be initially on if the -p option is specified; otherwise, off. The current line number shall be unchanged.
Quit Command
Synopsis:
q
The q command shall cause ed to exit. If the buffer change flag is currently set to changed,
the user shall be warned, as described previously.
Quit Without Checking Command
Synopsis:
Q
The Q command shall cause ed to exit without checking the current state of the buffer change
flag.
Read Command
Synopsis:
($)r [file]
The r command shall read in the file named by the pathname file and append it after the addressed
line. If no file argument is given, the currently remembered pathname, if any, shall be used (see the e and f
commands). The currently remembered pathname shall not be changed unless there is no remembered pathname. Address 0 shall be valid
for r and shall cause the file to be read at the beginning of the buffer. If the read is successful, and -s was not
specified, the number of bytes read shall be written to standard output in the following format:
"%d\n",
The current line number shall be set to the address of the last line read in. If file is replaced by
'!', the rest of the line shall be taken to be a shell command line whose output is to be read. Such a shell command line
shall not be remembered as the current pathname.
If the number of bytes read is 0 it is unspecified whether the buffer change flag is set to changed or left
unaltered.
Substitute Command
Synopsis:
(.,.)s/RE/replacement/flags
The s command shall search each addressed line for an occurrence of the specified RE and replace either the
first or all (non-overlapped) matched strings with the replacement; see the following description of the g suffix.
Any character other than , , or  can be used instead of a  to delimit the
RE and the replacement. Within the RE, in certain circumstances the RE delimiter can be used as a literal character; see Regular Expressions in ed. Within the replacement, the delimiter shall not terminate the replacement if it
is the second character of an escape sequence (see XBD 9.1 Regular Expression
Definitions) and the escaped delimiter shall be treated as that literal character in the replacement (losing any special
meaning it would have had if it was not used as the delimiter and was not escaped). It shall be an error if the substitution fails
on every addressed line. The current line shall be set to the address of the last line on which a substitution occurred.
An unescaped  ('&') appearing in the replacement shall be replaced by the string
matching the RE on the current line. As a more general feature, the characters '\n', where the  is
unescaped and n is a digit, shall be replaced by the text matched by the corresponding back-reference expression. If the
corresponding back-reference expression does not match, then the characters '\n' shall be replaced by the empty string.
When the character '%' is the only character in replacement, the replacement used in the most recent
substitute command shall be used as replacement in the current substitute command; if there was no previous substitute
command, the use of '%' in this manner shall be an error. The '%' shall lose its special meaning when it is in a
replacement string of more than one character or is escaped. It is unspecified what special meaning is given to any character other
than , '&', '%', or digits.
A line can be split by substituting a  into it. The application shall ensure it escapes the
in the replacement by preceding it by . Such substitution cannot be done as part of a
g or v command list. The current line number shall be set to the address of the last line on which a
substitution is performed. If no substitution is performed, the current line number shall be unchanged. If a line is split, a
substitution shall be considered to have been performed on each of the new lines for the purpose of determining the new current
line number. A substitution shall be considered to have been performed even if the replacement string is identical to the string
that it replaces.
The application shall ensure that the value of flags is zero or more of:
count
Substitute for the countth occurrence only of the RE found on each addressed line.
g
Globally substitute for all non-overlapping instances of the RE rather than just the first one. If both g and
count are specified, the results are unspecified.
l
Write to standard output the final line in which a substitution was made. The line shall be written in the format specified for
the l command.
n
Write to standard output the final line in which a substitution was made. The line shall be written in the format specified for
the n command.
p
Write to standard output the final line in which a substitution was made. The line shall be written in the format specified for
the p command.
Copy Command
Synopsis:
(.,.)taddress
The t command shall be equivalent to the m command, except that a copy of the addressed lines shall
be placed after address address (which can be 0); the current line number shall be set to the address of the last line
added.
Undo Command
Synopsis:
u
The u command shall nullify the effect of the most recent command that modified anything in the buffer,
namely the most recent a, c, d, g, i, j, m, r, s, t,
u, v, G, or V command. All changes made to the buffer by a g, G, v, or V
global command shall be undone as a single change; if no changes were made by the global command (such as with
g/RE/p), the u command shall have no effect. The current line number shall be set to the value it had
immediately before the command being undone started.
Global Non-Matched Command
Synopsis:
(1,$)v/RE/command list
This command shall be equivalent to the global command g except that the lines that are marked during the
first step shall be those for which the line excluding the terminating  does not match the RE.
Interactive Global Not-Matched Command
Synopsis:
(1,$)V/RE/
This command shall be equivalent to the interactive global command G except that the lines that are marked
during the first step shall be those for which the line excluding the terminating  does not match the RE.
Write Command
Synopsis:
(1,$)w [file]
The w command shall write the addressed lines into the file named by the pathname file. The command
shall create the file, if it does not exist, or shall replace the contents of the existing file. The currently remembered pathname
shall not be changed unless there is no remembered pathname. If no pathname is given, the currently remembered pathname, if any,
shall be used (see the e and f commands); the current line number shall be unchanged. If the command is successful,
the number of bytes written shall be written to standard output, unless the -s option was specified, in the following
format:
"%d\n",
If file begins with '!', the rest of the line shall be taken to be a shell command line whose
standard input shall be the addressed lines. Such a shell command line shall not be remembered as the current pathname. This usage
of the w command with '!' shall not alter the buffer change flag; thus, this alone shall not prevent the warning to
the user if an attempt is made to destroy the editor buffer via the e or q commands.
Line Number Command
Synopsis:
($)=
The line number of the addressed line shall be written to standard output in the following format:
"%d\n",
The current line number shall be unchanged by this command.
Shell Escape Command
Synopsis:
!command
The remainder of the line after the '!' shall be sent to the command interpreter to be interpreted as a
shell command line. Within the text of that shell command line, the unescaped character '%' shall be replaced with the
remembered pathname; if a '!' appears as the first character of the command, it shall be replaced with the text of the
previous shell command executed via '!'. Thus, "!!" shall repeat the previous !command. If any
replacements of '%' or '!' are performed, the modified line shall be written to the standard output before
command is executed. The ! command shall write:
"!\n"
to standard output upon completion, unless the -s option is specified. The current line number shall be
unchanged.
Null Command
Synopsis:
(.+1)
An address alone on a line shall cause the addressed line to be written. A  alone shall be
equivalent to "+1p". The current line number shall be set to the address of the written line.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion without any file or command errors.
>0
An error occurred.
CONSEQUENCES OF ERRORS
When an error in the input script is encountered, or when an error is detected that is a consequence of the data (not) present
in the file or due to an external condition such as a read or write error:
If the standard input is a terminal device file, all input shall be flushed, and a new command read.
If the standard input is not a terminal device file, ed shall behave as described under CONSEQUENCES OF
ERRORS in 1.4 Utility Description Defaults.
The following sections are informative.
APPLICATION USAGE
Because of the extremely terse nature of the default error messages, the prudent script writer begins the ed input
commands with an H command, so that if any errors do occur at least some clue as to the cause is made available.
In earlier versions of this standard, an obsolescent - option was described. This is no longer specified.
Applications should use the -s option. Using - as a file operand now produces unspecified results. This allows
implementations to continue to support the former required behavior.
EXAMPLES
None.
RATIONALE
The initial description of this utility was adapted from the SVID. It contains some features not found in Version 7 or
BSD-derived systems. Some of the differences between the POSIX and BSD ed utilities include, but need not be limited to:
The BSD - option does not suppress the '!' prompt after a ! command.
BSD does not support the special meanings of the '%' and '!' characters within a !
command.
BSD does not support the addresses ';' and ','.
BSD allows the command/suffix pairs pp, ll, and so on, which are unspecified in this volume of
POSIX.1-2024.
BSD does not support the '!' character part of the e, r, or w commands.
A failed g command in BSD sets the line number to the last line searched if there are no matches.
BSD does not default the command list to the p command.
BSD does not support the G, h, H, n, or V commands.
On BSD, if there is no inserted text, the insert command changes the current line to the referenced line -1; that
is, the line before the specified line.
On BSD, the j command with only a single address changes the current line to that address.
BSD does not support the P command; moreover, in BSD it is synonymous with the p command.
BSD does not support the undo of the commands j, m, r, s, or t.
The Version 7 ed command W, and the BSD ed commands W, wq, and z are not
present in this volume of POSIX.1-2024.
The -s option was added to allow the functionality of the removed - option in a manner compatible
with the Utility Syntax Guidelines.
In early proposals there was a limit, {ED_FILE_MAX}, that described the historical limitations of some ed
utilities in their handling of large files; some of these have had problems with files larger than 100000 bytes. It was this
limitation that prompted much of the desire to include a split command in this volume
of POSIX.1-2024. Since this limit was removed, this volume of POSIX.1-2024 requires that implementations document the file size
limits imposed by ed in the conformance document. The limit {ED_LINE_MAX} was also removed; therefore, the global limit
{LINE_MAX} is used for input and output lines.
The manner in which the l command writes non-printable characters was changed to avoid the historical
backspace-overstrike method. On video display terminals, the overstrike is ambiguous because most terminals simply replace
overstruck characters, making the l format not useful for its intended purpose of unambiguously understanding the content of
the line. The historical -escapes were also ambiguous. (The string "a\0011" could represent a line
containing those six characters or a line containing the three characters 'a', a byte with a binary value of 1, and a 1.)
In the format required here, a  appearing in the line is written as "\\" so that the output is truly
unambiguous. The method of marking the ends of lines was adopted from the ex editor and
is required for any line ending in  characters; the '$' is placed on all lines so that a real '$' at
the end of a line cannot be misinterpreted.
Earlier versions of this standard allowed for implementations with bytes other than eight bits, but this has been
modified in this version.
The description of how a NUL is written was removed. The NUL character cannot be in text files, and this volume of
POSIX.1-2024 should not dictate behavior in the case of undefined, erroneous input.
Unlike some of the other editing utilities, the filenames accepted by the E, e, R, and
r commands are not patterns.
Early proposals stated that the -p option worked only when standard input was associated with a terminal
device. This has been changed to conform to historical implementations, thereby allowing applications to interpose themselves
between a user and the ed utility.
The form of the substitute command that uses the n suffix was limited in some historical documentation
(where this was described incorrectly as "backreferencing"). This limit has been omitted because there is no reason why an editor
processing lines of {LINE_MAX} length should have this restriction. The command s/x/X/2047 should be able to substitute the
2047th occurrence of 'x' on a line.
The use of printing commands with printing suffixes (such as pn, lp, and so on) was made unspecified
because BSD-based systems allow this, whereas System V does not.
Some BSD-based systems exit immediately upon receipt of end-of-file if all of the lines in the file have been
deleted. Since this volume of POSIX.1-2024 refers to the q command in this instance, such behavior is not allowed.
Some historical implementations returned exit status zero even if command errors had occurred; this is not allowed
by this volume of POSIX.1-2024.
Some historical implementations contained a bug that allowed a single  to be entered in input mode as
. This is not allowed by ed because there is no description of escaping any
of the characters in input mode;  characters are entered into the buffer exactly as typed. The typical method of
entering a single  has been to precede it with another character and then use the substitute command to delete that
character.
It is difficult under some modes of some versions of historical operating system terminal drivers to distinguish
between an end-of-file condition and terminal disconnect. POSIX.1-2024 does not require implementations to distinguish between the
two situations, which permits historical implementations of the ed utility on historical platforms to conform.
Implementations are encouraged to distinguish between the two, if possible, and take appropriate action on terminal disconnect.
Historically, ed accepted a zero address for the a and r commands in order to insert text at
the start of the edit buffer. When the buffer was empty the command .= returned zero. POSIX.1-2024 requires conformance to
historical practice.
For consistency with the a and r commands and better user functionality, the i command also
accepts an address of 0. However, it is unspecified if 0i is treated as 1i (which will fail if the buffer is
empty), or means insert at the beginning of the buffer (which will succeed even if the buffer is empty). Earlier versions of this
standard required address 0 for the c command to be treated as 1 also, but this requirement has been removed, though
implementations are permitted to do this as an extension.
All of the following are valid addresses:
+++
Three lines after the current line.
/pattern/-
One line before the next occurrence of pattern.
-2
Two lines before the current line.
3 ---- 2
Line one (note the intermediate negative address).
1 2 3
Line six.
More than the maximum number of accepted addresses can be provided to commands taking addresses; for example,
"1,2,3,4,5p" prints lines 4 and 5, because two is the maximum number of addresses accepted by the print command.
This, in combination with the  delimiter, permits users to create commands based on ordered patterns in the file.
For example, the command "3;/foo/;+2p" will display the first line after line 3 that contains the pattern foo, plus
the next two lines. Note that the address "3;" must still be evaluated before being discarded, because the search origin
for the "/foo/" address depends on this.
Historically, ed disallowed address chains, as discussed above, consisting solely of  or
separators; for example, ",,," or ";;;" were considered an error. For consistency of address
specification, this restriction is removed. The following table lists some of the address forms now possible:
Address
Addr1
Addr2
Status
Comment
7,
7
7
Historical
7,5,
5
5
Historical
7,5,9
5
9
Historical
7,9
7
9
Historical
7,+
7
.+
Historical
,
1
$
Historical
,7
1
7
Extension
,,
$
$
Extension
,;
$
$
Extension
7;
7
7
Historical
7;5;
5
5
Historical
7;5;9
5
9
Historical
7;5,9
5
9
Historical
7;$;4
$
4
Historical
Valid, but erroneous.
7;9
7
9
Historical
7;+
7
8
Historical
;
.
$
Historical
;7
.
7
Extension
;;
$
$
Extension
;,
$
$
Extension
Historically, ed accepted the '^' character as an address, in which case it was identical to the
character. POSIX.1-2024 does not require or prohibit this behavior.
Implementations are encouraged to set the buffer change flag to changed-and-warned when an e or
q command warns that an attempt was made to destroy the editor buffer. Some existing implementations set it to
unchanged, but this has the undesirable side-effect that a SIGHUP received after the warning is given does not write the
buffer to ed.hup.
FUTURE DIRECTIONS
If this utility is directed to create a new directory entry that contains any bytes that have the encoded value of a
character, implementations are encouraged to treat this as an error. A future version of this standard may require
implementations to treat this as an error.
A future version of this standard may require that the buffer change flag is set to changed-and-warned when
an e or q command warns that an attempt was made to destroy the editor buffer.
SEE ALSO
1.4 Utility Description Defaults, ex, sed, sh, vi
XBD Escape Sequences and Associated Actions, 8. Environment Variables, 9.3
Basic Regular Expressions, 11. General Terminal Interface,
12.2 Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 2.
Issue 5
In the OPTIONS section, the meaning of -s and - is clarified.
A second FUTURE DIRECTION is added.
Issue 6
The obsolescent single-minus form is removed.
A second APPLICATION USAGE note is added.
The Open Group Corrigendum U025/2 is applied, correcting the description of the Edit section.
The ed utility is updated to align with the IEEE P1003.2b draft standard. This includes addition of the
treatment of the SIGQUIT signal, changes to ed addressing, and changes to processing when end-of-file is detected and when
terminal disconnect is detected.
The normative text is reworded to avoid use of the term "must" for application requirements.
IEEE Std 1003.1-2001/Cor 1-2002, item XCU/TC1/D6/22 is applied, adding the text: "Any line modified
by the command list shall be unmarked." to the G command. This change corresponds to a similar change made to the
g command in the first version of this standard.
IEEE Std 1003.1-2001/Cor 2-2004, item XCU/TC2/D6/7 is applied, removing text describing behavior on
systems with bytes consisting of more than eight bits.
Issue 7
Austin Group Interpretation 1003.1-2001 #027 is applied, clarifying the behavior if an operand is '-'.
Austin Group Interpretation 1003.1-2001 #036 is applied, clarifying the behavior for BREs.
SD5-XCU-ERN-94 is applied, updating text in the EXTENDED DESCRIPTION where a terminal disconnect is detected (in
Commands in ed).
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
SD5-XCU-ERN-135 is applied, removing some RATIONALE text that is no longer applicable.
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0090 [584], XCU/TC2-2008/0091 [584], and XCU/TC2-2008/0092
[584] are applied.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to disallow the creation of filenames containing any bytes that
have the encoded value of a  character.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
Austin Group Defect 1130 is applied, removing the requirement for the c command to accept an address of 0
and updating the information about address 0 in the RATIONALE section.
Austin Group Defect 1131 is applied, changing the address 0 requirements for the i command.
Austin Group Defect 1204 is applied, clarifying the behavior when a closing delimiter that would be the last
character before a  is omitted.
Austin Group Defect 1281 is applied, moving some text in the description of the s command and changing it to
use "shall".
Austin Group Defect 1298 is applied, changing the CONSEQUENCES OF ERRORS section.
Austin Group Defect 1308 is applied, changing the Addr2 value for address 7,+ in the table of
address forms in the RATIONALE section.
Austin Group Defect 1311 is applied, changing "join command" to "j command" in the RATIONALE
section.
Austin Group Defect 1582 is applied, clarifying the behavior when an address is omitted between two address
separators.
Austin Group Defect 1607 is applied, clarifying the behavior when more than the maximum number of accepted
addresses are provided to a command.
Austin Group Defect 1662 is applied, clarifying requirements relating to delimiters in addresses and in s
commands.
Austin Group Defect 1786 is applied, clarifying the behavior when an e command names a file that does not
exist, and clarifying how the ed utility keeps track of whether the buffer has been modified.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/zcat.html =====
compress
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
compress, uncompress, zcat — compress and decompress data
SYNOPSIS
[XSI]
compress [-fv] [-b value] [-g | -m algo] [file...]
compress -c [-fv] [-b value] [-g | -m algo] [file]
compress -d [-cfv] [file...]
uncompress [-cfv] [file...]
zcat [file...]
DESCRIPTION
The
compress
utility, when the
-d
option is not specified, shall apply the compression algorithm identified
by the
-g
option or the
-m
algo
option to the named files to attempt to reduce their size without loss
of information. The compress utility with the
-d
option shall apply the appropriate decompression algorithm to the
named files to restore the data to their original state.
The
uncompress
utility shall be equivalent to
compress
-d.
The
zcat
utility shall be equivalent to
compress
-c -d.
If multiple
file
operands are specified, the decompressed data from each input file
shall be concatenated to standard output.
When compressing data, unless the
-c
option is specified, after an input file other than standard input has
been compressed, the compressed data from the input file shall be
stored in a file with the same pathname as the input file but with an
added suffix. The added suffix shall be the suffix associated with the
algorithm (see the algorithms in
Compression algorithms, algo option-argument values, and suffixes
).
If appending the suffix would make the size of the last component of
the output file's pathname exceed
{NAME_MAX}
bytes, the command shall fail. If appending the suffix would make the
size of the pathname exceed
{PATH_MAX}
bytes, the command may fail.
When decompressing data, unless the
-c
option is specified, after an input file other than standard input has
been decompressed, the decompressed data from the input file shall be
stored in a file with the same pathname as the input file but with the
suffix associated with the algorithm removed.
[OB]
If
file
has no suffix associated with a known compression algorithm or
file
does not exist and does not have a
.Z
suffix,
file
shall be used as the name of the output file, and the default suffix
.Z
shall be appended to
file
to form the input pathname.
The behavior is unspecified if the input pathname ends with a suffix
other than the suffix associated with the algorithm used to compress
the data. When the
-c
option is specified,
file
can have any suffix, or no suffix, and the utility shall use
file
as the input file and examine the file's contents to determine which
algorithm to use to decompress the data (it is not an error if
file
does not have a suffix that matches the suffix associated with the
compression algorithm).
When compressing or decompressing a file other than standard input and the
-c
option is not specified, if the invoking process has sufficient privilege,
the ownership, modes, access time, and modification time of the output
file shall match the ownership, modes, access time, and modification
time of the input file. After the output file has been successfully
created, the input file shall be removed if the invoking process has
sufficient privileges. If the invoking process does not have sufficient
privileges to remove the input file (for example, if the directory has
the S_ISVTX bit set) the behavior depends on whether the
-f
option is specified: if
-f
is not specified, the output file shall be removed, a diagnostic
message shall be written and the utility shall continue processing
other files but the final exit status shall be non-zero; if
-f
is specified, the output file shall not be removed and it is
unspecified whether the inability to remove the input file is treated
as an error. If it is not treated as an error, a warning message may
be written to standard error
If no
file
operands are specified, standard input shall be compressed or
decompressed to standard output.
[OB]
If an input file that is to be removed after processing has multiple
hard links, the
compress
and
uncompress
utilities may write a diagnostic message to standard error and do
nothing with the file; this behavior may depend on whether the
-f
option is specified. If a diagnostic message is written, the final
exit status shall be non-zero.
OPTIONS
The
compress,
uncompress,
and
zcat
utilities shall conform to XBD
12.2 Utility Syntax Guidelines
,
except that Guideline 1 does not apply to
uncompress
since the utility name has ten letters.
The following options shall be supported:
-b valueIf the compression algorithm is LZW,
value
specifies the maximum number of bits to use in a code. For a
conforming application, the
value
argument shall be:
9 2An error occurred.
The following exit values shall be returned for
uncompress
and
zcat:
0Successful completion.
>0An error occurred.
CONSEQUENCES OF ERRORS
If an error occurs while compressing or decompressing an input file
other than standard input, the input file shall remain unmodified.
The following sections are informative.
APPLICATION USAGE
The amount of compression obtained depends on the size of the input,
the number of bits
per code, and the distribution of common substrings. Typically, text
such as source code or English is reduced by 50-60%. Compression is
generally much better than that achieved by Huffman coding
or adaptive Huffman coding (compact),
and takes less time to compute.
Although
compress
strictly follows the default actions upon receipt of a signal or when
an error occurs, some unexpected results may occur. In some
implementations it is likely that a partially compressed file is left
in place, alongside its uncompressed input file. Since the general
operation of
compress
is to delete the uncompressed file only after the
.Z
file has been successfully filled, an application should always
carefully check the exit status of
compress
before arbitrarily deleting files that have like-named neighbors with
.Z
suffixes.
In addition to trying
file
and
file.Z
when looking for a file to decompress, some implementations of
uncompress
and
zcat
also try suffixes for other known compression algorithms if neither
file
nor
file.Z
is found. This version of the standard allows, but does not require
this behavior. Portable applications should always specify the full
pathname (including the suffix) of files to be decompressed.
EXAMPLES
None.
RATIONALE
Earlier versions of this standard limited the number of bits used by
conforming applications for the
lzw
algorithm to 14 due to address space limitations on 16-bit
architectures. Using 15 or 16 is a much more common default when using
current hardware.
Earlier versions of this standard only supported LZW compression. The
standard developers noted that existing implementations added other
compression utilities, such as
gzip,
and found it desirable to support this widespread usage. Some
implementations had extended the
compress
utility to support such other schemes. The standard developers
generalized this practice by the addition of the
-m
option, even though this was not previous practice.
The
uncompress
-d
option is added to match undocumented existing practice of tested
implementations.
FUTURE DIRECTIONS
If this utility is directed to create a new directory entry that
contains any bytes that have the encoded value of a
character, implementations are encouraged to treat this as an error.
A future version of this standard may require implementations to treat
this as an error.
When decompressing a file, the requirement to add
.Z
to a
file
operand if the given pathname does not include a suffix associated
with a known compression algorithm or if
file
does not exist and does not already have a
.Z
extension is an obsolescent feature and may be removed in a future version.
SEE ALSO
XBD
8. Environment Variables
,
12.2 Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 4.
Issue 6
The normative text is reworded to avoid use of the term "must"
for application requirements.
An error case is added for systems not supporting adaptive Lempel-Ziv
coding.
Issue 7
SD5-XCU-ERN-97 is applied, updating the SYNOPSIS.
Austin Group Interpretation 1003.1-2001 #125 is applied, revising
the ENVIRONMENT VARIABLES section.
Issue 8
Austin Group Defect 251 is applied, encouraging implementations to
disallow the creation of filenames containing any bytes that have the
encoded value of a
character.
Austin Group Defect 1041 is applied, combining the
compress,
uncompress
and
zcat
pages into one and extensively modifying most sections.
Austin Group Defect 1122 is applied, changing the description of
NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index |
XBD |
XSH |
XCU |
XRAT ]
>>
===== susv5-html/utilities/tty.html =====
tty
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
tty — return user's terminal name
SYNOPSIS
tty
DESCRIPTION
The tty utility shall write to the standard output the name of the terminal that is open as standard input. The name that
is used shall be equivalent to the string that would be returned by the ttyname()
function defined in the System Interfaces volume of POSIX.1-2024.
OPTIONS
The tty utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
OPERANDS
None.
STDIN
While no input is read from standard input, standard input shall be examined to determine whether or not it is a terminal, and,
if so, to determine the name of the terminal.
INPUT FILES
None.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of tty:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error and
informative messages written to standard output.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
If standard input is a terminal device, a pathname of the terminal as specified by the ttyname() function defined in the System Interfaces volume of POSIX.1-2024 shall be written
in the following format:
"%s\n",
Otherwise, a message shall be written indicating that standard input is not connected to a terminal. In the POSIX locale, the
tty utility shall use the format:
"not a tty\n"
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
Standard input is a terminal, and the output specified in STDOUT was successfully written to standard output.
1
Standard input is not a terminal, and the output specified in STDOUT was successfully written to standard output.
>1
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
This utility checks the status of the file open as standard input against that of an implementation-defined set of files. It is
possible that no match can be found, or that the match found need not be the same file as that which was opened for standard input
(although they are the same device).
EXAMPLES
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
XBD 8. Environment Variables, 12.2 Utility Syntax Guidelines
XSH isatty(), ttyname()
CHANGE HISTORY
First released in Issue 2.
Issue 5
The SYNOPSIS is changed to indicate two forms of the command, with the second form marked as obsolete. This is a clarification
and does not change the functionality published in previous issues.
Issue 6
The obsolescent -s option is removed.
Issue 8
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
Austin Group Defect 1509 is applied, changing the EXIT STATUS section.
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/comm.html =====
comm
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
comm — select or reject lines common to two files
SYNOPSIS
comm [-123] file1 file2
DESCRIPTION
The comm utility shall read file1 and file2, which should be ordered in the current collating sequence, and
produce three text columns as output: lines only in file1, lines only in file2, and lines in both files.
If the lines in both files are not ordered according to the collating sequence of the current locale, the results are
unspecified.
If the collating sequence of the current locale does not have a total ordering of all characters (see XBD 7.3.2 LC_COLLATE) and any lines from the input files collate equally but are
not identical, comm shall treat them as different lines and shall expect them to be ordered according to a further
byte-by-byte comparison using the collating sequence for the POSIX locale; if they are not ordered in this way, the output of
comm can identify such lines as being both unique to file1 and unique to file2 instead of being in both
files.
OPTIONS
The comm utility shall conform to XBD 12.2 Utility Syntax
Guidelines.
The following options shall be supported:
-1
Suppress the output column of lines unique to file1.
-2
Suppress the output column of lines unique to file2.
-3
Suppress the output column of lines duplicated in file1 and file2.
OPERANDS
The following operands shall be supported:
file1
A pathname of the first file to be compared. If file1 is '-', the standard input shall be used.
file2
A pathname of the second file to be compared. If file2 is '-', the standard input shall be used.
If both file1 and file2 refer to standard input or to the same FIFO special, block special, or character special
file, the results are undefined.
STDIN
The standard input shall be used only if one of the file1 or file2 operands refers to standard input. See the
INPUT FILES section.
INPUT FILES
The input files shall be text files.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of comm:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_COLLATE
Determine the locale for the collating sequence comm expects to have been used when the input files were sorted.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
[XSI]
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
The comm utility shall produce output depending on the options selected. If the -1, -2, and -3
options are all selected, comm shall write nothing to standard output.
If the -1 option is not selected, lines contained only in file1 shall be written using the format:
"%s\n",
If the -2 option is not selected, lines contained only in file2 are written using the format:
"%s%s\n", ,
where the string  is as follows:
The -1 option is not selected.
null string
The -1 option is selected.
If the -3 option is not selected, lines contained in both files shall be written using the format:
"%s%s\n", ,
where the string  is as follows:
Neither the -1 nor the -2 option is selected.
Exactly one of the -1 and -2 options is selected.
null string
Both the -1 and -2 options are selected.
If the input files were ordered according to the collating sequence of the current locale, the lines written shall be in the
collating sequence of the current locale. If the input files contained any lines that collated equally but were not identical and
within each file those lines were ordered according to a further byte-by-byte comparison using the collating sequence for the POSIX
locale, then lines written that collate equally but are not identical shall be ordered according to a further byte-by-byte
comparison using the collating sequence for the POSIX locale.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
All input files were successfully output as specified.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
If the input files are not properly presorted, the output of comm might not be useful.
When using comm to process pathnames, it is recommended that LC_ALL, or at least LC_CTYPE and LC_COLLATE, are set to
POSIX or C in the environment, since pathnames can contain byte sequences that do not form valid characters in some locales, in
which case the utility's behavior would be undefined. In the POSIX locale each byte is a valid single-byte character, and therefore
this problem is avoided.
If the collating sequence of the current locale does not have a total ordering of all characters, since comm treats lines
as being the same only if they are identical, some lines can be misleadingly identified as being both unique to file1 and
unique to file2 if lines that collate equally but are not identical are not ordered in the way that comm expects. If
the input does not come from utilities (such as ls and sort) which provide this ordering, the problem can be avoided by pre-sorting the input files
using sort.
EXAMPLES
If a file named xcu contains a sorted list of the utilities in this volume of POSIX.1-2024, a file named xpg3
contains a sorted list of the utilities specified in the X/Open Portability Guide, Issue 3, and a file named svid89 contains
a sorted list of the utilities in the System V Interface Definition Third Edition:
comm -23 xcu xpg3 | comm -23 - svid89
would print a list of utilities in this volume of POSIX.1-2024 not specified by either of the other documents:
comm -12 xcu xpg3 | comm -12 - svid89
would print a list of utilities specified by all three documents, and:
comm -12 xpg3 svid89 | comm -23 - xcu
would print a list of utilities specified by both XPG3 and the SVID, but not specified in this volume of POSIX.1-2024.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
cmp, diff, sort, uniq
XBD 7.3.2 LC_COLLATE, 8. Environment Variables, 12.2
Utility Syntax Guidelines
CHANGE HISTORY
First released in Issue 2.
Issue 6
The normative text is reworded to avoid use of the term "must" for application requirements.
Issue 7
POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0076 [963], XCU/TC2-2008/0077 [663], and XCU/TC2-2008/0078 [963] are
applied.
Issue 8
Austin Group Defect 1070 is applied, changing the requirements when any lines from the input files collate equally but are not
identical.
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/unlink.html =====
unlink
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
unlink — call the unlink function
SYNOPSIS
[XSI]  unlink file
DESCRIPTION
The unlink utility shall perform the function call:
unlink(file);
A user may need appropriate privileges to invoke the unlink utility.
OPTIONS
None.
OPERANDS
The following operands shall be supported:
file
The pathname of an existing file.
STDIN
Not used.
INPUT FILES
Not used.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of unlink:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
None.
STDERR
The standard error shall be used only for diagnostic messages.
OUTPUT FILES
None.
EXTENDED DESCRIPTION
None.
EXIT STATUS
The following exit values shall be returned:
0
Successful completion.
>0
An error occurred.
CONSEQUENCES OF ERRORS
Default.
The following sections are informative.
APPLICATION USAGE
None.
EXAMPLES
None.
RATIONALE
None.
FUTURE DIRECTIONS
None.
SEE ALSO
link, rm
XBD 8. Environment Variables
XSH unlink()
CHANGE HISTORY
First released in Issue 5.
Issue 8
Austin Group Defect 1122 is applied, changing the description of NLSPATH .
End of informative text.
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
>>
===== susv5-html/utilities/builtins-redirector.html =====
Shell Command Language
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
Please enable javascript in your browser to automatically redirect to the target page, otherwise select the link below.
2.15 Special Built-In Utilities
break
colon
continue
dot
eval
exec
exit
export
readonly
return
set
shift
times
trap
unset
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
===== susv5-html/utilities/export.html =====
Shell Command Language
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
Please enable javascript in your browser to automatically redirect to the target page, otherwise select the link below.
2.15 Special Built-In Utilities
break
colon
continue
dot
eval
exec
exit
export
readonly
return
set
shift
times
trap
unset
UNIX® is a registered Trademark of The Open Group.
POSIX™ is a Trademark of The IEEE.
Copyright © 2001-2024 The IEEE and The Open Group, All Rights Reserved
[ Main Index | XBD | XSH | XCU | XRAT
]
===== susv5-html/utilities/prs.html =====
prs
>>
The Open Group Base Specifications Issue 8
IEEE Std 1003.1-2024
Copyright © 2001-2024 The IEEE and The Open Group
NAME
prs — print an SCCS file (DEVELOPMENT)
SYNOPSIS
[XSI]  prs [-a] [-d dataspec]
[-r[SID]] file...
prs [-e|-l] -c cutoff [-d dataspec]
file...
prs [-e|-l] -r[SID] [-d dataspec]
file...
DESCRIPTION
The prs utility shall write to standard output parts or all of an SCCS file in a user-supplied format.
OPTIONS
The prs utility shall conform to XBD 12.2 Utility Syntax
Guidelines, except that the -r option has an optional option-argument. This optional option-argument cannot be
presented as a separate argument. The following options shall be supported:
-d dataspec
Specify the output data specification. The dataspec shall be a string consisting of SCCS file data
keywords (see Data Keywords) interspersed with optional user-supplied text.
-r[SID]
Specify the SCCS identification string (SID) of a delta for which information is desired. If no SID option-argument is
specified, the SID of the most recently created delta shall be assumed.
-e
Request information for all deltas created earlier than and including the delta designated via the -r option or the
date-time given by the -c option.
-l
Request information for all deltas created later than and including the delta designated via the -r option or the
date-time given by the -c option.
-c cutoff
Indicate the cutoff date-time, in the form:
YY[MM[DD[HH[MM[SS]]]]]
For the YY component, values in the range [69,99] shall refer to years 1969 to 1999 inclusive, and values in the range
[00,68] shall refer to years 2000 to 2068 inclusive.
Note:
It is expected that in a future version of this standard the default century inferred from a 2-digit year will change. (This
would apply to all commands accepting a 2-digit year as input.)
No changes (deltas) to the SCCS file that were created after the specified cutoff date-time shall be included in the
output. Units omitted from the date-time default to their maximum possible values; for example, -c 7502 is equivalent
to -c 750228235959.
-a
Request writing of information for both removed—that is, delta
type=R (see rmdel)—and existing—that is, delta type=D,—deltas. If the -a option is not specified, information for
existing deltas only shall be provided.
OPERANDS
The following operand shall be supported:
file
A pathname of an existing SCCS file or a directory. If file is a directory, the prs utility shall behave as
though each file in the directory were specified as a named file, except that non-SCCS files (last component of the pathname does
not begin with s.) and unreadable files shall be silently ignored.
If exactly one file operand appears, and it is '-', the standard input shall be read; each line of the standard
input shall be taken to be the name of an SCCS file to be processed. Non-SCCS files and unreadable files shall be silently
ignored.
STDIN
The standard input shall be a text file used only when the file operand is specified as '-'. Each line of the
text file shall be interpreted as an SCCS pathname.
INPUT FILES
Any SCCS files displayed are files of an unspecified format.
ENVIRONMENT VARIABLES
The following environment variables shall affect the execution of prs:
LANG
Provide a default value for the internationalization variables that are unset or null. (See XBD 8.2 Internationalization Variables the precedence of internationalization
variables used to determine the values of locale categories.)
LC_ALL
If set to a non-empty string value, override the values of all the other internationalization variables.
LC_CTYPE
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as
opposed to multi-byte characters in arguments and input files).
LC_MESSAGES
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.
NLSPATH
Determine the location of messages objects and message catalogs.
ASYNCHRONOUS EVENTS
Default.
STDOUT
The standard output shall be a text file whose format is dependent on the data keywords specified with the -d option.
Data Keywords
Data keywords specify which parts of an SCCS file shall be retrieved and output. All parts of an SCCS file have an associated
data keyword. A data keyword may appear in a dataspec multiple times.
The information written by prs shall consist of:
The user-supplied text
Appropriate values (extracted from the SCCS file) substituted for the recognized data keywords in the order of appearance in the
dataspec
The format of a data keyword value shall either be simple ('S'), in which keyword substitution is direct, or multi-line
('M').
User-supplied text shall be any text other than recognized data keywords. A  shall be specified by '\t' and
by '\n'. When the -r option is not specified, the default dataspec shall be:
:PN::\n\n
and the following dataspec shall be used for each selected delta:
:Dt:\t:DL:\nMRs:\n:MR:COMMENTS:\n:C:
SCCS File Data Keywords
Keyword
Data Item
File Section
Value
Format
:Dt:
Delta information
Delta Table
See below*
S
:DL:
Delta line statistics
"
:Li:/:Ld:/:Lu:
S
:Li:
Lines inserted by Delta
"
nnnnn***
S
:Ld:
Lines deleted by Delta
"
nnnnn***
S
:Lu:
Lines unchanged by Delta
"
nnnnn***
S
:DT:
Delta type
"
D or R
S
:I:
SCCS ID string (SID)
"
See below**
S
:R:
Release number
"
nnnn
S
:L:
Level number
"
nnnn
S
:B:
Branch number
"
nnnn
S
:S:
Sequence number
"
nnnn
S
:D:
Date delta created
"
:Dy:/:Dm:/:Dd:
S
:Dy:
Year delta created
"
nn
S
:Dm:
Month delta created