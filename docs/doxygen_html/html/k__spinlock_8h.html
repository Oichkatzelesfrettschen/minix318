<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MINIX Kernel Documentation: minix/kernel/k_spinlock.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MINIX Kernel Documentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_207bf8c12f5ffd71867b262b7e0c4f41.html">minix</a></li><li class="navelem"><a class="el" href="dir_a593f8436b1bc29ffa99b7ee170e7ac1.html">kernel</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">k_spinlock.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Defines a simple, non-recursive spinlock using GCC atomic builtins.
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;minix/sys_config.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for k_spinlock.h:</div>
<div class="dyncontent">
<div class="center"><img src="k__spinlock_8h__incl.png" border="0" usemap="#aminix_2kernel_2k__spinlock_8h" alt=""/></div>
<map name="aminix_2kernel_2k__spinlock_8h" id="aminix_2kernel_2k__spinlock_8h">
<area shape="rect" title="Defines a simple, non&#45;recursive spinlock using GCC atomic builtins." alt="" coords="5,5,193,31"/>
<area shape="rect" title=" " alt="" coords="28,79,171,104"/>
<area shape="poly" title=" " alt="" coords="102,31,102,65,97,65,97,31"/>
</map>
</div>
</div>
<p><a href="k__spinlock_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsimple__spinlock__t.html">simple_spinlock_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure representing a simple spinlock.  <a href="structsimple__spinlock__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ab64669b95d563f14428a1f073106ef04" id="r_ab64669b95d563f14428a1f073106ef04"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="k__spinlock_8h.html#ab64669b95d563f14428a1f073106ef04">MAX_SPIN_THRESHOLD</a>&#160;&#160;&#160;100000</td></tr>
<tr class="memdesc:ab64669b95d563f14428a1f073106ef04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of spin iterations before attempting to yield.  <br /></td></tr>
<tr class="separator:ab64669b95d563f14428a1f073106ef04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e692108b27a8b15089a297b451f293" id="r_ab7e692108b27a8b15089a297b451f293"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="k__spinlock_8h.html#ab7e692108b27a8b15089a297b451f293">KERNEL_YIELD_DEFINED</a></td></tr>
<tr class="separator:ab7e692108b27a8b15089a297b451f293"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a79887c626e823a36834e349fb75c539c" id="r_a79887c626e823a36834e349fb75c539c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="k__spinlock_8h.html#a79887c626e823a36834e349fb75c539c">arch_pause</a> (void)</td></tr>
<tr class="memdesc:a79887c626e823a36834e349fb75c539c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Placeholder for arch_pause on non-x86 architectures.  <br /></td></tr>
<tr class="separator:a79887c626e823a36834e349fb75c539c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b96827abeb83529b5d946e2654231ed" id="r_a3b96827abeb83529b5d946e2654231ed"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="k__spinlock_8h.html#a3b96827abeb83529b5d946e2654231ed">kernel_yield</a> (void)</td></tr>
<tr class="memdesc:a3b96827abeb83529b5d946e2654231ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yields the CPU, typically to the scheduler. (Stub Implementation)  <br /></td></tr>
<tr class="separator:a3b96827abeb83529b5d946e2654231ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614711109a66b779e92036c573e57002" id="r_a614711109a66b779e92036c573e57002"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="k__spinlock_8h.html#a614711109a66b779e92036c573e57002">simple_spin_init</a> (<a class="el" href="structsimple__spinlock__t.html">simple_spinlock_t</a> *lock)</td></tr>
<tr class="memdesc:a614711109a66b779e92036c573e57002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a spinlock to the unlocked state and resets statistics.  <br /></td></tr>
<tr class="separator:a614711109a66b779e92036c573e57002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e8fd03b0cdf6f309bde43577c3dd548" id="r_a8e8fd03b0cdf6f309bde43577c3dd548"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="k__spinlock_8h.html#a8e8fd03b0cdf6f309bde43577c3dd548">simple_spin_lock</a> (<a class="el" href="structsimple__spinlock__t.html">simple_spinlock_t</a> *lock)</td></tr>
<tr class="memdesc:a8e8fd03b0cdf6f309bde43577c3dd548"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires a spinlock, busy-waiting if necessary.  <br /></td></tr>
<tr class="separator:a8e8fd03b0cdf6f309bde43577c3dd548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62d430c4e62aaa0d945088f5e1adc32" id="r_ad62d430c4e62aaa0d945088f5e1adc32"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="k__spinlock_8h.html#ad62d430c4e62aaa0d945088f5e1adc32">simple_spin_unlock</a> (<a class="el" href="structsimple__spinlock__t.html">simple_spinlock_t</a> *lock)</td></tr>
<tr class="memdesc:ad62d430c4e62aaa0d945088f5e1adc32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases a previously acquired spinlock.  <br /></td></tr>
<tr class="separator:ad62d430c4e62aaa0d945088f5e1adc32"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Defines a simple, non-recursive spinlock using GCC atomic builtins. </p>
<p>This header provides a basic spinlock implementation suitable for short critical sections, particularly in contexts where sleeping is not permissible (e.g., some interrupt handlers or core kernel code before schedulers are fully active). It is designed with SMP considerations, relying on GCC's atomic builtins which typically ensure full memory barriers for sequential consistency. Includes adaptive spinning using <code><a class="el" href="k__spinlock_8h.html#a79887c626e823a36834e349fb75c539c" title="Placeholder for arch_pause on non-x86 architectures.">arch_pause()</a></code> for supported architectures. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ab7e692108b27a8b15089a297b451f293" name="ab7e692108b27a8b15089a297b451f293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7e692108b27a8b15089a297b451f293">&#9670;&#160;</a></span>KERNEL_YIELD_DEFINED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define KERNEL_YIELD_DEFINED</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab64669b95d563f14428a1f073106ef04" name="ab64669b95d563f14428a1f073106ef04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab64669b95d563f14428a1f073106ef04">&#9670;&#160;</a></span>MAX_SPIN_THRESHOLD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_SPIN_THRESHOLD&#160;&#160;&#160;100000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum number of spin iterations before attempting to yield. </p>
<p>This threshold is used in <code>simple_spin_lock</code> to prevent a CPU from monopolizing resources by spinning indefinitely on a highly contended lock. After this many spins in the inner loop, <code><a class="el" href="k__spinlock_8h.html#a3b96827abeb83529b5d946e2654231ed" title="Yields the CPU, typically to the scheduler. (Stub Implementation)">kernel_yield()</a></code> is called. The value should be tuned based on system characteristics and expected contention levels. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a79887c626e823a36834e349fb75c539c" name="a79887c626e823a36834e349fb75c539c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79887c626e823a36834e349fb75c539c">&#9670;&#160;</a></span>arch_pause()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void arch_pause </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Placeholder for arch_pause on non-x86 architectures. </p>
<p>For architectures other than i386/x86_64, this function currently acts as a no-op. It can be defined with architecture-specific pause/yield instructions if available to improve spin-wait loop performance. </p>

</div>
</div>
<a id="a3b96827abeb83529b5d946e2654231ed" name="a3b96827abeb83529b5d946e2654231ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b96827abeb83529b5d946e2654231ed">&#9670;&#160;</a></span>kernel_yield()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void kernel_yield </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Yields the CPU, typically to the scheduler. (Stub Implementation) </p>
<p>This function is called when a spinlock has been spinning for too long (exceeding MAX_SPIN_THRESHOLD), as a mechanism to prevent CPU monopolization and allow other threads/processes to run.</p>
<dl class="section note"><dt>Note</dt><dd>This is a stub implementation. A full implementation would typically involve interacting with the system scheduler to relinquish the CPU. For now, it at least performs an <code><a class="el" href="k__spinlock_8h.html#a79887c626e823a36834e349fb75c539c" title="Placeholder for arch_pause on non-x86 architectures.">arch_pause()</a></code> to reduce contention. A real implementation might call something like <code>sched_yield()</code> or <code>yield()</code>. </dd></dl>

</div>
</div>
<a id="a614711109a66b779e92036c573e57002" name="a614711109a66b779e92036c573e57002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a614711109a66b779e92036c573e57002">&#9670;&#160;</a></span>simple_spin_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void simple_spin_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimple__spinlock__t.html">simple_spinlock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a spinlock to the unlocked state and resets statistics. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>Pointer to the <a class="el" href="structsimple__spinlock__t.html" title="Structure representing a simple spinlock.">simple_spinlock_t</a> to initialize.</td></tr>
  </table>
  </dd>
</dl>
<p>This function must be called before the spinlock is used for the first time. It sets the lock state to 0 (unlocked) and initializes statistics counters to zero. </p>

</div>
</div>
<a id="a8e8fd03b0cdf6f309bde43577c3dd548" name="a8e8fd03b0cdf6f309bde43577c3dd548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e8fd03b0cdf6f309bde43577c3dd548">&#9670;&#160;</a></span>simple_spin_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void simple_spin_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimple__spinlock__t.html">simple_spinlock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Acquires a spinlock, busy-waiting if necessary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>Pointer to the <a class="el" href="structsimple__spinlock__t.html" title="Structure representing a simple spinlock.">simple_spinlock_t</a> to acquire.</td></tr>
  </table>
  </dd>
</dl>
<p>This function attempts to acquire the lock. If the lock is already held, it will spin (busy-wait) until the lock becomes available. This function is non-recursive; a thread attempting to acquire a lock it already holds will deadlock. Includes a spin counter and calls <code><a class="el" href="k__spinlock_8h.html#a3b96827abeb83529b5d946e2654231ed" title="Yields the CPU, typically to the scheduler. (Stub Implementation)">kernel_yield()</a></code> if spinning excessively. Also updates lock acquisition and contention statistics. </p>

</div>
</div>
<a id="ad62d430c4e62aaa0d945088f5e1adc32" name="ad62d430c4e62aaa0d945088f5e1adc32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad62d430c4e62aaa0d945088f5e1adc32">&#9670;&#160;</a></span>simple_spin_unlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void simple_spin_unlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsimple__spinlock__t.html">simple_spinlock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases a previously acquired spinlock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>Pointer to the <a class="el" href="structsimple__spinlock__t.html" title="Structure representing a simple spinlock.">simple_spinlock_t</a> to release.</td></tr>
  </table>
  </dd>
</dl>
<p>This function releases the lock, allowing another thread to acquire it. It must only be called by the thread that currently holds the lock. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
